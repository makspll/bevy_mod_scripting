#![allow(clippy::all, unused_imports)]
// This file is generated by `bevy_mod_scripting_derive/main.rs` change the template not this file
extern crate self as bevy_script_api;
use crate::{
    error::ReflectionError,
    script_ref::{ReflectedValue, ValueIndex},
    sub_reflect::ReflectPathElem,
};
use bevy::animation::AnimationPlayer;
use bevy::asset::AssetPathId;
use bevy::asset::HandleId;
use bevy::asset::LabelId;
use bevy::asset::SourcePathId;
use bevy::core::Name;
use bevy::core_pipeline::clear_color::ClearColor;
use bevy::core_pipeline::clear_color::ClearColorConfig;
use bevy::core_pipeline::core_2d::Camera2d;
use bevy::core_pipeline::core_3d::Camera3d;
use bevy::core_pipeline::core_3d::Camera3dDepthLoadOp;
use bevy::ecs::entity::Entity;
use bevy::gltf::GltfExtras;
use bevy::hierarchy::Children;
use bevy::hierarchy::Parent;
use bevy::math::bool::BVec2;
use bevy::math::bool::BVec3;
use bevy::math::bool::BVec3A;
use bevy::math::bool::BVec4;
use bevy::math::bool::BVec4A;
use bevy::math::f32::Affine2;
use bevy::math::f32::Affine3A;
use bevy::math::f32::Mat2;
use bevy::math::f32::Mat3;
use bevy::math::f32::Mat3A;
use bevy::math::f32::Mat4;
use bevy::math::f32::Quat;
use bevy::math::f32::Vec2;
use bevy::math::f32::Vec3;
use bevy::math::f32::Vec3A;
use bevy::math::f32::Vec4;
use bevy::math::f64::DAffine2;
use bevy::math::f64::DAffine3;
use bevy::math::f64::DMat2;
use bevy::math::f64::DMat3;
use bevy::math::f64::DMat4;
use bevy::math::f64::DQuat;
use bevy::math::f64::DVec2;
use bevy::math::f64::DVec3;
use bevy::math::f64::DVec4;
use bevy::math::i32::IVec2;
use bevy::math::i32::IVec3;
use bevy::math::i32::IVec4;
use bevy::math::u32::UVec2;
use bevy::math::u32::UVec3;
use bevy::math::u32::UVec4;
use bevy::math::EulerRot;
use bevy::math::Rect;
use bevy::pbr::wireframe::Wireframe;
use bevy::pbr::wireframe::WireframeConfig;
use bevy::pbr::AlphaMode;
use bevy::pbr::AmbientLight;
use bevy::pbr::CubemapVisibleEntities;
use bevy::pbr::DirectionalLight;
use bevy::pbr::DirectionalLightShadowMap;
use bevy::pbr::NotShadowCaster;
use bevy::pbr::NotShadowReceiver;
use bevy::pbr::PointLight;
use bevy::pbr::PointLightShadowMap;
use bevy::prelude::App;
use bevy::reflect::Enum;
use bevy::render::camera::Camera;
use bevy::render::camera::CameraProjection;
use bevy::render::camera::CameraRenderGraph;
use bevy::render::camera::OrthographicProjection;
use bevy::render::camera::PerspectiveProjection;
use bevy::render::camera::Projection;
use bevy::render::camera::RenderTarget;
use bevy::render::camera::ScalingMode;
use bevy::render::camera::Viewport;
use bevy::render::camera::WindowOrigin;
use bevy::render::color::Color;
use bevy::render::mesh::skinning::SkinnedMesh;
use bevy::render::primitives::Aabb;
use bevy::render::primitives::CubemapFrusta;
use bevy::render::primitives::Frustum;
use bevy::render::view::visibility::ComputedVisibility;
use bevy::render::view::visibility::RenderLayers;
use bevy::render::view::visibility::Visibility;
use bevy::render::view::visibility::VisibleEntities;
use bevy::render::view::Msaa;
use bevy::sprite::Anchor;
use bevy::sprite::Mesh2dHandle;
use bevy::sprite::Sprite;
use bevy::sprite::TextureAtlasSprite;
use bevy::text::HorizontalAlign;
use bevy::text::Text;
use bevy::text::Text2dBounds;
use bevy::text::Text2dSize;
use bevy::text::TextAlignment;
use bevy::text::TextSection;
use bevy::text::TextStyle;
use bevy::text::VerticalAlign;
use bevy::time::Stopwatch;
use bevy::time::Timer;
use bevy::transform::components::GlobalTransform;
use bevy::transform::components::Transform;
use bevy::ui::widget::Button;
use bevy::ui::widget::ImageMode;
use bevy::ui::AlignContent;
use bevy::ui::AlignItems;
use bevy::ui::AlignSelf;
use bevy::ui::CalculatedClip;
use bevy::ui::CalculatedSize;
use bevy::ui::Direction;
use bevy::ui::Display;
use bevy::ui::FlexDirection;
use bevy::ui::FlexWrap;
use bevy::ui::FocusPolicy;
use bevy::ui::Interaction;
use bevy::ui::JustifyContent;
use bevy::ui::Node;
use bevy::ui::Overflow;
use bevy::ui::PositionType;
use bevy::ui::Style;
use bevy::ui::UiImage;
use bevy::ui::Val;
use bevy_mod_scripting_core::prelude::*;
use bevy_mod_scripting_derive::impl_script_newtype;
use std::ops::*;
use std::sync::Mutex;
#[cfg(feature = "lua")]
use {
    crate::lua::RegisterForeignLuaType,
    bevy_mod_scripting_lua::{docs::LuaDocFragment, tealr::mlu::mlua::MetaMethod},
    bevy_mod_scripting_lua_derive::impl_lua_newtype,
};
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Defines how each line is aligned within the flexbox.
    ///
    ///It only applies if [`FlexWrap::Wrap`] is present and if there are multiple lines of items.
    bevy_ui::AlignContent :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///How items are aligned according to the cross axis
    bevy_ui::AlignItems :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Works like [`AlignItems`] but applies only to a single item
    bevy_ui::AlignSelf :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Defines the text direction
    ///
    ///For example English is written LTR (left-to-right) while Arabic is written RTL (right-to-left).
    bevy_ui::Direction :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Defines how flexbox items are ordered within a flexbox
    bevy_ui::FlexDirection :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Defines if flexbox items appear on a single line or on multiple lines
    bevy_ui::FlexWrap :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Describes whether the node should block interactions with lower nodes
    bevy_ui::FocusPolicy :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Describes what type of input interaction has occurred for a UI node.
    ///
    ///This is commonly queried with a `Changed<Interaction>` filter.
    ///
    ///Updated in [`ui_focus_system`].
    ///
    ///If a UI node has both [`Interaction`] and [`ComputedVisibility`] components,
    ///[`Interaction`] will always be [`Interaction::None`]
    ///when [`ComputedVisibility::is_visible()`] is false.
    ///This ensures that hidden UI nodes are not interactable,
    ///and do not end up stuck in an active state if hidden at the wrong time.
    ///
    ///Note that you can also control the visibility of a node using the [`Display`](crate::ui_node::Display) property,
    ///which fully collapses it during layout calculations.
    bevy_ui::Interaction :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Defines how items are aligned according to the main axis
    bevy_ui::JustifyContent :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Whether to show or hide overflowing items
    bevy_ui::Overflow :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///The strategy used to position this node
    bevy_ui::PositionType :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///An enum that describes possible types of value in flexbox layout options
    bevy_ui::Val :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
        self Div Raw(f32) -> Wrapped(Val),
        self Mul Raw(f32) -> Wrapped(Val),
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///The calculated clip of the node
    bevy_ui::CalculatedClip :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
        /// The rect of the clip
        clip: Wrapped(Rect),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///The calculated size of the node
    bevy_ui::CalculatedSize :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
        /// The size of the node
        size: Raw(ReflectedValue),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Describes the size of a UI node
    bevy_ui::Node :
    Clone +
    Debug +
    Methods
    (
        ///The calculated node size as width and height in pixels
        ///automatically calculated by [`super::flex::flex_node_system`]
        size(&self:) -> Wrapped(Vec2),

    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Describes the style of a UI node
    ///
    ///It uses the [Flexbox](https://cssreference.io/flexbox/) system.
    ///
    ///**Note:** Bevy's UI is upside down compared to how Flexbox normally works, to stay consistent with engine paradigms about layouting from
    ///the upper left corner of the display
    bevy_ui::Style :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
        /// Whether to arrange this node and its children with flexbox layout
        ///
        /// If this is set to [`Display::None`], this node will be collapsed.
        display: Wrapped(Display),
        /// Whether to arrange this node relative to other nodes, or positioned absolutely
        position_type: Wrapped(PositionType),
        /// Which direction the content of this node should go
        direction: Wrapped(Direction),
        /// Whether to use column or row layout
        flex_direction: Wrapped(FlexDirection),
        /// How to wrap nodes
        flex_wrap: Wrapped(FlexWrap),
        /// How items are aligned according to the cross axis
        align_items: Wrapped(AlignItems),
        /// Like align_items but for only this item
        align_self: Wrapped(AlignSelf),
        /// How to align each line, only applies if flex_wrap is set to
        /// [`FlexWrap::Wrap`] and there are multiple lines of items
        align_content: Wrapped(AlignContent),
        /// How items align according to the main axis
        justify_content: Wrapped(JustifyContent),
        /// The position of the node as described by its Rect
        position: Raw(ReflectedValue),
        /// The margin of the node
        margin: Raw(ReflectedValue),
        /// The padding of the node
        padding: Raw(ReflectedValue),
        /// The border of the node
        border: Raw(ReflectedValue),
        /// Defines how much a flexbox item should grow if there's space available
        flex_grow: Raw(f32),
        /// How to shrink if there's not enough space available
        flex_shrink: Raw(f32),
        /// The initial size of the item
        flex_basis: Wrapped(Val),
        /// The size of the flexbox
        size: Raw(ReflectedValue),
        /// The minimum size of the flexbox
        min_size: Raw(ReflectedValue),
        /// The maximum size of the flexbox
        max_size: Raw(ReflectedValue),
        /// The aspect ratio of the flexbox
        aspect_ratio: Raw(ReflectedValue),
        /// How to handle overflow
        overflow: Wrapped(Overflow),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///The 2D texture displayed for this UI node
    bevy_ui::UiImage :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Marker struct for buttons
    bevy_ui::widget::Button :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Describes how to resize the Image node
    bevy_ui::widget::ImageMode :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Whether to use a Flexbox layout model.
    ///
    ///Part of the [`Style`] component.
    bevy_ui::Display :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Animation controls
    bevy_animation::AnimationPlayer :
    Methods
    (
        ///Pause the animation
        pause(&mut self:),

        ///Unpause the animation
        resume(&mut self:),

        ///Is the animation paused
        is_paused(&self:) -> Raw(bool),

        ///Speed of the animation playback
        speed(&self:) -> Raw(f32),

        ///Time elapsed playing the animation
        elapsed(&self:) -> Raw(f32),

    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Component used to identify an entity. Stores a hash for faster comparisons
    ///The hash is eagerly re-computed upon each update to the name.
    ///
    ///[`Name`] should not be treated as a globally unique identifier for entities,
    ///as multiple entities can have the same name.  [`bevy_ecs::entity::Entity`] should be
    ///used instead as the default unique identifier.
    bevy_core::Name :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    bevy_gltf::GltfExtras :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
        value: Raw(String),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Contains references to the child entities of this entity.
    ///
    ///See [`HierarchyQueryExt`] for hierarchy related methods on [`Query`].
    ///
    ///[`HierarchyQueryExt`]: crate::query_extension::HierarchyQueryExt
    ///[`Query`]: bevy_ecs::system::Query
    bevy_hierarchy::Children :
    Debug +
    Methods
    (
        ///Swaps the child at `a_index` with the child at `b_index`.
        swap(&mut self:Raw(usize),Raw(usize)),

    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Holds a reference to the parent entity of this entity.
    ///This component should only be present on entities that actually have a parent entity.
    ///
    ///See [`HierarchyQueryExt`] for hierarchy related methods on [`Query`].
    ///
    ///[`HierarchyQueryExt`]: crate::query_extension::HierarchyQueryExt
    ///[`Query`]: bevy_ecs::system::Query
    bevy_hierarchy::Parent :
    Debug +
    Methods
    (
        ///Gets the [`Entity`] ID of the parent.
        get(&self:) -> Wrapped(Entity),

    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///The maximum width and height of text. The text will wrap according to the specified size.
    ///Characters out of the bounds after wrapping will be truncated. Text is aligned according to the
    ///specified `TextAlignment`.
    ///
    ///Note: only characters that are completely out of the bounds will be truncated, so this is not a
    ///reliable limit if it is necessary to contain the text strictly in the bounds. Currently this
    ///component is mainly useful for text wrapping only.
    bevy_text::Text2dBounds :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
        size: Wrapped(Vec2),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///The calculated size of text drawn in 2D scene.
    bevy_text::Text2dSize :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
        size: Wrapped(Vec2),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    bevy_text::Text :
    Clone +
    Debug +
    Methods
    (
        ///Returns this [`Text`] with a new [`TextAlignment`].
        with_alignment(self:Wrapped(TextAlignment)) -> self,

    )
    + Fields
    (
        sections: Raw(ReflectedValue),
        alignment: Wrapped(TextAlignment),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    bevy_text::TextAlignment :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
        vertical: Wrapped(VerticalAlign),
        horizontal: Wrapped(HorizontalAlign),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    bevy_text::TextSection :
    Clone +
    Debug +
    Methods
    (
        ///Create an empty [`TextSection`] from a style. Useful when the value will be set dynamically.
        from_style(Wrapped(TextStyle)) -> self,

    )
    + Fields
    (
        value: Raw(String),
        style: Wrapped(TextStyle),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    bevy_text::TextStyle :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
        font: Raw(ReflectedValue),
        font_size: Raw(f32),
        color: Wrapped(Color),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Describes horizontal alignment preference for positioning & bounds.
    bevy_text::HorizontalAlign :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Describes vertical alignment preference for positioning & bounds. Currently a placeholder
    ///for future functionality.
    bevy_text::VerticalAlign :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A Stopwatch is a struct that track elapsed time when started.
    ///
    ///# Examples
    ///
    ///```
    ///# use bevy_time::*;
    ///use std::time::Duration;
    ///let mut stopwatch = Stopwatch::new();
    ///assert_eq!(stopwatch.elapsed_secs(), 0.0);
    ///
    ///stopwatch.tick(Duration::from_secs_f32(1.0)); // tick one second
    ///assert_eq!(stopwatch.elapsed_secs(), 1.0);
    ///
    ///stopwatch.pause();
    ///stopwatch.tick(Duration::from_secs_f32(1.0)); // paused stopwatches don't tick
    ///assert_eq!(stopwatch.elapsed_secs(), 1.0);
    ///
    ///stopwatch.reset(); // reset the stopwatch
    ///assert!(stopwatch.paused());
    ///assert_eq!(stopwatch.elapsed_secs(), 0.0);
    ///```
    bevy_time::Stopwatch :
    Clone +
    Debug +
    Methods
    (
        ///Create a new unpaused `Stopwatch` with no elapsed time.
        ///
        ///# Examples
        ///```
        ///# use bevy_time::*;
        ///let stopwatch = Stopwatch::new();
        ///assert_eq!(stopwatch.elapsed_secs(), 0.0);
        ///assert_eq!(stopwatch.paused(), false);
        ///```
        new() -> self,

        ///Returns the elapsed time since the last [`reset`](Stopwatch::reset)
        ///of the stopwatch, in seconds.
        ///
        ///# Examples
        ///```
        ///# use bevy_time::*;
        ///use std::time::Duration;
        ///let mut stopwatch = Stopwatch::new();
        ///stopwatch.tick(Duration::from_secs(1));
        ///assert_eq!(stopwatch.elapsed_secs(), 1.0);
        ///```
        ///
        ///# See Also
        ///
        ///[`elapsed`](Stopwatch::elapsed) - if a `Duration` is desirable instead.
        ///[`elapsed_secs_f64`](Stopwatch::elapsed_secs_f64) - if an `f64` is desirable instead.
        elapsed_secs(&self:) -> Raw(f32),

        ///Returns the elapsed time since the last [`reset`](Stopwatch::reset)
        ///of the stopwatch, in seconds, as f64.
        ///
        ///# See Also
        ///
        ///[`elapsed`](Stopwatch::elapsed) - if a `Duration` is desirable instead.
        ///[`elapsed_secs`](Stopwatch::elapsed_secs) - if an `f32` is desirable instead.
        elapsed_secs_f64(&self:) -> Raw(f64),

        ///Pauses the stopwatch. Any call to [`tick`](Stopwatch::tick) while
        ///paused will not have any effect on the elapsed time.
        ///
        ///# Examples
        ///```
        ///# use bevy_time::*;
        ///use std::time::Duration;
        ///let mut stopwatch = Stopwatch::new();
        ///stopwatch.pause();
        ///stopwatch.tick(Duration::from_secs_f32(1.5));
        ///assert!(stopwatch.paused());
        ///assert_eq!(stopwatch.elapsed_secs(), 0.0);
        ///```
        pause(&mut self:),

        ///Unpauses the stopwatch. Resume the effect of ticking on elapsed time.
        ///
        ///# Examples
        ///```
        ///# use bevy_time::*;
        ///use std::time::Duration;
        ///let mut stopwatch = Stopwatch::new();
        ///stopwatch.pause();
        ///stopwatch.tick(Duration::from_secs_f32(1.0));
        ///stopwatch.unpause();
        ///stopwatch.tick(Duration::from_secs_f32(1.0));
        ///assert!(!stopwatch.paused());
        ///assert_eq!(stopwatch.elapsed_secs(), 1.0);
        ///```
        unpause(&mut self:),

        ///Returns `true` if the stopwatch is paused.
        ///
        ///# Examples
        ///```
        ///# use bevy_time::*;
        ///let mut stopwatch = Stopwatch::new();
        ///assert!(!stopwatch.paused());
        ///stopwatch.pause();
        ///assert!(stopwatch.paused());
        ///stopwatch.unpause();
        ///assert!(!stopwatch.paused());
        ///```
        paused(&self:) -> Raw(bool),

        ///Resets the stopwatch. The reset doesn’t affect the paused state of the stopwatch.
        ///
        ///# Examples
        ///```
        ///# use bevy_time::*;
        ///use std::time::Duration;
        ///let mut stopwatch = Stopwatch::new();
        ///stopwatch.tick(Duration::from_secs_f32(1.5));
        ///stopwatch.reset();
        ///assert_eq!(stopwatch.elapsed_secs(), 0.0);
        ///```
        reset(&mut self:),

    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Tracks elapsed time. Enters the finished state once `duration` is reached.
    ///
    ///Non repeating timers will stop tracking and stay in the finished state until reset.
    ///Repeating timers will only be in the finished state on each tick `duration` is reached or
    ///exceeded, and can still be reset at any given point.
    ///
    ///Paused timers will not have elapsed time increased.
    bevy_time::Timer :
    Clone +
    Debug +
    Methods
    (
        ///Returns `true` if the timer has reached its duration at least once.
        ///See also [`Timer::just_finished`](Timer::just_finished).
        ///
        ///# Examples
        ///```
        ///# use bevy_time::*;
        ///use std::time::Duration;
        ///let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
        ///timer.tick(Duration::from_secs_f32(1.5));
        ///assert!(timer.finished());
        ///timer.tick(Duration::from_secs_f32(0.5));
        ///assert!(timer.finished());
        ///```
        finished(&self:) -> Raw(bool),

        ///Returns `true` only on the tick the timer reached its duration.
        ///
        ///# Examples
        ///```
        ///# use bevy_time::*;
        ///use std::time::Duration;
        ///let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
        ///timer.tick(Duration::from_secs_f32(1.5));
        ///assert!(timer.just_finished());
        ///timer.tick(Duration::from_secs_f32(0.5));
        ///assert!(!timer.just_finished());
        ///```
        just_finished(&self:) -> Raw(bool),

        ///Returns the time elapsed on the timer as an `f32`.
        ///See also [`Timer::elapsed`](Timer::elapsed).
        elapsed_secs(&self:) -> Raw(f32),

        ///Pauses the Timer. Disables the ticking of the timer.
        ///
        ///See also [`Stopwatch::pause`](Stopwatch::pause).
        ///
        ///# Examples
        ///```
        ///# use bevy_time::*;
        ///use std::time::Duration;
        ///let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
        ///timer.pause();
        ///timer.tick(Duration::from_secs_f32(0.5));
        ///assert_eq!(timer.elapsed_secs(), 0.0);
        ///```
        pause(&mut self:),

        ///Unpauses the Timer. Resumes the ticking of the timer.
        ///
        ///See also [`Stopwatch::unpause()`](Stopwatch::unpause).
        ///
        ///# Examples
        ///```
        ///# use bevy_time::*;
        ///use std::time::Duration;
        ///let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
        ///timer.pause();
        ///timer.tick(Duration::from_secs_f32(0.5));
        ///timer.unpause();
        ///timer.tick(Duration::from_secs_f32(0.5));
        ///assert_eq!(timer.elapsed_secs(), 0.5);
        ///```
        unpause(&mut self:),

        ///Returns `true` if the timer is paused.
        ///
        ///See also [`Stopwatch::paused`](Stopwatch::paused).
        ///
        ///# Examples
        ///```
        ///# use bevy_time::*;
        ///let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
        ///assert!(!timer.paused());
        ///timer.pause();
        ///assert!(timer.paused());
        ///timer.unpause();
        ///assert!(!timer.paused());
        ///```
        paused(&self:) -> Raw(bool),

        ///Resets the timer. The reset doesn't affect the `paused` state of the timer.
        ///
        ///See also [`Stopwatch::reset`](Stopwatch::reset).
        ///
        ///Examples
        ///```
        ///# use bevy_time::*;
        ///use std::time::Duration;
        ///let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
        ///timer.tick(Duration::from_secs_f32(1.5));
        ///timer.reset();
        ///assert!(!timer.finished());
        ///assert!(!timer.just_finished());
        ///assert_eq!(timer.elapsed_secs(), 0.0);
        ///```
        reset(&mut self:),

        ///Returns the percentage of the timer elapsed time (goes from 0.0 to 1.0).
        ///
        ///# Examples
        ///```
        ///# use bevy_time::*;
        ///use std::time::Duration;
        ///let mut timer = Timer::from_seconds(2.0, TimerMode::Once);
        ///timer.tick(Duration::from_secs_f32(0.5));
        ///assert_eq!(timer.percent(), 0.25);
        ///```
        percent(&self:) -> Raw(f32),

        ///Returns the percentage of the timer remaining time (goes from 1.0 to 0.0).
        ///
        ///# Examples
        ///```
        ///# use bevy_time::*;
        ///use std::time::Duration;
        ///let mut timer = Timer::from_seconds(2.0, TimerMode::Once);
        ///timer.tick(Duration::from_secs_f32(0.5));
        ///assert_eq!(timer.percent_left(), 0.75);
        ///```
        percent_left(&self:) -> Raw(f32),

        ///Returns the remaining time in seconds
        ///
        ///# Examples
        ///```
        ///# use bevy_time::*;
        ///use std::cmp::Ordering;
        ///use std::time::Duration;
        ///let mut timer = Timer::from_seconds(2.0, TimerMode::Once);
        ///timer.tick(Duration::from_secs_f32(0.5));
        ///let result = timer.remaining_secs().total_cmp(&1.5);
        ///assert_eq!(Ordering::Equal, result);
        ///```
        remaining_secs(&self:) -> Raw(f32),

        ///Returns the number of times a repeating timer
        ///finished during the last [`tick`](Timer<T>::tick) call.
        ///
        ///For non repeating-timers, this method will only ever
        ///return 0 or 1.
        ///
        ///# Examples
        ///```
        ///# use bevy_time::*;
        ///use std::time::Duration;
        ///let mut timer = Timer::from_seconds(1.0, TimerMode::Repeating);
        ///timer.tick(Duration::from_secs_f32(6.0));
        ///assert_eq!(timer.times_finished_this_tick(), 6);
        ///timer.tick(Duration::from_secs_f32(2.0));
        ///assert_eq!(timer.times_finished_this_tick(), 2);
        ///timer.tick(Duration::from_secs_f32(0.5));
        ///assert_eq!(timer.times_finished_this_tick(), 0);
        ///```
        times_finished_this_tick(&self:) -> Raw(u32),

    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Lightweight identifier of an [entity](crate::entity).
    ///
    ///The identifier is implemented using a [generational index]: a combination of an index and a generation.
    ///This allows fast insertion after data removal in an array while minimizing loss of spatial locality.
    ///
    ///[generational index]: https://lucassardois.medium.com/generational-indices-guide-8e3c5f7fd594
    ///
    ///# Usage
    ///
    ///This data type is returned by iterating a `Query` that has `Entity` as part of its query fetch type parameter ([learn more]).
    ///It can also be obtained by calling [`EntityCommands::id`] or [`EntityMut::id`].
    ///
    ///```
    ///# use bevy_ecs::prelude::*;
    ///# #[derive(Component)]
    ///# struct SomeComponent;
    ///fn setup(mut commands: Commands) {
    ///    // Calling `spawn` returns `EntityCommands`.
    ///    let entity = commands.spawn(SomeComponent).id();
    ///}
    ///
    ///fn exclusive_system(world: &mut World) {
    ///    // Calling `spawn` returns `EntityMut`.
    ///    let entity = world.spawn(SomeComponent).id();
    ///}
    ///#
    ///# bevy_ecs::system::assert_is_system(setup);
    ///# bevy_ecs::system::assert_is_system(exclusive_system);
    ///```
    ///
    ///It can be used to refer to a specific entity to apply [`EntityCommands`], or to call [`Query::get`] (or similar methods) to access its components.
    ///
    ///```
    ///# use bevy_ecs::prelude::*;
    ///#
    ///# #[derive(Component)]
    ///# struct Expired;
    ///#
    ///fn dispose_expired_food(mut commands: Commands, query: Query<Entity, With<Expired>>) {
    ///    for food_entity in &query {
    ///        commands.entity(food_entity).despawn();
    ///    }
    ///}
    ///#
    ///# bevy_ecs::system::assert_is_system(dispose_expired_food);
    ///```
    ///
    ///[learn more]: crate::system::Query#entity-id-access
    ///[`EntityCommands::id`]: crate::system::EntityCommands::id
    ///[`EntityMut::id`]: crate::world::EntityMut::id
    ///[`EntityCommands`]: crate::system::EntityCommands
    ///[`Query::get`]: crate::system::Query::get
    bevy_ecs::entity::Entity :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new entity reference with the specified `index` and a generation of 0.
        ///
        ///# Note
        ///
        ///Spawning a specific `entity` value is __rarely the right choice__. Most apps should favor
        ///[`Commands::spawn`](crate::system::Commands::spawn). This method should generally
        ///only be used for sharing entities across apps, and only when they have a scheme
        ///worked out to share an index space (which doesn't happen by default).
        ///
        ///In general, one should not try to synchronize the ECS by attempting to ensure that
        ///`Entity` lines up between instances, but instead insert a secondary identifier as
        ///a component.
        ///
        ///There are still some use cases where it might be appropriate to use this function
        ///externally.
        ///
        ///## Examples
        ///
        ///Initializing a collection (e.g. `array` or `Vec`) with a known size:
        ///
        ///```no_run
        ///# use bevy_ecs::prelude::*;
        ///// Create a new array of size 10 and initialize it with (invalid) entities.
        ///let mut entities: [Entity; 10] = [Entity::from_raw(0); 10];
        ///
        ///// ... replace the entities with valid ones.
        ///```
        ///
        ///Deriving `Reflect` for a component that has an `Entity` field:
        ///
        ///```no_run
        ///# use bevy_ecs::{prelude::*, component::*};
        ///# use bevy_reflect::Reflect;
        ///#[derive(Reflect, Component)]
        ///#[reflect(Component)]
        ///pub struct MyStruct {
        ///    pub entity: Entity,
        ///}
        ///
        ///impl FromWorld for MyStruct {
        ///    fn from_world(_world: &mut World) -> Self {
        ///        Self {
        ///            entity: Entity::from_raw(u32::MAX),
        ///        }
        ///    }
        ///}
        ///```
        from_raw(Raw(u32)) -> Wrapped(Entity),

        ///Convert to a form convenient for passing outside of rust.
        ///
        ///Only useful for identifying entities within the same instance of an application. Do not use
        ///for serialization between runs.
        ///
        ///No particular structure is guaranteed for the returned bits.
        to_bits(self:) -> Raw(u64),

        ///Reconstruct an `Entity` previously destructured with [`Entity::to_bits`].
        ///
        ///Only useful when applied to results from `to_bits` in the same instance of an application.
        from_bits(Raw(u64)) -> self,

        ///Return a transiently unique identifier.
        ///
        ///No two simultaneously-live entities share the same index, but dead entities' indices may collide
        ///with both live and dead entities. Useful for compactly representing entities within a
        ///specific snapshot of the world, such as when serializing.
        index(self:) -> Raw(u32),

        ///Returns the generation of this Entity's index. The generation is incremented each time an
        ///entity with a given index is despawned. This serves as a "count" of the number of times a
        ///given index has been reused (index, generation) pairs uniquely identify a given Entity.
        generation(self:) -> Raw(u32),

    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Describe the position of an entity. If the entity has a parent, the position is relative
    ///to its parent position.
    ///
    ///* To place or move an entity, you should set its [`Transform`].
    ///* To get the global transform of an entity, you should get its [`GlobalTransform`].
    ///* To be displayed, an entity must have both a [`Transform`] and a [`GlobalTransform`].
    ///  * You may use the [`TransformBundle`](crate::TransformBundle) to guarantee this.
    ///
    ///## [`Transform`] and [`GlobalTransform`]
    ///
    ///[`Transform`] is the position of an entity relative to its parent position, or the reference
    ///frame if it doesn't have a [`Parent`](bevy_hierarchy::Parent).
    ///
    ///[`GlobalTransform`] is the position of an entity relative to the reference frame.
    ///
    ///[`GlobalTransform`] is updated from [`Transform`] in the system
    ///[`transform_propagate_system`](crate::transform_propagate_system).
    ///
    ///This system runs in stage [`CoreStage::PostUpdate`](crate::CoreStage::PostUpdate). If you
    ///update the [`Transform`] of an entity in this stage or after, you will notice a 1 frame lag
    ///before the [`GlobalTransform`] is updated.
    ///
    ///# Examples
    ///
    ///- [`transform`]
    ///- [`global_vs_local_translation`]
    ///
    ///[`global_vs_local_translation`]: https://github.com/bevyengine/bevy/blob/latest/examples/transforms/global_vs_local_translation.rs
    ///[`transform`]: https://github.com/bevyengine/bevy/blob/latest/examples/transforms/transform.rs
    bevy_transform::components::Transform :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new [`Transform`] at the position `(x, y, z)`. In 2d, the `z` component
        ///is used for z-ordering elements: higher `z`-value will be in front of lower
        ///`z`-value.
        from_xyz(Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Extracts the translation, rotation, and scale from `matrix`. It must be a 3d affine
        ///transformation matrix.
        from_matrix(Wrapped(Mat4)) -> self,

        ///Creates a new [`Transform`], with `translation`. Rotation will be 0 and scale 1 on
        ///all axes.
        from_translation(Wrapped(Vec3)) -> self,

        ///Creates a new [`Transform`], with `rotation`. Translation will be 0 and scale 1 on
        ///all axes.
        from_rotation(Wrapped(Quat)) -> self,

        ///Creates a new [`Transform`], with `scale`. Translation will be 0 and rotation 0 on
        ///all axes.
        from_scale(Wrapped(Vec3)) -> self,

        ///Updates and returns this [`Transform`] by rotating it so that its unit
        ///vector in the local negative `Z` direction is toward `target` and its
        ///unit vector in the local `Y` direction is toward `up`.
        looking_at(self:Wrapped(Vec3),Wrapped(Vec3)) -> self,

        ///Returns this [`Transform`] with a new translation.
        with_translation(self:Wrapped(Vec3)) -> self,

        ///Returns this [`Transform`] with a new rotation.
        with_rotation(self:Wrapped(Quat)) -> self,

        ///Returns this [`Transform`] with a new scale.
        with_scale(self:Wrapped(Vec3)) -> self,

        ///Returns the 3d affine transformation matrix from this transforms translation,
        ///rotation, and scale.
        compute_matrix(&self:) -> Wrapped(Mat4),

        ///Returns the 3d affine transformation matrix from this transforms translation,
        ///rotation, and scale.
        compute_affine(&self:) -> Wrapped(Affine3A),

        ///Get the unit vector in the local `X` direction.
        local_x(&self:) -> Wrapped(Vec3),

        ///Equivalent to [`-local_x()`][Transform::local_x()]
        left(&self:) -> Wrapped(Vec3),

        ///Equivalent to [`local_x()`][Transform::local_x()]
        right(&self:) -> Wrapped(Vec3),

        ///Get the unit vector in the local `Y` direction.
        local_y(&self:) -> Wrapped(Vec3),

        ///Equivalent to [`local_y()`][Transform::local_y]
        up(&self:) -> Wrapped(Vec3),

        ///Equivalent to [`-local_y()`][Transform::local_y]
        down(&self:) -> Wrapped(Vec3),

        ///Get the unit vector in the local `Z` direction.
        local_z(&self:) -> Wrapped(Vec3),

        ///Equivalent to [`-local_z()`][Transform::local_z]
        forward(&self:) -> Wrapped(Vec3),

        ///Equivalent to [`local_z()`][Transform::local_z]
        back(&self:) -> Wrapped(Vec3),

        ///Rotates this [`Transform`] by the given rotation.
        ///
        ///If this [`Transform`] has a parent, the `rotation` is relative to the rotation of the parent.
        ///
        ///# Examples
        ///
        ///- [`3d_rotation`]
        ///
        ///[`3d_rotation`]: https://github.com/bevyengine/bevy/blob/latest/examples/transforms/3d_rotation.rs
        rotate(&mut self:Wrapped(Quat)),

        ///Rotates this [`Transform`] around the given `axis` by `angle` (in radians).
        ///
        ///If this [`Transform`] has a parent, the `axis` is relative to the rotation of the parent.
        rotate_axis(&mut self:Wrapped(Vec3),Raw(f32)),

        ///Rotates this [`Transform`] around the `X` axis by `angle` (in radians).
        ///
        ///If this [`Transform`] has a parent, the axis is relative to the rotation of the parent.
        rotate_x(&mut self:Raw(f32)),

        ///Rotates this [`Transform`] around the `Y` axis by `angle` (in radians).
        ///
        ///If this [`Transform`] has a parent, the axis is relative to the rotation of the parent.
        rotate_y(&mut self:Raw(f32)),

        ///Rotates this [`Transform`] around the `Z` axis by `angle` (in radians).
        ///
        ///If this [`Transform`] has a parent, the axis is relative to the rotation of the parent.
        rotate_z(&mut self:Raw(f32)),

        ///Rotates this [`Transform`] by the given `rotation`.
        ///
        ///The `rotation` is relative to this [`Transform`]'s current rotation.
        rotate_local(&mut self:Wrapped(Quat)),

        ///Rotates this [`Transform`] around its local `axis` by `angle` (in radians).
        rotate_local_axis(&mut self:Wrapped(Vec3),Raw(f32)),

        ///Rotates this [`Transform`] around its local `X` axis by `angle` (in radians).
        rotate_local_x(&mut self:Raw(f32)),

        ///Rotates this [`Transform`] around its local `Y` axis by `angle` (in radians).
        rotate_local_y(&mut self:Raw(f32)),

        ///Rotates this [`Transform`] around its local `Z` axis by `angle` (in radians).
        rotate_local_z(&mut self:Raw(f32)),

        ///Translates this [`Transform`] around a `point` in space.
        ///
        ///If this [`Transform`] has a parent, the `point` is relative to the [`Transform`] of the parent.
        translate_around(&mut self:Wrapped(Vec3),Wrapped(Quat)),

        ///Rotates this [`Transform`] around a `point` in space.
        ///
        ///If this [`Transform`] has a parent, the `point` is relative to the [`Transform`] of the parent.
        rotate_around(&mut self:Wrapped(Vec3),Wrapped(Quat)),

        ///Rotates this [`Transform`] so that its local negative `Z` direction is toward
        ///`target` and its local `Y` direction is toward `up`.
        look_at(&mut self:Wrapped(Vec3),Wrapped(Vec3)),

        ///Multiplies `self` with `transform` component by component, returning the
        ///resulting [`Transform`]
        mul_transform(&self:Wrapped(Transform)) -> self,

        ///Transforms the given `point`, applying scale, rotation and translation.
        ///
        ///If this [`Transform`] has a parent, this will transform a `point` that is
        ///relative to the parent's [`Transform`] into one relative to this [`Transform`].
        ///
        ///If this [`Transform`] does not have a parent, this will transform a `point`
        ///that is in global space into one relative to this [`Transform`].
        ///
        ///If you want to transform a `point` in global space to the local space of this [`Transform`],
        ///consider using [`GlobalTransform::transform_point()`] instead.
        transform_point(&self:Wrapped(Vec3)) -> Wrapped(Vec3),

    )
    + Fields
    (
        /// Position of the entity. In 2d, the last value of the `Vec3` is used for z-ordering.
        ///
        /// See the [`translations`] example for usage.
        ///
        /// [`translations`]: https://github.com/bevyengine/bevy/blob/latest/examples/transforms/translation.rs
        translation: Wrapped(Vec3),
        /// Rotation of the entity.
        ///
        /// See the [`3d_rotation`] example for usage.
        ///
        /// [`3d_rotation`]: https://github.com/bevyengine/bevy/blob/latest/examples/transforms/3d_rotation.rs
        rotation: Wrapped(Quat),
        /// Scale of the entity.
        ///
        /// See the [`scale`] example for usage.
        ///
        /// [`scale`]: https://github.com/bevyengine/bevy/blob/latest/examples/transforms/scale.rs
        scale: Wrapped(Vec3),
    )
    + BinOps
    (
        self Mul Wrapped(Transform) -> Wrapped(Transform),
        self Mul Wrapped(Vec3) -> Wrapped(Vec3),
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Describe the position of an entity relative to the reference frame.
    ///
    ///* To place or move an entity, you should set its [`Transform`].
    ///* To get the global transform of an entity, you should get its [`GlobalTransform`].
    ///* For transform hierarchies to work correctly, you must have both a [`Transform`] and a [`GlobalTransform`].
    ///  * You may use the [`TransformBundle`](crate::TransformBundle) to guarantee this.
    ///
    ///## [`Transform`] and [`GlobalTransform`]
    ///
    ///[`Transform`] is the position of an entity relative to its parent position, or the reference
    ///frame if it doesn't have a [`Parent`](bevy_hierarchy::Parent).
    ///
    ///[`GlobalTransform`] is the position of an entity relative to the reference frame.
    ///
    ///[`GlobalTransform`] is updated from [`Transform`] in the system
    ///[`transform_propagate_system`](crate::transform_propagate_system).
    ///
    ///This system runs in stage [`CoreStage::PostUpdate`](crate::CoreStage::PostUpdate). If you
    ///update the [`Transform`] of an entity in this stage or after, you will notice a 1 frame lag
    ///before the [`GlobalTransform`] is updated.
    ///
    ///# Examples
    ///
    ///- [`global_vs_local_translation`]
    ///
    ///[`global_vs_local_translation`]: https://github.com/bevyengine/bevy/blob/latest/examples/transforms/global_vs_local_translation.rs
    bevy_transform::components::GlobalTransform :
    Clone +
    Debug +
    Methods
    (
        ///Returns the 3d affine transformation matrix as a [`Mat4`].
        compute_matrix(&self:) -> Wrapped(Mat4),

        ///Returns the 3d affine transformation matrix as an [`Affine3A`].
        affine(&self:) -> Wrapped(Affine3A),

        ///Returns the transformation as a [`Transform`].
        ///
        ///The transform is expected to be non-degenerate and without shearing, or the output
        ///will be invalid.
        compute_transform(&self:) -> Wrapped(Transform),

        ///Return the local right vector (X).
        right(&self:) -> Wrapped(Vec3),

        ///Return the local left vector (-X).
        left(&self:) -> Wrapped(Vec3),

        ///Return the local up vector (Y).
        up(&self:) -> Wrapped(Vec3),

        ///Return the local down vector (-Y).
        down(&self:) -> Wrapped(Vec3),

        ///Return the local back vector (Z).
        back(&self:) -> Wrapped(Vec3),

        ///Return the local forward vector (-Z).
        forward(&self:) -> Wrapped(Vec3),

        ///Get the translation as a [`Vec3`].
        translation(&self:) -> Wrapped(Vec3),

        ///Get the translation as a [`Vec3A`].
        translation_vec3a(&self:) -> Wrapped(Vec3A),

        ///Get an upper bound of the radius from the given `extents`.
        radius_vec3a(&self:Wrapped(Vec3A)) -> Raw(f32),

        ///Transforms the given `point`, applying shear, scale, rotation and translation.
        ///
        ///This moves `point` into the local space of this [`GlobalTransform`].
        transform_point(&self:Wrapped(Vec3)) -> Wrapped(Vec3),

        ///Multiplies `self` with `transform` component by component, returning the
        ///resulting [`GlobalTransform`]
        mul_transform(&self:Wrapped(Transform)) -> self,

    )
    + Fields
    (
    )
    + BinOps
    (
        self Mul Wrapped(GlobalTransform) -> Wrapped(GlobalTransform),
        self Mul Wrapped(Transform) -> Wrapped(GlobalTransform),
        self Mul Wrapped(Vec3) -> Wrapped(Vec3),
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///An ambient light, which lights the entire scene equally.
    bevy_pbr::AmbientLight :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
        color: Wrapped(Color),
        /// A direct scale factor multiplied with `color` before being passed to the shader.
        brightness: Raw(f32),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    bevy_pbr::CubemapVisibleEntities :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A Directional light.
    ///
    ///Directional lights don't exist in reality but they are a good
    ///approximation for light sources VERY far away, like the sun or
    ///the moon.
    ///
    ///The light shines along the forward direction of the entity's transform. With a default transform
    ///this would be along the negative-Z axis.
    ///
    ///Valid values for `illuminance` are:
    ///
    ///| Illuminance (lux) | Surfaces illuminated by                        |
    ///|-------------------|------------------------------------------------|
    ///| 0.0001            | Moonless, overcast night sky (starlight)       |
    ///| 0.002             | Moonless clear night sky with airglow          |
    ///| 0.05–0.3          | Full moon on a clear night                     |
    ///| 3.4               | Dark limit of civil twilight under a clear sky |
    ///| 20–50             | Public areas with dark surroundings            |
    ///| 50                | Family living room lights                      |
    ///| 80                | Office building hallway/toilet lighting        |
    ///| 100               | Very dark overcast day                         |
    ///| 150               | Train station platforms                        |
    ///| 320–500           | Office lighting                                |
    ///| 400               | Sunrise or sunset on a clear day.              |
    ///| 1000              | Overcast day; typical TV studio lighting       |
    ///| 10,000–25,000     | Full daylight (not direct sun)                 |
    ///| 32,000–100,000    | Direct sunlight                                |
    ///
    ///Source: [Wikipedia](https://en.wikipedia.org/wiki/Lux)
    ///
    ///## Shadows
    ///
    ///To enable shadows, set the `shadows_enabled` property to `true`.
    ///
    ///While directional lights contribute to the illumination of meshes regardless
    ///of their (or the meshes') positions, currently only a limited region of the scene
    ///(the _shadow volume_) can cast and receive shadows for any given directional light.
    ///
    ///The shadow volume is a _rectangular cuboid_, with left/right/bottom/top/near/far
    ///planes controllable via the `shadow_projection` field. It is affected by the
    ///directional light entity's [`GlobalTransform`], and as such can be freely repositioned in the
    ///scene, (or even scaled!) without affecting illumination in any other way, by simply
    ///moving (or scaling) the entity around. The shadow volume is always oriented towards the
    ///light entity's forward direction.
    ///
    ///For smaller scenes, a static directional light with a preset volume is typically
    ///sufficient. For larger scenes with movable cameras, you might want to introduce
    ///a system that dynamically repositions and scales the light entity (and therefore
    ///its shadow volume) based on the scene subject's position (e.g. a player character)
    ///and its relative distance to the camera.
    ///
    ///Shadows are produced via [shadow mapping](https://en.wikipedia.org/wiki/Shadow_mapping).
    ///To control the resolution of the shadow maps, use the [`DirectionalLightShadowMap`] resource:
    ///
    ///```
    ///# use bevy_app::prelude::*;
    ///# use bevy_pbr::DirectionalLightShadowMap;
    ///App::new()
    ///    .insert_resource(DirectionalLightShadowMap { size: 2048 });
    ///```
    ///
    ///**Note:** Very large shadow map resolutions (> 4K) can have non-negligible performance and
    ///memory impact, and not work properly under mobile or lower-end hardware. To improve the visual
    ///fidelity of shadow maps, it's typically advisable to first reduce the `shadow_projection`
    ///left/right/top/bottom to a scene-appropriate size, before ramping up the shadow map
    ///resolution.
    bevy_pbr::DirectionalLight :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
        color: Wrapped(Color),
        /// Illuminance in lux
        illuminance: Raw(f32),
        shadows_enabled: Raw(bool),
        /// A projection that controls the volume in which shadow maps are rendered
        shadow_projection: Wrapped(OrthographicProjection),
        shadow_depth_bias: Raw(f32),
        /// A bias applied along the direction of the fragment's surface normal. It is scaled to the
        /// shadow map's texel size so that it is automatically adjusted to the orthographic projection.
        shadow_normal_bias: Raw(f32),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Controls the resolution of [`DirectionalLight`] shadow maps.
    bevy_pbr::DirectionalLightShadowMap :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
        size: Raw(usize),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Add this component to make a [`Mesh`](bevy_render::mesh::Mesh) not cast shadows.
    bevy_pbr::NotShadowCaster :
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Add this component to make a [`Mesh`](bevy_render::mesh::Mesh) not receive shadows.
    bevy_pbr::NotShadowReceiver :
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A light that emits light in all directions from a central point.
    ///
    ///Real-world values for `intensity` (luminous power in lumens) based on the electrical power
    ///consumption of the type of real-world light are:
    ///
    ///| Luminous Power (lumen) (i.e. the intensity member) | Incandescent non-halogen (Watts) | Incandescent halogen (Watts) | Compact fluorescent (Watts) | LED (Watts |
    ///|------|-----|----|--------|-------|
    ///| 200  | 25  |    | 3-5    | 3     |
    ///| 450  | 40  | 29 | 9-11   | 5-8   |
    ///| 800  | 60  |    | 13-15  | 8-12  |
    ///| 1100 | 75  | 53 | 18-20  | 10-16 |
    ///| 1600 | 100 | 72 | 24-28  | 14-17 |
    ///| 2400 | 150 |    | 30-52  | 24-30 |
    ///| 3100 | 200 |    | 49-75  | 32    |
    ///| 4000 | 300 |    | 75-100 | 40.5  |
    ///
    ///Source: [Wikipedia](https://en.wikipedia.org/wiki/Lumen_(unit)#Lighting)
    bevy_pbr::PointLight :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
        color: Wrapped(Color),
        intensity: Raw(f32),
        range: Raw(f32),
        radius: Raw(f32),
        shadows_enabled: Raw(bool),
        shadow_depth_bias: Raw(f32),
        /// A bias applied along the direction of the fragment's surface normal. It is scaled to the
        /// shadow map's texel size so that it can be small close to the camera and gets larger further
        /// away.
        shadow_normal_bias: Raw(f32),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    bevy_pbr::PointLightShadowMap :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
        size: Raw(usize),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Sets how a material's base color alpha channel is used for transparency.
    bevy_pbr::AlphaMode :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Controls whether an entity should rendered in wireframe-mode if the [`WireframePlugin`] is enabled
    bevy_pbr::wireframe::Wireframe :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    bevy_pbr::wireframe::WireframeConfig :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
        /// Whether to show wireframes for all meshes. If `false`, only meshes with a [Wireframe] component will be rendered.
        global: Raw(bool),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///The depth clear operation to perform for the main 3d pass.
    bevy_core_pipeline::core_3d::Camera3dDepthLoadOp :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A [`Resource`] that stores the color that is used to clear the screen between frames.
    ///
    ///This color appears as the "background" color for simple apps,
    ///when there are portions of the screen with nothing rendered.
    bevy_core_pipeline::clear_color::ClearColor :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    bevy_core_pipeline::clear_color::ClearColorConfig :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    bevy_core_pipeline::core_2d::Camera2d :
    Clone +
    Methods
    (
    )
    + Fields
    (
        clear_color: Wrapped(ClearColorConfig),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Configuration for the "main 3d render graph".
    bevy_core_pipeline::core_3d::Camera3d :
    Clone +
    Methods
    (
    )
    + Fields
    (
        /// The clear color operation to perform for the main 3d pass.
        clear_color: Wrapped(ClearColorConfig),
        /// The depth clear operation to perform for the main 3d pass.
        depth_load_op: Wrapped(Camera3dDepthLoadOp),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///How a sprite is positioned relative to its [`Transform`](bevy_transform::components::Transform).
    ///It defaults to `Anchor::Center`.
    bevy_sprite::Anchor :
    Clone +
    Debug +
    Methods
    (
        as_vec(&self:) -> Wrapped(Vec2),

    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Component for rendering with meshes in the 2d pipeline, usually with a [2d material](crate::Material2d) such as [`ColorMaterial`](crate::ColorMaterial).
    ///
    ///It wraps a [`Handle<Mesh>`] to differentiate from the 3d pipelines which use the handles directly as components
    bevy_sprite::Mesh2dHandle :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    bevy_sprite::TextureAtlasSprite :
    Clone +
    Debug +
    Methods
    (
        new(Raw(usize)) -> Wrapped(TextureAtlasSprite),

    )
    + Fields
    (
        color: Wrapped(Color),
        index: Raw(usize),
        flip_x: Raw(bool),
        flip_y: Raw(bool),
        /// An optional custom size for the sprite that will be used when rendering, instead of the size
        /// of the sprite's image in the atlas
        custom_size: Raw(ReflectedValue),
        anchor: Wrapped(Anchor),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    bevy_sprite::Sprite :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
        /// The sprite's color tint
        color: Wrapped(Color),
        /// Flip the sprite along the `X` axis
        flip_x: Raw(bool),
        /// Flip the sprite along the `Y` axis
        flip_y: Raw(bool),
        /// An optional custom size for the sprite that will be used when rendering, instead of the size
        /// of the sprite's image
        custom_size: Raw(ReflectedValue),
        /// An optional rectangle representing the region of the sprite's image to render, instead of
        /// rendering the full image. This is an easy one-off alternative to using a texture atlas.
        rect: Raw(ReflectedValue),
        /// [`Anchor`] point of the sprite in the world
        anchor: Wrapped(Anchor),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Describes which rendering layers an entity belongs to.
    ///
    ///Cameras with this component will only render entities with intersecting
    ///layers.
    ///
    ///There are 32 layers numbered `0` - [`TOTAL_LAYERS`](RenderLayers::TOTAL_LAYERS). Entities may
    ///belong to one or more layers, or no layer at all.
    ///
    ///The [`Default`] instance of `RenderLayers` contains layer `0`, the first layer.
    ///
    ///An entity with this component without any layers is invisible.
    ///
    ///Entities without this component belong to layer `0`.
    bevy_render::view::visibility::RenderLayers :
    Clone +
    Debug +
    Methods
    (
        ///Create a new `RenderLayers` that belongs to all layers.
        all() -> self,

        ///Create a new `RenderLayers` that belongs to no layers.
        none() -> self,

        ///Determine if a `RenderLayers` intersects another.
        ///
        ///`RenderLayers`s intersect if they share any common layers.
        ///
        ///A `RenderLayers` with no layers will not match any other
        ///`RenderLayers`, even another with no layers.
        intersects(&self:Wrapped(&RenderLayers)) -> Raw(bool),

    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///User indication of whether an entity is visible. Propagates down the entity hierarchy.
    ///If an entity is hidden in this way,  all [`Children`] (and all of their children and so on) will also be hidden.
    ///This is done by setting the values of their [`ComputedVisibility`] component.
    bevy_render::view::visibility::Visibility :
    Clone +
    Debug +
    Methods
    (
        ///Toggle the visibility.
        toggle(&mut self:),

    )
    + Fields
    (
        /// Indicates whether this entity is visible. Hidden values will propagate down the entity hierarchy.
        /// If this entity is hidden, all of its descendants will be hidden as well. See [`Children`] and [`Parent`] for
        /// hierarchy info.
        is_visible: Raw(bool),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Collection of entities visible from the current view.
    ///
    ///This component contains all entities which are visible from the currently
    ///rendered view. The collection is updated automatically by the [`check_visibility()`]
    ///system, and renderers can use it to optimize rendering of a particular view, to
    ///prevent drawing items not visible from that view.
    ///
    ///This component is intended to be attached to the same entity as the [`Camera`] and
    ///the [`Frustum`] defining the view.
    ///
    ///Currently this component is ignored by the sprite renderer, so sprite rendering
    ///is not optimized per view.
    bevy_render::view::visibility::VisibleEntities :
    Clone +
    Debug +
    Methods
    (
        len(&self:) -> Raw(usize),

        is_empty(&self:) -> Raw(bool),

    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Algorithmically-computed indication of whether an entity is visible and should be extracted for rendering
    bevy_render::view::visibility::ComputedVisibility :
    Clone +
    Debug +
    Methods
    (
        ///Whether this entity is visible to something this frame. This is true if and only if [`Self::is_visible_in_hierarchy`] and [`Self::is_visible_in_view`]
        ///are true. This is the canonical method to call to determine if an entity should be drawn.
        ///This value is updated in [`CoreStage::PostUpdate`] during the [`VisibilitySystems::CheckVisibility`] system label. Reading it from the
        ///[`CoreStage::Update`] stage will yield the value from the previous frame.
        is_visible(&self:) -> Raw(bool),

        ///Whether this entity is visible in the entity hierarchy, which is determined by the [`Visibility`] component.
        ///This takes into account "visibility inheritance". If any of this entity's ancestors (see [`Parent`]) are hidden, this entity
        ///will be hidden as well. This value is updated in the [`CoreStage::PostUpdate`] stage in the
        ///[`VisibilitySystems::VisibilityPropagate`] system label.
        is_visible_in_hierarchy(&self:) -> Raw(bool),

        ///Whether this entity is visible in _any_ view (Cameras, Lights, etc). Each entity type (and view type) should choose how to set this
        ///value. For cameras and drawn entities, this will take into account [`RenderLayers`].
        ///
        ///This value is reset to `false` every frame in [`VisibilitySystems::VisibilityPropagate`] during [`CoreStage::PostUpdate`].
        ///Each entity type then chooses how to set this field in the [`CoreStage::PostUpdate`] stage in the
        ///[`VisibilitySystems::CheckVisibility`] system label. Meshes might use frustum culling to decide if they are visible in a view.
        ///Other entities might just set this to `true` every frame.
        is_visible_in_view(&self:) -> Raw(bool),

        ///Sets `is_visible_in_view` to `true`. This is not reversible for a given frame, as it encodes whether or not this is visible in
        ///_any_ view. This will be automatically reset to `false` every frame in [`VisibilitySystems::VisibilityPropagate`] and then set
        ///to the proper value in [`VisibilitySystems::CheckVisibility`]. This should _only_ be set in systems with the [`VisibilitySystems::CheckVisibility`]
        ///label. Don't call this unless you are defining a custom visibility system. For normal user-defined entity visibility, see [`Visibility`].
        set_visible_in_view(&mut self:),

    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    bevy_render::mesh::skinning::SkinnedMesh :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
        inverse_bindposes: Raw(ReflectedValue),
        joints: Raw(ReflectedValue),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    bevy_render::camera::ScalingMode :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    bevy_render::camera::WindowOrigin :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    bevy_render::color::Color :
    Clone +
    Debug +
    Methods
    (
        ///New `Color` from sRGB colorspace.
        ///
        ///# Arguments
        ///
        ///* `r` - Red channel. [0.0, 1.0]
        ///* `g` - Green channel. [0.0, 1.0]
        ///* `b` - Blue channel. [0.0, 1.0]
        ///
        ///See also [`Color::rgba`], [`Color::rgb_u8`], [`Color::hex`].
        rgb(Raw(f32),Raw(f32),Raw(f32)) -> Wrapped(Color),

        ///New `Color` from sRGB colorspace.
        ///
        ///# Arguments
        ///
        ///* `r` - Red channel. [0.0, 1.0]
        ///* `g` - Green channel. [0.0, 1.0]
        ///* `b` - Blue channel. [0.0, 1.0]
        ///* `a` - Alpha channel. [0.0, 1.0]
        ///
        ///See also [`Color::rgb`], [`Color::rgba_u8`], [`Color::hex`].
        rgba(Raw(f32),Raw(f32),Raw(f32),Raw(f32)) -> Wrapped(Color),

        ///New `Color` from linear RGB colorspace.
        ///
        ///# Arguments
        ///
        ///* `r` - Red channel. [0.0, 1.0]
        ///* `g` - Green channel. [0.0, 1.0]
        ///* `b` - Blue channel. [0.0, 1.0]
        ///
        ///See also [`Color::rgb`], [`Color::rgba_linear`].
        rgb_linear(Raw(f32),Raw(f32),Raw(f32)) -> Wrapped(Color),

        ///New `Color` from linear RGB colorspace.
        ///
        ///# Arguments
        ///
        ///* `r` - Red channel. [0.0, 1.0]
        ///* `g` - Green channel. [0.0, 1.0]
        ///* `b` - Blue channel. [0.0, 1.0]
        ///* `a` - Alpha channel. [0.0, 1.0]
        ///
        ///See also [`Color::rgba`], [`Color::rgb_linear`].
        rgba_linear(Raw(f32),Raw(f32),Raw(f32),Raw(f32)) -> Wrapped(Color),

        ///New `Color` with HSL representation in sRGB colorspace.
        ///
        ///# Arguments
        ///
        ///* `hue` - Hue channel. [0.0, 360.0]
        ///* `saturation` - Saturation channel. [0.0, 1.0]
        ///* `lightness` - Lightness channel. [0.0, 1.0]
        ///
        ///See also [`Color::hsla`].
        hsl(Raw(f32),Raw(f32),Raw(f32)) -> Wrapped(Color),

        ///New `Color` with HSL representation in sRGB colorspace.
        ///
        ///# Arguments
        ///
        ///* `hue` - Hue channel. [0.0, 360.0]
        ///* `saturation` - Saturation channel. [0.0, 1.0]
        ///* `lightness` - Lightness channel. [0.0, 1.0]
        ///* `alpha` - Alpha channel. [0.0, 1.0]
        ///
        ///See also [`Color::hsl`].
        hsla(Raw(f32),Raw(f32),Raw(f32),Raw(f32)) -> Wrapped(Color),

        ///New `Color` from sRGB colorspace.
        ///
        ///# Arguments
        ///
        ///* `r` - Red channel. [0, 255]
        ///* `g` - Green channel. [0, 255]
        ///* `b` - Blue channel. [0, 255]
        ///
        ///See also [`Color::rgb`], [`Color::rgba_u8`], [`Color::hex`].
        rgb_u8(Raw(u8),Raw(u8),Raw(u8)) -> Wrapped(Color),

        ///New `Color` from sRGB colorspace.
        ///
        ///# Arguments
        ///
        ///* `r` - Red channel. [0, 255]
        ///* `g` - Green channel. [0, 255]
        ///* `b` - Blue channel. [0, 255]
        ///* `a` - Alpha channel. [0, 255]
        ///
        ///See also [`Color::rgba`], [`Color::rgb_u8`], [`Color::hex`].
        rgba_u8(Raw(u8),Raw(u8),Raw(u8),Raw(u8)) -> Wrapped(Color),

        ///Get red in sRGB colorspace.
        r(&self:) -> Raw(f32),

        ///Get green in sRGB colorspace.
        g(&self:) -> Raw(f32),

        ///Get blue in sRGB colorspace.
        b(&self:) -> Raw(f32),

        ///Get alpha.
        a(&self:) -> Raw(f32),

        ///Converts a `Color` to variant `Color::Rgba`
        as_rgba(Wrapped(&Color):) -> Wrapped(Color),

        ///Converts a `Color` to variant `Color::RgbaLinear`
        as_rgba_linear(Wrapped(&Color):) -> Wrapped(Color),

        ///Converts a `Color` to variant `Color::Hsla`
        as_hsla(Wrapped(&Color):) -> Wrapped(Color),

        ///Converts `Color` to a `u32` from sRGB colorspace.
        ///
        ///Maps the RGBA channels in RGBA order to a little-endian byte array (GPUs are little-endian).
        ///`A` will be the most significant byte and `R` the least significant.
        as_rgba_u32(Wrapped(Color):) -> Raw(u32),

        ///Converts Color to a u32 from linear RGB colorspace.
        ///
        ///Maps the RGBA channels in RGBA order to a little-endian byte array (GPUs are little-endian).
        ///`A` will be the most significant byte and `R` the least significant.
        as_linear_rgba_u32(Wrapped(Color):) -> Raw(u32),

    )
    + Fields
    (
    )
    + BinOps
    (
        self Add Wrapped(Color) -> Wrapped(Color),
        self Add Wrapped(Vec4) -> Wrapped(Color),
        self Mul Raw(f32) -> Wrapped(Color),
        self Mul Wrapped(Vec4) -> Wrapped(Color),
        self Mul Wrapped(Vec3) -> Wrapped(Color),
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///An Axis-Aligned Bounding Box
    bevy_render::primitives::Aabb :
    Clone +
    Debug +
    Methods
    (
        from_min_max(Wrapped(Vec3),Wrapped(Vec3)) -> self,

        min(&self:) -> Wrapped(Vec3A),

        max(&self:) -> Wrapped(Vec3A),

    )
    + Fields
    (
        center: Wrapped(Vec3A),
        half_extents: Wrapped(Vec3A),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    bevy_render::primitives::CubemapFrusta :
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A frustum defined by the 6 containing planes
    ///Planes are ordered left, right, top, bottom, near, far
    ///Normals point into the contained volume
    bevy_render::primitives::Frustum :
    Clone +
    Debug +
    Methods
    (
        from_view_projection(Wrapped(&Mat4),Wrapped(&Vec3),Wrapped(&Vec3),Raw(f32)) -> self,

        intersects_obb(&self:Wrapped(&Aabb),Wrapped(&Mat4),Raw(bool)) -> Raw(bool),

    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Configuration resource for [Multi-Sample Anti-Aliasing](https://en.wikipedia.org/wiki/Multisample_anti-aliasing).
    ///
    ///# Example
    ///```
    ///# use bevy_app::prelude::App;
    ///# use bevy_render::prelude::Msaa;
    ///App::new()
    ///    .insert_resource(Msaa { samples: 4 })
    ///    .run();
    ///```
    bevy_render::view::Msaa :
    Clone +
    Methods
    (
    )
    + Fields
    (
        /// The number of samples to run for Multi-Sample Anti-Aliasing. Higher numbers result in
        /// smoother edges.
        /// Defaults to 4.
        ///
        /// Note that WGPU currently only supports 1 or 4 samples.
        /// Ultimately we plan on supporting whatever is natively supported on a given device.
        /// Check out this issue for more info: <https://github.com/gfx-rs/wgpu/issues/1832>
        samples: Raw(u32),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///The defining component for camera entities, storing information about how and what to render
    ///through this camera.
    ///
    ///The [`Camera`] component is added to an entity to define the properties of the viewpoint from
    ///which rendering occurs. It defines the position of the view to render, the projection method
    ///to transform the 3D objects into a 2D image, as well as the render target into which that image
    ///is produced.
    ///
    ///Adding a camera is typically done by adding a bundle, either the `Camera2dBundle` or the
    ///`Camera3dBundle`.
    bevy_render::camera::Camera :
    Clone +
    Debug +
    Methods
    (
        ///The projection matrix computed using this camera's [`CameraProjection`].
        projection_matrix(&self:) -> Wrapped(Mat4),

    )
    + Fields
    (
        /// If set, this camera will render to the given [`Viewport`] rectangle within the configured [`RenderTarget`].
        viewport: Raw(ReflectedValue),
        /// Cameras with a lower priority will be rendered before cameras with a higher priority.
        priority: Raw(isize),
        /// If this is set to `true`, this camera will be rendered to its specified [`RenderTarget`]. If `false`, this
        /// camera will not be rendered.
        is_active: Raw(bool),
        /// The "target" that this camera will render to.
        target: Wrapped(RenderTarget),
        /// If this is set to `true`, the camera will use an intermediate "high dynamic range" render texture.
        /// Warning: we are still working on this feature. If MSAA is enabled, there will be artifacts in
        /// some cases. When rendering with WebGL, this will crash if MSAA is enabled.
        /// See <https://github.com/bevyengine/bevy/pull/3425> for details.
        hdr: Raw(bool),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///The "target" that a [`Camera`] will render to. For example, this could be a [`Window`](bevy_window::Window)
    ///swapchain or an [`Image`].
    bevy_render::camera::RenderTarget :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Render viewport configuration for the [`Camera`] component.
    ///
    ///The viewport defines the area on the render target to which the camera renders its image.
    ///You can overlay multiple cameras in a single window using viewports to create effects like
    ///split screen, minimaps, and character viewers.
    bevy_render::camera::Viewport :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
        /// The physical position to render this viewport to within the [`RenderTarget`] of this [`Camera`].
        /// (0,0) corresponds to the top-left corner
        physical_position: Wrapped(UVec2),
        /// The physical size of the viewport rectangle to render to within the [`RenderTarget`] of this [`Camera`].
        /// The origin of the rectangle is in the top-left corner.
        physical_size: Wrapped(UVec2),
        /// The minimum and maximum depth to render (on a scale from 0.0 to 1.0).
        depth: Raw(ReflectedValue),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A configurable [`CameraProjection`] that can select its projection type at runtime.
    bevy_render::camera::Projection :
    Clone +
    Debug +
    Methods
    (
        get_projection_matrix(&self:) -> Wrapped(Mat4),

        update(&mut self:Raw(f32),Raw(f32)),

        far(&self:) -> Raw(f32),

    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    bevy_render::camera::OrthographicProjection :
    Clone +
    Debug +
    Methods
    (
        get_projection_matrix(&self:) -> Wrapped(Mat4),

        update(&mut self:Raw(f32),Raw(f32)),

        far(&self:) -> Raw(f32),

    )
    + Fields
    (
        left: Raw(f32),
        right: Raw(f32),
        bottom: Raw(f32),
        top: Raw(f32),
        near: Raw(f32),
        #[rename("_far")]
        far: Raw(f32),
        window_origin: Wrapped(WindowOrigin),
        scaling_mode: Wrapped(ScalingMode),
        scale: Raw(f32),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 3D camera projection in which distant objects appear smaller than close objects.
    bevy_render::camera::PerspectiveProjection :
    Clone +
    Debug +
    Methods
    (
        get_projection_matrix(&self:) -> Wrapped(Mat4),

        update(&mut self:Raw(f32),Raw(f32)),

        far(&self:) -> Raw(f32),

    )
    + Fields
    (
        /// The vertical field of view (FOV) in radians.
        ///
        /// Defaults to a value of π/4 radians or 45 degrees.
        fov: Raw(f32),
        /// The aspect ratio (width divided by height) of the viewing frustum.
        ///
        /// Bevy's [`camera_system`](crate::camera::camera_system) automatically
        /// updates this value when the aspect ratio of the associated window changes.
        ///
        /// Defaults to a value of `1.0`.
        aspect_ratio: Raw(f32),
        /// The distance from the camera in world units of the viewing frustum's near plane.
        ///
        /// Objects closer to the camera than this value will not be visible.
        ///
        /// Defaults to a value of `0.1`.
        near: Raw(f32),
        /// The distance from the camera in world units of the viewing frustum's far plane.
        ///
        /// Objects farther from the camera than this value will not be visible.
        ///
        /// Defaults to a value of `1000.0`.
        #[rename("_far")]
        far: Raw(f32),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Configures the [`RenderGraph`](crate::render_graph::RenderGraph) name assigned to be run for a given [`Camera`] entity.
    bevy_render::camera::CameraRenderGraph :
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///An unique identifier to an asset path.
    bevy_asset::AssetPathId :
    Clone +
    Debug +
    Methods
    (
        ///Gets the id of the source path.
        source_path_id(&self:) -> Wrapped(SourcePathId),

        ///Gets the id of the sub-asset label.
        label_id(&self:) -> Wrapped(LabelId),

    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///An unique identifier to a sub-asset label.
    bevy_asset::LabelId :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///An unique identifier to the source path of an asset.
    bevy_asset::SourcePathId :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A unique, stable asset id.
    bevy_asset::HandleId :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 2-dimensional vector.
    glam::f32::Vec2 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new vector.
        new(Raw(f32),Raw(f32)) -> self,

        ///Creates a vector with all elements set to `v`.
        splat(Raw(f32)) -> self,

        ///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
        ///for each element of `self`.
        ///
        ///A true element in the mask uses the corresponding element from `if_true`, and false
        ///uses the element from `if_false`.
        select(Wrapped(BVec2),self,self) -> self,

        ///Creates a 3D vector from `self` and the given `z` value.
        extend(self:Raw(f32)) -> Wrapped(Vec3),

        ///Computes the dot product of `self` and `rhs`.
        dot(self:self) -> Raw(f32),

        ///Returns a vector where every component is the dot product of `self` and `rhs`.
        dot_into_vec(self:self) -> self,

        ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
        min(self:self) -> self,

        ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
        max(self:self) -> self,

        ///Component-wise clamping of values, similar to [`f32::clamp`].
        ///
        ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp(self:self,self) -> self,

        ///Returns the horizontal minimum of `self`.
        ///
        ///In other words this computes `min(x, y, ..)`.
        min_element(self:) -> Raw(f32),

        ///Returns the horizontal maximum of `self`.
        ///
        ///In other words this computes `max(x, y, ..)`.
        max_element(self:) -> Raw(f32),

        ///Returns a vector mask containing the result of a `==` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
        ///elements.
        cmpeq(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `!=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
        ///elements.
        cmpne(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `>=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
        ///elements.
        cmpge(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `>` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
        ///elements.
        cmpgt(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `<=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
        ///elements.
        cmple(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `<` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
        ///elements.
        cmplt(self:self) -> Wrapped(BVec2),

        ///Returns a vector containing the absolute value of each element of `self`.
        abs(self:) -> self,

        ///Returns a vector with elements representing the sign of `self`.
        ///
        ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
        ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
        ///- `NAN` if the number is `NAN`
        signum(self:) -> self,

        ///Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `self`.
        ///
        ///A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
        ///into the first lowest bit, element `y` into the second, etc.
        is_negative_bitmask(self:) -> Raw(u32),

        ///Returns `true` if, and only if, all elements are finite.  If any element is either
        ///`NaN`, positive or negative infinity, this will return `false`.
        is_finite(self:) -> Raw(bool),

        ///Returns `true` if any elements are `NaN`.
        is_nan(self:) -> Raw(bool),

        ///Performs `is_nan` on each element of self, returning a vector mask of the results.
        ///
        ///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
        is_nan_mask(self:) -> Wrapped(BVec2),

        ///Computes the length of `self`.
        length(self:) -> Raw(f32),

        ///Computes the squared length of `self`.
        ///
        ///This is faster than `length()` as it avoids a square root operation.
        length_squared(self:) -> Raw(f32),

        ///Computes `1.0 / length()`.
        ///
        ///For valid results, `self` must _not_ be of length zero.
        length_recip(self:) -> Raw(f32),

        ///Computes the Euclidean distance between two points in space.
        distance(self:self) -> Raw(f32),

        ///Compute the squared euclidean distance between two points in space.
        distance_squared(self:self) -> Raw(f32),

        ///Returns `self` normalized to length 1.0.
        ///
        ///For valid results, `self` must _not_ be of length zero, nor very close to zero.
        ///
        ///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
        ///
        ///Panics
        ///
        ///Will panic if `self` is zero length when `glam_assert` is enabled.
        normalize(self:) -> self,

        ///Returns `self` normalized to length 1.0 if possible, else returns zero.
        ///
        ///In particular, if the input is zero (or very close to zero), or non-finite,
        ///the result of this operation will be zero.
        ///
        ///See also [`Self::try_normalize`].
        normalize_or_zero(self:) -> self,

        ///Returns whether `self` is length `1.0` or not.
        ///
        ///Uses a precision threshold of `1e-6`.
        is_normalized(self:) -> Raw(bool),

        ///Returns the vector projection of `self` onto `rhs`.
        ///
        ///`rhs` must be of non-zero length.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is zero length when `glam_assert` is enabled.
        project_onto(self:self) -> self,

        ///Returns the vector rejection of `self` from `rhs`.
        ///
        ///The vector rejection is the vector perpendicular to the projection of `self` onto
        ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
        ///
        ///`rhs` must be of non-zero length.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
        reject_from(self:self) -> self,

        ///Returns the vector projection of `self` onto `rhs`.
        ///
        ///`rhs` must be normalized.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
        project_onto_normalized(self:self) -> self,

        ///Returns the vector rejection of `self` from `rhs`.
        ///
        ///The vector rejection is the vector perpendicular to the projection of `self` onto
        ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
        ///
        ///`rhs` must be normalized.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
        reject_from_normalized(self:self) -> self,

        ///Returns a vector containing the nearest integer to a number for each element of `self`.
        ///Round half-way cases away from 0.0.
        round(self:) -> self,

        ///Returns a vector containing the largest integer less than or equal to a number for each
        ///element of `self`.
        floor(self:) -> self,

        ///Returns a vector containing the smallest integer greater than or equal to a number for
        ///each element of `self`.
        ceil(self:) -> self,

        ///Returns a vector containing the fractional part of the vector, e.g. `self -
        ///self.floor()`.
        ///
        ///Note that this is fast but not precise for large numbers.
        fract(self:) -> self,

        ///Returns a vector containing `e^self` (the exponential function) for each element of
        ///`self`.
        exp(self:) -> self,

        ///Returns a vector containing each element of `self` raised to the power of `n`.
        powf(self:Raw(f32)) -> self,

        ///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
        recip(self:) -> self,

        ///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
        ///
        ///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
        ///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
        ///extrapolated.
        lerp(self:self,Raw(f32)) -> self,

        ///Returns true if the absolute difference of all elements between `self` and `rhs` is
        ///less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two vectors contain similar elements. It works best when
        ///comparing with a known value. The `max_abs_diff` that should be used used depends on
        ///the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(self:self,Raw(f32)) -> Raw(bool),

        ///Returns a vector with a length no less than `min` and no more than `max`
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp_length(self:Raw(f32),Raw(f32)) -> self,

        ///Returns a vector with a length no more than `max`
        clamp_length_max(self:Raw(f32)) -> self,

        ///Returns a vector with a length no less than `min`
        clamp_length_min(self:Raw(f32)) -> self,

        ///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
        ///error, yielding a more accurate result than an unfused multiply-add.
        ///
        ///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
        ///architecture has a dedicated fma CPU instruction. However, this is not always true,
        ///and will be heavily dependant on designing algorithms with specific target hardware in
        ///mind.
        mul_add(self:self,self) -> self,

        ///Creates a 2D vector containing `[angle.cos(), angle.sin()]`. This can be used in
        ///conjunction with the `rotate` method, e.g. `Vec2::from_angle(PI).rotate(Vec2::Y)` will
        ///create the vector [-1, 0] and rotate `Vec2::Y` around it returning `-Vec2::Y`.
        from_angle(Raw(f32)) -> self,

        ///Returns the angle (in radians) between `self` and `rhs`.
        ///
        ///The input vectors do not need to be unit length however they must be non-zero.
        angle_between(self:self) -> Raw(f32),

        ///Returns a vector that is equal to `self` rotated by 90 degrees.
        perp(self:) -> self,

        ///The perpendicular dot product of `self` and `rhs`.
        ///Also known as the wedge product, 2D cross product, and determinant.
        perp_dot(self:self) -> Raw(f32),

        ///Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
        ///then this just rotation. This is what you usually want. Otherwise,
        ///it will be like a rotation with a multiplication by `self`'s length.
        rotate(self:self) -> self,

        ///Casts all elements of `self` to `f64`.
        as_dvec2(&self:) -> Wrapped(DVec2),

        ///Casts all elements of `self` to `i32`.
        as_ivec2(&self:) -> Wrapped(IVec2),

        ///Casts all elements of `self` to `u32`.
        as_uvec2(&self:) -> Wrapped(UVec2),

    )
    + Fields
    (
        x: Raw(f32),
        y: Raw(f32),
    )
    + BinOps
    (
        self Add self -> Wrapped(Vec2),
        self Add Raw(f32) -> Wrapped(Vec2),
        self Add Wrapped(Vec2) -> Wrapped(Vec2),
        self Sub self -> Wrapped(Vec2),
        self Sub Raw(f32) -> Wrapped(Vec2),
        self Sub Wrapped(Vec2) -> Wrapped(Vec2),
        self Div self -> Wrapped(Vec2),
        self Div Raw(f32) -> Wrapped(Vec2),
        self Div Wrapped(Vec2) -> Wrapped(Vec2),
        self Mul self -> Wrapped(Vec2),
        self Mul Raw(f32) -> Wrapped(Vec2),
        self Mul Wrapped(Vec2) -> Wrapped(Vec2),
        self Rem self -> Wrapped(Vec2),
        self Rem Raw(f32) -> Wrapped(Vec2),
        self Rem Wrapped(Vec2) -> Wrapped(Vec2),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {
        (MetaMethod::Index) => |_,s,idx: usize| {Ok(s.inner()?[idx])};
        mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,f32)| {s.val_mut(|s| Ok(s[idx] = val))?};
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 3-dimensional vector.
    glam::f32::Vec3 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new vector.
        new(Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Creates a vector with all elements set to `v`.
        splat(Raw(f32)) -> self,

        ///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
        ///for each element of `self`.
        ///
        ///A true element in the mask uses the corresponding element from `if_true`, and false
        ///uses the element from `if_false`.
        select(Wrapped(BVec3),self,self) -> self,

        ///Creates a 4D vector from `self` and the given `w` value.
        extend(self:Raw(f32)) -> Wrapped(Vec4),

        ///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
        ///
        ///Truncation may also be performed by using `self.xy()` or `Vec2::from()`.
        truncate(self:) -> Wrapped(Vec2),

        ///Computes the dot product of `self` and `rhs`.
        dot(self:self) -> Raw(f32),

        ///Returns a vector where every component is the dot product of `self` and `rhs`.
        dot_into_vec(self:self) -> self,

        ///Computes the cross product of `self` and `rhs`.
        cross(self:self) -> self,

        ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
        min(self:self) -> self,

        ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
        max(self:self) -> self,

        ///Component-wise clamping of values, similar to [`f32::clamp`].
        ///
        ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp(self:self,self) -> self,

        ///Returns the horizontal minimum of `self`.
        ///
        ///In other words this computes `min(x, y, ..)`.
        min_element(self:) -> Raw(f32),

        ///Returns the horizontal maximum of `self`.
        ///
        ///In other words this computes `max(x, y, ..)`.
        max_element(self:) -> Raw(f32),

        ///Returns a vector mask containing the result of a `==` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
        ///elements.
        cmpeq(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `!=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
        ///elements.
        cmpne(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `>=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
        ///elements.
        cmpge(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `>` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
        ///elements.
        cmpgt(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `<=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
        ///elements.
        cmple(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `<` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
        ///elements.
        cmplt(self:self) -> Wrapped(BVec3),

        ///Returns a vector containing the absolute value of each element of `self`.
        abs(self:) -> self,

        ///Returns a vector with elements representing the sign of `self`.
        ///
        ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
        ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
        ///- `NAN` if the number is `NAN`
        signum(self:) -> self,

        ///Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.
        ///
        ///A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
        ///into the first lowest bit, element `y` into the second, etc.
        is_negative_bitmask(self:) -> Raw(u32),

        ///Returns `true` if, and only if, all elements are finite.  If any element is either
        ///`NaN`, positive or negative infinity, this will return `false`.
        is_finite(self:) -> Raw(bool),

        ///Returns `true` if any elements are `NaN`.
        is_nan(self:) -> Raw(bool),

        ///Performs `is_nan` on each element of self, returning a vector mask of the results.
        ///
        ///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
        is_nan_mask(self:) -> Wrapped(BVec3),

        ///Computes the length of `self`.
        length(self:) -> Raw(f32),

        ///Computes the squared length of `self`.
        ///
        ///This is faster than `length()` as it avoids a square root operation.
        length_squared(self:) -> Raw(f32),

        ///Computes `1.0 / length()`.
        ///
        ///For valid results, `self` must _not_ be of length zero.
        length_recip(self:) -> Raw(f32),

        ///Computes the Euclidean distance between two points in space.
        distance(self:self) -> Raw(f32),

        ///Compute the squared euclidean distance between two points in space.
        distance_squared(self:self) -> Raw(f32),

        ///Returns `self` normalized to length 1.0.
        ///
        ///For valid results, `self` must _not_ be of length zero, nor very close to zero.
        ///
        ///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
        ///
        ///Panics
        ///
        ///Will panic if `self` is zero length when `glam_assert` is enabled.
        normalize(self:) -> self,

        ///Returns `self` normalized to length 1.0 if possible, else returns zero.
        ///
        ///In particular, if the input is zero (or very close to zero), or non-finite,
        ///the result of this operation will be zero.
        ///
        ///See also [`Self::try_normalize`].
        normalize_or_zero(self:) -> self,

        ///Returns whether `self` is length `1.0` or not.
        ///
        ///Uses a precision threshold of `1e-6`.
        is_normalized(self:) -> Raw(bool),

        ///Returns the vector projection of `self` onto `rhs`.
        ///
        ///`rhs` must be of non-zero length.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is zero length when `glam_assert` is enabled.
        project_onto(self:self) -> self,

        ///Returns the vector rejection of `self` from `rhs`.
        ///
        ///The vector rejection is the vector perpendicular to the projection of `self` onto
        ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
        ///
        ///`rhs` must be of non-zero length.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
        reject_from(self:self) -> self,

        ///Returns the vector projection of `self` onto `rhs`.
        ///
        ///`rhs` must be normalized.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
        project_onto_normalized(self:self) -> self,

        ///Returns the vector rejection of `self` from `rhs`.
        ///
        ///The vector rejection is the vector perpendicular to the projection of `self` onto
        ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
        ///
        ///`rhs` must be normalized.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
        reject_from_normalized(self:self) -> self,

        ///Returns a vector containing the nearest integer to a number for each element of `self`.
        ///Round half-way cases away from 0.0.
        round(self:) -> self,

        ///Returns a vector containing the largest integer less than or equal to a number for each
        ///element of `self`.
        floor(self:) -> self,

        ///Returns a vector containing the smallest integer greater than or equal to a number for
        ///each element of `self`.
        ceil(self:) -> self,

        ///Returns a vector containing the fractional part of the vector, e.g. `self -
        ///self.floor()`.
        ///
        ///Note that this is fast but not precise for large numbers.
        fract(self:) -> self,

        ///Returns a vector containing `e^self` (the exponential function) for each element of
        ///`self`.
        exp(self:) -> self,

        ///Returns a vector containing each element of `self` raised to the power of `n`.
        powf(self:Raw(f32)) -> self,

        ///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
        recip(self:) -> self,

        ///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
        ///
        ///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
        ///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
        ///extrapolated.
        lerp(self:self,Raw(f32)) -> self,

        ///Returns true if the absolute difference of all elements between `self` and `rhs` is
        ///less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two vectors contain similar elements. It works best when
        ///comparing with a known value. The `max_abs_diff` that should be used used depends on
        ///the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(self:self,Raw(f32)) -> Raw(bool),

        ///Returns a vector with a length no less than `min` and no more than `max`
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp_length(self:Raw(f32),Raw(f32)) -> self,

        ///Returns a vector with a length no more than `max`
        clamp_length_max(self:Raw(f32)) -> self,

        ///Returns a vector with a length no less than `min`
        clamp_length_min(self:Raw(f32)) -> self,

        ///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
        ///error, yielding a more accurate result than an unfused multiply-add.
        ///
        ///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
        ///architecture has a dedicated fma CPU instruction. However, this is not always true,
        ///and will be heavily dependant on designing algorithms with specific target hardware in
        ///mind.
        mul_add(self:self,self) -> self,

        ///Returns the angle (in radians) between two vectors.
        ///
        ///The input vectors do not need to be unit length however they must be non-zero.
        angle_between(self:self) -> Raw(f32),

        ///Returns some vector that is orthogonal to the given one.
        ///
        ///The input vector must be finite and non-zero.
        ///
        ///The output vector is not necessarily unit-length.
        ///For that use [`Self::any_orthonormal_vector`] instead.
        any_orthogonal_vector(&self:) -> self,

        ///Returns any unit-length vector that is orthogonal to the given one.
        ///The input vector must be finite and non-zero.
        ///
        ///# Panics
        ///
        ///Will panic if `self` is not normalized when `glam_assert` is enabled.
        any_orthonormal_vector(&self:) -> self,

        ///Casts all elements of `self` to `f64`.
        as_dvec3(&self:) -> Wrapped(DVec3),

        ///Casts all elements of `self` to `i32`.
        as_ivec3(&self:) -> Wrapped(IVec3),

        ///Casts all elements of `self` to `u32`.
        as_uvec3(&self:) -> Wrapped(UVec3),

    )
    + Fields
    (
        x: Raw(f32),
        y: Raw(f32),
        z: Raw(f32),
    )
    + BinOps
    (
        self Add self -> Wrapped(Vec3),
        self Add Raw(f32) -> Wrapped(Vec3),
        self Add Wrapped(Vec3) -> Wrapped(Vec3),
        self Sub self -> Wrapped(Vec3),
        self Sub Raw(f32) -> Wrapped(Vec3),
        self Sub Wrapped(Vec3) -> Wrapped(Vec3),
        self Div self -> Wrapped(Vec3),
        self Div Raw(f32) -> Wrapped(Vec3),
        self Div Wrapped(Vec3) -> Wrapped(Vec3),
        self Mul self -> Wrapped(Vec3),
        self Mul Raw(f32) -> Wrapped(Vec3),
        self Mul Wrapped(Vec3) -> Wrapped(Vec3),
        self Rem self -> Wrapped(Vec3),
        self Rem Raw(f32) -> Wrapped(Vec3),
        self Rem Wrapped(Vec3) -> Wrapped(Vec3),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {
        (MetaMethod::Index) => |_,s,idx: usize| {Ok(s.inner()?[idx])};
        mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,f32)| {s.val_mut(|s| Ok(s[idx] = val))?};
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 3-dimensional vector with SIMD support.
    ///
    ///This type is 16 byte aligned. A SIMD vector type is used for storage on supported platforms for
    ///better performance than the `Vec3` type.
    ///
    ///It is possible to convert between `Vec3` and `Vec3A` types using `From` trait implementations.
    glam::f32::Vec3A :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new vector.
        new(Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Creates a vector with all elements set to `v`.
        splat(Raw(f32)) -> self,

        ///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
        ///for each element of `self`.
        ///
        ///A true element in the mask uses the corresponding element from `if_true`, and false
        ///uses the element from `if_false`.
        select(Wrapped(BVec3A),self,self) -> self,

        ///Creates a 4D vector from `self` and the given `w` value.
        extend(self:Raw(f32)) -> Wrapped(Vec4),

        ///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
        ///
        ///Truncation may also be performed by using `self.xy()` or `Vec2::from()`.
        truncate(self:) -> Wrapped(Vec2),

        ///Computes the dot product of `self` and `rhs`.
        dot(self:self) -> Raw(f32),

        ///Returns a vector where every component is the dot product of `self` and `rhs`.
        dot_into_vec(self:self) -> self,

        ///Computes the cross product of `self` and `rhs`.
        cross(self:self) -> self,

        ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
        min(self:self) -> self,

        ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
        max(self:self) -> self,

        ///Component-wise clamping of values, similar to [`f32::clamp`].
        ///
        ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp(self:self,self) -> self,

        ///Returns the horizontal minimum of `self`.
        ///
        ///In other words this computes `min(x, y, ..)`.
        min_element(self:) -> Raw(f32),

        ///Returns the horizontal maximum of `self`.
        ///
        ///In other words this computes `max(x, y, ..)`.
        max_element(self:) -> Raw(f32),

        ///Returns a vector mask containing the result of a `==` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
        ///elements.
        cmpeq(self:self) -> Wrapped(BVec3A),

        ///Returns a vector mask containing the result of a `!=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
        ///elements.
        cmpne(self:self) -> Wrapped(BVec3A),

        ///Returns a vector mask containing the result of a `>=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
        ///elements.
        cmpge(self:self) -> Wrapped(BVec3A),

        ///Returns a vector mask containing the result of a `>` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
        ///elements.
        cmpgt(self:self) -> Wrapped(BVec3A),

        ///Returns a vector mask containing the result of a `<=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
        ///elements.
        cmple(self:self) -> Wrapped(BVec3A),

        ///Returns a vector mask containing the result of a `<` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
        ///elements.
        cmplt(self:self) -> Wrapped(BVec3A),

        ///Returns a vector containing the absolute value of each element of `self`.
        abs(self:) -> self,

        ///Returns a vector with elements representing the sign of `self`.
        ///
        ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
        ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
        ///- `NAN` if the number is `NAN`
        signum(self:) -> self,

        ///Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.
        ///
        ///A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
        ///into the first lowest bit, element `y` into the second, etc.
        is_negative_bitmask(self:) -> Raw(u32),

        ///Returns `true` if, and only if, all elements are finite.  If any element is either
        ///`NaN`, positive or negative infinity, this will return `false`.
        is_finite(self:) -> Raw(bool),

        ///Returns `true` if any elements are `NaN`.
        is_nan(self:) -> Raw(bool),

        ///Performs `is_nan` on each element of self, returning a vector mask of the results.
        ///
        ///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
        is_nan_mask(self:) -> Wrapped(BVec3A),

        ///Computes the length of `self`.
        length(self:) -> Raw(f32),

        ///Computes the squared length of `self`.
        ///
        ///This is faster than `length()` as it avoids a square root operation.
        length_squared(self:) -> Raw(f32),

        ///Computes `1.0 / length()`.
        ///
        ///For valid results, `self` must _not_ be of length zero.
        length_recip(self:) -> Raw(f32),

        ///Computes the Euclidean distance between two points in space.
        distance(self:self) -> Raw(f32),

        ///Compute the squared euclidean distance between two points in space.
        distance_squared(self:self) -> Raw(f32),

        ///Returns `self` normalized to length 1.0.
        ///
        ///For valid results, `self` must _not_ be of length zero, nor very close to zero.
        ///
        ///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
        ///
        ///Panics
        ///
        ///Will panic if `self` is zero length when `glam_assert` is enabled.
        normalize(self:) -> self,

        ///Returns `self` normalized to length 1.0 if possible, else returns zero.
        ///
        ///In particular, if the input is zero (or very close to zero), or non-finite,
        ///the result of this operation will be zero.
        ///
        ///See also [`Self::try_normalize`].
        normalize_or_zero(self:) -> self,

        ///Returns whether `self` is length `1.0` or not.
        ///
        ///Uses a precision threshold of `1e-6`.
        is_normalized(self:) -> Raw(bool),

        ///Returns the vector projection of `self` onto `rhs`.
        ///
        ///`rhs` must be of non-zero length.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is zero length when `glam_assert` is enabled.
        project_onto(self:self) -> self,

        ///Returns the vector rejection of `self` from `rhs`.
        ///
        ///The vector rejection is the vector perpendicular to the projection of `self` onto
        ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
        ///
        ///`rhs` must be of non-zero length.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
        reject_from(self:self) -> self,

        ///Returns the vector projection of `self` onto `rhs`.
        ///
        ///`rhs` must be normalized.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
        project_onto_normalized(self:self) -> self,

        ///Returns the vector rejection of `self` from `rhs`.
        ///
        ///The vector rejection is the vector perpendicular to the projection of `self` onto
        ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
        ///
        ///`rhs` must be normalized.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
        reject_from_normalized(self:self) -> self,

        ///Returns a vector containing the nearest integer to a number for each element of `self`.
        ///Round half-way cases away from 0.0.
        round(self:) -> self,

        ///Returns a vector containing the largest integer less than or equal to a number for each
        ///element of `self`.
        floor(self:) -> self,

        ///Returns a vector containing the smallest integer greater than or equal to a number for
        ///each element of `self`.
        ceil(self:) -> self,

        ///Returns a vector containing the fractional part of the vector, e.g. `self -
        ///self.floor()`.
        ///
        ///Note that this is fast but not precise for large numbers.
        fract(self:) -> self,

        ///Returns a vector containing `e^self` (the exponential function) for each element of
        ///`self`.
        exp(self:) -> self,

        ///Returns a vector containing each element of `self` raised to the power of `n`.
        powf(self:Raw(f32)) -> self,

        ///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
        recip(self:) -> self,

        ///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
        ///
        ///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
        ///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
        ///extrapolated.
        lerp(self:self,Raw(f32)) -> self,

        ///Returns true if the absolute difference of all elements between `self` and `rhs` is
        ///less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two vectors contain similar elements. It works best when
        ///comparing with a known value. The `max_abs_diff` that should be used used depends on
        ///the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(self:self,Raw(f32)) -> Raw(bool),

        ///Returns a vector with a length no less than `min` and no more than `max`
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp_length(self:Raw(f32),Raw(f32)) -> self,

        ///Returns a vector with a length no more than `max`
        clamp_length_max(self:Raw(f32)) -> self,

        ///Returns a vector with a length no less than `min`
        clamp_length_min(self:Raw(f32)) -> self,

        ///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
        ///error, yielding a more accurate result than an unfused multiply-add.
        ///
        ///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
        ///architecture has a dedicated fma CPU instruction. However, this is not always true,
        ///and will be heavily dependant on designing algorithms with specific target hardware in
        ///mind.
        mul_add(self:self,self) -> self,

        ///Returns the angle (in radians) between two vectors.
        ///
        ///The input vectors do not need to be unit length however they must be non-zero.
        angle_between(self:self) -> Raw(f32),

        ///Returns some vector that is orthogonal to the given one.
        ///
        ///The input vector must be finite and non-zero.
        ///
        ///The output vector is not necessarily unit-length.
        ///For that use [`Self::any_orthonormal_vector`] instead.
        any_orthogonal_vector(&self:) -> self,

        ///Returns any unit-length vector that is orthogonal to the given one.
        ///The input vector must be finite and non-zero.
        ///
        ///# Panics
        ///
        ///Will panic if `self` is not normalized when `glam_assert` is enabled.
        any_orthonormal_vector(&self:) -> self,

        ///Casts all elements of `self` to `f64`.
        as_dvec3(&self:) -> Wrapped(DVec3),

        ///Casts all elements of `self` to `i32`.
        as_ivec3(&self:) -> Wrapped(IVec3),

        ///Casts all elements of `self` to `u32`.
        as_uvec3(&self:) -> Wrapped(UVec3),

    )
    + Fields
    (
    )
    + BinOps
    (
        self Add self -> Wrapped(Vec3A),
        self Add Raw(f32) -> Wrapped(Vec3A),
        self Add Wrapped(Vec3A) -> Wrapped(Vec3A),
        self Sub self -> Wrapped(Vec3A),
        self Sub Raw(f32) -> Wrapped(Vec3A),
        self Sub Wrapped(Vec3A) -> Wrapped(Vec3A),
        self Div self -> Wrapped(Vec3A),
        self Div Raw(f32) -> Wrapped(Vec3A),
        self Div Wrapped(Vec3A) -> Wrapped(Vec3A),
        self Mul self -> Wrapped(Vec3A),
        self Mul Raw(f32) -> Wrapped(Vec3A),
        self Mul Wrapped(Vec3A) -> Wrapped(Vec3A),
        self Rem self -> Wrapped(Vec3A),
        self Rem Raw(f32) -> Wrapped(Vec3A),
        self Rem Wrapped(Vec3A) -> Wrapped(Vec3A),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {
        (MetaMethod::Index) => |_,s,idx: usize| {Ok(s.inner()?[idx])};
        mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,f32)| {s.val_mut(|s| Ok(s[idx] = val))?};
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 4-dimensional vector with SIMD support.
    ///
    ///This type uses 16 byte aligned SIMD vector type for storage.
    glam::f32::Vec4 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new vector.
        new(Raw(f32),Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Creates a vector with all elements set to `v`.
        splat(Raw(f32)) -> self,

        ///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
        ///for each element of `self`.
        ///
        ///A true element in the mask uses the corresponding element from `if_true`, and false
        ///uses the element from `if_false`.
        select(Wrapped(BVec4A),self,self) -> self,

        ///Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
        ///
        ///Truncation to `Vec3` may also be performed by using `self.xyz()` or `Vec3::from()`.
        ///
        ///To truncate to `Vec3A` use `Vec3A::from()`.
        truncate(self:) -> Wrapped(Vec3),

        ///Computes the dot product of `self` and `rhs`.
        dot(self:self) -> Raw(f32),

        ///Returns a vector where every component is the dot product of `self` and `rhs`.
        dot_into_vec(self:self) -> self,

        ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
        min(self:self) -> self,

        ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
        max(self:self) -> self,

        ///Component-wise clamping of values, similar to [`f32::clamp`].
        ///
        ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp(self:self,self) -> self,

        ///Returns the horizontal minimum of `self`.
        ///
        ///In other words this computes `min(x, y, ..)`.
        min_element(self:) -> Raw(f32),

        ///Returns the horizontal maximum of `self`.
        ///
        ///In other words this computes `max(x, y, ..)`.
        max_element(self:) -> Raw(f32),

        ///Returns a vector mask containing the result of a `==` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
        ///elements.
        cmpeq(self:self) -> Wrapped(BVec4A),

        ///Returns a vector mask containing the result of a `!=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
        ///elements.
        cmpne(self:self) -> Wrapped(BVec4A),

        ///Returns a vector mask containing the result of a `>=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
        ///elements.
        cmpge(self:self) -> Wrapped(BVec4A),

        ///Returns a vector mask containing the result of a `>` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
        ///elements.
        cmpgt(self:self) -> Wrapped(BVec4A),

        ///Returns a vector mask containing the result of a `<=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
        ///elements.
        cmple(self:self) -> Wrapped(BVec4A),

        ///Returns a vector mask containing the result of a `<` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
        ///elements.
        cmplt(self:self) -> Wrapped(BVec4A),

        ///Returns a vector containing the absolute value of each element of `self`.
        abs(self:) -> self,

        ///Returns a vector with elements representing the sign of `self`.
        ///
        ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
        ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
        ///- `NAN` if the number is `NAN`
        signum(self:) -> self,

        ///Returns a bitmask with the lowest 4 bits set to the sign bits from the elements of `self`.
        ///
        ///A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
        ///into the first lowest bit, element `y` into the second, etc.
        is_negative_bitmask(self:) -> Raw(u32),

        ///Returns `true` if, and only if, all elements are finite.  If any element is either
        ///`NaN`, positive or negative infinity, this will return `false`.
        is_finite(self:) -> Raw(bool),

        ///Returns `true` if any elements are `NaN`.
        is_nan(self:) -> Raw(bool),

        ///Performs `is_nan` on each element of self, returning a vector mask of the results.
        ///
        ///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
        is_nan_mask(self:) -> Wrapped(BVec4A),

        ///Computes the length of `self`.
        length(self:) -> Raw(f32),

        ///Computes the squared length of `self`.
        ///
        ///This is faster than `length()` as it avoids a square root operation.
        length_squared(self:) -> Raw(f32),

        ///Computes `1.0 / length()`.
        ///
        ///For valid results, `self` must _not_ be of length zero.
        length_recip(self:) -> Raw(f32),

        ///Computes the Euclidean distance between two points in space.
        distance(self:self) -> Raw(f32),

        ///Compute the squared euclidean distance between two points in space.
        distance_squared(self:self) -> Raw(f32),

        ///Returns `self` normalized to length 1.0.
        ///
        ///For valid results, `self` must _not_ be of length zero, nor very close to zero.
        ///
        ///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
        ///
        ///Panics
        ///
        ///Will panic if `self` is zero length when `glam_assert` is enabled.
        normalize(self:) -> self,

        ///Returns `self` normalized to length 1.0 if possible, else returns zero.
        ///
        ///In particular, if the input is zero (or very close to zero), or non-finite,
        ///the result of this operation will be zero.
        ///
        ///See also [`Self::try_normalize`].
        normalize_or_zero(self:) -> self,

        ///Returns whether `self` is length `1.0` or not.
        ///
        ///Uses a precision threshold of `1e-6`.
        is_normalized(self:) -> Raw(bool),

        ///Returns the vector projection of `self` onto `rhs`.
        ///
        ///`rhs` must be of non-zero length.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is zero length when `glam_assert` is enabled.
        project_onto(self:self) -> self,

        ///Returns the vector rejection of `self` from `rhs`.
        ///
        ///The vector rejection is the vector perpendicular to the projection of `self` onto
        ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
        ///
        ///`rhs` must be of non-zero length.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
        reject_from(self:self) -> self,

        ///Returns the vector projection of `self` onto `rhs`.
        ///
        ///`rhs` must be normalized.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
        project_onto_normalized(self:self) -> self,

        ///Returns the vector rejection of `self` from `rhs`.
        ///
        ///The vector rejection is the vector perpendicular to the projection of `self` onto
        ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
        ///
        ///`rhs` must be normalized.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
        reject_from_normalized(self:self) -> self,

        ///Returns a vector containing the nearest integer to a number for each element of `self`.
        ///Round half-way cases away from 0.0.
        round(self:) -> self,

        ///Returns a vector containing the largest integer less than or equal to a number for each
        ///element of `self`.
        floor(self:) -> self,

        ///Returns a vector containing the smallest integer greater than or equal to a number for
        ///each element of `self`.
        ceil(self:) -> self,

        ///Returns a vector containing the fractional part of the vector, e.g. `self -
        ///self.floor()`.
        ///
        ///Note that this is fast but not precise for large numbers.
        fract(self:) -> self,

        ///Returns a vector containing `e^self` (the exponential function) for each element of
        ///`self`.
        exp(self:) -> self,

        ///Returns a vector containing each element of `self` raised to the power of `n`.
        powf(self:Raw(f32)) -> self,

        ///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
        recip(self:) -> self,

        ///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
        ///
        ///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
        ///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
        ///extrapolated.
        lerp(self:self,Raw(f32)) -> self,

        ///Returns true if the absolute difference of all elements between `self` and `rhs` is
        ///less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two vectors contain similar elements. It works best when
        ///comparing with a known value. The `max_abs_diff` that should be used used depends on
        ///the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(self:self,Raw(f32)) -> Raw(bool),

        ///Returns a vector with a length no less than `min` and no more than `max`
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp_length(self:Raw(f32),Raw(f32)) -> self,

        ///Returns a vector with a length no more than `max`
        clamp_length_max(self:Raw(f32)) -> self,

        ///Returns a vector with a length no less than `min`
        clamp_length_min(self:Raw(f32)) -> self,

        ///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
        ///error, yielding a more accurate result than an unfused multiply-add.
        ///
        ///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
        ///architecture has a dedicated fma CPU instruction. However, this is not always true,
        ///and will be heavily dependant on designing algorithms with specific target hardware in
        ///mind.
        mul_add(self:self,self) -> self,

        ///Casts all elements of `self` to `f64`.
        as_dvec4(&self:) -> Wrapped(DVec4),

        ///Casts all elements of `self` to `i32`.
        as_ivec4(&self:) -> Wrapped(IVec4),

        ///Casts all elements of `self` to `u32`.
        as_uvec4(&self:) -> Wrapped(UVec4),

    )
    + Fields
    (
    )
    + BinOps
    (
        self Add self -> Wrapped(Vec4),
        self Add Raw(f32) -> Wrapped(Vec4),
        self Add Wrapped(Vec4) -> Wrapped(Vec4),
        self Sub self -> Wrapped(Vec4),
        self Sub Raw(f32) -> Wrapped(Vec4),
        self Sub Wrapped(Vec4) -> Wrapped(Vec4),
        self Div self -> Wrapped(Vec4),
        self Div Raw(f32) -> Wrapped(Vec4),
        self Div Wrapped(Vec4) -> Wrapped(Vec4),
        self Mul self -> Wrapped(Vec4),
        self Mul Raw(f32) -> Wrapped(Vec4),
        self Mul Wrapped(Vec4) -> Wrapped(Vec4),
        self Rem self -> Wrapped(Vec4),
        self Rem Raw(f32) -> Wrapped(Vec4),
        self Rem Wrapped(Vec4) -> Wrapped(Vec4),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {
        (MetaMethod::Index) => |_,s,idx: usize| {Ok(s.inner()?[idx])};
        mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,f32)| {s.val_mut(|s| Ok(s[idx] = val))?};
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 2-dimensional `bool` vector mask.
    glam::bool::BVec2 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new vector mask.
        new(Raw(bool),Raw(bool)) -> self,

        ///Creates a vector with all elements set to `v`.
        splat(Raw(bool)) -> self,

        ///Returns a bitmask with the lowest 2 bits set from the elements of `self`.
        ///
        ///A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
        ///into the first lowest bit, element `y` into the second, etc.
        bitmask(self:) -> Raw(u32),

        ///Returns true if any of the elements are true, false otherwise.
        any(self:) -> Raw(bool),

        ///Returns true if all the elements are true, false otherwise.
        all(self:) -> Raw(bool),

    )
    + Fields
    (
        x: Raw(bool),
        y: Raw(bool),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 3-dimensional `bool` vector mask.
    glam::bool::BVec3 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new vector mask.
        new(Raw(bool),Raw(bool),Raw(bool)) -> self,

        ///Creates a vector with all elements set to `v`.
        splat(Raw(bool)) -> self,

        ///Returns a bitmask with the lowest 3 bits set from the elements of `self`.
        ///
        ///A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
        ///into the first lowest bit, element `y` into the second, etc.
        bitmask(self:) -> Raw(u32),

        ///Returns true if any of the elements are true, false otherwise.
        any(self:) -> Raw(bool),

        ///Returns true if all the elements are true, false otherwise.
        all(self:) -> Raw(bool),

    )
    + Fields
    (
        x: Raw(bool),
        y: Raw(bool),
        z: Raw(bool),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 4-dimensional `bool` vector mask.
    glam::bool::BVec4 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new vector mask.
        new(Raw(bool),Raw(bool),Raw(bool),Raw(bool)) -> self,

        ///Creates a vector with all elements set to `v`.
        splat(Raw(bool)) -> self,

        ///Returns a bitmask with the lowest 4 bits set from the elements of `self`.
        ///
        ///A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
        ///into the first lowest bit, element `y` into the second, etc.
        bitmask(self:) -> Raw(u32),

        ///Returns true if any of the elements are true, false otherwise.
        any(self:) -> Raw(bool),

        ///Returns true if all the elements are true, false otherwise.
        all(self:) -> Raw(bool),

    )
    + Fields
    (
        x: Raw(bool),
        y: Raw(bool),
        z: Raw(bool),
        w: Raw(bool),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 3-dimensional SIMD vector mask.
    ///
    ///This type is 16 byte aligned and is backed by a SIMD vector. If SIMD is not available
    ///`BVec3A` will be a type alias for `BVec3`.
    glam::bool::BVec3A :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new vector mask.
        new(Raw(bool),Raw(bool),Raw(bool)) -> self,

        ///Creates a vector with all elements set to `v`.
        splat(Raw(bool)) -> self,

        ///Returns a bitmask with the lowest 3 bits set from the elements of `self`.
        ///
        ///A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
        ///into the first lowest bit, element `y` into the second, etc.
        bitmask(self:) -> Raw(u32),

        ///Returns true if any of the elements are true, false otherwise.
        any(self:) -> Raw(bool),

        ///Returns true if all the elements are true, false otherwise.
        all(self:) -> Raw(bool),

    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 4-dimensional SIMD vector mask.
    ///
    ///This type is 16 byte aligned and is backed by a SIMD vector. If SIMD is not available
    ///`BVec4A` will be a type alias for `BVec4`.
    glam::bool::BVec4A :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new vector mask.
        new(Raw(bool),Raw(bool),Raw(bool),Raw(bool)) -> self,

        ///Creates a vector with all elements set to `v`.
        splat(Raw(bool)) -> self,

        ///Returns a bitmask with the lowest 4 bits set from the elements of `self`.
        ///
        ///A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
        ///into the first lowest bit, element `y` into the second, etc.
        bitmask(self:) -> Raw(u32),

        ///Returns true if any of the elements are true, false otherwise.
        any(self:) -> Raw(bool),

        ///Returns true if all the elements are true, false otherwise.
        all(self:) -> Raw(bool),

    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 2-dimensional vector.
    glam::f64::DVec2 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new vector.
        new(Raw(f64),Raw(f64)) -> self,

        ///Creates a vector with all elements set to `v`.
        splat(Raw(f64)) -> self,

        ///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
        ///for each element of `self`.
        ///
        ///A true element in the mask uses the corresponding element from `if_true`, and false
        ///uses the element from `if_false`.
        select(Wrapped(BVec2),self,self) -> self,

        ///Creates a 3D vector from `self` and the given `z` value.
        extend(self:Raw(f64)) -> Wrapped(DVec3),

        ///Computes the dot product of `self` and `rhs`.
        dot(self:self) -> Raw(f64),

        ///Returns a vector where every component is the dot product of `self` and `rhs`.
        dot_into_vec(self:self) -> self,

        ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
        min(self:self) -> self,

        ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
        max(self:self) -> self,

        ///Component-wise clamping of values, similar to [`f64::clamp`].
        ///
        ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp(self:self,self) -> self,

        ///Returns the horizontal minimum of `self`.
        ///
        ///In other words this computes `min(x, y, ..)`.
        min_element(self:) -> Raw(f64),

        ///Returns the horizontal maximum of `self`.
        ///
        ///In other words this computes `max(x, y, ..)`.
        max_element(self:) -> Raw(f64),

        ///Returns a vector mask containing the result of a `==` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
        ///elements.
        cmpeq(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `!=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
        ///elements.
        cmpne(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `>=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
        ///elements.
        cmpge(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `>` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
        ///elements.
        cmpgt(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `<=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
        ///elements.
        cmple(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `<` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
        ///elements.
        cmplt(self:self) -> Wrapped(BVec2),

        ///Returns a vector containing the absolute value of each element of `self`.
        abs(self:) -> self,

        ///Returns a vector with elements representing the sign of `self`.
        ///
        ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
        ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
        ///- `NAN` if the number is `NAN`
        signum(self:) -> self,

        ///Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `self`.
        ///
        ///A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
        ///into the first lowest bit, element `y` into the second, etc.
        is_negative_bitmask(self:) -> Raw(u32),

        ///Returns `true` if, and only if, all elements are finite.  If any element is either
        ///`NaN`, positive or negative infinity, this will return `false`.
        is_finite(self:) -> Raw(bool),

        ///Returns `true` if any elements are `NaN`.
        is_nan(self:) -> Raw(bool),

        ///Performs `is_nan` on each element of self, returning a vector mask of the results.
        ///
        ///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
        is_nan_mask(self:) -> Wrapped(BVec2),

        ///Computes the length of `self`.
        length(self:) -> Raw(f64),

        ///Computes the squared length of `self`.
        ///
        ///This is faster than `length()` as it avoids a square root operation.
        length_squared(self:) -> Raw(f64),

        ///Computes `1.0 / length()`.
        ///
        ///For valid results, `self` must _not_ be of length zero.
        length_recip(self:) -> Raw(f64),

        ///Computes the Euclidean distance between two points in space.
        distance(self:self) -> Raw(f64),

        ///Compute the squared euclidean distance between two points in space.
        distance_squared(self:self) -> Raw(f64),

        ///Returns `self` normalized to length 1.0.
        ///
        ///For valid results, `self` must _not_ be of length zero, nor very close to zero.
        ///
        ///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
        ///
        ///Panics
        ///
        ///Will panic if `self` is zero length when `glam_assert` is enabled.
        normalize(self:) -> self,

        ///Returns `self` normalized to length 1.0 if possible, else returns zero.
        ///
        ///In particular, if the input is zero (or very close to zero), or non-finite,
        ///the result of this operation will be zero.
        ///
        ///See also [`Self::try_normalize`].
        normalize_or_zero(self:) -> self,

        ///Returns whether `self` is length `1.0` or not.
        ///
        ///Uses a precision threshold of `1e-6`.
        is_normalized(self:) -> Raw(bool),

        ///Returns the vector projection of `self` onto `rhs`.
        ///
        ///`rhs` must be of non-zero length.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is zero length when `glam_assert` is enabled.
        project_onto(self:self) -> self,

        ///Returns the vector rejection of `self` from `rhs`.
        ///
        ///The vector rejection is the vector perpendicular to the projection of `self` onto
        ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
        ///
        ///`rhs` must be of non-zero length.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
        reject_from(self:self) -> self,

        ///Returns the vector projection of `self` onto `rhs`.
        ///
        ///`rhs` must be normalized.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
        project_onto_normalized(self:self) -> self,

        ///Returns the vector rejection of `self` from `rhs`.
        ///
        ///The vector rejection is the vector perpendicular to the projection of `self` onto
        ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
        ///
        ///`rhs` must be normalized.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
        reject_from_normalized(self:self) -> self,

        ///Returns a vector containing the nearest integer to a number for each element of `self`.
        ///Round half-way cases away from 0.0.
        round(self:) -> self,

        ///Returns a vector containing the largest integer less than or equal to a number for each
        ///element of `self`.
        floor(self:) -> self,

        ///Returns a vector containing the smallest integer greater than or equal to a number for
        ///each element of `self`.
        ceil(self:) -> self,

        ///Returns a vector containing the fractional part of the vector, e.g. `self -
        ///self.floor()`.
        ///
        ///Note that this is fast but not precise for large numbers.
        fract(self:) -> self,

        ///Returns a vector containing `e^self` (the exponential function) for each element of
        ///`self`.
        exp(self:) -> self,

        ///Returns a vector containing each element of `self` raised to the power of `n`.
        powf(self:Raw(f64)) -> self,

        ///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
        recip(self:) -> self,

        ///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
        ///
        ///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
        ///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
        ///extrapolated.
        lerp(self:self,Raw(f64)) -> self,

        ///Returns true if the absolute difference of all elements between `self` and `rhs` is
        ///less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two vectors contain similar elements. It works best when
        ///comparing with a known value. The `max_abs_diff` that should be used used depends on
        ///the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(self:self,Raw(f64)) -> Raw(bool),

        ///Returns a vector with a length no less than `min` and no more than `max`
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp_length(self:Raw(f64),Raw(f64)) -> self,

        ///Returns a vector with a length no more than `max`
        clamp_length_max(self:Raw(f64)) -> self,

        ///Returns a vector with a length no less than `min`
        clamp_length_min(self:Raw(f64)) -> self,

        ///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
        ///error, yielding a more accurate result than an unfused multiply-add.
        ///
        ///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
        ///architecture has a dedicated fma CPU instruction. However, this is not always true,
        ///and will be heavily dependant on designing algorithms with specific target hardware in
        ///mind.
        mul_add(self:self,self) -> self,

        ///Creates a 2D vector containing `[angle.cos(), angle.sin()]`. This can be used in
        ///conjunction with the `rotate` method, e.g. `Vec2::from_angle(PI).rotate(Vec2::Y)` will
        ///create the vector [-1, 0] and rotate `Vec2::Y` around it returning `-Vec2::Y`.
        from_angle(Raw(f64)) -> self,

        ///Returns the angle (in radians) between `self` and `rhs`.
        ///
        ///The input vectors do not need to be unit length however they must be non-zero.
        angle_between(self:self) -> Raw(f64),

        ///Returns a vector that is equal to `self` rotated by 90 degrees.
        perp(self:) -> self,

        ///The perpendicular dot product of `self` and `rhs`.
        ///Also known as the wedge product, 2D cross product, and determinant.
        perp_dot(self:self) -> Raw(f64),

        ///Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
        ///then this just rotation. This is what you usually want. Otherwise,
        ///it will be like a rotation with a multiplication by `self`'s length.
        rotate(self:self) -> self,

        ///Casts all elements of `self` to `f32`.
        as_vec2(&self:) -> Wrapped(Vec2),

        ///Casts all elements of `self` to `i32`.
        as_ivec2(&self:) -> Wrapped(IVec2),

        ///Casts all elements of `self` to `u32`.
        as_uvec2(&self:) -> Wrapped(UVec2),

    )
    + Fields
    (
        x: Raw(f64),
        y: Raw(f64),
    )
    + BinOps
    (
        self Add self -> Wrapped(DVec2),
        self Add Raw(f64) -> Wrapped(DVec2),
        self Add Wrapped(DVec2) -> Wrapped(DVec2),
        self Sub self -> Wrapped(DVec2),
        self Sub Raw(f64) -> Wrapped(DVec2),
        self Sub Wrapped(DVec2) -> Wrapped(DVec2),
        self Div self -> Wrapped(DVec2),
        self Div Raw(f64) -> Wrapped(DVec2),
        self Div Wrapped(DVec2) -> Wrapped(DVec2),
        self Mul self -> Wrapped(DVec2),
        self Mul Raw(f64) -> Wrapped(DVec2),
        self Mul Wrapped(DVec2) -> Wrapped(DVec2),
        self Rem self -> Wrapped(DVec2),
        self Rem Raw(f64) -> Wrapped(DVec2),
        self Rem Wrapped(DVec2) -> Wrapped(DVec2),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {
        (MetaMethod::Index) => |_,s,idx: usize| {Ok(s.inner()?[idx])};
        mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,f64)| {s.val_mut(|s| Ok(s[idx] = val))?};
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 3-dimensional vector.
    glam::f64::DVec3 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new vector.
        new(Raw(f64),Raw(f64),Raw(f64)) -> self,

        ///Creates a vector with all elements set to `v`.
        splat(Raw(f64)) -> self,

        ///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
        ///for each element of `self`.
        ///
        ///A true element in the mask uses the corresponding element from `if_true`, and false
        ///uses the element from `if_false`.
        select(Wrapped(BVec3),self,self) -> self,

        ///Creates a 4D vector from `self` and the given `w` value.
        extend(self:Raw(f64)) -> Wrapped(DVec4),

        ///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
        ///
        ///Truncation may also be performed by using `self.xy()` or `DVec2::from()`.
        truncate(self:) -> Wrapped(DVec2),

        ///Computes the dot product of `self` and `rhs`.
        dot(self:self) -> Raw(f64),

        ///Returns a vector where every component is the dot product of `self` and `rhs`.
        dot_into_vec(self:self) -> self,

        ///Computes the cross product of `self` and `rhs`.
        cross(self:self) -> self,

        ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
        min(self:self) -> self,

        ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
        max(self:self) -> self,

        ///Component-wise clamping of values, similar to [`f64::clamp`].
        ///
        ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp(self:self,self) -> self,

        ///Returns the horizontal minimum of `self`.
        ///
        ///In other words this computes `min(x, y, ..)`.
        min_element(self:) -> Raw(f64),

        ///Returns the horizontal maximum of `self`.
        ///
        ///In other words this computes `max(x, y, ..)`.
        max_element(self:) -> Raw(f64),

        ///Returns a vector mask containing the result of a `==` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
        ///elements.
        cmpeq(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `!=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
        ///elements.
        cmpne(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `>=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
        ///elements.
        cmpge(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `>` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
        ///elements.
        cmpgt(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `<=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
        ///elements.
        cmple(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `<` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
        ///elements.
        cmplt(self:self) -> Wrapped(BVec3),

        ///Returns a vector containing the absolute value of each element of `self`.
        abs(self:) -> self,

        ///Returns a vector with elements representing the sign of `self`.
        ///
        ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
        ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
        ///- `NAN` if the number is `NAN`
        signum(self:) -> self,

        ///Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.
        ///
        ///A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
        ///into the first lowest bit, element `y` into the second, etc.
        is_negative_bitmask(self:) -> Raw(u32),

        ///Returns `true` if, and only if, all elements are finite.  If any element is either
        ///`NaN`, positive or negative infinity, this will return `false`.
        is_finite(self:) -> Raw(bool),

        ///Returns `true` if any elements are `NaN`.
        is_nan(self:) -> Raw(bool),

        ///Performs `is_nan` on each element of self, returning a vector mask of the results.
        ///
        ///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
        is_nan_mask(self:) -> Wrapped(BVec3),

        ///Computes the length of `self`.
        length(self:) -> Raw(f64),

        ///Computes the squared length of `self`.
        ///
        ///This is faster than `length()` as it avoids a square root operation.
        length_squared(self:) -> Raw(f64),

        ///Computes `1.0 / length()`.
        ///
        ///For valid results, `self` must _not_ be of length zero.
        length_recip(self:) -> Raw(f64),

        ///Computes the Euclidean distance between two points in space.
        distance(self:self) -> Raw(f64),

        ///Compute the squared euclidean distance between two points in space.
        distance_squared(self:self) -> Raw(f64),

        ///Returns `self` normalized to length 1.0.
        ///
        ///For valid results, `self` must _not_ be of length zero, nor very close to zero.
        ///
        ///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
        ///
        ///Panics
        ///
        ///Will panic if `self` is zero length when `glam_assert` is enabled.
        normalize(self:) -> self,

        ///Returns `self` normalized to length 1.0 if possible, else returns zero.
        ///
        ///In particular, if the input is zero (or very close to zero), or non-finite,
        ///the result of this operation will be zero.
        ///
        ///See also [`Self::try_normalize`].
        normalize_or_zero(self:) -> self,

        ///Returns whether `self` is length `1.0` or not.
        ///
        ///Uses a precision threshold of `1e-6`.
        is_normalized(self:) -> Raw(bool),

        ///Returns the vector projection of `self` onto `rhs`.
        ///
        ///`rhs` must be of non-zero length.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is zero length when `glam_assert` is enabled.
        project_onto(self:self) -> self,

        ///Returns the vector rejection of `self` from `rhs`.
        ///
        ///The vector rejection is the vector perpendicular to the projection of `self` onto
        ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
        ///
        ///`rhs` must be of non-zero length.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
        reject_from(self:self) -> self,

        ///Returns the vector projection of `self` onto `rhs`.
        ///
        ///`rhs` must be normalized.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
        project_onto_normalized(self:self) -> self,

        ///Returns the vector rejection of `self` from `rhs`.
        ///
        ///The vector rejection is the vector perpendicular to the projection of `self` onto
        ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
        ///
        ///`rhs` must be normalized.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
        reject_from_normalized(self:self) -> self,

        ///Returns a vector containing the nearest integer to a number for each element of `self`.
        ///Round half-way cases away from 0.0.
        round(self:) -> self,

        ///Returns a vector containing the largest integer less than or equal to a number for each
        ///element of `self`.
        floor(self:) -> self,

        ///Returns a vector containing the smallest integer greater than or equal to a number for
        ///each element of `self`.
        ceil(self:) -> self,

        ///Returns a vector containing the fractional part of the vector, e.g. `self -
        ///self.floor()`.
        ///
        ///Note that this is fast but not precise for large numbers.
        fract(self:) -> self,

        ///Returns a vector containing `e^self` (the exponential function) for each element of
        ///`self`.
        exp(self:) -> self,

        ///Returns a vector containing each element of `self` raised to the power of `n`.
        powf(self:Raw(f64)) -> self,

        ///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
        recip(self:) -> self,

        ///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
        ///
        ///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
        ///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
        ///extrapolated.
        lerp(self:self,Raw(f64)) -> self,

        ///Returns true if the absolute difference of all elements between `self` and `rhs` is
        ///less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two vectors contain similar elements. It works best when
        ///comparing with a known value. The `max_abs_diff` that should be used used depends on
        ///the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(self:self,Raw(f64)) -> Raw(bool),

        ///Returns a vector with a length no less than `min` and no more than `max`
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp_length(self:Raw(f64),Raw(f64)) -> self,

        ///Returns a vector with a length no more than `max`
        clamp_length_max(self:Raw(f64)) -> self,

        ///Returns a vector with a length no less than `min`
        clamp_length_min(self:Raw(f64)) -> self,

        ///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
        ///error, yielding a more accurate result than an unfused multiply-add.
        ///
        ///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
        ///architecture has a dedicated fma CPU instruction. However, this is not always true,
        ///and will be heavily dependant on designing algorithms with specific target hardware in
        ///mind.
        mul_add(self:self,self) -> self,

        ///Returns the angle (in radians) between two vectors.
        ///
        ///The input vectors do not need to be unit length however they must be non-zero.
        angle_between(self:self) -> Raw(f64),

        ///Returns some vector that is orthogonal to the given one.
        ///
        ///The input vector must be finite and non-zero.
        ///
        ///The output vector is not necessarily unit-length.
        ///For that use [`Self::any_orthonormal_vector`] instead.
        any_orthogonal_vector(&self:) -> self,

        ///Returns any unit-length vector that is orthogonal to the given one.
        ///The input vector must be finite and non-zero.
        ///
        ///# Panics
        ///
        ///Will panic if `self` is not normalized when `glam_assert` is enabled.
        any_orthonormal_vector(&self:) -> self,

        ///Casts all elements of `self` to `f32`.
        as_vec3(&self:) -> Wrapped(Vec3),

        ///Casts all elements of `self` to `f32`.
        as_vec3a(&self:) -> Wrapped(Vec3A),

        ///Casts all elements of `self` to `i32`.
        as_ivec3(&self:) -> Wrapped(IVec3),

        ///Casts all elements of `self` to `u32`.
        as_uvec3(&self:) -> Wrapped(UVec3),

    )
    + Fields
    (
        x: Raw(f64),
        y: Raw(f64),
        z: Raw(f64),
    )
    + BinOps
    (
        self Add self -> Wrapped(DVec3),
        self Add Raw(f64) -> Wrapped(DVec3),
        self Add Wrapped(DVec3) -> Wrapped(DVec3),
        self Sub self -> Wrapped(DVec3),
        self Sub Raw(f64) -> Wrapped(DVec3),
        self Sub Wrapped(DVec3) -> Wrapped(DVec3),
        self Div self -> Wrapped(DVec3),
        self Div Raw(f64) -> Wrapped(DVec3),
        self Div Wrapped(DVec3) -> Wrapped(DVec3),
        self Mul self -> Wrapped(DVec3),
        self Mul Raw(f64) -> Wrapped(DVec3),
        self Mul Wrapped(DVec3) -> Wrapped(DVec3),
        self Rem self -> Wrapped(DVec3),
        self Rem Raw(f64) -> Wrapped(DVec3),
        self Rem Wrapped(DVec3) -> Wrapped(DVec3),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {
        (MetaMethod::Index) => |_,s,idx: usize| {Ok(s.inner()?[idx])};
        mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,f64)| {s.val_mut(|s| Ok(s[idx] = val))?};
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 4-dimensional vector.
    glam::f64::DVec4 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new vector.
        new(Raw(f64),Raw(f64),Raw(f64),Raw(f64)) -> self,

        ///Creates a vector with all elements set to `v`.
        splat(Raw(f64)) -> self,

        ///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
        ///for each element of `self`.
        ///
        ///A true element in the mask uses the corresponding element from `if_true`, and false
        ///uses the element from `if_false`.
        select(Wrapped(BVec4),self,self) -> self,

        ///Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
        ///
        ///Truncation to `DVec3` may also be performed by using `self.xyz()` or `DVec3::from()`.
        truncate(self:) -> Wrapped(DVec3),

        ///Computes the dot product of `self` and `rhs`.
        dot(self:self) -> Raw(f64),

        ///Returns a vector where every component is the dot product of `self` and `rhs`.
        dot_into_vec(self:self) -> self,

        ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
        min(self:self) -> self,

        ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
        max(self:self) -> self,

        ///Component-wise clamping of values, similar to [`f64::clamp`].
        ///
        ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp(self:self,self) -> self,

        ///Returns the horizontal minimum of `self`.
        ///
        ///In other words this computes `min(x, y, ..)`.
        min_element(self:) -> Raw(f64),

        ///Returns the horizontal maximum of `self`.
        ///
        ///In other words this computes `max(x, y, ..)`.
        max_element(self:) -> Raw(f64),

        ///Returns a vector mask containing the result of a `==` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
        ///elements.
        cmpeq(self:self) -> Wrapped(BVec4),

        ///Returns a vector mask containing the result of a `!=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
        ///elements.
        cmpne(self:self) -> Wrapped(BVec4),

        ///Returns a vector mask containing the result of a `>=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
        ///elements.
        cmpge(self:self) -> Wrapped(BVec4),

        ///Returns a vector mask containing the result of a `>` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
        ///elements.
        cmpgt(self:self) -> Wrapped(BVec4),

        ///Returns a vector mask containing the result of a `<=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
        ///elements.
        cmple(self:self) -> Wrapped(BVec4),

        ///Returns a vector mask containing the result of a `<` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
        ///elements.
        cmplt(self:self) -> Wrapped(BVec4),

        ///Returns a vector containing the absolute value of each element of `self`.
        abs(self:) -> self,

        ///Returns a vector with elements representing the sign of `self`.
        ///
        ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
        ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
        ///- `NAN` if the number is `NAN`
        signum(self:) -> self,

        ///Returns a bitmask with the lowest 4 bits set to the sign bits from the elements of `self`.
        ///
        ///A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
        ///into the first lowest bit, element `y` into the second, etc.
        is_negative_bitmask(self:) -> Raw(u32),

        ///Returns `true` if, and only if, all elements are finite.  If any element is either
        ///`NaN`, positive or negative infinity, this will return `false`.
        is_finite(self:) -> Raw(bool),

        ///Returns `true` if any elements are `NaN`.
        is_nan(self:) -> Raw(bool),

        ///Performs `is_nan` on each element of self, returning a vector mask of the results.
        ///
        ///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
        is_nan_mask(self:) -> Wrapped(BVec4),

        ///Computes the length of `self`.
        length(self:) -> Raw(f64),

        ///Computes the squared length of `self`.
        ///
        ///This is faster than `length()` as it avoids a square root operation.
        length_squared(self:) -> Raw(f64),

        ///Computes `1.0 / length()`.
        ///
        ///For valid results, `self` must _not_ be of length zero.
        length_recip(self:) -> Raw(f64),

        ///Computes the Euclidean distance between two points in space.
        distance(self:self) -> Raw(f64),

        ///Compute the squared euclidean distance between two points in space.
        distance_squared(self:self) -> Raw(f64),

        ///Returns `self` normalized to length 1.0.
        ///
        ///For valid results, `self` must _not_ be of length zero, nor very close to zero.
        ///
        ///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
        ///
        ///Panics
        ///
        ///Will panic if `self` is zero length when `glam_assert` is enabled.
        normalize(self:) -> self,

        ///Returns `self` normalized to length 1.0 if possible, else returns zero.
        ///
        ///In particular, if the input is zero (or very close to zero), or non-finite,
        ///the result of this operation will be zero.
        ///
        ///See also [`Self::try_normalize`].
        normalize_or_zero(self:) -> self,

        ///Returns whether `self` is length `1.0` or not.
        ///
        ///Uses a precision threshold of `1e-6`.
        is_normalized(self:) -> Raw(bool),

        ///Returns the vector projection of `self` onto `rhs`.
        ///
        ///`rhs` must be of non-zero length.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is zero length when `glam_assert` is enabled.
        project_onto(self:self) -> self,

        ///Returns the vector rejection of `self` from `rhs`.
        ///
        ///The vector rejection is the vector perpendicular to the projection of `self` onto
        ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
        ///
        ///`rhs` must be of non-zero length.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
        reject_from(self:self) -> self,

        ///Returns the vector projection of `self` onto `rhs`.
        ///
        ///`rhs` must be normalized.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
        project_onto_normalized(self:self) -> self,

        ///Returns the vector rejection of `self` from `rhs`.
        ///
        ///The vector rejection is the vector perpendicular to the projection of `self` onto
        ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
        ///
        ///`rhs` must be normalized.
        ///
        ///# Panics
        ///
        ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
        reject_from_normalized(self:self) -> self,

        ///Returns a vector containing the nearest integer to a number for each element of `self`.
        ///Round half-way cases away from 0.0.
        round(self:) -> self,

        ///Returns a vector containing the largest integer less than or equal to a number for each
        ///element of `self`.
        floor(self:) -> self,

        ///Returns a vector containing the smallest integer greater than or equal to a number for
        ///each element of `self`.
        ceil(self:) -> self,

        ///Returns a vector containing the fractional part of the vector, e.g. `self -
        ///self.floor()`.
        ///
        ///Note that this is fast but not precise for large numbers.
        fract(self:) -> self,

        ///Returns a vector containing `e^self` (the exponential function) for each element of
        ///`self`.
        exp(self:) -> self,

        ///Returns a vector containing each element of `self` raised to the power of `n`.
        powf(self:Raw(f64)) -> self,

        ///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
        recip(self:) -> self,

        ///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
        ///
        ///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
        ///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
        ///extrapolated.
        lerp(self:self,Raw(f64)) -> self,

        ///Returns true if the absolute difference of all elements between `self` and `rhs` is
        ///less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two vectors contain similar elements. It works best when
        ///comparing with a known value. The `max_abs_diff` that should be used used depends on
        ///the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(self:self,Raw(f64)) -> Raw(bool),

        ///Returns a vector with a length no less than `min` and no more than `max`
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp_length(self:Raw(f64),Raw(f64)) -> self,

        ///Returns a vector with a length no more than `max`
        clamp_length_max(self:Raw(f64)) -> self,

        ///Returns a vector with a length no less than `min`
        clamp_length_min(self:Raw(f64)) -> self,

        ///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
        ///error, yielding a more accurate result than an unfused multiply-add.
        ///
        ///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
        ///architecture has a dedicated fma CPU instruction. However, this is not always true,
        ///and will be heavily dependant on designing algorithms with specific target hardware in
        ///mind.
        mul_add(self:self,self) -> self,

        ///Casts all elements of `self` to `f32`.
        as_vec4(&self:) -> Wrapped(Vec4),

        ///Casts all elements of `self` to `i32`.
        as_ivec4(&self:) -> Wrapped(IVec4),

        ///Casts all elements of `self` to `u32`.
        as_uvec4(&self:) -> Wrapped(UVec4),

    )
    + Fields
    (
        x: Raw(f64),
        y: Raw(f64),
        z: Raw(f64),
        w: Raw(f64),
    )
    + BinOps
    (
        self Add self -> Wrapped(DVec4),
        self Add Raw(f64) -> Wrapped(DVec4),
        self Add Wrapped(DVec4) -> Wrapped(DVec4),
        self Sub self -> Wrapped(DVec4),
        self Sub Raw(f64) -> Wrapped(DVec4),
        self Sub Wrapped(DVec4) -> Wrapped(DVec4),
        self Div self -> Wrapped(DVec4),
        self Div Raw(f64) -> Wrapped(DVec4),
        self Div Wrapped(DVec4) -> Wrapped(DVec4),
        self Mul self -> Wrapped(DVec4),
        self Mul Raw(f64) -> Wrapped(DVec4),
        self Mul Wrapped(DVec4) -> Wrapped(DVec4),
        self Rem self -> Wrapped(DVec4),
        self Rem Raw(f64) -> Wrapped(DVec4),
        self Rem Wrapped(DVec4) -> Wrapped(DVec4),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {
        (MetaMethod::Index) => |_,s,idx: usize| {Ok(s.inner()?[idx])};
        mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,f64)| {s.val_mut(|s| Ok(s[idx] = val))?};
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 2-dimensional vector.
    glam::i32::IVec2 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new vector.
        new(Raw(i32),Raw(i32)) -> self,

        ///Creates a vector with all elements set to `v`.
        splat(Raw(i32)) -> self,

        ///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
        ///for each element of `self`.
        ///
        ///A true element in the mask uses the corresponding element from `if_true`, and false
        ///uses the element from `if_false`.
        select(Wrapped(BVec2),self,self) -> self,

        ///Creates a 3D vector from `self` and the given `z` value.
        extend(self:Raw(i32)) -> Wrapped(IVec3),

        ///Computes the dot product of `self` and `rhs`.
        dot(self:self) -> Raw(i32),

        ///Returns a vector where every component is the dot product of `self` and `rhs`.
        dot_into_vec(self:self) -> self,

        ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
        min(self:self) -> self,

        ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
        max(self:self) -> self,

        ///Component-wise clamping of values, similar to [`i32::clamp`].
        ///
        ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp(self:self,self) -> self,

        ///Returns the horizontal minimum of `self`.
        ///
        ///In other words this computes `min(x, y, ..)`.
        min_element(self:) -> Raw(i32),

        ///Returns the horizontal maximum of `self`.
        ///
        ///In other words this computes `max(x, y, ..)`.
        max_element(self:) -> Raw(i32),

        ///Returns a vector mask containing the result of a `==` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
        ///elements.
        cmpeq(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `!=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
        ///elements.
        cmpne(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `>=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
        ///elements.
        cmpge(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `>` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
        ///elements.
        cmpgt(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `<=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
        ///elements.
        cmple(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `<` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
        ///elements.
        cmplt(self:self) -> Wrapped(BVec2),

        ///Returns a vector containing the absolute value of each element of `self`.
        abs(self:) -> self,

        ///Returns a vector with elements representing the sign of `self`.
        ///
        ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
        ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
        ///- `NAN` if the number is `NAN`
        signum(self:) -> self,

        ///Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `self`.
        ///
        ///A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
        ///into the first lowest bit, element `y` into the second, etc.
        is_negative_bitmask(self:) -> Raw(u32),

        ///Returns a vector that is equal to `self` rotated by 90 degrees.
        perp(self:) -> self,

        ///The perpendicular dot product of `self` and `rhs`.
        ///Also known as the wedge product, 2D cross product, and determinant.
        perp_dot(self:self) -> Raw(i32),

        ///Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
        ///then this just rotation. This is what you usually want. Otherwise,
        ///it will be like a rotation with a multiplication by `self`'s length.
        rotate(self:self) -> self,

        ///Casts all elements of `self` to `f32`.
        as_vec2(&self:) -> Wrapped(Vec2),

        ///Casts all elements of `self` to `f64`.
        as_dvec2(&self:) -> Wrapped(DVec2),

        ///Casts all elements of `self` to `u32`.
        as_uvec2(&self:) -> Wrapped(UVec2),

    )
    + Fields
    (
        x: Raw(i32),
        y: Raw(i32),
    )
    + BinOps
    (
        self Add self -> Wrapped(IVec2),
        self Add Raw(i32) -> Wrapped(IVec2),
        self Add Wrapped(IVec2) -> Wrapped(IVec2),
        self Sub self -> Wrapped(IVec2),
        self Sub Raw(i32) -> Wrapped(IVec2),
        self Sub Wrapped(IVec2) -> Wrapped(IVec2),
        self Div self -> Wrapped(IVec2),
        self Div Raw(i32) -> Wrapped(IVec2),
        self Div Wrapped(IVec2) -> Wrapped(IVec2),
        self Mul self -> Wrapped(IVec2),
        self Mul Raw(i32) -> Wrapped(IVec2),
        self Mul Wrapped(IVec2) -> Wrapped(IVec2),
        self Rem self -> Wrapped(IVec2),
        self Rem Raw(i32) -> Wrapped(IVec2),
        self Rem Wrapped(IVec2) -> Wrapped(IVec2),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {
        (MetaMethod::Index) => |_,s,idx: usize| {Ok(s.inner()?[idx])};
        mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,i32)| {s.val_mut(|s| Ok(s[idx] = val))?};
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 3-dimensional vector.
    glam::i32::IVec3 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new vector.
        new(Raw(i32),Raw(i32),Raw(i32)) -> self,

        ///Creates a vector with all elements set to `v`.
        splat(Raw(i32)) -> self,

        ///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
        ///for each element of `self`.
        ///
        ///A true element in the mask uses the corresponding element from `if_true`, and false
        ///uses the element from `if_false`.
        select(Wrapped(BVec3),self,self) -> self,

        ///Creates a 4D vector from `self` and the given `w` value.
        extend(self:Raw(i32)) -> Wrapped(IVec4),

        ///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
        ///
        ///Truncation may also be performed by using `self.xy()` or `IVec2::from()`.
        truncate(self:) -> Wrapped(IVec2),

        ///Computes the dot product of `self` and `rhs`.
        dot(self:self) -> Raw(i32),

        ///Returns a vector where every component is the dot product of `self` and `rhs`.
        dot_into_vec(self:self) -> self,

        ///Computes the cross product of `self` and `rhs`.
        cross(self:self) -> self,

        ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
        min(self:self) -> self,

        ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
        max(self:self) -> self,

        ///Component-wise clamping of values, similar to [`i32::clamp`].
        ///
        ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp(self:self,self) -> self,

        ///Returns the horizontal minimum of `self`.
        ///
        ///In other words this computes `min(x, y, ..)`.
        min_element(self:) -> Raw(i32),

        ///Returns the horizontal maximum of `self`.
        ///
        ///In other words this computes `max(x, y, ..)`.
        max_element(self:) -> Raw(i32),

        ///Returns a vector mask containing the result of a `==` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
        ///elements.
        cmpeq(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `!=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
        ///elements.
        cmpne(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `>=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
        ///elements.
        cmpge(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `>` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
        ///elements.
        cmpgt(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `<=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
        ///elements.
        cmple(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `<` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
        ///elements.
        cmplt(self:self) -> Wrapped(BVec3),

        ///Returns a vector containing the absolute value of each element of `self`.
        abs(self:) -> self,

        ///Returns a vector with elements representing the sign of `self`.
        ///
        ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
        ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
        ///- `NAN` if the number is `NAN`
        signum(self:) -> self,

        ///Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.
        ///
        ///A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
        ///into the first lowest bit, element `y` into the second, etc.
        is_negative_bitmask(self:) -> Raw(u32),

        ///Casts all elements of `self` to `f32`.
        as_vec3(&self:) -> Wrapped(Vec3),

        ///Casts all elements of `self` to `f32`.
        as_vec3a(&self:) -> Wrapped(Vec3A),

        ///Casts all elements of `self` to `f64`.
        as_dvec3(&self:) -> Wrapped(DVec3),

        ///Casts all elements of `self` to `u32`.
        as_uvec3(&self:) -> Wrapped(UVec3),

    )
    + Fields
    (
        x: Raw(i32),
        y: Raw(i32),
        z: Raw(i32),
    )
    + BinOps
    (
        self Add self -> Wrapped(IVec3),
        self Add Raw(i32) -> Wrapped(IVec3),
        self Add Wrapped(IVec3) -> Wrapped(IVec3),
        self Sub self -> Wrapped(IVec3),
        self Sub Raw(i32) -> Wrapped(IVec3),
        self Sub Wrapped(IVec3) -> Wrapped(IVec3),
        self Div self -> Wrapped(IVec3),
        self Div Raw(i32) -> Wrapped(IVec3),
        self Div Wrapped(IVec3) -> Wrapped(IVec3),
        self Mul self -> Wrapped(IVec3),
        self Mul Raw(i32) -> Wrapped(IVec3),
        self Mul Wrapped(IVec3) -> Wrapped(IVec3),
        self Rem self -> Wrapped(IVec3),
        self Rem Raw(i32) -> Wrapped(IVec3),
        self Rem Wrapped(IVec3) -> Wrapped(IVec3),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {
        (MetaMethod::Index) => |_,s,idx: usize| {Ok(s.inner()?[idx])};
        mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,i32)| {s.val_mut(|s| Ok(s[idx] = val))?};
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 4-dimensional vector.
    glam::i32::IVec4 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new vector.
        new(Raw(i32),Raw(i32),Raw(i32),Raw(i32)) -> self,

        ///Creates a vector with all elements set to `v`.
        splat(Raw(i32)) -> self,

        ///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
        ///for each element of `self`.
        ///
        ///A true element in the mask uses the corresponding element from `if_true`, and false
        ///uses the element from `if_false`.
        select(Wrapped(BVec4),self,self) -> self,

        ///Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
        ///
        ///Truncation to `IVec3` may also be performed by using `self.xyz()` or `IVec3::from()`.
        truncate(self:) -> Wrapped(IVec3),

        ///Computes the dot product of `self` and `rhs`.
        dot(self:self) -> Raw(i32),

        ///Returns a vector where every component is the dot product of `self` and `rhs`.
        dot_into_vec(self:self) -> self,

        ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
        min(self:self) -> self,

        ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
        max(self:self) -> self,

        ///Component-wise clamping of values, similar to [`i32::clamp`].
        ///
        ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp(self:self,self) -> self,

        ///Returns the horizontal minimum of `self`.
        ///
        ///In other words this computes `min(x, y, ..)`.
        min_element(self:) -> Raw(i32),

        ///Returns the horizontal maximum of `self`.
        ///
        ///In other words this computes `max(x, y, ..)`.
        max_element(self:) -> Raw(i32),

        ///Returns a vector mask containing the result of a `==` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
        ///elements.
        cmpeq(self:self) -> Wrapped(BVec4),

        ///Returns a vector mask containing the result of a `!=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
        ///elements.
        cmpne(self:self) -> Wrapped(BVec4),

        ///Returns a vector mask containing the result of a `>=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
        ///elements.
        cmpge(self:self) -> Wrapped(BVec4),

        ///Returns a vector mask containing the result of a `>` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
        ///elements.
        cmpgt(self:self) -> Wrapped(BVec4),

        ///Returns a vector mask containing the result of a `<=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
        ///elements.
        cmple(self:self) -> Wrapped(BVec4),

        ///Returns a vector mask containing the result of a `<` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
        ///elements.
        cmplt(self:self) -> Wrapped(BVec4),

        ///Returns a vector containing the absolute value of each element of `self`.
        abs(self:) -> self,

        ///Returns a vector with elements representing the sign of `self`.
        ///
        ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
        ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
        ///- `NAN` if the number is `NAN`
        signum(self:) -> self,

        ///Returns a bitmask with the lowest 4 bits set to the sign bits from the elements of `self`.
        ///
        ///A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
        ///into the first lowest bit, element `y` into the second, etc.
        is_negative_bitmask(self:) -> Raw(u32),

        ///Casts all elements of `self` to `f32`.
        as_vec4(&self:) -> Wrapped(Vec4),

        ///Casts all elements of `self` to `f64`.
        as_dvec4(&self:) -> Wrapped(DVec4),

        ///Casts all elements of `self` to `u32`.
        as_uvec4(&self:) -> Wrapped(UVec4),

    )
    + Fields
    (
        x: Raw(i32),
        y: Raw(i32),
        z: Raw(i32),
        w: Raw(i32),
    )
    + BinOps
    (
        self Add self -> Wrapped(IVec4),
        self Add Raw(i32) -> Wrapped(IVec4),
        self Add Wrapped(IVec4) -> Wrapped(IVec4),
        self Sub self -> Wrapped(IVec4),
        self Sub Raw(i32) -> Wrapped(IVec4),
        self Sub Wrapped(IVec4) -> Wrapped(IVec4),
        self Div self -> Wrapped(IVec4),
        self Div Raw(i32) -> Wrapped(IVec4),
        self Div Wrapped(IVec4) -> Wrapped(IVec4),
        self Mul self -> Wrapped(IVec4),
        self Mul Raw(i32) -> Wrapped(IVec4),
        self Mul Wrapped(IVec4) -> Wrapped(IVec4),
        self Rem self -> Wrapped(IVec4),
        self Rem Raw(i32) -> Wrapped(IVec4),
        self Rem Wrapped(IVec4) -> Wrapped(IVec4),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {
        (MetaMethod::Index) => |_,s,idx: usize| {Ok(s.inner()?[idx])};
        mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,i32)| {s.val_mut(|s| Ok(s[idx] = val))?};
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 2-dimensional vector.
    glam::u32::UVec2 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new vector.
        new(Raw(u32),Raw(u32)) -> self,

        ///Creates a vector with all elements set to `v`.
        splat(Raw(u32)) -> self,

        ///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
        ///for each element of `self`.
        ///
        ///A true element in the mask uses the corresponding element from `if_true`, and false
        ///uses the element from `if_false`.
        select(Wrapped(BVec2),self,self) -> self,

        ///Creates a 3D vector from `self` and the given `z` value.
        extend(self:Raw(u32)) -> Wrapped(UVec3),

        ///Computes the dot product of `self` and `rhs`.
        dot(self:self) -> Raw(u32),

        ///Returns a vector where every component is the dot product of `self` and `rhs`.
        dot_into_vec(self:self) -> self,

        ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
        min(self:self) -> self,

        ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
        max(self:self) -> self,

        ///Component-wise clamping of values, similar to [`u32::clamp`].
        ///
        ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp(self:self,self) -> self,

        ///Returns the horizontal minimum of `self`.
        ///
        ///In other words this computes `min(x, y, ..)`.
        min_element(self:) -> Raw(u32),

        ///Returns the horizontal maximum of `self`.
        ///
        ///In other words this computes `max(x, y, ..)`.
        max_element(self:) -> Raw(u32),

        ///Returns a vector mask containing the result of a `==` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
        ///elements.
        cmpeq(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `!=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
        ///elements.
        cmpne(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `>=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
        ///elements.
        cmpge(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `>` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
        ///elements.
        cmpgt(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `<=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
        ///elements.
        cmple(self:self) -> Wrapped(BVec2),

        ///Returns a vector mask containing the result of a `<` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
        ///elements.
        cmplt(self:self) -> Wrapped(BVec2),

        ///Casts all elements of `self` to `f32`.
        as_vec2(&self:) -> Wrapped(Vec2),

        ///Casts all elements of `self` to `f64`.
        as_dvec2(&self:) -> Wrapped(DVec2),

        ///Casts all elements of `self` to `i32`.
        as_ivec2(&self:) -> Wrapped(IVec2),

    )
    + Fields
    (
        x: Raw(u32),
        y: Raw(u32),
    )
    + BinOps
    (
        self Add self -> Wrapped(UVec2),
        self Add Raw(u32) -> Wrapped(UVec2),
        self Add Wrapped(UVec2) -> Wrapped(UVec2),
        self Sub self -> Wrapped(UVec2),
        self Sub Raw(u32) -> Wrapped(UVec2),
        self Sub Wrapped(UVec2) -> Wrapped(UVec2),
        self Div self -> Wrapped(UVec2),
        self Div Raw(u32) -> Wrapped(UVec2),
        self Div Wrapped(UVec2) -> Wrapped(UVec2),
        self Mul self -> Wrapped(UVec2),
        self Mul Raw(u32) -> Wrapped(UVec2),
        self Mul Wrapped(UVec2) -> Wrapped(UVec2),
        self Rem self -> Wrapped(UVec2),
        self Rem Raw(u32) -> Wrapped(UVec2),
        self Rem Wrapped(UVec2) -> Wrapped(UVec2),
    )
    + UnaryOps
    (
    )
    lua impl
    {
        (MetaMethod::Index) => |_,s,idx: usize| {Ok(s.inner()?[idx])};
        mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,u32)| {s.val_mut(|s| Ok(s[idx] = val))?};
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 3-dimensional vector.
    glam::u32::UVec3 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new vector.
        new(Raw(u32),Raw(u32),Raw(u32)) -> self,

        ///Creates a vector with all elements set to `v`.
        splat(Raw(u32)) -> self,

        ///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
        ///for each element of `self`.
        ///
        ///A true element in the mask uses the corresponding element from `if_true`, and false
        ///uses the element from `if_false`.
        select(Wrapped(BVec3),self,self) -> self,

        ///Creates a 4D vector from `self` and the given `w` value.
        extend(self:Raw(u32)) -> Wrapped(UVec4),

        ///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
        ///
        ///Truncation may also be performed by using `self.xy()` or `UVec2::from()`.
        truncate(self:) -> Wrapped(UVec2),

        ///Computes the dot product of `self` and `rhs`.
        dot(self:self) -> Raw(u32),

        ///Returns a vector where every component is the dot product of `self` and `rhs`.
        dot_into_vec(self:self) -> self,

        ///Computes the cross product of `self` and `rhs`.
        cross(self:self) -> self,

        ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
        min(self:self) -> self,

        ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
        max(self:self) -> self,

        ///Component-wise clamping of values, similar to [`u32::clamp`].
        ///
        ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp(self:self,self) -> self,

        ///Returns the horizontal minimum of `self`.
        ///
        ///In other words this computes `min(x, y, ..)`.
        min_element(self:) -> Raw(u32),

        ///Returns the horizontal maximum of `self`.
        ///
        ///In other words this computes `max(x, y, ..)`.
        max_element(self:) -> Raw(u32),

        ///Returns a vector mask containing the result of a `==` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
        ///elements.
        cmpeq(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `!=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
        ///elements.
        cmpne(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `>=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
        ///elements.
        cmpge(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `>` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
        ///elements.
        cmpgt(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `<=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
        ///elements.
        cmple(self:self) -> Wrapped(BVec3),

        ///Returns a vector mask containing the result of a `<` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
        ///elements.
        cmplt(self:self) -> Wrapped(BVec3),

        ///Casts all elements of `self` to `f32`.
        as_vec3(&self:) -> Wrapped(Vec3),

        ///Casts all elements of `self` to `f32`.
        as_vec3a(&self:) -> Wrapped(Vec3A),

        ///Casts all elements of `self` to `f64`.
        as_dvec3(&self:) -> Wrapped(DVec3),

        ///Casts all elements of `self` to `i32`.
        as_ivec3(&self:) -> Wrapped(IVec3),

    )
    + Fields
    (
        x: Raw(u32),
        y: Raw(u32),
        z: Raw(u32),
    )
    + BinOps
    (
        self Add self -> Wrapped(UVec3),
        self Add Raw(u32) -> Wrapped(UVec3),
        self Add Wrapped(UVec3) -> Wrapped(UVec3),
        self Sub self -> Wrapped(UVec3),
        self Sub Raw(u32) -> Wrapped(UVec3),
        self Sub Wrapped(UVec3) -> Wrapped(UVec3),
        self Div self -> Wrapped(UVec3),
        self Div Raw(u32) -> Wrapped(UVec3),
        self Div Wrapped(UVec3) -> Wrapped(UVec3),
        self Mul self -> Wrapped(UVec3),
        self Mul Raw(u32) -> Wrapped(UVec3),
        self Mul Wrapped(UVec3) -> Wrapped(UVec3),
        self Rem self -> Wrapped(UVec3),
        self Rem Raw(u32) -> Wrapped(UVec3),
        self Rem Wrapped(UVec3) -> Wrapped(UVec3),
    )
    + UnaryOps
    (
    )
    lua impl
    {
        (MetaMethod::Index) => |_,s,idx: usize| {Ok(s.inner()?[idx])};
        mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,u32)| {s.val_mut(|s| Ok(s[idx] = val))?};
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 4-dimensional vector.
    glam::u32::UVec4 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new vector.
        new(Raw(u32),Raw(u32),Raw(u32),Raw(u32)) -> self,

        ///Creates a vector with all elements set to `v`.
        splat(Raw(u32)) -> self,

        ///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
        ///for each element of `self`.
        ///
        ///A true element in the mask uses the corresponding element from `if_true`, and false
        ///uses the element from `if_false`.
        select(Wrapped(BVec4),self,self) -> self,

        ///Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
        ///
        ///Truncation to `UVec3` may also be performed by using `self.xyz()` or `UVec3::from()`.
        truncate(self:) -> Wrapped(UVec3),

        ///Computes the dot product of `self` and `rhs`.
        dot(self:self) -> Raw(u32),

        ///Returns a vector where every component is the dot product of `self` and `rhs`.
        dot_into_vec(self:self) -> self,

        ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
        min(self:self) -> self,

        ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
        ///
        ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
        max(self:self) -> self,

        ///Component-wise clamping of values, similar to [`u32::clamp`].
        ///
        ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
        ///
        ///# Panics
        ///
        ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
        clamp(self:self,self) -> self,

        ///Returns the horizontal minimum of `self`.
        ///
        ///In other words this computes `min(x, y, ..)`.
        min_element(self:) -> Raw(u32),

        ///Returns the horizontal maximum of `self`.
        ///
        ///In other words this computes `max(x, y, ..)`.
        max_element(self:) -> Raw(u32),

        ///Returns a vector mask containing the result of a `==` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
        ///elements.
        cmpeq(self:self) -> Wrapped(BVec4),

        ///Returns a vector mask containing the result of a `!=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
        ///elements.
        cmpne(self:self) -> Wrapped(BVec4),

        ///Returns a vector mask containing the result of a `>=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
        ///elements.
        cmpge(self:self) -> Wrapped(BVec4),

        ///Returns a vector mask containing the result of a `>` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
        ///elements.
        cmpgt(self:self) -> Wrapped(BVec4),

        ///Returns a vector mask containing the result of a `<=` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
        ///elements.
        cmple(self:self) -> Wrapped(BVec4),

        ///Returns a vector mask containing the result of a `<` comparison for each element of
        ///`self` and `rhs`.
        ///
        ///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
        ///elements.
        cmplt(self:self) -> Wrapped(BVec4),

        ///Casts all elements of `self` to `f32`.
        as_vec4(&self:) -> Wrapped(Vec4),

        ///Casts all elements of `self` to `f64`.
        as_dvec4(&self:) -> Wrapped(DVec4),

        ///Casts all elements of `self` to `i32`.
        as_ivec4(&self:) -> Wrapped(IVec4),

    )
    + Fields
    (
        x: Raw(u32),
        y: Raw(u32),
        z: Raw(u32),
        w: Raw(u32),
    )
    + BinOps
    (
        self Add self -> Wrapped(UVec4),
        self Add Raw(u32) -> Wrapped(UVec4),
        self Add Wrapped(UVec4) -> Wrapped(UVec4),
        self Sub self -> Wrapped(UVec4),
        self Sub Raw(u32) -> Wrapped(UVec4),
        self Sub Wrapped(UVec4) -> Wrapped(UVec4),
        self Div self -> Wrapped(UVec4),
        self Div Raw(u32) -> Wrapped(UVec4),
        self Div Wrapped(UVec4) -> Wrapped(UVec4),
        self Mul self -> Wrapped(UVec4),
        self Mul Raw(u32) -> Wrapped(UVec4),
        self Mul Wrapped(UVec4) -> Wrapped(UVec4),
        self Rem self -> Wrapped(UVec4),
        self Rem Raw(u32) -> Wrapped(UVec4),
        self Rem Wrapped(UVec4) -> Wrapped(UVec4),
    )
    + UnaryOps
    (
    )
    lua impl
    {
        (MetaMethod::Index) => |_,s,idx: usize| {Ok(s.inner()?[idx])};
        mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,u32)| {s.val_mut(|s| Ok(s[idx] = val))?};
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 3x3 column major matrix.
    ///
    ///This 3x3 matrix type features convenience methods for creating and using linear and
    ///affine transformations. If you are primarily dealing with 2D affine transformations the
    ///[`Affine2`](crate::Affine2) type is much faster and more space efficient than
    ///using a 3x3 matrix.
    ///
    ///Linear transformations including 3D rotation and scale can be created using methods
    ///such as [`Self::from_diagonal()`], [`Self::from_quat()`], [`Self::from_axis_angle()`],
    ///[`Self::from_rotation_x()`], [`Self::from_rotation_y()`], or
    ///[`Self::from_rotation_z()`].
    ///
    ///The resulting matrices can be use to transform 3D vectors using regular vector
    ///multiplication.
    ///
    ///Affine transformations including 2D translation, rotation and scale can be created
    ///using methods such as [`Self::from_translation()`], [`Self::from_angle()`],
    ///[`Self::from_scale()`] and [`Self::from_scale_angle_translation()`].
    ///
    ///The [`Self::transform_point2()`] and [`Self::transform_vector2()`] convenience methods
    ///are provided for performing affine transforms on 2D vectors and points. These multiply
    ///2D inputs as 3D vectors with an implicit `z` value of `1` for points and `0` for
    ///vectors respectively. These methods assume that `Self` contains a valid affine
    ///transform.
    glam::f32::Mat3 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a 3x3 matrix from two column vectors.
        from_cols(Wrapped(Vec3),Wrapped(Vec3),Wrapped(Vec3)) -> self,

        ///Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.
        from_diagonal(Wrapped(Vec3)) -> self,

        ///Creates a 3x3 matrix from a 4x4 matrix, discarding the 4th row and column.
        from_mat4(Wrapped(Mat4)) -> self,

        ///Creates a 3D rotation matrix from the given quaternion.
        ///
        ///# Panics
        ///
        ///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
        from_quat(Wrapped(Quat)) -> self,

        ///Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in
        ///radians).
        ///
        ///# Panics
        ///
        ///Will panic if `axis` is not normalized when `glam_assert` is enabled.
        from_axis_angle(Wrapped(Vec3),Raw(f32)) -> self,

        ///Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in
        ///radians).
        from_euler(Wrapped(EulerRot),Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Creates a 3D rotation matrix from `angle` (in radians) around the x axis.
        from_rotation_x(Raw(f32)) -> self,

        ///Creates a 3D rotation matrix from `angle` (in radians) around the y axis.
        from_rotation_y(Raw(f32)) -> self,

        ///Creates a 3D rotation matrix from `angle` (in radians) around the z axis.
        from_rotation_z(Raw(f32)) -> self,

        ///Creates an affine transformation matrix from the given 2D `translation`.
        ///
        ///The resulting matrix can be used to transform 2D points and vectors. See
        ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
        from_translation(Wrapped(Vec2)) -> self,

        ///Creates an affine transformation matrix from the given 2D rotation `angle` (in
        ///radians).
        ///
        ///The resulting matrix can be used to transform 2D points and vectors. See
        ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
        from_angle(Raw(f32)) -> self,

        ///Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in
        ///radians) and `translation`.
        ///
        ///The resulting matrix can be used to transform 2D points and vectors. See
        ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
        from_scale_angle_translation(Wrapped(Vec2),Raw(f32),Wrapped(Vec2)) -> self,

        ///Creates an affine transformation matrix from the given non-uniform 2D `scale`.
        ///
        ///The resulting matrix can be used to transform 2D points and vectors. See
        ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
        ///
        ///# Panics
        ///
        ///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
        from_scale(Wrapped(Vec2)) -> self,

        ///Creates an affine transformation matrix from the given 2x2 matrix.
        ///
        ///The resulting matrix can be used to transform 2D points and vectors. See
        ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
        from_mat2(Wrapped(Mat2)) -> self,

        ///Returns the matrix column for the given `index`.
        ///
        ///# Panics
        ///
        ///Panics if `index` is greater than 2.
        col(&self:Raw(usize)) -> Wrapped(Vec3),

        ///Returns the matrix row for the given `index`.
        ///
        ///# Panics
        ///
        ///Panics if `index` is greater than 2.
        row(&self:Raw(usize)) -> Wrapped(Vec3),

        ///Returns `true` if, and only if, all elements are finite.
        ///If any element is either `NaN`, positive or negative infinity, this will return `false`.
        is_finite(&self:) -> Raw(bool),

        ///Returns `true` if any elements are `NaN`.
        is_nan(&self:) -> Raw(bool),

        ///Returns the transpose of `self`.
        transpose(&self:) -> self,

        ///Returns the determinant of `self`.
        determinant(&self:) -> Raw(f32),

        ///Returns the inverse of `self`.
        ///
        ///If the matrix is not invertible the returned matrix will be invalid.
        ///
        ///# Panics
        ///
        ///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
        inverse(&self:) -> self,

        ///Transforms the given 2D vector as a point.
        ///
        ///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.
        ///
        ///This method assumes that `self` contains a valid affine transform.
        ///
        ///# Panics
        ///
        ///Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.
        transform_point2(&self:Wrapped(Vec2)) -> Wrapped(Vec2),

        ///Rotates the given 2D vector.
        ///
        ///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.
        ///
        ///This method assumes that `self` contains a valid affine transform.
        ///
        ///# Panics
        ///
        ///Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.
        transform_vector2(&self:Wrapped(Vec2)) -> Wrapped(Vec2),

        ///Transforms a 3D vector.
        mul_vec3(&self:Wrapped(Vec3)) -> Wrapped(Vec3),

        ///Transforms a `Vec3A`.
        mul_vec3a(&self:Wrapped(Vec3A)) -> Wrapped(Vec3A),

        ///Multiplies two 3x3 matrices.
        mul_mat3(&self:&self) -> self,

        ///Adds two 3x3 matrices.
        add_mat3(&self:&self) -> self,

        ///Subtracts two 3x3 matrices.
        sub_mat3(&self:&self) -> self,

        ///Multiplies a 3x3 matrix by a scalar.
        mul_scalar(&self:Raw(f32)) -> self,

        ///Returns true if the absolute difference of all elements between `self` and `rhs`
        ///is less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two matrices contain similar elements. It works best
        ///when comparing with a known value. The `max_abs_diff` that should be used used
        ///depends on the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(&self:self,Raw(f32)) -> Raw(bool),

        as_dmat3(&self:) -> Wrapped(DMat3),

    )
    + Fields
    (
        x_axis: Wrapped(Vec3),
        y_axis: Wrapped(Vec3),
        z_axis: Wrapped(Vec3),
    )
    + BinOps
    (
        self Add self -> Wrapped(Mat3),
        self Sub self -> Wrapped(Mat3),
        self Mul Wrapped(Affine2) -> Wrapped(Mat3),
        self Mul self -> Wrapped(Mat3),
        self Mul Wrapped(Vec3) -> Wrapped(Vec3),
        self Mul Wrapped(Mat3) -> Wrapped(Mat3),
        self Mul Raw(f32) -> Wrapped(Mat3),
        self Mul Wrapped(Vec3A) -> Wrapped(Vec3A),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {

    mut (MetaMethod::Index) => |_,s,idx : usize| {
        Ok(LuaVec3::new_ref(
                s.script_ref().sub_ref(ReflectPathElem::SubReflectionIndexed{
                    label:"col",
                    index: idx,
                    get: |idx,ref_| Err(ReflectionError::InsufficientProvenance{
                        path: "".to_owned(),
                        msg: "Cannot get column of matrix with immutable reference".to_owned()
                    }),
                    get_mut: |idx, ref_| {
                        if ref_.is::<Mat3>(){
                            Ok(ref_.downcast_mut::<Mat3>()
                                .unwrap()
                                .col_mut(idx))
                        } else {
                            Err(ReflectionError::CannotDowncast{from: ref_.type_name().to_owned().into(), to:"Mat3".into()})
                        }
                    }
                })
            )
        )
    }
;
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 2x2 column major matrix.
    glam::f32::Mat2 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a 2x2 matrix from two column vectors.
        from_cols(Wrapped(Vec2),Wrapped(Vec2)) -> self,

        ///Creates a 2x2 matrix with its diagonal set to `diagonal` and all other entries set to 0.
        from_diagonal(Wrapped(Vec2)) -> self,

        ///Creates a 2x2 matrix containing the combining non-uniform `scale` and rotation of
        ///`angle` (in radians).
        from_scale_angle(Wrapped(Vec2),Raw(f32)) -> self,

        ///Creates a 2x2 matrix containing a rotation of `angle` (in radians).
        from_angle(Raw(f32)) -> self,

        ///Creates a 2x2 matrix from a 3x3 matrix, discarding the 2nd row and column.
        from_mat3(Wrapped(Mat3)) -> self,

        ///Creates a 2x2 matrix from a 3x3 matrix, discarding the 2nd row and column.
        from_mat3a(Wrapped(Mat3A)) -> self,

        ///Returns the matrix column for the given `index`.
        ///
        ///# Panics
        ///
        ///Panics if `index` is greater than 1.
        col(&self:Raw(usize)) -> Wrapped(Vec2),

        ///Returns the matrix row for the given `index`.
        ///
        ///# Panics
        ///
        ///Panics if `index` is greater than 1.
        row(&self:Raw(usize)) -> Wrapped(Vec2),

        ///Returns `true` if, and only if, all elements are finite.
        ///If any element is either `NaN`, positive or negative infinity, this will return `false`.
        is_finite(&self:) -> Raw(bool),

        ///Returns `true` if any elements are `NaN`.
        is_nan(&self:) -> Raw(bool),

        ///Returns the transpose of `self`.
        transpose(&self:) -> self,

        ///Returns the determinant of `self`.
        determinant(&self:) -> Raw(f32),

        ///Returns the inverse of `self`.
        ///
        ///If the matrix is not invertible the returned matrix will be invalid.
        ///
        ///# Panics
        ///
        ///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
        inverse(&self:) -> self,

        ///Transforms a 2D vector.
        mul_vec2(&self:Wrapped(Vec2)) -> Wrapped(Vec2),

        ///Multiplies two 2x2 matrices.
        mul_mat2(&self:&self) -> self,

        ///Adds two 2x2 matrices.
        add_mat2(&self:&self) -> self,

        ///Subtracts two 2x2 matrices.
        sub_mat2(&self:&self) -> self,

        ///Multiplies a 2x2 matrix by a scalar.
        mul_scalar(&self:Raw(f32)) -> self,

        ///Returns true if the absolute difference of all elements between `self` and `rhs`
        ///is less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two matrices contain similar elements. It works best
        ///when comparing with a known value. The `max_abs_diff` that should be used used
        ///depends on the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(&self:self,Raw(f32)) -> Raw(bool),

        as_dmat2(&self:) -> Wrapped(DMat2),

    )
    + Fields
    (
    )
    + BinOps
    (
        self Add self -> Wrapped(Mat2),
        self Sub self -> Wrapped(Mat2),
        self Mul self -> Wrapped(Mat2),
        self Mul Wrapped(Vec2) -> Wrapped(Vec2),
        self Mul Wrapped(Mat2) -> Wrapped(Mat2),
        self Mul Raw(f32) -> Wrapped(Mat2),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {

    mut (MetaMethod::Index) => |_,s,idx : usize| {
        Ok(LuaVec2::new_ref(
                s.script_ref().sub_ref(ReflectPathElem::SubReflectionIndexed{
                    label:"col",
                    index: idx,
                    get: |idx,ref_| Err(ReflectionError::InsufficientProvenance{
                        path: "".to_owned(),
                        msg: "Cannot get column of matrix with immutable reference".to_owned()
                    }),
                    get_mut: |idx, ref_| {
                        if ref_.is::<Mat2>(){
                            Ok(ref_.downcast_mut::<Mat2>()
                                .unwrap()
                                .col_mut(idx))
                        } else {
                            Err(ReflectionError::CannotDowncast{from: ref_.type_name().to_owned().into(), to:"Mat2".into()})
                        }
                    }
                })
            )
        )
    }
;
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 3x3 column major matrix.
    ///
    ///This 3x3 matrix type features convenience methods for creating and using linear and
    ///affine transformations. If you are primarily dealing with 2D affine transformations the
    ///[`Affine2`](crate::Affine2) type is much faster and more space efficient than
    ///using a 3x3 matrix.
    ///
    ///Linear transformations including 3D rotation and scale can be created using methods
    ///such as [`Self::from_diagonal()`], [`Self::from_quat()`], [`Self::from_axis_angle()`],
    ///[`Self::from_rotation_x()`], [`Self::from_rotation_y()`], or
    ///[`Self::from_rotation_z()`].
    ///
    ///The resulting matrices can be use to transform 3D vectors using regular vector
    ///multiplication.
    ///
    ///Affine transformations including 2D translation, rotation and scale can be created
    ///using methods such as [`Self::from_translation()`], [`Self::from_angle()`],
    ///[`Self::from_scale()`] and [`Self::from_scale_angle_translation()`].
    ///
    ///The [`Self::transform_point2()`] and [`Self::transform_vector2()`] convenience methods
    ///are provided for performing affine transforms on 2D vectors and points. These multiply
    ///2D inputs as 3D vectors with an implicit `z` value of `1` for points and `0` for
    ///vectors respectively. These methods assume that `Self` contains a valid affine
    ///transform.
    glam::f32::Mat3A :
    Clone +
    Debug +
    Methods
    (
        ///Creates a 3x3 matrix from two column vectors.
        from_cols(Wrapped(Vec3A),Wrapped(Vec3A),Wrapped(Vec3A)) -> self,

        ///Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.
        from_diagonal(Wrapped(Vec3)) -> self,

        ///Creates a 3x3 matrix from a 4x4 matrix, discarding the 4th row and column.
        from_mat4(Wrapped(Mat4)) -> self,

        ///Creates a 3D rotation matrix from the given quaternion.
        ///
        ///# Panics
        ///
        ///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
        from_quat(Wrapped(Quat)) -> self,

        ///Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in
        ///radians).
        ///
        ///# Panics
        ///
        ///Will panic if `axis` is not normalized when `glam_assert` is enabled.
        from_axis_angle(Wrapped(Vec3),Raw(f32)) -> self,

        ///Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in
        ///radians).
        from_euler(Wrapped(EulerRot),Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Creates a 3D rotation matrix from `angle` (in radians) around the x axis.
        from_rotation_x(Raw(f32)) -> self,

        ///Creates a 3D rotation matrix from `angle` (in radians) around the y axis.
        from_rotation_y(Raw(f32)) -> self,

        ///Creates a 3D rotation matrix from `angle` (in radians) around the z axis.
        from_rotation_z(Raw(f32)) -> self,

        ///Creates an affine transformation matrix from the given 2D `translation`.
        ///
        ///The resulting matrix can be used to transform 2D points and vectors. See
        ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
        from_translation(Wrapped(Vec2)) -> self,

        ///Creates an affine transformation matrix from the given 2D rotation `angle` (in
        ///radians).
        ///
        ///The resulting matrix can be used to transform 2D points and vectors. See
        ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
        from_angle(Raw(f32)) -> self,

        ///Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in
        ///radians) and `translation`.
        ///
        ///The resulting matrix can be used to transform 2D points and vectors. See
        ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
        from_scale_angle_translation(Wrapped(Vec2),Raw(f32),Wrapped(Vec2)) -> self,

        ///Creates an affine transformation matrix from the given non-uniform 2D `scale`.
        ///
        ///The resulting matrix can be used to transform 2D points and vectors. See
        ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
        ///
        ///# Panics
        ///
        ///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
        from_scale(Wrapped(Vec2)) -> self,

        ///Creates an affine transformation matrix from the given 2x2 matrix.
        ///
        ///The resulting matrix can be used to transform 2D points and vectors. See
        ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
        from_mat2(Wrapped(Mat2)) -> self,

        ///Returns the matrix column for the given `index`.
        ///
        ///# Panics
        ///
        ///Panics if `index` is greater than 2.
        col(&self:Raw(usize)) -> Wrapped(Vec3A),

        ///Returns the matrix row for the given `index`.
        ///
        ///# Panics
        ///
        ///Panics if `index` is greater than 2.
        row(&self:Raw(usize)) -> Wrapped(Vec3A),

        ///Returns `true` if, and only if, all elements are finite.
        ///If any element is either `NaN`, positive or negative infinity, this will return `false`.
        is_finite(&self:) -> Raw(bool),

        ///Returns `true` if any elements are `NaN`.
        is_nan(&self:) -> Raw(bool),

        ///Returns the transpose of `self`.
        transpose(&self:) -> self,

        ///Returns the determinant of `self`.
        determinant(&self:) -> Raw(f32),

        ///Returns the inverse of `self`.
        ///
        ///If the matrix is not invertible the returned matrix will be invalid.
        ///
        ///# Panics
        ///
        ///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
        inverse(&self:) -> self,

        ///Transforms the given 2D vector as a point.
        ///
        ///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.
        ///
        ///This method assumes that `self` contains a valid affine transform.
        ///
        ///# Panics
        ///
        ///Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.
        transform_point2(&self:Wrapped(Vec2)) -> Wrapped(Vec2),

        ///Rotates the given 2D vector.
        ///
        ///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.
        ///
        ///This method assumes that `self` contains a valid affine transform.
        ///
        ///# Panics
        ///
        ///Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.
        transform_vector2(&self:Wrapped(Vec2)) -> Wrapped(Vec2),

        ///Transforms a 3D vector.
        mul_vec3(&self:Wrapped(Vec3)) -> Wrapped(Vec3),

        ///Transforms a `Vec3A`.
        mul_vec3a(&self:Wrapped(Vec3A)) -> Wrapped(Vec3A),

        ///Multiplies two 3x3 matrices.
        mul_mat3(&self:&self) -> self,

        ///Adds two 3x3 matrices.
        add_mat3(&self:&self) -> self,

        ///Subtracts two 3x3 matrices.
        sub_mat3(&self:&self) -> self,

        ///Multiplies a 3x3 matrix by a scalar.
        mul_scalar(&self:Raw(f32)) -> self,

        ///Returns true if the absolute difference of all elements between `self` and `rhs`
        ///is less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two matrices contain similar elements. It works best
        ///when comparing with a known value. The `max_abs_diff` that should be used used
        ///depends on the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(&self:self,Raw(f32)) -> Raw(bool),

        as_dmat3(&self:) -> Wrapped(DMat3),

    )
    + Fields
    (
        x_axis: Wrapped(Vec3A),
        y_axis: Wrapped(Vec3A),
        z_axis: Wrapped(Vec3A),
    )
    + BinOps
    (
        self Add self -> Wrapped(Mat3A),
        self Sub self -> Wrapped(Mat3A),
        self Mul Wrapped(Affine2) -> Wrapped(Mat3A),
        self Mul self -> Wrapped(Mat3A),
        self Mul Wrapped(Vec3A) -> Wrapped(Vec3A),
        self Mul Wrapped(Mat3A) -> Wrapped(Mat3A),
        self Mul Raw(f32) -> Wrapped(Mat3A),
        self Mul Wrapped(Vec3) -> Wrapped(Vec3),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {

    mut (MetaMethod::Index) => |_,s,idx : usize| {
        Ok(LuaVec3A::new_ref(
                s.script_ref().sub_ref(ReflectPathElem::SubReflectionIndexed{
                    label:"col",
                    index: idx,
                    get: |idx,ref_| Err(ReflectionError::InsufficientProvenance{
                        path: "".to_owned(),
                        msg: "Cannot get column of matrix with immutable reference".to_owned()
                    }),
                    get_mut: |idx, ref_| {
                        if ref_.is::<Mat3A>(){
                            Ok(ref_.downcast_mut::<Mat3A>()
                                .unwrap()
                                .col_mut(idx))
                        } else {
                            Err(ReflectionError::CannotDowncast{from: ref_.type_name().to_owned().into(), to:"Mat3A".into()})
                        }
                    }
                })
            )
        )
    }
;
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 4x4 column major matrix.
    ///
    ///This 4x4 matrix type features convenience methods for creating and using affine transforms and
    ///perspective projections. If you are primarily dealing with 3D affine transformations
    ///considering using [`Affine3A`](crate::Affine3A) which is faster than a 4x4 matrix
    ///for some affine operations.
    ///
    ///Affine transformations including 3D translation, rotation and scale can be created
    ///using methods such as [`Self::from_translation()`], [`Self::from_quat()`],
    ///[`Self::from_scale()`] and [`Self::from_scale_rotation_translation()`].
    ///
    ///Othographic projections can be created using the methods [`Self::orthographic_lh()`] for
    ///left-handed coordinate systems and [`Self::orthographic_rh()`] for right-handed
    ///systems. The resulting matrix is also an affine transformation.
    ///
    ///The [`Self::transform_point3()`] and [`Self::transform_vector3()`] convenience methods
    ///are provided for performing affine transformations on 3D vectors and points. These
    ///multiply 3D inputs as 4D vectors with an implicit `w` value of `1` for points and `0`
    ///for vectors respectively. These methods assume that `Self` contains a valid affine
    ///transform.
    ///
    ///Perspective projections can be created using methods such as
    ///[`Self::perspective_lh()`], [`Self::perspective_infinite_lh()`] and
    ///[`Self::perspective_infinite_reverse_lh()`] for left-handed co-ordinate systems and
    ///[`Self::perspective_rh()`], [`Self::perspective_infinite_rh()`] and
    ///[`Self::perspective_infinite_reverse_rh()`] for right-handed co-ordinate systems.
    ///
    ///The resulting perspective project can be use to transform 3D vectors as points with
    ///perspective correction using the [`Self::project_point3()`] convenience method.
    glam::f32::Mat4 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a 4x4 matrix from two column vectors.
        from_cols(Wrapped(Vec4),Wrapped(Vec4),Wrapped(Vec4),Wrapped(Vec4)) -> self,

        ///Creates a 4x4 matrix with its diagonal set to `diagonal` and all other entries set to 0.
        from_diagonal(Wrapped(Vec4)) -> self,

        ///Creates an affine transformation matrix from the given 3D `scale`, `rotation` and
        ///`translation`.
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        ///
        ///# Panics
        ///
        ///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
        from_scale_rotation_translation(Wrapped(Vec3),Wrapped(Quat),Wrapped(Vec3)) -> self,

        ///Creates an affine transformation matrix from the given 3D `translation`.
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        ///
        ///# Panics
        ///
        ///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
        from_rotation_translation(Wrapped(Quat),Wrapped(Vec3)) -> self,

        ///Creates an affine transformation matrix from the given `rotation` quaternion.
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        ///
        ///# Panics
        ///
        ///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
        from_quat(Wrapped(Quat)) -> self,

        ///Creates an affine transformation matrix from the given 3x3 linear transformation
        ///matrix.
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        from_mat3(Wrapped(Mat3)) -> self,

        ///Creates an affine transformation matrix from the given 3x3 linear transformation
        ///matrix.
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        from_mat3a(Wrapped(Mat3A)) -> self,

        ///Creates an affine transformation matrix from the given 3D `translation`.
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        from_translation(Wrapped(Vec3)) -> self,

        ///Creates an affine transformation matrix containing a 3D rotation around a normalized
        ///rotation `axis` of `angle` (in radians).
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        ///
        ///# Panics
        ///
        ///Will panic if `axis` is not normalized when `glam_assert` is enabled.
        from_axis_angle(Wrapped(Vec3),Raw(f32)) -> self,

        ///Creates a affine transformation matrix containing a rotation from the given euler
        ///rotation sequence and angles (in radians).
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        from_euler(Wrapped(EulerRot),Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Creates an affine transformation matrix containing a 3D rotation around the x axis of
        ///`angle` (in radians).
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        from_rotation_x(Raw(f32)) -> self,

        ///Creates an affine transformation matrix containing a 3D rotation around the y axis of
        ///`angle` (in radians).
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        from_rotation_y(Raw(f32)) -> self,

        ///Creates an affine transformation matrix containing a 3D rotation around the z axis of
        ///`angle` (in radians).
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        from_rotation_z(Raw(f32)) -> self,

        ///Creates an affine transformation matrix containing the given 3D non-uniform `scale`.
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        ///
        ///# Panics
        ///
        ///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
        from_scale(Wrapped(Vec3)) -> self,

        ///Returns the matrix column for the given `index`.
        ///
        ///# Panics
        ///
        ///Panics if `index` is greater than 3.
        col(&self:Raw(usize)) -> Wrapped(Vec4),

        ///Returns the matrix row for the given `index`.
        ///
        ///# Panics
        ///
        ///Panics if `index` is greater than 3.
        row(&self:Raw(usize)) -> Wrapped(Vec4),

        ///Returns `true` if, and only if, all elements are finite.
        ///If any element is either `NaN`, positive or negative infinity, this will return `false`.
        is_finite(&self:) -> Raw(bool),

        ///Returns `true` if any elements are `NaN`.
        is_nan(&self:) -> Raw(bool),

        ///Returns the transpose of `self`.
        transpose(&self:) -> self,

        ///Returns the determinant of `self`.
        determinant(&self:) -> Raw(f32),

        ///Returns the inverse of `self`.
        ///
        ///If the matrix is not invertible the returned matrix will be invalid.
        ///
        ///# Panics
        ///
        ///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
        inverse(&self:) -> self,

        ///Creates a left-handed view matrix using a camera position, an up direction, and a facing
        ///direction.
        ///
        ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
        look_to_lh(Wrapped(Vec3),Wrapped(Vec3),Wrapped(Vec3)) -> self,

        ///Creates a right-handed view matrix using a camera position, an up direction, and a facing
        ///direction.
        ///
        ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
        look_to_rh(Wrapped(Vec3),Wrapped(Vec3),Wrapped(Vec3)) -> self,

        ///Creates a left-handed view matrix using a camera position, an up direction, and a focal
        ///point.
        ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
        ///
        ///# Panics
        ///
        ///Will panic if `up` is not normalized when `glam_assert` is enabled.
        look_at_lh(Wrapped(Vec3),Wrapped(Vec3),Wrapped(Vec3)) -> self,

        ///Creates a right-handed view matrix using a camera position, an up direction, and a focal
        ///point.
        ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
        ///
        ///# Panics
        ///
        ///Will panic if `up` is not normalized when `glam_assert` is enabled.
        look_at_rh(Wrapped(Vec3),Wrapped(Vec3),Wrapped(Vec3)) -> self,

        ///Creates a right-handed perspective projection matrix with [-1,1] depth range.
        ///This is the same as the OpenGL `gluPerspective` function.
        ///See <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml>
        perspective_rh_gl(Raw(f32),Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Creates a left-handed perspective projection matrix with `[0,1]` depth range.
        ///
        ///# Panics
        ///
        ///Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
        ///enabled.
        perspective_lh(Raw(f32),Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Creates a right-handed perspective projection matrix with `[0,1]` depth range.
        ///
        ///# Panics
        ///
        ///Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
        ///enabled.
        perspective_rh(Raw(f32),Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
        ///
        ///# Panics
        ///
        ///Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
        perspective_infinite_lh(Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
        ///
        ///# Panics
        ///
        ///Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
        perspective_infinite_reverse_lh(Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Creates an infinite right-handed perspective projection matrix with
        ///`[0,1]` depth range.
        perspective_infinite_rh(Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Creates an infinite reverse right-handed perspective projection matrix
        ///with `[0,1]` depth range.
        perspective_infinite_reverse_rh(Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Creates a right-handed orthographic projection matrix with `[-1,1]` depth
        ///range.  This is the same as the OpenGL `glOrtho` function in OpenGL.
        ///See
        ///<https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml>
        orthographic_rh_gl(Raw(f32),Raw(f32),Raw(f32),Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Creates a left-handed orthographic projection matrix with `[0,1]` depth range.
        orthographic_lh(Raw(f32),Raw(f32),Raw(f32),Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Creates a right-handed orthographic projection matrix with `[0,1]` depth range.
        orthographic_rh(Raw(f32),Raw(f32),Raw(f32),Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Transforms the given 3D vector as a point, applying perspective correction.
        ///
        ///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is `1.0`.
        ///The perspective divide is performed meaning the resulting 3D vector is divided by `w`.
        ///
        ///This method assumes that `self` contains a projective transform.
        project_point3(&self:Wrapped(Vec3)) -> Wrapped(Vec3),

        ///Transforms the given 3D vector as a point.
        ///
        ///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
        ///`1.0`.
        ///
        ///This method assumes that `self` contains a valid affine transform. It does not perform
        ///a persective divide, if `self` contains a perspective transform, or if you are unsure,
        ///the [`Self::project_point3()`] method should be used instead.
        ///
        ///# Panics
        ///
        ///Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
        transform_point3(&self:Wrapped(Vec3)) -> Wrapped(Vec3),

        ///Transforms the give 3D vector as a direction.
        ///
        ///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
        ///`0.0`.
        ///
        ///This method assumes that `self` contains a valid affine transform.
        ///
        ///# Panics
        ///
        ///Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
        transform_vector3(&self:Wrapped(Vec3)) -> Wrapped(Vec3),

        ///Transforms the given `Vec3A` as 3D point.
        ///
        ///This is the equivalent of multiplying the `Vec3A` as a 4D vector where `w` is `1.0`.
        transform_point3a(&self:Wrapped(Vec3A)) -> Wrapped(Vec3A),

        ///Transforms the give `Vec3A` as 3D vector.
        ///
        ///This is the equivalent of multiplying the `Vec3A` as a 4D vector where `w` is `0.0`.
        transform_vector3a(&self:Wrapped(Vec3A)) -> Wrapped(Vec3A),

        ///Transforms a 4D vector.
        mul_vec4(&self:Wrapped(Vec4)) -> Wrapped(Vec4),

        ///Multiplies two 4x4 matrices.
        mul_mat4(&self:&self) -> self,

        ///Adds two 4x4 matrices.
        add_mat4(&self:&self) -> self,

        ///Subtracts two 4x4 matrices.
        sub_mat4(&self:&self) -> self,

        ///Multiplies a 4x4 matrix by a scalar.
        mul_scalar(&self:Raw(f32)) -> self,

        ///Returns true if the absolute difference of all elements between `self` and `rhs`
        ///is less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two matrices contain similar elements. It works best
        ///when comparing with a known value. The `max_abs_diff` that should be used used
        ///depends on the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(&self:self,Raw(f32)) -> Raw(bool),

        as_dmat4(&self:) -> Wrapped(DMat4),

    )
    + Fields
    (
        x_axis: Wrapped(Vec4),
        y_axis: Wrapped(Vec4),
        z_axis: Wrapped(Vec4),
        w_axis: Wrapped(Vec4),
    )
    + BinOps
    (
        self Add self -> Wrapped(Mat4),
        self Sub self -> Wrapped(Mat4),
        self Mul Wrapped(Affine3A) -> Wrapped(Mat4),
        self Mul self -> Wrapped(Mat4),
        self Mul Wrapped(Vec4) -> Wrapped(Vec4),
        self Mul Wrapped(Mat4) -> Wrapped(Mat4),
        self Mul Raw(f32) -> Wrapped(Mat4),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {

    mut (MetaMethod::Index) => |_,s,idx : usize| {
        Ok(LuaVec4::new_ref(
                s.script_ref().sub_ref(ReflectPathElem::SubReflectionIndexed{
                    label:"col",
                    index: idx,
                    get: |idx,ref_| Err(ReflectionError::InsufficientProvenance{
                        path: "".to_owned(),
                        msg: "Cannot get column of matrix with immutable reference".to_owned()
                    }),
                    get_mut: |idx, ref_| {
                        if ref_.is::<Mat4>(){
                            Ok(ref_.downcast_mut::<Mat4>()
                                .unwrap()
                                .col_mut(idx))
                        } else {
                            Err(ReflectionError::CannotDowncast{from: ref_.type_name().to_owned().into(), to:"Mat4".into()})
                        }
                    }
                })
            )
        )
    }
;
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 2x2 column major matrix.
    glam::f64::DMat2 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a 2x2 matrix from two column vectors.
        from_cols(Wrapped(DVec2),Wrapped(DVec2)) -> self,

        ///Creates a 2x2 matrix with its diagonal set to `diagonal` and all other entries set to 0.
        from_diagonal(Wrapped(DVec2)) -> self,

        ///Creates a 2x2 matrix containing the combining non-uniform `scale` and rotation of
        ///`angle` (in radians).
        from_scale_angle(Wrapped(DVec2),Raw(f64)) -> self,

        ///Creates a 2x2 matrix containing a rotation of `angle` (in radians).
        from_angle(Raw(f64)) -> self,

        ///Creates a 2x2 matrix from a 3x3 matrix, discarding the 2nd row and column.
        from_mat3(Wrapped(DMat3)) -> self,

        ///Returns the matrix column for the given `index`.
        ///
        ///# Panics
        ///
        ///Panics if `index` is greater than 1.
        col(&self:Raw(usize)) -> Wrapped(DVec2),

        ///Returns the matrix row for the given `index`.
        ///
        ///# Panics
        ///
        ///Panics if `index` is greater than 1.
        row(&self:Raw(usize)) -> Wrapped(DVec2),

        ///Returns `true` if, and only if, all elements are finite.
        ///If any element is either `NaN`, positive or negative infinity, this will return `false`.
        is_finite(&self:) -> Raw(bool),

        ///Returns `true` if any elements are `NaN`.
        is_nan(&self:) -> Raw(bool),

        ///Returns the transpose of `self`.
        transpose(&self:) -> self,

        ///Returns the determinant of `self`.
        determinant(&self:) -> Raw(f64),

        ///Returns the inverse of `self`.
        ///
        ///If the matrix is not invertible the returned matrix will be invalid.
        ///
        ///# Panics
        ///
        ///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
        inverse(&self:) -> self,

        ///Transforms a 2D vector.
        mul_vec2(&self:Wrapped(DVec2)) -> Wrapped(DVec2),

        ///Multiplies two 2x2 matrices.
        mul_mat2(&self:&self) -> self,

        ///Adds two 2x2 matrices.
        add_mat2(&self:&self) -> self,

        ///Subtracts two 2x2 matrices.
        sub_mat2(&self:&self) -> self,

        ///Multiplies a 2x2 matrix by a scalar.
        mul_scalar(&self:Raw(f64)) -> self,

        ///Returns true if the absolute difference of all elements between `self` and `rhs`
        ///is less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two matrices contain similar elements. It works best
        ///when comparing with a known value. The `max_abs_diff` that should be used used
        ///depends on the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(&self:self,Raw(f64)) -> Raw(bool),

        as_mat2(&self:) -> Wrapped(Mat2),

    )
    + Fields
    (
        x_axis: Wrapped(DVec2),
        y_axis: Wrapped(DVec2),
    )
    + BinOps
    (
        self Add self -> Wrapped(DMat2),
        self Sub self -> Wrapped(DMat2),
        self Mul self -> Wrapped(DMat2),
        self Mul Wrapped(DVec2) -> Wrapped(DVec2),
        self Mul Wrapped(DMat2) -> Wrapped(DMat2),
        self Mul Raw(f64) -> Wrapped(DMat2),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {

    mut (MetaMethod::Index) => |_,s,idx : usize| {
        Ok(LuaDVec2::new_ref(
                s.script_ref().sub_ref(ReflectPathElem::SubReflectionIndexed{
                    label:"col",
                    index: idx,
                    get: |idx,ref_| Err(ReflectionError::InsufficientProvenance{
                        path: "".to_owned(),
                        msg: "Cannot get column of matrix with immutable reference".to_owned()
                    }),
                    get_mut: |idx, ref_| {
                        if ref_.is::<DMat2>(){
                            Ok(ref_.downcast_mut::<DMat2>()
                                .unwrap()
                                .col_mut(idx))
                        } else {
                            Err(ReflectionError::CannotDowncast{from: ref_.type_name().to_owned().into(), to:"DMat2".into()})
                        }
                    }
                })
            )
        )
    }
;
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 3x3 column major matrix.
    ///
    ///This 3x3 matrix type features convenience methods for creating and using linear and
    ///affine transformations. If you are primarily dealing with 2D affine transformations the
    ///[`DAffine2`](crate::DAffine2) type is much faster and more space efficient than
    ///using a 3x3 matrix.
    ///
    ///Linear transformations including 3D rotation and scale can be created using methods
    ///such as [`Self::from_diagonal()`], [`Self::from_quat()`], [`Self::from_axis_angle()`],
    ///[`Self::from_rotation_x()`], [`Self::from_rotation_y()`], or
    ///[`Self::from_rotation_z()`].
    ///
    ///The resulting matrices can be use to transform 3D vectors using regular vector
    ///multiplication.
    ///
    ///Affine transformations including 2D translation, rotation and scale can be created
    ///using methods such as [`Self::from_translation()`], [`Self::from_angle()`],
    ///[`Self::from_scale()`] and [`Self::from_scale_angle_translation()`].
    ///
    ///The [`Self::transform_point2()`] and [`Self::transform_vector2()`] convenience methods
    ///are provided for performing affine transforms on 2D vectors and points. These multiply
    ///2D inputs as 3D vectors with an implicit `z` value of `1` for points and `0` for
    ///vectors respectively. These methods assume that `Self` contains a valid affine
    ///transform.
    glam::f64::DMat3 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a 3x3 matrix from two column vectors.
        from_cols(Wrapped(DVec3),Wrapped(DVec3),Wrapped(DVec3)) -> self,

        ///Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.
        from_diagonal(Wrapped(DVec3)) -> self,

        ///Creates a 3x3 matrix from a 4x4 matrix, discarding the 4th row and column.
        from_mat4(Wrapped(DMat4)) -> self,

        ///Creates a 3D rotation matrix from the given quaternion.
        ///
        ///# Panics
        ///
        ///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
        from_quat(Wrapped(DQuat)) -> self,

        ///Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in
        ///radians).
        ///
        ///# Panics
        ///
        ///Will panic if `axis` is not normalized when `glam_assert` is enabled.
        from_axis_angle(Wrapped(DVec3),Raw(f64)) -> self,

        ///Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in
        ///radians).
        from_euler(Wrapped(EulerRot),Raw(f64),Raw(f64),Raw(f64)) -> self,

        ///Creates a 3D rotation matrix from `angle` (in radians) around the x axis.
        from_rotation_x(Raw(f64)) -> self,

        ///Creates a 3D rotation matrix from `angle` (in radians) around the y axis.
        from_rotation_y(Raw(f64)) -> self,

        ///Creates a 3D rotation matrix from `angle` (in radians) around the z axis.
        from_rotation_z(Raw(f64)) -> self,

        ///Creates an affine transformation matrix from the given 2D `translation`.
        ///
        ///The resulting matrix can be used to transform 2D points and vectors. See
        ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
        from_translation(Wrapped(DVec2)) -> self,

        ///Creates an affine transformation matrix from the given 2D rotation `angle` (in
        ///radians).
        ///
        ///The resulting matrix can be used to transform 2D points and vectors. See
        ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
        from_angle(Raw(f64)) -> self,

        ///Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in
        ///radians) and `translation`.
        ///
        ///The resulting matrix can be used to transform 2D points and vectors. See
        ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
        from_scale_angle_translation(Wrapped(DVec2),Raw(f64),Wrapped(DVec2)) -> self,

        ///Creates an affine transformation matrix from the given non-uniform 2D `scale`.
        ///
        ///The resulting matrix can be used to transform 2D points and vectors. See
        ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
        ///
        ///# Panics
        ///
        ///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
        from_scale(Wrapped(DVec2)) -> self,

        ///Creates an affine transformation matrix from the given 2x2 matrix.
        ///
        ///The resulting matrix can be used to transform 2D points and vectors. See
        ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
        from_mat2(Wrapped(DMat2)) -> self,

        ///Returns the matrix column for the given `index`.
        ///
        ///# Panics
        ///
        ///Panics if `index` is greater than 2.
        col(&self:Raw(usize)) -> Wrapped(DVec3),

        ///Returns the matrix row for the given `index`.
        ///
        ///# Panics
        ///
        ///Panics if `index` is greater than 2.
        row(&self:Raw(usize)) -> Wrapped(DVec3),

        ///Returns `true` if, and only if, all elements are finite.
        ///If any element is either `NaN`, positive or negative infinity, this will return `false`.
        is_finite(&self:) -> Raw(bool),

        ///Returns `true` if any elements are `NaN`.
        is_nan(&self:) -> Raw(bool),

        ///Returns the transpose of `self`.
        transpose(&self:) -> self,

        ///Returns the determinant of `self`.
        determinant(&self:) -> Raw(f64),

        ///Returns the inverse of `self`.
        ///
        ///If the matrix is not invertible the returned matrix will be invalid.
        ///
        ///# Panics
        ///
        ///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
        inverse(&self:) -> self,

        ///Transforms the given 2D vector as a point.
        ///
        ///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.
        ///
        ///This method assumes that `self` contains a valid affine transform.
        ///
        ///# Panics
        ///
        ///Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.
        transform_point2(&self:Wrapped(DVec2)) -> Wrapped(DVec2),

        ///Rotates the given 2D vector.
        ///
        ///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.
        ///
        ///This method assumes that `self` contains a valid affine transform.
        ///
        ///# Panics
        ///
        ///Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.
        transform_vector2(&self:Wrapped(DVec2)) -> Wrapped(DVec2),

        ///Transforms a 3D vector.
        mul_vec3(&self:Wrapped(DVec3)) -> Wrapped(DVec3),

        ///Multiplies two 3x3 matrices.
        mul_mat3(&self:&self) -> self,

        ///Adds two 3x3 matrices.
        add_mat3(&self:&self) -> self,

        ///Subtracts two 3x3 matrices.
        sub_mat3(&self:&self) -> self,

        ///Multiplies a 3x3 matrix by a scalar.
        mul_scalar(&self:Raw(f64)) -> self,

        ///Returns true if the absolute difference of all elements between `self` and `rhs`
        ///is less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two matrices contain similar elements. It works best
        ///when comparing with a known value. The `max_abs_diff` that should be used used
        ///depends on the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(&self:self,Raw(f64)) -> Raw(bool),

        as_mat3(&self:) -> Wrapped(Mat3),

    )
    + Fields
    (
        x_axis: Wrapped(DVec3),
        y_axis: Wrapped(DVec3),
        z_axis: Wrapped(DVec3),
    )
    + BinOps
    (
        self Add self -> Wrapped(DMat3),
        self Sub self -> Wrapped(DMat3),
        self Mul Wrapped(DAffine2) -> Wrapped(DMat3),
        self Mul self -> Wrapped(DMat3),
        self Mul Wrapped(DVec3) -> Wrapped(DVec3),
        self Mul Wrapped(DMat3) -> Wrapped(DMat3),
        self Mul Raw(f64) -> Wrapped(DMat3),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {

    mut (MetaMethod::Index) => |_,s,idx : usize| {
        Ok(LuaDVec3::new_ref(
                s.script_ref().sub_ref(ReflectPathElem::SubReflectionIndexed{
                    label:"col",
                    index: idx,
                    get: |idx,ref_| Err(ReflectionError::InsufficientProvenance{
                        path: "".to_owned(),
                        msg: "Cannot get column of matrix with immutable reference".to_owned()
                    }),
                    get_mut: |idx, ref_| {
                        if ref_.is::<DMat3>(){
                            Ok(ref_.downcast_mut::<DMat3>()
                                .unwrap()
                                .col_mut(idx))
                        } else {
                            Err(ReflectionError::CannotDowncast{from: ref_.type_name().to_owned().into(), to:"DMat3".into()})
                        }
                    }
                })
            )
        )
    }
;
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 4x4 column major matrix.
    ///
    ///This 4x4 matrix type features convenience methods for creating and using affine transforms and
    ///perspective projections. If you are primarily dealing with 3D affine transformations
    ///considering using [`DAffine3`](crate::DAffine3) which is faster than a 4x4 matrix
    ///for some affine operations.
    ///
    ///Affine transformations including 3D translation, rotation and scale can be created
    ///using methods such as [`Self::from_translation()`], [`Self::from_quat()`],
    ///[`Self::from_scale()`] and [`Self::from_scale_rotation_translation()`].
    ///
    ///Othographic projections can be created using the methods [`Self::orthographic_lh()`] for
    ///left-handed coordinate systems and [`Self::orthographic_rh()`] for right-handed
    ///systems. The resulting matrix is also an affine transformation.
    ///
    ///The [`Self::transform_point3()`] and [`Self::transform_vector3()`] convenience methods
    ///are provided for performing affine transformations on 3D vectors and points. These
    ///multiply 3D inputs as 4D vectors with an implicit `w` value of `1` for points and `0`
    ///for vectors respectively. These methods assume that `Self` contains a valid affine
    ///transform.
    ///
    ///Perspective projections can be created using methods such as
    ///[`Self::perspective_lh()`], [`Self::perspective_infinite_lh()`] and
    ///[`Self::perspective_infinite_reverse_lh()`] for left-handed co-ordinate systems and
    ///[`Self::perspective_rh()`], [`Self::perspective_infinite_rh()`] and
    ///[`Self::perspective_infinite_reverse_rh()`] for right-handed co-ordinate systems.
    ///
    ///The resulting perspective project can be use to transform 3D vectors as points with
    ///perspective correction using the [`Self::project_point3()`] convenience method.
    glam::f64::DMat4 :
    Clone +
    Debug +
    Methods
    (
        ///Creates a 4x4 matrix from two column vectors.
        from_cols(Wrapped(DVec4),Wrapped(DVec4),Wrapped(DVec4),Wrapped(DVec4)) -> self,

        ///Creates a 4x4 matrix with its diagonal set to `diagonal` and all other entries set to 0.
        from_diagonal(Wrapped(DVec4)) -> self,

        ///Creates an affine transformation matrix from the given 3D `scale`, `rotation` and
        ///`translation`.
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        ///
        ///# Panics
        ///
        ///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
        from_scale_rotation_translation(Wrapped(DVec3),Wrapped(DQuat),Wrapped(DVec3)) -> self,

        ///Creates an affine transformation matrix from the given 3D `translation`.
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        ///
        ///# Panics
        ///
        ///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
        from_rotation_translation(Wrapped(DQuat),Wrapped(DVec3)) -> self,

        ///Creates an affine transformation matrix from the given `rotation` quaternion.
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        ///
        ///# Panics
        ///
        ///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
        from_quat(Wrapped(DQuat)) -> self,

        ///Creates an affine transformation matrix from the given 3x3 linear transformation
        ///matrix.
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        from_mat3(Wrapped(DMat3)) -> self,

        ///Creates an affine transformation matrix from the given 3D `translation`.
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        from_translation(Wrapped(DVec3)) -> self,

        ///Creates an affine transformation matrix containing a 3D rotation around a normalized
        ///rotation `axis` of `angle` (in radians).
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        ///
        ///# Panics
        ///
        ///Will panic if `axis` is not normalized when `glam_assert` is enabled.
        from_axis_angle(Wrapped(DVec3),Raw(f64)) -> self,

        ///Creates a affine transformation matrix containing a rotation from the given euler
        ///rotation sequence and angles (in radians).
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        from_euler(Wrapped(EulerRot),Raw(f64),Raw(f64),Raw(f64)) -> self,

        ///Creates an affine transformation matrix containing a 3D rotation around the x axis of
        ///`angle` (in radians).
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        from_rotation_x(Raw(f64)) -> self,

        ///Creates an affine transformation matrix containing a 3D rotation around the y axis of
        ///`angle` (in radians).
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        from_rotation_y(Raw(f64)) -> self,

        ///Creates an affine transformation matrix containing a 3D rotation around the z axis of
        ///`angle` (in radians).
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        from_rotation_z(Raw(f64)) -> self,

        ///Creates an affine transformation matrix containing the given 3D non-uniform `scale`.
        ///
        ///The resulting matrix can be used to transform 3D points and vectors. See
        ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
        ///
        ///# Panics
        ///
        ///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
        from_scale(Wrapped(DVec3)) -> self,

        ///Returns the matrix column for the given `index`.
        ///
        ///# Panics
        ///
        ///Panics if `index` is greater than 3.
        col(&self:Raw(usize)) -> Wrapped(DVec4),

        ///Returns the matrix row for the given `index`.
        ///
        ///# Panics
        ///
        ///Panics if `index` is greater than 3.
        row(&self:Raw(usize)) -> Wrapped(DVec4),

        ///Returns `true` if, and only if, all elements are finite.
        ///If any element is either `NaN`, positive or negative infinity, this will return `false`.
        is_finite(&self:) -> Raw(bool),

        ///Returns `true` if any elements are `NaN`.
        is_nan(&self:) -> Raw(bool),

        ///Returns the transpose of `self`.
        transpose(&self:) -> self,

        ///Returns the determinant of `self`.
        determinant(&self:) -> Raw(f64),

        ///Returns the inverse of `self`.
        ///
        ///If the matrix is not invertible the returned matrix will be invalid.
        ///
        ///# Panics
        ///
        ///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
        inverse(&self:) -> self,

        ///Creates a left-handed view matrix using a camera position, an up direction, and a facing
        ///direction.
        ///
        ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
        look_to_lh(Wrapped(DVec3),Wrapped(DVec3),Wrapped(DVec3)) -> self,

        ///Creates a right-handed view matrix using a camera position, an up direction, and a facing
        ///direction.
        ///
        ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
        look_to_rh(Wrapped(DVec3),Wrapped(DVec3),Wrapped(DVec3)) -> self,

        ///Creates a left-handed view matrix using a camera position, an up direction, and a focal
        ///point.
        ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
        ///
        ///# Panics
        ///
        ///Will panic if `up` is not normalized when `glam_assert` is enabled.
        look_at_lh(Wrapped(DVec3),Wrapped(DVec3),Wrapped(DVec3)) -> self,

        ///Creates a right-handed view matrix using a camera position, an up direction, and a focal
        ///point.
        ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
        ///
        ///# Panics
        ///
        ///Will panic if `up` is not normalized when `glam_assert` is enabled.
        look_at_rh(Wrapped(DVec3),Wrapped(DVec3),Wrapped(DVec3)) -> self,

        ///Creates a right-handed perspective projection matrix with [-1,1] depth range.
        ///This is the same as the OpenGL `gluPerspective` function.
        ///See <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml>
        perspective_rh_gl(Raw(f64),Raw(f64),Raw(f64),Raw(f64)) -> self,

        ///Creates a left-handed perspective projection matrix with `[0,1]` depth range.
        ///
        ///# Panics
        ///
        ///Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
        ///enabled.
        perspective_lh(Raw(f64),Raw(f64),Raw(f64),Raw(f64)) -> self,

        ///Creates a right-handed perspective projection matrix with `[0,1]` depth range.
        ///
        ///# Panics
        ///
        ///Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
        ///enabled.
        perspective_rh(Raw(f64),Raw(f64),Raw(f64),Raw(f64)) -> self,

        ///Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
        ///
        ///# Panics
        ///
        ///Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
        perspective_infinite_lh(Raw(f64),Raw(f64),Raw(f64)) -> self,

        ///Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
        ///
        ///# Panics
        ///
        ///Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
        perspective_infinite_reverse_lh(Raw(f64),Raw(f64),Raw(f64)) -> self,

        ///Creates an infinite right-handed perspective projection matrix with
        ///`[0,1]` depth range.
        perspective_infinite_rh(Raw(f64),Raw(f64),Raw(f64)) -> self,

        ///Creates an infinite reverse right-handed perspective projection matrix
        ///with `[0,1]` depth range.
        perspective_infinite_reverse_rh(Raw(f64),Raw(f64),Raw(f64)) -> self,

        ///Creates a right-handed orthographic projection matrix with `[-1,1]` depth
        ///range.  This is the same as the OpenGL `glOrtho` function in OpenGL.
        ///See
        ///<https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml>
        orthographic_rh_gl(Raw(f64),Raw(f64),Raw(f64),Raw(f64),Raw(f64),Raw(f64)) -> self,

        ///Creates a left-handed orthographic projection matrix with `[0,1]` depth range.
        orthographic_lh(Raw(f64),Raw(f64),Raw(f64),Raw(f64),Raw(f64),Raw(f64)) -> self,

        ///Creates a right-handed orthographic projection matrix with `[0,1]` depth range.
        orthographic_rh(Raw(f64),Raw(f64),Raw(f64),Raw(f64),Raw(f64),Raw(f64)) -> self,

        ///Transforms the given 3D vector as a point, applying perspective correction.
        ///
        ///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is `1.0`.
        ///The perspective divide is performed meaning the resulting 3D vector is divided by `w`.
        ///
        ///This method assumes that `self` contains a projective transform.
        project_point3(&self:Wrapped(DVec3)) -> Wrapped(DVec3),

        ///Transforms the given 3D vector as a point.
        ///
        ///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
        ///`1.0`.
        ///
        ///This method assumes that `self` contains a valid affine transform. It does not perform
        ///a persective divide, if `self` contains a perspective transform, or if you are unsure,
        ///the [`Self::project_point3()`] method should be used instead.
        ///
        ///# Panics
        ///
        ///Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
        transform_point3(&self:Wrapped(DVec3)) -> Wrapped(DVec3),

        ///Transforms the give 3D vector as a direction.
        ///
        ///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
        ///`0.0`.
        ///
        ///This method assumes that `self` contains a valid affine transform.
        ///
        ///# Panics
        ///
        ///Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
        transform_vector3(&self:Wrapped(DVec3)) -> Wrapped(DVec3),

        ///Transforms a 4D vector.
        mul_vec4(&self:Wrapped(DVec4)) -> Wrapped(DVec4),

        ///Multiplies two 4x4 matrices.
        mul_mat4(&self:&self) -> self,

        ///Adds two 4x4 matrices.
        add_mat4(&self:&self) -> self,

        ///Subtracts two 4x4 matrices.
        sub_mat4(&self:&self) -> self,

        ///Multiplies a 4x4 matrix by a scalar.
        mul_scalar(&self:Raw(f64)) -> self,

        ///Returns true if the absolute difference of all elements between `self` and `rhs`
        ///is less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two matrices contain similar elements. It works best
        ///when comparing with a known value. The `max_abs_diff` that should be used used
        ///depends on the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(&self:self,Raw(f64)) -> Raw(bool),

        as_mat4(&self:) -> Wrapped(Mat4),

    )
    + Fields
    (
        x_axis: Wrapped(DVec4),
        y_axis: Wrapped(DVec4),
        z_axis: Wrapped(DVec4),
        w_axis: Wrapped(DVec4),
    )
    + BinOps
    (
        self Add self -> Wrapped(DMat4),
        self Sub self -> Wrapped(DMat4),
        self Mul Wrapped(DAffine3) -> Wrapped(DMat4),
        self Mul self -> Wrapped(DMat4),
        self Mul Wrapped(DVec4) -> Wrapped(DVec4),
        self Mul Wrapped(DMat4) -> Wrapped(DMat4),
        self Mul Raw(f64) -> Wrapped(DMat4),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {

    mut (MetaMethod::Index) => |_,s,idx : usize| {
        Ok(LuaDVec4::new_ref(
                s.script_ref().sub_ref(ReflectPathElem::SubReflectionIndexed{
                    label:"col",
                    index: idx,
                    get: |idx,ref_| Err(ReflectionError::InsufficientProvenance{
                        path: "".to_owned(),
                        msg: "Cannot get column of matrix with immutable reference".to_owned()
                    }),
                    get_mut: |idx, ref_| {
                        if ref_.is::<DMat4>(){
                            Ok(ref_.downcast_mut::<DMat4>()
                                .unwrap()
                                .col_mut(idx))
                        } else {
                            Err(ReflectionError::CannotDowncast{from: ref_.type_name().to_owned().into(), to:"DMat4".into()})
                        }
                    }
                })
            )
        )
    }
;
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 2D affine transform, which can represent translation, rotation, scaling and shear.
    glam::f32::Affine2 :
    Clone +
    Debug +
    Methods
    (
        ///Creates an affine transform from three column vectors.
        from_cols(Wrapped(Vec2),Wrapped(Vec2),Wrapped(Vec2)) -> self,

        ///Creates an affine transform that changes scale.
        ///Note that if any scale is zero the transform will be non-invertible.
        from_scale(Wrapped(Vec2)) -> self,

        ///Creates an affine transform from the given rotation `angle`.
        from_angle(Raw(f32)) -> self,

        ///Creates an affine transformation from the given 2D `translation`.
        from_translation(Wrapped(Vec2)) -> self,

        ///Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation)
        from_mat2(Wrapped(Mat2)) -> self,

        ///Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation) and a
        ///translation vector.
        ///
        ///Equivalent to
        ///`Affine2::from_translation(translation) * Affine2::from_mat2(mat2)`
        from_mat2_translation(Wrapped(Mat2),Wrapped(Vec2)) -> self,

        ///Creates an affine transform from the given 2D `scale`, rotation `angle` (in radians) and
        ///`translation`.
        ///
        ///Equivalent to `Affine2::from_translation(translation) *
        ///Affine2::from_angle(angle) * Affine2::from_scale(scale)`
        from_scale_angle_translation(Wrapped(Vec2),Raw(f32),Wrapped(Vec2)) -> self,

        ///Creates an affine transform from the given 2D rotation `angle` (in radians) and
        ///`translation`.
        ///
        ///Equivalent to `Affine2::from_translation(translation) * Affine2::from_angle(angle)`
        from_angle_translation(Raw(f32),Wrapped(Vec2)) -> self,

        ///The given `Mat3` must be an affine transform,
        from_mat3(Wrapped(Mat3)) -> self,

        ///The given `Mat3A` must be an affine transform,
        from_mat3a(Wrapped(Mat3A)) -> self,

        ///Transforms the given 2D point, applying shear, scale, rotation and translation.
        transform_point2(&self:Wrapped(Vec2)) -> Wrapped(Vec2),

        ///Transforms the given 2D vector, applying shear, scale and rotation (but NOT
        ///translation).
        ///
        ///To also apply translation, use [`Self::transform_point2`] instead.
        transform_vector2(&self:Wrapped(Vec2)) -> Wrapped(Vec2),

        ///Returns `true` if, and only if, all elements are finite.
        ///
        ///If any element is either `NaN`, positive or negative infinity, this will return
        ///`false`.
        is_finite(&self:) -> Raw(bool),

        ///Returns `true` if any elements are `NaN`.
        is_nan(&self:) -> Raw(bool),

        ///Returns true if the absolute difference of all elements between `self` and `rhs`
        ///is less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two 3x4 matrices contain similar elements. It works
        ///best when comparing with a known value. The `max_abs_diff` that should be used used
        ///depends on the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(&self:self,Raw(f32)) -> Raw(bool),

        ///Return the inverse of this transform.
        ///
        ///Note that if the transform is not invertible the result will be invalid.
        inverse(&self:) -> self,

    )
    + Fields
    (
        matrix2: Wrapped(Mat2),
        translation: Wrapped(Vec2),
    )
    + BinOps
    (
        self Mul Wrapped(Affine2) -> Wrapped(Affine2),
        self Mul Wrapped(Mat3) -> Wrapped(Mat3),
        self Mul Wrapped(Mat3A) -> Wrapped(Mat3A),
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 3D affine transform, which can represent translation, rotation, scaling and shear.
    glam::f32::Affine3A :
    Clone +
    Debug +
    Methods
    (
        ///Creates an affine transform from three column vectors.
        from_cols(Wrapped(Vec3A),Wrapped(Vec3A),Wrapped(Vec3A),Wrapped(Vec3A)) -> self,

        ///Creates an affine transform that changes scale.
        ///Note that if any scale is zero the transform will be non-invertible.
        from_scale(Wrapped(Vec3)) -> self,

        ///Creates an affine transform from the given `rotation` quaternion.
        from_quat(Wrapped(Quat)) -> self,

        ///Creates an affine transform containing a 3D rotation around a normalized
        ///rotation `axis` of `angle` (in radians).
        from_axis_angle(Wrapped(Vec3),Raw(f32)) -> self,

        ///Creates an affine transform containing a 3D rotation around the x axis of
        ///`angle` (in radians).
        from_rotation_x(Raw(f32)) -> self,

        ///Creates an affine transform containing a 3D rotation around the y axis of
        ///`angle` (in radians).
        from_rotation_y(Raw(f32)) -> self,

        ///Creates an affine transform containing a 3D rotation around the z axis of
        ///`angle` (in radians).
        from_rotation_z(Raw(f32)) -> self,

        ///Creates an affine transformation from the given 3D `translation`.
        from_translation(Wrapped(Vec3)) -> self,

        ///Creates an affine transform from a 3x3 matrix (expressing scale, shear and
        ///rotation)
        from_mat3(Wrapped(Mat3)) -> self,

        ///Creates an affine transform from a 3x3 matrix (expressing scale, shear and rotation)
        ///and a translation vector.
        ///
        ///Equivalent to `Affine3A::from_translation(translation) * Affine3A::from_mat3(mat3)`
        from_mat3_translation(Wrapped(Mat3),Wrapped(Vec3)) -> self,

        ///Creates an affine transform from the given 3D `scale`, `rotation` and
        ///`translation`.
        ///
        ///Equivalent to `Affine3A::from_translation(translation) *
        ///Affine3A::from_quat(rotation) * Affine3A::from_scale(scale)`
        from_scale_rotation_translation(Wrapped(Vec3),Wrapped(Quat),Wrapped(Vec3)) -> self,

        ///Creates an affine transform from the given 3D `rotation` and `translation`.
        ///
        ///Equivalent to `Affine3A::from_translation(translation) * Affine3A::from_quat(rotation)`
        from_rotation_translation(Wrapped(Quat),Wrapped(Vec3)) -> self,

        ///The given `Mat4` must be an affine transform,
        ///i.e. contain no perspective transform.
        from_mat4(Wrapped(Mat4)) -> self,

        ///Creates a left-handed view transform using a camera position, an up direction, and a facing
        ///direction.
        ///
        ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
        look_to_lh(Wrapped(Vec3),Wrapped(Vec3),Wrapped(Vec3)) -> self,

        ///Creates a right-handed view transform using a camera position, an up direction, and a facing
        ///direction.
        ///
        ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
        look_to_rh(Wrapped(Vec3),Wrapped(Vec3),Wrapped(Vec3)) -> self,

        ///Creates a left-handed view transform using a camera position, an up direction, and a focal
        ///point.
        ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
        ///
        ///# Panics
        ///
        ///Will panic if `up` is not normalized when `glam_assert` is enabled.
        look_at_lh(Wrapped(Vec3),Wrapped(Vec3),Wrapped(Vec3)) -> self,

        ///Creates a right-handed view transform using a camera position, an up direction, and a focal
        ///point.
        ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
        ///
        ///# Panics
        ///
        ///Will panic if `up` is not normalized when `glam_assert` is enabled.
        look_at_rh(Wrapped(Vec3),Wrapped(Vec3),Wrapped(Vec3)) -> self,

        ///Transforms the given 3D points, applying shear, scale, rotation and translation.
        transform_point3(&self:Wrapped(Vec3)) -> Wrapped(Vec3),

        ///Transforms the given 3D vector, applying shear, scale and rotation (but NOT
        ///translation).
        ///
        ///To also apply translation, use [`Self::transform_point3`] instead.
        transform_vector3(&self:Wrapped(Vec3)) -> Wrapped(Vec3),

        ///Transforms the given `Vec3A`, applying shear, scale, rotation and translation.
        transform_point3a(&self:Wrapped(Vec3A)) -> Wrapped(Vec3A),

        ///Transforms the given `Vec3A`, applying shear, scale and rotation (but NOT
        ///translation).
        ///
        ///To also apply translation, use [`Self::transform_point3a`] instead.
        transform_vector3a(&self:Wrapped(Vec3A)) -> Wrapped(Vec3A),

        ///Returns `true` if, and only if, all elements are finite.
        ///
        ///If any element is either `NaN`, positive or negative infinity, this will return
        ///`false`.
        is_finite(&self:) -> Raw(bool),

        ///Returns `true` if any elements are `NaN`.
        is_nan(&self:) -> Raw(bool),

        ///Returns true if the absolute difference of all elements between `self` and `rhs`
        ///is less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two 3x4 matrices contain similar elements. It works
        ///best when comparing with a known value. The `max_abs_diff` that should be used used
        ///depends on the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(&self:self,Raw(f32)) -> Raw(bool),

        ///Return the inverse of this transform.
        ///
        ///Note that if the transform is not invertible the result will be invalid.
        inverse(&self:) -> self,

    )
    + Fields
    (
        matrix3: Wrapped(Mat3A),
        translation: Wrapped(Vec3A),
    )
    + BinOps
    (
        self Mul Wrapped(Affine3A) -> Wrapped(Affine3A),
        self Mul Wrapped(Mat4) -> Wrapped(Mat4),
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 2D affine transform, which can represent translation, rotation, scaling and shear.
    glam::f64::DAffine2 :
    Clone +
    Debug +
    Methods
    (
        ///Creates an affine transform from three column vectors.
        from_cols(Wrapped(DVec2),Wrapped(DVec2),Wrapped(DVec2)) -> self,

        ///Creates an affine transform that changes scale.
        ///Note that if any scale is zero the transform will be non-invertible.
        from_scale(Wrapped(DVec2)) -> self,

        ///Creates an affine transform from the given rotation `angle`.
        from_angle(Raw(f64)) -> self,

        ///Creates an affine transformation from the given 2D `translation`.
        from_translation(Wrapped(DVec2)) -> self,

        ///Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation)
        from_mat2(Wrapped(DMat2)) -> self,

        ///Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation) and a
        ///translation vector.
        ///
        ///Equivalent to
        ///`DAffine2::from_translation(translation) * DAffine2::from_mat2(mat2)`
        from_mat2_translation(Wrapped(DMat2),Wrapped(DVec2)) -> self,

        ///Creates an affine transform from the given 2D `scale`, rotation `angle` (in radians) and
        ///`translation`.
        ///
        ///Equivalent to `DAffine2::from_translation(translation) *
        ///DAffine2::from_angle(angle) * DAffine2::from_scale(scale)`
        from_scale_angle_translation(Wrapped(DVec2),Raw(f64),Wrapped(DVec2)) -> self,

        ///Creates an affine transform from the given 2D rotation `angle` (in radians) and
        ///`translation`.
        ///
        ///Equivalent to `DAffine2::from_translation(translation) * DAffine2::from_angle(angle)`
        from_angle_translation(Raw(f64),Wrapped(DVec2)) -> self,

        ///The given `DMat3` must be an affine transform,
        from_mat3(Wrapped(DMat3)) -> self,

        ///Transforms the given 2D point, applying shear, scale, rotation and translation.
        transform_point2(&self:Wrapped(DVec2)) -> Wrapped(DVec2),

        ///Transforms the given 2D vector, applying shear, scale and rotation (but NOT
        ///translation).
        ///
        ///To also apply translation, use [`Self::transform_point2`] instead.
        transform_vector2(&self:Wrapped(DVec2)) -> Wrapped(DVec2),

        ///Returns `true` if, and only if, all elements are finite.
        ///
        ///If any element is either `NaN`, positive or negative infinity, this will return
        ///`false`.
        is_finite(&self:) -> Raw(bool),

        ///Returns `true` if any elements are `NaN`.
        is_nan(&self:) -> Raw(bool),

        ///Returns true if the absolute difference of all elements between `self` and `rhs`
        ///is less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two 3x4 matrices contain similar elements. It works
        ///best when comparing with a known value. The `max_abs_diff` that should be used used
        ///depends on the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(&self:self,Raw(f64)) -> Raw(bool),

        ///Return the inverse of this transform.
        ///
        ///Note that if the transform is not invertible the result will be invalid.
        inverse(&self:) -> self,

    )
    + Fields
    (
        matrix2: Wrapped(DMat2),
        translation: Wrapped(DVec2),
    )
    + BinOps
    (
        self Mul Wrapped(DAffine2) -> Wrapped(DAffine2),
        self Mul Wrapped(DMat3) -> Wrapped(DMat3),
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A 3D affine transform, which can represent translation, rotation, scaling and shear.
    glam::f64::DAffine3 :
    Clone +
    Debug +
    Methods
    (
        ///Creates an affine transform from three column vectors.
        from_cols(Wrapped(DVec3),Wrapped(DVec3),Wrapped(DVec3),Wrapped(DVec3)) -> self,

        ///Creates an affine transform that changes scale.
        ///Note that if any scale is zero the transform will be non-invertible.
        from_scale(Wrapped(DVec3)) -> self,

        ///Creates an affine transform from the given `rotation` quaternion.
        from_quat(Wrapped(DQuat)) -> self,

        ///Creates an affine transform containing a 3D rotation around a normalized
        ///rotation `axis` of `angle` (in radians).
        from_axis_angle(Wrapped(DVec3),Raw(f64)) -> self,

        ///Creates an affine transform containing a 3D rotation around the x axis of
        ///`angle` (in radians).
        from_rotation_x(Raw(f64)) -> self,

        ///Creates an affine transform containing a 3D rotation around the y axis of
        ///`angle` (in radians).
        from_rotation_y(Raw(f64)) -> self,

        ///Creates an affine transform containing a 3D rotation around the z axis of
        ///`angle` (in radians).
        from_rotation_z(Raw(f64)) -> self,

        ///Creates an affine transformation from the given 3D `translation`.
        from_translation(Wrapped(DVec3)) -> self,

        ///Creates an affine transform from a 3x3 matrix (expressing scale, shear and
        ///rotation)
        from_mat3(Wrapped(DMat3)) -> self,

        ///Creates an affine transform from a 3x3 matrix (expressing scale, shear and rotation)
        ///and a translation vector.
        ///
        ///Equivalent to `DAffine3::from_translation(translation) * DAffine3::from_mat3(mat3)`
        from_mat3_translation(Wrapped(DMat3),Wrapped(DVec3)) -> self,

        ///Creates an affine transform from the given 3D `scale`, `rotation` and
        ///`translation`.
        ///
        ///Equivalent to `DAffine3::from_translation(translation) *
        ///DAffine3::from_quat(rotation) * DAffine3::from_scale(scale)`
        from_scale_rotation_translation(Wrapped(DVec3),Wrapped(DQuat),Wrapped(DVec3)) -> self,

        ///Creates an affine transform from the given 3D `rotation` and `translation`.
        ///
        ///Equivalent to `DAffine3::from_translation(translation) * DAffine3::from_quat(rotation)`
        from_rotation_translation(Wrapped(DQuat),Wrapped(DVec3)) -> self,

        ///The given `DMat4` must be an affine transform,
        ///i.e. contain no perspective transform.
        from_mat4(Wrapped(DMat4)) -> self,

        ///Creates a left-handed view transform using a camera position, an up direction, and a facing
        ///direction.
        ///
        ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
        look_to_lh(Wrapped(DVec3),Wrapped(DVec3),Wrapped(DVec3)) -> self,

        ///Creates a right-handed view transform using a camera position, an up direction, and a facing
        ///direction.
        ///
        ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
        look_to_rh(Wrapped(DVec3),Wrapped(DVec3),Wrapped(DVec3)) -> self,

        ///Creates a left-handed view transform using a camera position, an up direction, and a focal
        ///point.
        ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
        ///
        ///# Panics
        ///
        ///Will panic if `up` is not normalized when `glam_assert` is enabled.
        look_at_lh(Wrapped(DVec3),Wrapped(DVec3),Wrapped(DVec3)) -> self,

        ///Creates a right-handed view transform using a camera position, an up direction, and a focal
        ///point.
        ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
        ///
        ///# Panics
        ///
        ///Will panic if `up` is not normalized when `glam_assert` is enabled.
        look_at_rh(Wrapped(DVec3),Wrapped(DVec3),Wrapped(DVec3)) -> self,

        ///Transforms the given 3D points, applying shear, scale, rotation and translation.
        transform_point3(&self:Wrapped(DVec3)) -> Wrapped(DVec3),

        ///Transforms the given 3D vector, applying shear, scale and rotation (but NOT
        ///translation).
        ///
        ///To also apply translation, use [`Self::transform_point3`] instead.
        transform_vector3(&self:Wrapped(DVec3)) -> Wrapped(DVec3),

        ///Returns `true` if, and only if, all elements are finite.
        ///
        ///If any element is either `NaN`, positive or negative infinity, this will return
        ///`false`.
        is_finite(&self:) -> Raw(bool),

        ///Returns `true` if any elements are `NaN`.
        is_nan(&self:) -> Raw(bool),

        ///Returns true if the absolute difference of all elements between `self` and `rhs`
        ///is less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two 3x4 matrices contain similar elements. It works
        ///best when comparing with a known value. The `max_abs_diff` that should be used used
        ///depends on the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(&self:self,Raw(f64)) -> Raw(bool),

        ///Return the inverse of this transform.
        ///
        ///Note that if the transform is not invertible the result will be invalid.
        inverse(&self:) -> self,

    )
    + Fields
    (
        matrix3: Wrapped(DMat3),
        translation: Wrapped(DVec3),
    )
    + BinOps
    (
        self Mul Wrapped(DAffine3) -> Wrapped(DAffine3),
        self Mul Wrapped(DMat4) -> Wrapped(DMat4),
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A quaternion representing an orientation.
    ///
    ///This quaternion is intended to be of unit length but may denormalize due to
    ///floating point "error creep" which can occur when successive quaternion
    ///operations are applied.
    ///
    ///This type is 16 byte aligned.
    glam::f32::Quat :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new rotation quaternion.
        ///
        ///This should generally not be called manually unless you know what you are doing.
        ///Use one of the other constructors instead such as `identity` or `from_axis_angle`.
        ///
        ///`from_xyzw` is mostly used by unit tests and `serde` deserialization.
        ///
        ///# Preconditions
        ///
        ///This function does not check if the input is normalized, it is up to the user to
        ///provide normalized input or to normalized the resulting quaternion.
        from_xyzw(Raw(f32),Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Creates a new rotation quaternion from a 4D vector.
        ///
        ///# Preconditions
        ///
        ///This function does not check if the input is normalized, it is up to the user to
        ///provide normalized input or to normalized the resulting quaternion.
        from_vec4(Wrapped(Vec4)) -> self,

        ///Create a quaternion for a normalized rotation `axis` and `angle` (in radians).
        ///The axis must be normalized (unit-length).
        ///
        ///# Panics
        ///
        ///Will panic if `axis` is not normalized when `glam_assert` is enabled.
        from_axis_angle(Wrapped(Vec3),Raw(f32)) -> self,

        ///Create a quaternion that rotates `v.length()` radians around `v.normalize()`.
        ///
        ///`from_scaled_axis(Vec3::ZERO)` results in the identity quaternion.
        from_scaled_axis(Wrapped(Vec3)) -> self,

        ///Creates a quaternion from the `angle` (in radians) around the x axis.
        from_rotation_x(Raw(f32)) -> self,

        ///Creates a quaternion from the `angle` (in radians) around the y axis.
        from_rotation_y(Raw(f32)) -> self,

        ///Creates a quaternion from the `angle` (in radians) around the z axis.
        from_rotation_z(Raw(f32)) -> self,

        ///Creates a quaternion from the given Euler rotation sequence and the angles (in radians).
        from_euler(Wrapped(EulerRot),Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Creates a quaternion from a 3x3 rotation matrix.
        from_mat3(Wrapped(&Mat3)) -> self,

        ///Creates a quaternion from a 3x3 SIMD aligned rotation matrix.
        from_mat3a(Wrapped(&Mat3A)) -> self,

        ///Creates a quaternion from a 3x3 rotation matrix inside a homogeneous 4x4 matrix.
        from_mat4(Wrapped(&Mat4)) -> self,

        ///Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the
        ///plane spanned by the two vectors.  Will rotate at most 180 degrees.
        ///
        ///The input vectors must be normalized (unit-length).
        ///
        ///`from_rotation_arc(from, to) * from ≈ to`.
        ///
        ///For near-singular cases (from≈to and from≈-to) the current implementation
        ///is only accurate to about 0.001 (for `f32`).
        ///
        ///# Panics
        ///
        ///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
        from_rotation_arc(Wrapped(Vec3),Wrapped(Vec3)) -> self,

        ///Gets the minimal rotation for transforming `from` to either `to` or `-to`.  This means
        ///that the resulting quaternion will rotate `from` so that it is colinear with `to`.
        ///
        ///The rotation is in the plane spanned by the two vectors.  Will rotate at most 90
        ///degrees.
        ///
        ///The input vectors must be normalized (unit-length).
        ///
        ///`to.dot(from_rotation_arc_colinear(from, to) * from).abs() ≈ 1`.
        ///
        ///# Panics
        ///
        ///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
        from_rotation_arc_colinear(Wrapped(Vec3),Wrapped(Vec3)) -> self,

        ///Gets the minimal rotation for transforming `from` to `to`.  The resulting rotation is
        ///around the z axis. Will rotate at most 180 degrees.
        ///
        ///The input vectors must be normalized (unit-length).
        ///
        ///`from_rotation_arc_2d(from, to) * from ≈ to`.
        ///
        ///For near-singular cases (from≈to and from≈-to) the current implementation
        ///is only accurate to about 0.001 (for `f32`).
        ///
        ///# Panics
        ///
        ///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
        from_rotation_arc_2d(Wrapped(Vec2),Wrapped(Vec2)) -> self,

        ///Returns the rotation axis scaled by the rotation in radians.
        to_scaled_axis(self:) -> Wrapped(Vec3),

        ///Returns the vector part of the quaternion.
        xyz(self:) -> Wrapped(Vec3),

        ///Returns the quaternion conjugate of `self`. For a unit quaternion the
        ///conjugate is also the inverse.
        conjugate(self:) -> self,

        ///Returns the inverse of a normalized quaternion.
        ///
        ///Typically quaternion inverse returns the conjugate of a normalized quaternion.
        ///Because `self` is assumed to already be unit length this method *does not* normalize
        ///before returning the conjugate.
        ///
        ///# Panics
        ///
        ///Will panic if `self` is not normalized when `glam_assert` is enabled.
        inverse(self:) -> self,

        ///Computes the dot product of `self` and `rhs`. The dot product is
        ///equal to the cosine of the angle between two quaternion rotations.
        dot(self:self) -> Raw(f32),

        ///Computes the length of `self`.
        length(self:) -> Raw(f32),

        ///Computes the squared length of `self`.
        ///
        ///This is generally faster than `length()` as it avoids a square
        ///root operation.
        length_squared(self:) -> Raw(f32),

        ///Computes `1.0 / length()`.
        ///
        ///For valid results, `self` must _not_ be of length zero.
        length_recip(self:) -> Raw(f32),

        ///Returns `self` normalized to length 1.0.
        ///
        ///For valid results, `self` must _not_ be of length zero.
        ///
        ///Panics
        ///
        ///Will panic if `self` is zero length when `glam_assert` is enabled.
        normalize(self:) -> self,

        ///Returns `true` if, and only if, all elements are finite.
        ///If any element is either `NaN`, positive or negative infinity, this will return `false`.
        is_finite(self:) -> Raw(bool),

        is_nan(self:) -> Raw(bool),

        ///Returns whether `self` of length `1.0` or not.
        ///
        ///Uses a precision threshold of `1e-6`.
        is_normalized(self:) -> Raw(bool),

        is_near_identity(self:) -> Raw(bool),

        ///Returns the angle (in radians) for the minimal rotation
        ///for transforming this quaternion into another.
        ///
        ///Both quaternions must be normalized.
        ///
        ///# Panics
        ///
        ///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
        angle_between(self:self) -> Raw(f32),

        ///Returns true if the absolute difference of all elements between `self` and `rhs`
        ///is less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two quaternions contain similar elements. It works
        ///best when comparing with a known value. The `max_abs_diff` that should be used used
        ///depends on the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(self:self,Raw(f32)) -> Raw(bool),

        ///Performs a linear interpolation between `self` and `rhs` based on
        ///the value `s`.
        ///
        ///When `s` is `0.0`, the result will be equal to `self`.  When `s`
        ///is `1.0`, the result will be equal to `rhs`.
        ///
        ///# Panics
        ///
        ///Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
        lerp(self:self,Raw(f32)) -> self,

        ///Performs a spherical linear interpolation between `self` and `end`
        ///based on the value `s`.
        ///
        ///When `s` is `0.0`, the result will be equal to `self`.  When `s`
        ///is `1.0`, the result will be equal to `end`.
        ///
        ///# Panics
        ///
        ///Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
        slerp(self:self,Raw(f32)) -> self,

        ///Multiplies a quaternion and a 3D vector, returning the rotated vector.
        ///
        ///# Panics
        ///
        ///Will panic if `self` is not normalized when `glam_assert` is enabled.
        mul_vec3(self:Wrapped(Vec3)) -> Wrapped(Vec3),

        ///Multiplies two quaternions. If they each represent a rotation, the result will
        ///represent the combined rotation.
        ///
        ///Note that due to floating point rounding the result may not be perfectly normalized.
        ///
        ///# Panics
        ///
        ///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
        mul_quat(self:self) -> self,

        ///Creates a quaternion from a 3x3 rotation matrix inside a 3D affine transform.
        from_affine3(Wrapped(&Affine3A)) -> self,

        ///Multiplies a quaternion and a 3D vector, returning the rotated vector.
        mul_vec3a(self:Wrapped(Vec3A)) -> Wrapped(Vec3A),

        as_f64(self:) -> Wrapped(DQuat),

    )
    + Fields
    (
    )
    + BinOps
    (
        self Add self -> Wrapped(Quat),
        self Sub self -> Wrapped(Quat),
        self Div Raw(f32) -> Wrapped(Quat),
        self Mul Raw(f32) -> Wrapped(Quat),
        self Mul self -> Wrapped(Quat),
        self Mul Wrapped(Vec3) -> Wrapped(Vec3),
        self Mul Wrapped(Vec3A) -> Wrapped(Vec3A),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A quaternion representing an orientation.
    ///
    ///This quaternion is intended to be of unit length but may denormalize due to
    ///floating point "error creep" which can occur when successive quaternion
    ///operations are applied.
    glam::f64::DQuat :
    Clone +
    Debug +
    Methods
    (
        ///Creates a new rotation quaternion.
        ///
        ///This should generally not be called manually unless you know what you are doing.
        ///Use one of the other constructors instead such as `identity` or `from_axis_angle`.
        ///
        ///`from_xyzw` is mostly used by unit tests and `serde` deserialization.
        ///
        ///# Preconditions
        ///
        ///This function does not check if the input is normalized, it is up to the user to
        ///provide normalized input or to normalized the resulting quaternion.
        from_xyzw(Raw(f64),Raw(f64),Raw(f64),Raw(f64)) -> self,

        ///Creates a new rotation quaternion from a 4D vector.
        ///
        ///# Preconditions
        ///
        ///This function does not check if the input is normalized, it is up to the user to
        ///provide normalized input or to normalized the resulting quaternion.
        from_vec4(Wrapped(DVec4)) -> self,

        ///Create a quaternion for a normalized rotation `axis` and `angle` (in radians).
        ///The axis must be normalized (unit-length).
        ///
        ///# Panics
        ///
        ///Will panic if `axis` is not normalized when `glam_assert` is enabled.
        from_axis_angle(Wrapped(DVec3),Raw(f64)) -> self,

        ///Create a quaternion that rotates `v.length()` radians around `v.normalize()`.
        ///
        ///`from_scaled_axis(Vec3::ZERO)` results in the identity quaternion.
        from_scaled_axis(Wrapped(DVec3)) -> self,

        ///Creates a quaternion from the `angle` (in radians) around the x axis.
        from_rotation_x(Raw(f64)) -> self,

        ///Creates a quaternion from the `angle` (in radians) around the y axis.
        from_rotation_y(Raw(f64)) -> self,

        ///Creates a quaternion from the `angle` (in radians) around the z axis.
        from_rotation_z(Raw(f64)) -> self,

        ///Creates a quaternion from the given Euler rotation sequence and the angles (in radians).
        from_euler(Wrapped(EulerRot),Raw(f64),Raw(f64),Raw(f64)) -> self,

        ///Creates a quaternion from a 3x3 rotation matrix.
        from_mat3(Wrapped(&DMat3)) -> self,

        ///Creates a quaternion from a 3x3 rotation matrix inside a homogeneous 4x4 matrix.
        from_mat4(Wrapped(&DMat4)) -> self,

        ///Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the
        ///plane spanned by the two vectors.  Will rotate at most 180 degrees.
        ///
        ///The input vectors must be normalized (unit-length).
        ///
        ///`from_rotation_arc(from, to) * from ≈ to`.
        ///
        ///For near-singular cases (from≈to and from≈-to) the current implementation
        ///is only accurate to about 0.001 (for `f32`).
        ///
        ///# Panics
        ///
        ///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
        from_rotation_arc(Wrapped(DVec3),Wrapped(DVec3)) -> self,

        ///Gets the minimal rotation for transforming `from` to either `to` or `-to`.  This means
        ///that the resulting quaternion will rotate `from` so that it is colinear with `to`.
        ///
        ///The rotation is in the plane spanned by the two vectors.  Will rotate at most 90
        ///degrees.
        ///
        ///The input vectors must be normalized (unit-length).
        ///
        ///`to.dot(from_rotation_arc_colinear(from, to) * from).abs() ≈ 1`.
        ///
        ///# Panics
        ///
        ///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
        from_rotation_arc_colinear(Wrapped(DVec3),Wrapped(DVec3)) -> self,

        ///Gets the minimal rotation for transforming `from` to `to`.  The resulting rotation is
        ///around the z axis. Will rotate at most 180 degrees.
        ///
        ///The input vectors must be normalized (unit-length).
        ///
        ///`from_rotation_arc_2d(from, to) * from ≈ to`.
        ///
        ///For near-singular cases (from≈to and from≈-to) the current implementation
        ///is only accurate to about 0.001 (for `f32`).
        ///
        ///# Panics
        ///
        ///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
        from_rotation_arc_2d(Wrapped(DVec2),Wrapped(DVec2)) -> self,

        ///Returns the rotation axis scaled by the rotation in radians.
        to_scaled_axis(self:) -> Wrapped(DVec3),

        ///Returns the vector part of the quaternion.
        xyz(self:) -> Wrapped(DVec3),

        ///Returns the quaternion conjugate of `self`. For a unit quaternion the
        ///conjugate is also the inverse.
        conjugate(self:) -> self,

        ///Returns the inverse of a normalized quaternion.
        ///
        ///Typically quaternion inverse returns the conjugate of a normalized quaternion.
        ///Because `self` is assumed to already be unit length this method *does not* normalize
        ///before returning the conjugate.
        ///
        ///# Panics
        ///
        ///Will panic if `self` is not normalized when `glam_assert` is enabled.
        inverse(self:) -> self,

        ///Computes the dot product of `self` and `rhs`. The dot product is
        ///equal to the cosine of the angle between two quaternion rotations.
        dot(self:self) -> Raw(f64),

        ///Computes the length of `self`.
        length(self:) -> Raw(f64),

        ///Computes the squared length of `self`.
        ///
        ///This is generally faster than `length()` as it avoids a square
        ///root operation.
        length_squared(self:) -> Raw(f64),

        ///Computes `1.0 / length()`.
        ///
        ///For valid results, `self` must _not_ be of length zero.
        length_recip(self:) -> Raw(f64),

        ///Returns `self` normalized to length 1.0.
        ///
        ///For valid results, `self` must _not_ be of length zero.
        ///
        ///Panics
        ///
        ///Will panic if `self` is zero length when `glam_assert` is enabled.
        normalize(self:) -> self,

        ///Returns `true` if, and only if, all elements are finite.
        ///If any element is either `NaN`, positive or negative infinity, this will return `false`.
        is_finite(self:) -> Raw(bool),

        is_nan(self:) -> Raw(bool),

        ///Returns whether `self` of length `1.0` or not.
        ///
        ///Uses a precision threshold of `1e-6`.
        is_normalized(self:) -> Raw(bool),

        is_near_identity(self:) -> Raw(bool),

        ///Returns the angle (in radians) for the minimal rotation
        ///for transforming this quaternion into another.
        ///
        ///Both quaternions must be normalized.
        ///
        ///# Panics
        ///
        ///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
        angle_between(self:self) -> Raw(f64),

        ///Returns true if the absolute difference of all elements between `self` and `rhs`
        ///is less than or equal to `max_abs_diff`.
        ///
        ///This can be used to compare if two quaternions contain similar elements. It works
        ///best when comparing with a known value. The `max_abs_diff` that should be used used
        ///depends on the values being compared against.
        ///
        ///For more see
        ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
        abs_diff_eq(self:self,Raw(f64)) -> Raw(bool),

        ///Performs a linear interpolation between `self` and `rhs` based on
        ///the value `s`.
        ///
        ///When `s` is `0.0`, the result will be equal to `self`.  When `s`
        ///is `1.0`, the result will be equal to `rhs`.
        ///
        ///# Panics
        ///
        ///Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
        lerp(self:self,Raw(f64)) -> self,

        ///Performs a spherical linear interpolation between `self` and `end`
        ///based on the value `s`.
        ///
        ///When `s` is `0.0`, the result will be equal to `self`.  When `s`
        ///is `1.0`, the result will be equal to `end`.
        ///
        ///# Panics
        ///
        ///Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
        slerp(self:self,Raw(f64)) -> self,

        ///Multiplies a quaternion and a 3D vector, returning the rotated vector.
        ///
        ///# Panics
        ///
        ///Will panic if `self` is not normalized when `glam_assert` is enabled.
        mul_vec3(self:Wrapped(DVec3)) -> Wrapped(DVec3),

        ///Multiplies two quaternions. If they each represent a rotation, the result will
        ///represent the combined rotation.
        ///
        ///Note that due to floating point rounding the result may not be perfectly normalized.
        ///
        ///# Panics
        ///
        ///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
        mul_quat(self:self) -> self,

        ///Creates a quaternion from a 3x3 rotation matrix inside a 3D affine transform.
        from_affine3(Wrapped(&DAffine3)) -> self,

        as_f32(self:) -> Wrapped(Quat),

    )
    + Fields
    (
        x: Raw(f64),
        y: Raw(f64),
        z: Raw(f64),
        w: Raw(f64),
    )
    + BinOps
    (
        self Add self -> Wrapped(DQuat),
        self Sub self -> Wrapped(DQuat),
        self Div Raw(f64) -> Wrapped(DQuat),
        self Mul Raw(f64) -> Wrapped(DQuat),
        self Mul self -> Wrapped(DQuat),
        self Mul Wrapped(DVec3) -> Wrapped(DVec3),
    )
    + UnaryOps
    (
        Neg self -> self
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///Euler rotation sequences.
    ///
    ///The angles are applied starting from the right.
    ///E.g. XYZ will first apply the z-axis rotation.
    ///
    ///YXZ can be used for yaw (y-axis), pitch (x-axis), roll (z-axis).
    glam::EulerRot :
    Clone +
    Debug +
    Methods
    (
    )
    + Fields
    (
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
impl_script_newtype! {
    #[languages(on_feature(lua))]
    ///A rectangle defined by two opposite corners.
    ///
    ///The rectangle is axis aligned, and defined by its minimum and maximum coordinates,
    ///stored in `Rect::min` and `Rect::max`, respectively. The minimum/maximum invariant
    ///must be upheld by the user when directly assigning the fields, otherwise some methods
    ///produce invalid results. It is generally recommended to use one of the constructor
    ///methods instead, which will ensure this invariant is met, unless you already have
    ///the minimum and maximum corners.
    bevy_math::Rect :
    Clone +
    Debug +
    Methods
    (
        ///Create a new rectangle from two corner points.
        ///
        ///The two points do not need to be the minimum and/or maximum corners.
        ///They only need to be two opposite corners.
        ///
        ///# Examples
        ///
        ///```rust
        ///# use bevy_math::Rect;
        ///let r = Rect::new(0., 4., 10., 6.); // w=10 h=2
        ///let r = Rect::new(2., 3., 5., -1.); // w=3 h=4
        ///```
        new(Raw(f32),Raw(f32),Raw(f32),Raw(f32)) -> self,

        ///Create a new rectangle from two corner points.
        ///
        ///The two points do not need to be the minimum and/or maximum corners.
        ///They only need to be two opposite corners.
        ///
        ///# Examples
        ///
        ///```rust
        ///# use bevy_math::{Rect, Vec2};
        ///// Unit rect from [0,0] to [1,1]
        ///let r = Rect::from_corners(Vec2::ZERO, Vec2::ONE); // w=1 h=1
        ///// Same; the points do not need to be ordered
        ///let r = Rect::from_corners(Vec2::ONE, Vec2::ZERO); // w=1 h=1
        ///```
        from_corners(Wrapped(Vec2),Wrapped(Vec2)) -> self,

        ///Create a new rectangle from its center and size.
        ///
        ///# Panics
        ///
        ///This method panics if any of the components of the size is negative.
        ///
        ///# Examples
        ///
        ///```rust
        ///# use bevy_math::{Rect, Vec2};
        ///let r = Rect::from_center_size(Vec2::ZERO, Vec2::ONE); // w=1 h=1
        ///assert!(r.min.abs_diff_eq(Vec2::splat(-0.5), 1e-5));
        ///assert!(r.max.abs_diff_eq(Vec2::splat(0.5), 1e-5));
        ///```
        from_center_size(Wrapped(Vec2),Wrapped(Vec2)) -> self,

        ///Create a new rectangle from its center and half-size.
        ///
        ///# Panics
        ///
        ///This method panics if any of the components of the half-size is negative.
        ///
        ///# Examples
        ///
        ///```rust
        ///# use bevy_math::{Rect, Vec2};
        ///let r = Rect::from_center_half_size(Vec2::ZERO, Vec2::ONE); // w=2 h=2
        ///assert!(r.min.abs_diff_eq(Vec2::splat(-1.), 1e-5));
        ///assert!(r.max.abs_diff_eq(Vec2::splat(1.), 1e-5));
        ///```
        from_center_half_size(Wrapped(Vec2),Wrapped(Vec2)) -> self,

        ///Check if the rectangle is empty.
        ///
        ///# Examples
        ///
        ///```rust
        ///# use bevy_math::{Rect, Vec2};
        ///let r = Rect::from_corners(Vec2::ZERO, Vec2::new(0., 1.)); // w=0 h=1
        ///assert!(r.is_empty());
        ///```
        is_empty(&self:) -> Raw(bool),

        ///Rectangle width (max.x - min.x).
        ///
        ///# Examples
        ///
        ///```rust
        ///# use bevy_math::Rect;
        ///let r = Rect::new(0., 0., 5., 1.); // w=5 h=1
        ///assert!((r.width() - 5.).abs() <= 1e-5);
        ///```
        width(&self:) -> Raw(f32),

        ///Rectangle height (max.y - min.y).
        ///
        ///# Examples
        ///
        ///```rust
        ///# use bevy_math::Rect;
        ///let r = Rect::new(0., 0., 5., 1.); // w=5 h=1
        ///assert!((r.height() - 1.).abs() <= 1e-5);
        ///```
        height(&self:) -> Raw(f32),

        ///Rectangle size.
        ///
        ///# Examples
        ///
        ///```rust
        ///# use bevy_math::{Rect, Vec2};
        ///let r = Rect::new(0., 0., 5., 1.); // w=5 h=1
        ///assert!(r.size().abs_diff_eq(Vec2::new(5., 1.), 1e-5));
        ///```
        size(&self:) -> Wrapped(Vec2),

        ///Rectangle half-size.
        ///
        ///# Examples
        ///
        ///```rust
        ///# use bevy_math::{Rect, Vec2};
        ///let r = Rect::new(0., 0., 5., 1.); // w=5 h=1
        ///assert!(r.half_size().abs_diff_eq(Vec2::new(2.5, 0.5), 1e-5));
        ///```
        half_size(&self:) -> Wrapped(Vec2),

        ///The center point of the rectangle.
        ///
        ///# Examples
        ///
        ///```rust
        ///# use bevy_math::{Rect, Vec2};
        ///let r = Rect::new(0., 0., 5., 1.); // w=5 h=1
        ///assert!(r.center().abs_diff_eq(Vec2::new(2.5, 0.5), 1e-5));
        ///```
        center(&self:) -> Wrapped(Vec2),

        ///Check if a point lies within this rectangle, inclusive of its edges.
        ///
        ///# Examples
        ///
        ///```rust
        ///# use bevy_math::Rect;
        ///let r = Rect::new(0., 0., 5., 1.); // w=5 h=1
        ///assert!(r.contains(r.center()));
        ///assert!(r.contains(r.min));
        ///assert!(r.contains(r.max));
        ///```
        contains(&self:Wrapped(Vec2)) -> Raw(bool),

        ///Build a new rectangle formed of the union of this rectangle and another rectangle.
        ///
        ///The union is the smallest rectangle enclosing both rectangles.
        ///
        ///# Examples
        ///
        ///```rust
        ///# use bevy_math::{Rect, Vec2};
        ///let r1 = Rect::new(0., 0., 5., 1.); // w=5 h=1
        ///let r2 = Rect::new(1., -1., 3., 3.); // w=2 h=4
        ///let r = r1.union(r2);
        ///assert!(r.min.abs_diff_eq(Vec2::new(0., -1.), 1e-5));
        ///assert!(r.max.abs_diff_eq(Vec2::new(5., 3.), 1e-5));
        ///```
        union(&self:Wrapped(Rect)) -> Wrapped(Rect),

        ///Build a new rectangle formed of the union of this rectangle and a point.
        ///
        ///The union is the smallest rectangle enclosing both the rectangle and the point. If the
        ///point is already inside the rectangle, this method returns a copy of the rectangle.
        ///
        ///# Examples
        ///
        ///```rust
        ///# use bevy_math::{Rect, Vec2};
        ///let r = Rect::new(0., 0., 5., 1.); // w=5 h=1
        ///let u = r.union_point(Vec2::new(3., 6.));
        ///assert!(u.min.abs_diff_eq(Vec2::ZERO, 1e-5));
        ///assert!(u.max.abs_diff_eq(Vec2::new(5., 6.), 1e-5));
        ///```
        union_point(&self:Wrapped(Vec2)) -> Wrapped(Rect),

        ///Build a new rectangle formed of the intersection of this rectangle and another rectangle.
        ///
        ///The intersection is the largest rectangle enclosed in both rectangles. If the intersection
        ///is empty, this method returns an empty rectangle ([`Rect::is_empty()`] returns `true`), but
        ///the actual values of [`Rect::min`] and [`Rect::max`] are implementation-dependent.
        ///
        ///# Examples
        ///
        ///```rust
        ///# use bevy_math::{Rect, Vec2};
        ///let r1 = Rect::new(0., 0., 5., 1.); // w=5 h=1
        ///let r2 = Rect::new(1., -1., 3., 3.); // w=2 h=4
        ///let r = r1.intersect(r2);
        ///assert!(r.min.abs_diff_eq(Vec2::new(1., 0.), 1e-5));
        ///assert!(r.max.abs_diff_eq(Vec2::new(3., 1.), 1e-5));
        ///```
        intersect(&self:Wrapped(Rect)) -> Wrapped(Rect),

        ///Create a new rectangle with a constant inset.
        ///
        ///The inset is the extra border on all sides. A positive inset produces a larger rectangle,
        ///while a negative inset is allowed and produces a smaller rectangle. If the inset is negative
        ///and its absolute value is larger than the rectangle half-size, the created rectangle is empty.
        ///
        ///# Examples
        ///
        ///```rust
        ///# use bevy_math::{Rect, Vec2};
        ///let r = Rect::new(0., 0., 5., 1.); // w=5 h=1
        ///let r2 = r.inset(3.); // w=11 h=7
        ///assert!(r2.min.abs_diff_eq(Vec2::splat(-3.), 1e-5));
        ///assert!(r2.max.abs_diff_eq(Vec2::new(8., 4.), 1e-5));
        ///```
        inset(&self:Raw(f32)) -> Wrapped(Rect),

    )
    + Fields
    (
        /// The minimum corner point of the rect.
        min: Wrapped(Vec2),
        /// The maximum corner point of the rect.
        max: Wrapped(Vec2),
    )
    + BinOps
    (
    )
    + UnaryOps
    (
    )
    lua impl
    {
    }
}
#[cfg(feature = "lua")]
crate::impl_tealr_generic!(pub(crate) struct T);
#[cfg(feature = "lua")]
#[derive(Default)]
pub(crate) struct BevyAPIGlobals;
#[cfg(feature = "lua")]
impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for BevyAPIGlobals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
        instances.add_instance(
            "Name",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaName>::new,
        )?;
        instances.add_instance(
            "Text",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaText>::new,
        )?;
        instances.add_instance(
            "TextSection",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaTextSection>::new,
        )?;
        instances.add_instance(
            "Stopwatch",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaStopwatch>::new,
        )?;
        instances.add_instance(
            "Timer",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaTimer>::new,
        )?;
        instances.add_instance(
            "Entity",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaEntity>::new,
        )?;
        instances.add_instance(
            "Transform",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaTransform>::new,
        )?;
        instances.add_instance(
            "TextureAtlasSprite",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaTextureAtlasSprite>::new,
        )?;
        instances.add_instance(
            "RenderLayers",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaRenderLayers>::new,
        )?;
        instances.add_instance(
            "Color",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaColor>::new,
        )?;
        instances.add_instance(
            "Aabb",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaAabb>::new,
        )?;
        instances.add_instance(
            "Frustum",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaFrustum>::new,
        )?;
        instances.add_instance(
            "CameraRenderGraph",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaCameraRenderGraph>::new,
        )?;
        instances.add_instance(
            "HandleId",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaHandleId>::new,
        )?;
        instances.add_instance(
            "Vec2",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaVec2>::new,
        )?;
        instances.add_instance(
            "Vec3",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaVec3>::new,
        )?;
        instances.add_instance(
            "Vec3A",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaVec3A>::new,
        )?;
        instances.add_instance(
            "Vec4",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaVec4>::new,
        )?;
        instances.add_instance(
            "BVec2",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaBVec2>::new,
        )?;
        instances.add_instance(
            "BVec3",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaBVec3>::new,
        )?;
        instances.add_instance(
            "BVec4",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaBVec4>::new,
        )?;
        instances.add_instance(
            "BVec3A",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaBVec3A>::new,
        )?;
        instances.add_instance(
            "BVec4A",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaBVec4A>::new,
        )?;
        instances.add_instance(
            "DVec2",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaDVec2>::new,
        )?;
        instances.add_instance(
            "DVec3",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaDVec3>::new,
        )?;
        instances.add_instance(
            "DVec4",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaDVec4>::new,
        )?;
        instances.add_instance(
            "IVec2",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaIVec2>::new,
        )?;
        instances.add_instance(
            "IVec3",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaIVec3>::new,
        )?;
        instances.add_instance(
            "IVec4",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaIVec4>::new,
        )?;
        instances.add_instance(
            "UVec2",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaUVec2>::new,
        )?;
        instances.add_instance(
            "UVec3",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaUVec3>::new,
        )?;
        instances.add_instance(
            "UVec4",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaUVec4>::new,
        )?;
        instances.add_instance(
            "Mat3",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaMat3>::new,
        )?;
        instances.add_instance(
            "Mat2",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaMat2>::new,
        )?;
        instances.add_instance(
            "Mat3A",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaMat3A>::new,
        )?;
        instances.add_instance(
            "Mat4",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaMat4>::new,
        )?;
        instances.add_instance(
            "DMat2",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaDMat2>::new,
        )?;
        instances.add_instance(
            "DMat3",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaDMat3>::new,
        )?;
        instances.add_instance(
            "DMat4",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaDMat4>::new,
        )?;
        instances.add_instance(
            "Affine2",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaAffine2>::new,
        )?;
        instances.add_instance(
            "Affine3A",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaAffine3A>::new,
        )?;
        instances.add_instance(
            "DAffine2",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaDAffine2>::new,
        )?;
        instances.add_instance(
            "DAffine3",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaDAffine3>::new,
        )?;
        instances.add_instance(
            "Quat",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaQuat>::new,
        )?;
        instances.add_instance(
            "DQuat",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaDQuat>::new,
        )?;
        instances.add_instance(
            "Rect",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaRect>::new,
        )?;
        instances.add_instance(
            "world",
            crate::lua::util::DummyTypeName::<crate::lua::bevy::LuaWorld>::new,
        )?;
        instances.add_instance(
            "script",
            crate::lua::util::DummyTypeName::<crate::lua::bevy::LuaScriptData>::new,
        )?;
        instances.add_instance(
            "entity",
            crate::lua::util::DummyTypeName::<crate::lua::bevy::LuaEntity>::new,
        )?;
        Ok(())
    }
}
#[cfg(feature = "lua")]
pub struct LuaBevyAPIProvider;
#[cfg(feature = "lua")]
impl APIProvider for LuaBevyAPIProvider {
    type APITarget = Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
    type ScriptContext = Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
    type DocTarget = LuaDocFragment;
    fn attach_api(&mut self, ctx: &mut Self::APITarget) -> Result<(), ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(BevyAPIGlobals, ctx)
            .map_err(|e| ScriptError::Other(e.to_string()))
    }
    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(LuaDocFragment::new(|tw| {
            tw
			.document_global_instance::<BevyAPIGlobals>().expect("Something went wrong documenting globals")
			.process_type::<LuaAlignContent>()
			.process_type::<LuaAlignItems>()
			.process_type::<LuaAlignSelf>()
			.process_type::<LuaDirection>()
			.process_type::<LuaFlexDirection>()
			.process_type::<LuaFlexWrap>()
			.process_type::<LuaFocusPolicy>()
			.process_type::<LuaInteraction>()
			.process_type::<LuaJustifyContent>()
			.process_type::<LuaOverflow>()
			.process_type::<LuaPositionType>()
			.process_type::<LuaVal>()
			.process_type::<LuaCalculatedClip>()
			.process_type::<LuaCalculatedSize>()
			.process_type::<LuaNode>()
			.process_type::<LuaStyle>()
			.process_type::<LuaUiImage>()
			.process_type::<LuaButton>()
			.process_type::<LuaImageMode>()
			.process_type::<LuaDisplay>()
			.process_type::<LuaAnimationPlayer>()
			.process_type::<LuaName>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaName>>()
			.process_type::<LuaGltfExtras>()
			.process_type::<LuaChildren>()
			.process_type::<LuaParent>()
			.process_type::<LuaText2dBounds>()
			.process_type::<LuaText2dSize>()
			.process_type::<LuaText>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaText>>()
			.process_type::<LuaTextAlignment>()
			.process_type::<LuaTextSection>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaTextSection>>()
			.process_type::<LuaTextStyle>()
			.process_type::<LuaHorizontalAlign>()
			.process_type::<LuaVerticalAlign>()
			.process_type::<LuaStopwatch>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaStopwatch>>()
			.process_type::<LuaTimer>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaTimer>>()
			.process_type::<LuaEntity>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaEntity>>()
			.process_type::<LuaTransform>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaTransform>>()
			.process_type::<LuaGlobalTransform>()
			.process_type::<LuaAmbientLight>()
			.process_type::<LuaCubemapVisibleEntities>()
			.process_type::<LuaDirectionalLight>()
			.process_type::<LuaDirectionalLightShadowMap>()
			.process_type::<LuaNotShadowCaster>()
			.process_type::<LuaNotShadowReceiver>()
			.process_type::<LuaPointLight>()
			.process_type::<LuaPointLightShadowMap>()
			.process_type::<LuaAlphaMode>()
			.process_type::<LuaWireframe>()
			.process_type::<LuaWireframeConfig>()
			.process_type::<LuaCamera3dDepthLoadOp>()
			.process_type::<LuaClearColor>()
			.process_type::<LuaClearColorConfig>()
			.process_type::<LuaCamera2d>()
			.process_type::<LuaCamera3d>()
			.process_type::<LuaAnchor>()
			.process_type::<LuaMesh2dHandle>()
			.process_type::<LuaTextureAtlasSprite>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaTextureAtlasSprite>>()
			.process_type::<LuaSprite>()
			.process_type::<LuaRenderLayers>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaRenderLayers>>()
			.process_type::<LuaVisibility>()
			.process_type::<LuaVisibleEntities>()
			.process_type::<LuaComputedVisibility>()
			.process_type::<LuaSkinnedMesh>()
			.process_type::<LuaScalingMode>()
			.process_type::<LuaWindowOrigin>()
			.process_type::<LuaColor>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaColor>>()
			.process_type::<LuaAabb>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaAabb>>()
			.process_type::<LuaCubemapFrusta>()
			.process_type::<LuaFrustum>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaFrustum>>()
			.process_type::<LuaMsaa>()
			.process_type::<LuaCamera>()
			.process_type::<LuaRenderTarget>()
			.process_type::<LuaViewport>()
			.process_type::<LuaProjection>()
			.process_type::<LuaOrthographicProjection>()
			.process_type::<LuaPerspectiveProjection>()
			.process_type::<LuaCameraRenderGraph>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaCameraRenderGraph>>()
			.process_type::<LuaAssetPathId>()
			.process_type::<LuaLabelId>()
			.process_type::<LuaSourcePathId>()
			.process_type::<LuaHandleId>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaHandleId>>()
			.process_type::<LuaVec2>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaVec2>>()
			.process_type::<LuaVec3>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaVec3>>()
			.process_type::<LuaVec3A>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaVec3A>>()
			.process_type::<LuaVec4>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaVec4>>()
			.process_type::<LuaBVec2>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaBVec2>>()
			.process_type::<LuaBVec3>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaBVec3>>()
			.process_type::<LuaBVec4>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaBVec4>>()
			.process_type::<LuaBVec3A>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaBVec3A>>()
			.process_type::<LuaBVec4A>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaBVec4A>>()
			.process_type::<LuaDVec2>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaDVec2>>()
			.process_type::<LuaDVec3>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaDVec3>>()
			.process_type::<LuaDVec4>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaDVec4>>()
			.process_type::<LuaIVec2>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaIVec2>>()
			.process_type::<LuaIVec3>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaIVec3>>()
			.process_type::<LuaIVec4>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaIVec4>>()
			.process_type::<LuaUVec2>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaUVec2>>()
			.process_type::<LuaUVec3>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaUVec3>>()
			.process_type::<LuaUVec4>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaUVec4>>()
			.process_type::<LuaMat3>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaMat3>>()
			.process_type::<LuaMat2>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaMat2>>()
			.process_type::<LuaMat3A>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaMat3A>>()
			.process_type::<LuaMat4>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaMat4>>()
			.process_type::<LuaDMat2>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaDMat2>>()
			.process_type::<LuaDMat3>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaDMat3>>()
			.process_type::<LuaDMat4>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaDMat4>>()
			.process_type::<LuaAffine2>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaAffine2>>()
			.process_type::<LuaAffine3A>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaAffine3A>>()
			.process_type::<LuaDAffine2>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaDAffine2>>()
			.process_type::<LuaDAffine3>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaDAffine3>>()
			.process_type::<LuaQuat>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaQuat>>()
			.process_type::<LuaDQuat>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaDQuat>>()
			.process_type::<LuaEulerRot>()
			.process_type::<LuaRect>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaRect>>()
			.process_type::<ReflectedValue>()
			.process_type::<crate::lua::bevy::LuaWorld>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<crate::lua::bevy::LuaWorld>>()
			.process_type::<crate::lua::bevy::LuaScriptData>()
			.process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<crate::lua::bevy::LuaScriptData>>()
			.process_type::<crate::lua::bevy::LuaTypeRegistration>()
			.process_type::<crate::lua::std::LuaVec<T>>()
        }))
    }
    fn setup_script(
        &mut self,
        script_data: &ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), ScriptError> {
        let ctx = ctx.get_mut().expect("Could not get context");
        let globals = ctx.globals();
        globals
            .set(
                "entity",
                crate::lua::bevy::LuaEntity::new(script_data.entity),
            )
            .map_err(ScriptError::new_other)?;
        globals
            .set::<_, crate::lua::bevy::LuaScriptData>("script", script_data.into())
            .map_err(ScriptError::new_other)?;

        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), ScriptError> {
        let ctx = ctx.get_mut().expect("Could not get context");
        let globals = ctx.globals();
        globals
            .set("world", crate::lua::bevy::LuaWorld::new(world_ptr))
            .map_err(ScriptError::new_other)
    }
    fn register_with_app(&self, app: &mut App) {
        app.register_foreign_lua_type::<AlignContent>();
        app.register_foreign_lua_type::<AlignItems>();
        app.register_foreign_lua_type::<AlignSelf>();
        app.register_foreign_lua_type::<Direction>();
        app.register_foreign_lua_type::<FlexDirection>();
        app.register_foreign_lua_type::<FlexWrap>();
        app.register_foreign_lua_type::<FocusPolicy>();
        app.register_foreign_lua_type::<Interaction>();
        app.register_foreign_lua_type::<JustifyContent>();
        app.register_foreign_lua_type::<Overflow>();
        app.register_foreign_lua_type::<PositionType>();
        app.register_foreign_lua_type::<Val>();
        app.register_foreign_lua_type::<CalculatedClip>();
        app.register_foreign_lua_type::<CalculatedSize>();
        app.register_foreign_lua_type::<Node>();
        app.register_foreign_lua_type::<Style>();
        app.register_foreign_lua_type::<UiImage>();
        app.register_foreign_lua_type::<Button>();
        app.register_foreign_lua_type::<ImageMode>();
        app.register_foreign_lua_type::<Display>();
        app.register_foreign_lua_type::<AnimationPlayer>();
        app.register_foreign_lua_type::<Name>();
        app.register_foreign_lua_type::<GltfExtras>();
        app.register_foreign_lua_type::<Children>();
        app.register_foreign_lua_type::<Parent>();
        app.register_foreign_lua_type::<Text2dBounds>();
        app.register_foreign_lua_type::<Text2dSize>();
        app.register_foreign_lua_type::<Text>();
        app.register_foreign_lua_type::<TextAlignment>();
        app.register_foreign_lua_type::<TextSection>();
        app.register_foreign_lua_type::<TextStyle>();
        app.register_foreign_lua_type::<HorizontalAlign>();
        app.register_foreign_lua_type::<VerticalAlign>();
        app.register_foreign_lua_type::<Stopwatch>();
        app.register_foreign_lua_type::<Timer>();
        app.register_foreign_lua_type::<Entity>();
        app.register_foreign_lua_type::<Transform>();
        app.register_foreign_lua_type::<GlobalTransform>();
        app.register_foreign_lua_type::<AmbientLight>();
        app.register_foreign_lua_type::<CubemapVisibleEntities>();
        app.register_foreign_lua_type::<DirectionalLight>();
        app.register_foreign_lua_type::<DirectionalLightShadowMap>();
        app.register_foreign_lua_type::<NotShadowCaster>();
        app.register_foreign_lua_type::<NotShadowReceiver>();
        app.register_foreign_lua_type::<PointLight>();
        app.register_foreign_lua_type::<PointLightShadowMap>();
        app.register_foreign_lua_type::<AlphaMode>();
        app.register_foreign_lua_type::<Wireframe>();
        app.register_foreign_lua_type::<WireframeConfig>();
        app.register_foreign_lua_type::<Camera3dDepthLoadOp>();
        app.register_foreign_lua_type::<ClearColor>();
        app.register_foreign_lua_type::<ClearColorConfig>();
        app.register_foreign_lua_type::<Camera2d>();
        app.register_foreign_lua_type::<Camera3d>();
        app.register_foreign_lua_type::<Anchor>();
        app.register_foreign_lua_type::<Mesh2dHandle>();
        app.register_foreign_lua_type::<TextureAtlasSprite>();
        app.register_foreign_lua_type::<Sprite>();
        app.register_foreign_lua_type::<RenderLayers>();
        app.register_foreign_lua_type::<Visibility>();
        app.register_foreign_lua_type::<VisibleEntities>();
        app.register_foreign_lua_type::<ComputedVisibility>();
        app.register_foreign_lua_type::<SkinnedMesh>();
        app.register_foreign_lua_type::<ScalingMode>();
        app.register_foreign_lua_type::<WindowOrigin>();
        app.register_foreign_lua_type::<Color>();
        app.register_foreign_lua_type::<Aabb>();
        app.register_foreign_lua_type::<CubemapFrusta>();
        app.register_foreign_lua_type::<Frustum>();
        app.register_foreign_lua_type::<Msaa>();
        app.register_foreign_lua_type::<Camera>();
        app.register_foreign_lua_type::<RenderTarget>();
        app.register_foreign_lua_type::<Viewport>();
        app.register_foreign_lua_type::<Projection>();
        app.register_foreign_lua_type::<OrthographicProjection>();
        app.register_foreign_lua_type::<PerspectiveProjection>();
        app.register_foreign_lua_type::<CameraRenderGraph>();
        app.register_foreign_lua_type::<AssetPathId>();
        app.register_foreign_lua_type::<LabelId>();
        app.register_foreign_lua_type::<SourcePathId>();
        app.register_foreign_lua_type::<HandleId>();
        app.register_foreign_lua_type::<Vec2>();
        app.register_foreign_lua_type::<Vec3>();
        app.register_foreign_lua_type::<Vec3A>();
        app.register_foreign_lua_type::<Vec4>();
        app.register_foreign_lua_type::<BVec2>();
        app.register_foreign_lua_type::<BVec3>();
        app.register_foreign_lua_type::<BVec4>();
        app.register_foreign_lua_type::<BVec3A>();
        app.register_foreign_lua_type::<BVec4A>();
        app.register_foreign_lua_type::<DVec2>();
        app.register_foreign_lua_type::<DVec3>();
        app.register_foreign_lua_type::<DVec4>();
        app.register_foreign_lua_type::<IVec2>();
        app.register_foreign_lua_type::<IVec3>();
        app.register_foreign_lua_type::<IVec4>();
        app.register_foreign_lua_type::<UVec2>();
        app.register_foreign_lua_type::<UVec3>();
        app.register_foreign_lua_type::<UVec4>();
        app.register_foreign_lua_type::<Mat3>();
        app.register_foreign_lua_type::<Mat2>();
        app.register_foreign_lua_type::<Mat3A>();
        app.register_foreign_lua_type::<Mat4>();
        app.register_foreign_lua_type::<DMat2>();
        app.register_foreign_lua_type::<DMat3>();
        app.register_foreign_lua_type::<DMat4>();
        app.register_foreign_lua_type::<Affine2>();
        app.register_foreign_lua_type::<Affine3A>();
        app.register_foreign_lua_type::<DAffine2>();
        app.register_foreign_lua_type::<DAffine3>();
        app.register_foreign_lua_type::<Quat>();
        app.register_foreign_lua_type::<DQuat>();
        app.register_foreign_lua_type::<EulerRot>();
        app.register_foreign_lua_type::<Rect>();
        app.register_foreign_lua_type::<i32>();
        app.register_foreign_lua_type::<u8>();
        app.register_foreign_lua_type::<isize>();
        app.register_foreign_lua_type::<u16>();
        app.register_foreign_lua_type::<usize>();
        app.register_foreign_lua_type::<i64>();
        app.register_foreign_lua_type::<i16>();
        app.register_foreign_lua_type::<u64>();
        app.register_foreign_lua_type::<bool>();
        app.register_foreign_lua_type::<f32>();
        app.register_foreign_lua_type::<u128>();
        app.register_foreign_lua_type::<i8>();
        app.register_foreign_lua_type::<u32>();
        app.register_foreign_lua_type::<i128>();
        app.register_foreign_lua_type::<String>();
        app.register_foreign_lua_type::<f64>();
    }
}
