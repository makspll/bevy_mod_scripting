// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use bevy_mod_scripting_core::{
    bindings::{
        ReflectReference, 
        function::{from::{Ref, Mut, Val}, namespace::{NamespaceBuilder}}
    }
};
use bevy_ecs::{prelude::*};


use bevy_mod_scripting_derive::script_bindings;


use crate::*;







pub struct BevyImageScriptingPlugin;


#[script_bindings(
    remote,
    name = "texture_atlas_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_image::prelude::TextureAtlas {


    
    fn assert_receiver_is_total_eq (_self:Ref<::bevy_image::prelude::TextureAtlas>,) -> () {
        let output: () =<::bevy_image::prelude::TextureAtlas as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_image::prelude::TextureAtlas>,) -> Val<::bevy_image::prelude::TextureAtlas> {
        let output: Val<::bevy_image::prelude::TextureAtlas> =<::bevy_image::prelude::TextureAtlas as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_image::prelude::TextureAtlas>,other:Ref<::bevy_image::prelude::TextureAtlas>,) -> bool {
        let output: bool =<::bevy_image::prelude::TextureAtlas as ::std::cmp::PartialEq::<::bevy_image::prelude::TextureAtlas>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "texture_atlas_layout_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_image::prelude::TextureAtlasLayout {


    
    ///  Add a *section* to the list in the layout and returns its index
    
    ///  which can be used with [`TextureAtlas`]
    
    ///  # Arguments
    
    ///  * `rect` - The section of the texture to be added
    
    ///  [`TextureAtlas`]: crate::TextureAtlas
    
    fn add_texture (mut _self:Mut<::bevy_image::prelude::TextureAtlasLayout>,rect:Val<::bevy_math::URect>,) -> usize {
        let output: usize =::bevy_image::prelude::TextureAtlasLayout::add_texture(&mut _self,rect.into_inner(),).into();
        output
    }


    
    fn assert_receiver_is_total_eq (_self:Ref<::bevy_image::prelude::TextureAtlasLayout>,) -> () {
        let output: () =<::bevy_image::prelude::TextureAtlasLayout as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_image::prelude::TextureAtlasLayout>,) -> Val<::bevy_image::prelude::TextureAtlasLayout> {
        let output: Val<::bevy_image::prelude::TextureAtlasLayout> =<::bevy_image::prelude::TextureAtlasLayout as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_image::prelude::TextureAtlasLayout>,other:Ref<::bevy_image::prelude::TextureAtlasLayout>,) -> bool {
        let output: bool =<::bevy_image::prelude::TextureAtlasLayout as ::std::cmp::PartialEq::<::bevy_image::prelude::TextureAtlasLayout>>::eq(&_self,&other,).into();
        output
    }


    
    fn is_empty (_self:Ref<::bevy_image::prelude::TextureAtlasLayout>,) -> bool {
        let output: bool =::bevy_image::prelude::TextureAtlasLayout::is_empty(&_self,).into();
        output
    }


    
    ///  The number of textures in the [`TextureAtlasLayout`]
    
    fn len (_self:Ref<::bevy_image::prelude::TextureAtlasLayout>,) -> usize {
        let output: usize =::bevy_image::prelude::TextureAtlasLayout::len(&_self,).into();
        output
    }


    
    ///  Create a new empty layout with custom `dimensions`
    
    fn new_empty (dimensions:Val<::bevy_math::UVec2>,) -> Val<::bevy_image::prelude::TextureAtlasLayout> {
        let output: Val<::bevy_image::prelude::TextureAtlasLayout> =::bevy_image::prelude::TextureAtlasLayout::new_empty(dimensions.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "image_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_image::prelude::Image {


    
    ///  Returns the aspect ratio (width / height) of a 2D image.
    
    fn aspect_ratio (_self:Ref<::bevy_image::prelude::Image>,) -> Val<::bevy_math::AspectRatio> {
        let output: Val<::bevy_math::AspectRatio> =::bevy_image::prelude::Image::aspect_ratio(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_image::prelude::Image>,) -> Val<::bevy_image::prelude::Image> {
        let output: Val<::bevy_image::prelude::Image> =<::bevy_image::prelude::Image as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new uninitialized 1x1x1 image
    
    fn default_uninit () -> Val<::bevy_image::prelude::Image> {
        let output: Val<::bevy_image::prelude::Image> =::bevy_image::prelude::Image::default_uninit().into();
        output
    }


    
    ///  Returns the height of a 2D image.
    
    fn height (_self:Ref<::bevy_image::prelude::Image>,) -> u32 {
        let output: u32 =::bevy_image::prelude::Image::height(&_self,).into();
        output
    }


    
    ///  Whether the texture format is compressed or uncompressed
    
    fn is_compressed (_self:Ref<::bevy_image::prelude::Image>,) -> bool {
        let output: bool =::bevy_image::prelude::Image::is_compressed(&_self,).into();
        output
    }


    
    ///  Compute the byte offset where the data of a specific pixel is stored
    
    ///  Returns None if the provided coordinates are out of bounds.
    
    ///  For 2D textures, Z is the layer number. For 1D textures, Y and Z are ignored.
    
    fn pixel_data_offset (_self:Ref<::bevy_image::prelude::Image>,coords:Val<::bevy_math::UVec3>,) -> ::std::option::Option<usize> {
        let output: ::std::option::Option<usize> =::bevy_image::prelude::Image::pixel_data_offset(&_self,coords.into_inner(),).into();
        output
    }


    
    ///  Takes a 2D image containing vertically stacked images of the same size, and reinterprets
    
    ///  it as a 2D array texture, where each of the stacked images becomes one layer of the
    
    ///  array. This is primarily for use with the `texture2DArray` shader uniform type.
    
    ///  # Panics
    
    ///  Panics if the texture is not 2D, has more than one layers or is not evenly dividable into
    
    ///  the `layers`.
    
    fn reinterpret_stacked_2d_as_array (mut _self:Mut<::bevy_image::prelude::Image>,layers:u32,) -> () {
        let output: () =::bevy_image::prelude::Image::reinterpret_stacked_2d_as_array(&mut _self,layers,).into();
        output
    }


    
    ///  Returns the size of a 2D image.
    
    fn size (_self:Ref<::bevy_image::prelude::Image>,) -> Val<::bevy_math::UVec2> {
        let output: Val<::bevy_math::UVec2> =::bevy_image::prelude::Image::size(&_self,).into();
        output
    }


    
    ///  Returns the size of a 2D image as f32.
    
    fn size_f32 (_self:Ref<::bevy_image::prelude::Image>,) -> Val<::bevy_math::Vec2> {
        let output: Val<::bevy_math::Vec2> =::bevy_image::prelude::Image::size_f32(&_self,).into();
        output
    }


    
    ///  A transparent white 1x1x1 image.
    
    ///  Contrast to [`Image::default`], which is opaque.
    
    fn transparent () -> Val<::bevy_image::prelude::Image> {
        let output: Val<::bevy_image::prelude::Image> =::bevy_image::prelude::Image::transparent().into();
        output
    }


    
    ///  Returns the width of a 2D image.
    
    fn width (_self:Ref<::bevy_image::prelude::Image>,) -> u32 {
        let output: u32 =::bevy_image::prelude::Image::width(&_self,).into();
        output
    }
     
}


impl Plugin for BevyImageScriptingPlugin {
    fn build(&self, app: &mut App) {
        let mut world = app.world_mut();

        
            register_texture_atlas_functions(&mut world);
        
            register_texture_atlas_layout_functions(&mut world);
        
            register_image_functions(&mut world);
        
    }
}
