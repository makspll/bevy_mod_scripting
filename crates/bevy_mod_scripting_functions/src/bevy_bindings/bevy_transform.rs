// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use bevy_mod_scripting_core::bindings::{
    ReflectReference,
    function::{
        from::{Ref, Mut, Val},
        namespace::NamespaceBuilder,
    },
};
use bevy_mod_scripting_derive::script_bindings;
use crate::*;
pub struct BevyTransformScriptingPlugin;
#[script_bindings(
    remote,
    name = "global_transform_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::transform::components::GlobalTransform {
    ///  Returns the 3d affine transformation matrix as an [`Affine3A`].
    fn affine(
        _self: Ref<bevy::transform::components::GlobalTransform>,
    ) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::transform::components::GlobalTransform::affine(
                &_self,
            )
            .into();
        output
    }
    /// Return the local back vector (Z).
    fn back(
        _self: Ref<bevy::transform::components::GlobalTransform>,
    ) -> Val<bevy::math::Dir3> {
        let output: Val<bevy::math::Dir3> = bevy::transform::components::GlobalTransform::back(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<bevy::transform::components::GlobalTransform>,
    ) -> Val<bevy::transform::components::GlobalTransform> {
        let output: Val<bevy::transform::components::GlobalTransform> = <bevy::transform::components::GlobalTransform as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the 3d affine transformation matrix as a [`Mat4`].
    fn compute_matrix(
        _self: Ref<bevy::transform::components::GlobalTransform>,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::transform::components::GlobalTransform::compute_matrix(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the transformation as a [`Transform`].
    ///  The transform is expected to be non-degenerate and without shearing, or the output
    ///  will be invalid.
    fn compute_transform(
        _self: Ref<bevy::transform::components::GlobalTransform>,
    ) -> Val<bevy::transform::components::Transform> {
        let output: Val<bevy::transform::components::Transform> = bevy::transform::components::GlobalTransform::compute_transform(
                &_self,
            )
            .into();
        output
    }
    /// Return the local down vector (-Y).
    fn down(
        _self: Ref<bevy::transform::components::GlobalTransform>,
    ) -> Val<bevy::math::Dir3> {
        let output: Val<bevy::math::Dir3> = bevy::transform::components::GlobalTransform::down(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<bevy::transform::components::GlobalTransform>,
        other: Ref<bevy::transform::components::GlobalTransform>,
    ) -> bool {
        let output: bool = <bevy::transform::components::GlobalTransform as ::core::cmp::PartialEq<
            bevy::transform::components::GlobalTransform,
        >>::eq(&_self, &other)
            .into();
        output
    }
    /// Return the local forward vector (-Z).
    fn forward(
        _self: Ref<bevy::transform::components::GlobalTransform>,
    ) -> Val<bevy::math::Dir3> {
        let output: Val<bevy::math::Dir3> = bevy::transform::components::GlobalTransform::forward(
                &_self,
            )
            .into();
        output
    }
    fn from_isometry(
        iso: Val<bevy::math::Isometry3d>,
    ) -> Val<bevy::transform::components::GlobalTransform> {
        let output: Val<bevy::transform::components::GlobalTransform> = bevy::transform::components::GlobalTransform::from_isometry(
                iso.into_inner(),
            )
            .into();
        output
    }
    fn from_rotation(
        rotation: Val<bevy::math::Quat>,
    ) -> Val<bevy::transform::components::GlobalTransform> {
        let output: Val<bevy::transform::components::GlobalTransform> = bevy::transform::components::GlobalTransform::from_rotation(
                rotation.into_inner(),
            )
            .into();
        output
    }
    fn from_scale(
        scale: Val<bevy::math::Vec3>,
    ) -> Val<bevy::transform::components::GlobalTransform> {
        let output: Val<bevy::transform::components::GlobalTransform> = bevy::transform::components::GlobalTransform::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    fn from_translation(
        translation: Val<bevy::math::Vec3>,
    ) -> Val<bevy::transform::components::GlobalTransform> {
        let output: Val<bevy::transform::components::GlobalTransform> = bevy::transform::components::GlobalTransform::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_xyz(
        x: f32,
        y: f32,
        z: f32,
    ) -> Val<bevy::transform::components::GlobalTransform> {
        let output: Val<bevy::transform::components::GlobalTransform> = bevy::transform::components::GlobalTransform::from_xyz(
                x,
                y,
                z,
            )
            .into();
        output
    }
    /// Return the local left vector (-X).
    fn left(
        _self: Ref<bevy::transform::components::GlobalTransform>,
    ) -> Val<bevy::math::Dir3> {
        let output: Val<bevy::math::Dir3> = bevy::transform::components::GlobalTransform::left(
                &_self,
            )
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::transform::components::GlobalTransform>,
        value: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::transform::components::GlobalTransform as ::core::ops::Mul<
            bevy::math::Vec3,
        >>::mul(_self.into_inner(), value.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::transform::components::GlobalTransform>,
        global_transform: Val<bevy::transform::components::GlobalTransform>,
    ) -> Val<bevy::transform::components::GlobalTransform> {
        let output: Val<bevy::transform::components::GlobalTransform> = <bevy::transform::components::GlobalTransform as ::core::ops::Mul<
            bevy::transform::components::GlobalTransform,
        >>::mul(_self.into_inner(), global_transform.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::transform::components::GlobalTransform>,
        transform: Val<bevy::transform::components::Transform>,
    ) -> Val<bevy::transform::components::GlobalTransform> {
        let output: Val<bevy::transform::components::GlobalTransform> = <bevy::transform::components::GlobalTransform as ::core::ops::Mul<
            bevy::transform::components::Transform,
        >>::mul(_self.into_inner(), transform.into_inner())
            .into();
        output
    }
    ///  Multiplies `self` with `transform` component by component, returning the
    ///  resulting [`GlobalTransform`]
    fn mul_transform(
        _self: Ref<bevy::transform::components::GlobalTransform>,
        transform: Val<bevy::transform::components::Transform>,
    ) -> Val<bevy::transform::components::GlobalTransform> {
        let output: Val<bevy::transform::components::GlobalTransform> = bevy::transform::components::GlobalTransform::mul_transform(
                &_self,
                transform.into_inner(),
            )
            .into();
        output
    }
    ///  Get an upper bound of the radius from the given `extents`.
    fn radius_vec3a(
        _self: Ref<bevy::transform::components::GlobalTransform>,
        extents: Val<bevy::math::Vec3A>,
    ) -> f32 {
        let output: f32 = bevy::transform::components::GlobalTransform::radius_vec3a(
                &_self,
                extents.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the [`Transform`] `self` would have if it was a child of an entity
    ///  with the `parent` [`GlobalTransform`].
    ///  This is useful if you want to "reparent" an [`Entity`](bevy_ecs::entity::Entity).
    ///  Say you have an entity `e1` that you want to turn into a child of `e2`,
    ///  but you want `e1` to keep the same global transform, even after re-parenting. You would use:
    ///  ```
    ///  # use bevy_transform::prelude::{GlobalTransform, Transform};
    ///  # use bevy_ecs::prelude::{Entity, Query, Component, Commands};
    ///  #[derive(Component)]
    ///  struct ToReparent {
    ///      new_parent: Entity,
    ///  }
    ///  fn reparent_system(
    ///      mut commands: Commands,
    ///      mut targets: Query<(&mut Transform, Entity, &GlobalTransform, &ToReparent)>,
    ///      transforms: Query<&GlobalTransform>,
    ///  ) {
    ///      for (mut transform, entity, initial, to_reparent) in targets.iter_mut() {
    ///          if let Ok(parent_transform) = transforms.get(to_reparent.new_parent) {
    ///              *transform = initial.reparented_to(parent_transform);
    ///              commands.entity(entity)
    ///                  .remove::<ToReparent>()
    ///                  .set_parent(to_reparent.new_parent);
    ///          }
    ///      }
    ///  }
    ///  ```
    ///  The transform is expected to be non-degenerate and without shearing, or the output
    ///  will be invalid.
    fn reparented_to(
        _self: Ref<bevy::transform::components::GlobalTransform>,
        parent: Ref<bevy::transform::components::GlobalTransform>,
    ) -> Val<bevy::transform::components::Transform> {
        let output: Val<bevy::transform::components::Transform> = bevy::transform::components::GlobalTransform::reparented_to(
                &_self,
                &parent,
            )
            .into();
        output
    }
    /// Return the local right vector (X).
    fn right(
        _self: Ref<bevy::transform::components::GlobalTransform>,
    ) -> Val<bevy::math::Dir3> {
        let output: Val<bevy::math::Dir3> = bevy::transform::components::GlobalTransform::right(
                &_self,
            )
            .into();
        output
    }
    ///  Get the rotation as a [`Quat`].
    ///  The transform is expected to be non-degenerate and without shearing, or the output will be invalid.
    ///  # Warning
    ///  This is calculated using `to_scale_rotation_translation`, meaning that you
    ///  should probably use it directly if you also need translation or scale.
    fn rotation(
        _self: Ref<bevy::transform::components::GlobalTransform>,
    ) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::transform::components::GlobalTransform::rotation(
                &_self,
            )
            .into();
        output
    }
    ///  Get the scale as a [`Vec3`].
    ///  The transform is expected to be non-degenerate and without shearing, or the output will be invalid.
    ///  Some of the computations overlap with `to_scale_rotation_translation`, which means you should use
    ///  it instead if you also need rotation.
    fn scale(
        _self: Ref<bevy::transform::components::GlobalTransform>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::transform::components::GlobalTransform::scale(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the isometric part of the transformation as an [isometry]. Any scaling done by the
    ///  transformation will be ignored.
    ///  The transform is expected to be non-degenerate and without shearing, or the output
    ///  will be invalid.
    ///  [isometry]: Isometry3d
    fn to_isometry(
        _self: Ref<bevy::transform::components::GlobalTransform>,
    ) -> Val<bevy::math::Isometry3d> {
        let output: Val<bevy::math::Isometry3d> = bevy::transform::components::GlobalTransform::to_isometry(
                &_self,
            )
            .into();
        output
    }
    ///  Transforms the given point from local space to global space, applying shear, scale, rotation and translation.
    ///  It can be used like this:
    ///  ```
    ///  # use bevy_transform::prelude::{GlobalTransform};
    ///  # use bevy_math::prelude::Vec3;
    ///  let global_transform = GlobalTransform::from_xyz(1., 2., 3.);
    ///  let local_point = Vec3::new(1., 2., 3.);
    ///  let global_point = global_transform.transform_point(local_point);
    ///  assert_eq!(global_point, Vec3::new(2., 4., 6.));
    ///  ```
    ///  ```
    ///  # use bevy_transform::prelude::{GlobalTransform};
    ///  # use bevy_math::Vec3;
    ///  let global_point = Vec3::new(2., 4., 6.);
    ///  let global_transform = GlobalTransform::from_xyz(1., 2., 3.);
    ///  let local_point = global_transform.affine().inverse().transform_point3(global_point);
    ///  assert_eq!(local_point, Vec3::new(1., 2., 3.))
    ///  ```
    ///  To apply shear, scale, and rotation *without* applying translation, different functions are available:
    ///  ```
    ///  # use bevy_transform::prelude::{GlobalTransform};
    ///  # use bevy_math::prelude::Vec3;
    ///  let global_transform = GlobalTransform::from_xyz(1., 2., 3.);
    ///  let local_direction = Vec3::new(1., 2., 3.);
    ///  let global_direction = global_transform.affine().transform_vector3(local_direction);
    ///  assert_eq!(global_direction, Vec3::new(1., 2., 3.));
    ///  let roundtripped_local_direction = global_transform.affine().inverse().transform_vector3(global_direction);
    ///  assert_eq!(roundtripped_local_direction, local_direction);
    ///  ```
    fn transform_point(
        _self: Ref<bevy::transform::components::GlobalTransform>,
        point: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::transform::components::GlobalTransform::transform_point(
                &_self,
                point.into_inner(),
            )
            .into();
        output
    }
    ///  Get the translation as a [`Vec3`].
    fn translation(
        _self: Ref<bevy::transform::components::GlobalTransform>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::transform::components::GlobalTransform::translation(
                &_self,
            )
            .into();
        output
    }
    ///  Get the translation as a [`Vec3A`].
    fn translation_vec3a(
        _self: Ref<bevy::transform::components::GlobalTransform>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::transform::components::GlobalTransform::translation_vec3a(
                &_self,
            )
            .into();
        output
    }
    /// Return the local up vector (Y).
    fn up(
        _self: Ref<bevy::transform::components::GlobalTransform>,
    ) -> Val<bevy::math::Dir3> {
        let output: Val<bevy::math::Dir3> = bevy::transform::components::GlobalTransform::up(
                &_self,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "transform_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::transform::components::Transform {
    ///  Equivalent to [`local_z()`][Transform::local_z]
    fn back(
        _self: Ref<bevy::transform::components::Transform>,
    ) -> Val<bevy::math::Dir3> {
        let output: Val<bevy::math::Dir3> = bevy::transform::components::Transform::back(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<bevy::transform::components::Transform>,
    ) -> Val<bevy::transform::components::Transform> {
        let output: Val<bevy::transform::components::Transform> = <bevy::transform::components::Transform as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the 3d affine transformation matrix from this transforms translation,
    ///  rotation, and scale.
    fn compute_affine(
        _self: Ref<bevy::transform::components::Transform>,
    ) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::transform::components::Transform::compute_affine(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the 3d affine transformation matrix from this transforms translation,
    ///  rotation, and scale.
    fn compute_matrix(
        _self: Ref<bevy::transform::components::Transform>,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::transform::components::Transform::compute_matrix(
                &_self,
            )
            .into();
        output
    }
    ///  Equivalent to [`-local_y()`][Transform::local_y]
    fn down(
        _self: Ref<bevy::transform::components::Transform>,
    ) -> Val<bevy::math::Dir3> {
        let output: Val<bevy::math::Dir3> = bevy::transform::components::Transform::down(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<bevy::transform::components::Transform>,
        other: Ref<bevy::transform::components::Transform>,
    ) -> bool {
        let output: bool = <bevy::transform::components::Transform as ::core::cmp::PartialEq<
            bevy::transform::components::Transform,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Equivalent to [`-local_z()`][Transform::local_z]
    fn forward(
        _self: Ref<bevy::transform::components::Transform>,
    ) -> Val<bevy::math::Dir3> {
        let output: Val<bevy::math::Dir3> = bevy::transform::components::Transform::forward(
                &_self,
            )
            .into();
        output
    }
    ///  Creates a new [`Transform`] that is equivalent to the given [isometry].
    ///  [isometry]: Isometry3d
    fn from_isometry(
        iso: Val<bevy::math::Isometry3d>,
    ) -> Val<bevy::transform::components::Transform> {
        let output: Val<bevy::transform::components::Transform> = bevy::transform::components::Transform::from_isometry(
                iso.into_inner(),
            )
            .into();
        output
    }
    ///  Extracts the translation, rotation, and scale from `matrix`. It must be a 3d affine
    ///  transformation matrix.
    fn from_matrix(
        world_from_local: Val<bevy::math::Mat4>,
    ) -> Val<bevy::transform::components::Transform> {
        let output: Val<bevy::transform::components::Transform> = bevy::transform::components::Transform::from_matrix(
                world_from_local.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new [`Transform`], with `rotation`. Translation will be 0 and scale 1 on
    ///  all axes.
    fn from_rotation(
        rotation: Val<bevy::math::Quat>,
    ) -> Val<bevy::transform::components::Transform> {
        let output: Val<bevy::transform::components::Transform> = bevy::transform::components::Transform::from_rotation(
                rotation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new [`Transform`], with `scale`. Translation will be 0 and rotation 0 on
    ///  all axes.
    fn from_scale(
        scale: Val<bevy::math::Vec3>,
    ) -> Val<bevy::transform::components::Transform> {
        let output: Val<bevy::transform::components::Transform> = bevy::transform::components::Transform::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new [`Transform`], with `translation`. Rotation will be 0 and scale 1 on
    ///  all axes.
    fn from_translation(
        translation: Val<bevy::math::Vec3>,
    ) -> Val<bevy::transform::components::Transform> {
        let output: Val<bevy::transform::components::Transform> = bevy::transform::components::Transform::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new [`Transform`] at the position `(x, y, z)`. In 2d, the `z` component
    ///  is used for z-ordering elements: higher `z`-value will be in front of lower
    ///  `z`-value.
    fn from_xyz(x: f32, y: f32, z: f32) -> Val<bevy::transform::components::Transform> {
        let output: Val<bevy::transform::components::Transform> = bevy::transform::components::Transform::from_xyz(
                x,
                y,
                z,
            )
            .into();
        output
    }
    ///  Returns `true` if, and only if, translation, rotation and scale all are
    ///  finite. If any of them contains a `NaN`, positive or negative infinity,
    ///  this will return `false`.
    fn is_finite(_self: Ref<bevy::transform::components::Transform>) -> bool {
        let output: bool = bevy::transform::components::Transform::is_finite(&_self)
            .into();
        output
    }
    ///  Equivalent to [`-local_x()`][Transform::local_x()]
    fn left(
        _self: Ref<bevy::transform::components::Transform>,
    ) -> Val<bevy::math::Dir3> {
        let output: Val<bevy::math::Dir3> = bevy::transform::components::Transform::left(
                &_self,
            )
            .into();
        output
    }
    ///  Get the unit vector in the local `X` direction.
    fn local_x(
        _self: Ref<bevy::transform::components::Transform>,
    ) -> Val<bevy::math::Dir3> {
        let output: Val<bevy::math::Dir3> = bevy::transform::components::Transform::local_x(
                &_self,
            )
            .into();
        output
    }
    ///  Get the unit vector in the local `Y` direction.
    fn local_y(
        _self: Ref<bevy::transform::components::Transform>,
    ) -> Val<bevy::math::Dir3> {
        let output: Val<bevy::math::Dir3> = bevy::transform::components::Transform::local_y(
                &_self,
            )
            .into();
        output
    }
    ///  Get the unit vector in the local `Z` direction.
    fn local_z(
        _self: Ref<bevy::transform::components::Transform>,
    ) -> Val<bevy::math::Dir3> {
        let output: Val<bevy::math::Dir3> = bevy::transform::components::Transform::local_z(
                &_self,
            )
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::transform::components::Transform>,
        value: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::transform::components::Transform as ::core::ops::Mul<
            bevy::math::Vec3,
        >>::mul(_self.into_inner(), value.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::transform::components::Transform>,
        global_transform: Val<bevy::transform::components::GlobalTransform>,
    ) -> Val<bevy::transform::components::GlobalTransform> {
        let output: Val<bevy::transform::components::GlobalTransform> = <bevy::transform::components::Transform as ::core::ops::Mul<
            bevy::transform::components::GlobalTransform,
        >>::mul(_self.into_inner(), global_transform.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::transform::components::Transform>,
        transform: Val<bevy::transform::components::Transform>,
    ) -> Val<bevy::transform::components::Transform> {
        let output: Val<bevy::transform::components::Transform> = <bevy::transform::components::Transform as ::core::ops::Mul<
            bevy::transform::components::Transform,
        >>::mul(_self.into_inner(), transform.into_inner())
            .into();
        output
    }
    ///  Multiplies `self` with `transform` component by component, returning the
    ///  resulting [`Transform`]
    fn mul_transform(
        _self: Ref<bevy::transform::components::Transform>,
        transform: Val<bevy::transform::components::Transform>,
    ) -> Val<bevy::transform::components::Transform> {
        let output: Val<bevy::transform::components::Transform> = bevy::transform::components::Transform::mul_transform(
                &_self,
                transform.into_inner(),
            )
            .into();
        output
    }
    ///  Equivalent to [`local_x()`][Transform::local_x()]
    fn right(
        _self: Ref<bevy::transform::components::Transform>,
    ) -> Val<bevy::math::Dir3> {
        let output: Val<bevy::math::Dir3> = bevy::transform::components::Transform::right(
                &_self,
            )
            .into();
        output
    }
    ///  Rotates this [`Transform`] by the given rotation.
    ///  If this [`Transform`] has a parent, the `rotation` is relative to the rotation of the parent.
    ///  # Examples
    ///  - [`3d_rotation`]
    ///  [`3d_rotation`]: https://github.com/bevyengine/bevy/blob/latest/examples/transforms/3d_rotation.rs
    fn rotate(
        mut _self: Mut<bevy::transform::components::Transform>,
        rotation: Val<bevy::math::Quat>,
    ) -> () {
        let output: () = bevy::transform::components::Transform::rotate(
                &mut _self,
                rotation.into_inner(),
            )
            .into();
        output
    }
    ///  Rotates this [`Transform`] around a `point` in space.
    ///  If this [`Transform`] has a parent, the `point` is relative to the [`Transform`] of the parent.
    fn rotate_around(
        mut _self: Mut<bevy::transform::components::Transform>,
        point: Val<bevy::math::Vec3>,
        rotation: Val<bevy::math::Quat>,
    ) -> () {
        let output: () = bevy::transform::components::Transform::rotate_around(
                &mut _self,
                point.into_inner(),
                rotation.into_inner(),
            )
            .into();
        output
    }
    ///  Rotates this [`Transform`] around the given `axis` by `angle` (in radians).
    ///  If this [`Transform`] has a parent, the `axis` is relative to the rotation of the parent.
    ///  # Warning
    ///  If you pass in an `axis` based on the current rotation (e.g. obtained via [`Transform::local_x`]),
    ///  floating point errors can accumulate exponentially when applying rotations repeatedly this way. This will
    ///  result in a denormalized rotation. In this case, it is recommended to normalize the [`Transform::rotation`] after
    ///  each call to this method.
    fn rotate_axis(
        mut _self: Mut<bevy::transform::components::Transform>,
        axis: Val<bevy::math::Dir3>,
        angle: f32,
    ) -> () {
        let output: () = bevy::transform::components::Transform::rotate_axis(
                &mut _self,
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    ///  Rotates this [`Transform`] by the given `rotation`.
    ///  The `rotation` is relative to this [`Transform`]'s current rotation.
    fn rotate_local(
        mut _self: Mut<bevy::transform::components::Transform>,
        rotation: Val<bevy::math::Quat>,
    ) -> () {
        let output: () = bevy::transform::components::Transform::rotate_local(
                &mut _self,
                rotation.into_inner(),
            )
            .into();
        output
    }
    ///  Rotates this [`Transform`] around its local `axis` by `angle` (in radians).
    ///  # Warning
    ///  If you pass in an `axis` based on the current rotation (e.g. obtained via [`Transform::local_x`]),
    ///  floating point errors can accumulate exponentially when applying rotations repeatedly this way. This will
    ///  result in a denormalized rotation. In this case, it is recommended to normalize the [`Transform::rotation`] after
    ///  each call to this method.
    fn rotate_local_axis(
        mut _self: Mut<bevy::transform::components::Transform>,
        axis: Val<bevy::math::Dir3>,
        angle: f32,
    ) -> () {
        let output: () = bevy::transform::components::Transform::rotate_local_axis(
                &mut _self,
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    ///  Rotates this [`Transform`] around its local `X` axis by `angle` (in radians).
    fn rotate_local_x(
        mut _self: Mut<bevy::transform::components::Transform>,
        angle: f32,
    ) -> () {
        let output: () = bevy::transform::components::Transform::rotate_local_x(
                &mut _self,
                angle,
            )
            .into();
        output
    }
    ///  Rotates this [`Transform`] around its local `Y` axis by `angle` (in radians).
    fn rotate_local_y(
        mut _self: Mut<bevy::transform::components::Transform>,
        angle: f32,
    ) -> () {
        let output: () = bevy::transform::components::Transform::rotate_local_y(
                &mut _self,
                angle,
            )
            .into();
        output
    }
    ///  Rotates this [`Transform`] around its local `Z` axis by `angle` (in radians).
    fn rotate_local_z(
        mut _self: Mut<bevy::transform::components::Transform>,
        angle: f32,
    ) -> () {
        let output: () = bevy::transform::components::Transform::rotate_local_z(
                &mut _self,
                angle,
            )
            .into();
        output
    }
    ///  Rotates this [`Transform`] around the `X` axis by `angle` (in radians).
    ///  If this [`Transform`] has a parent, the axis is relative to the rotation of the parent.
    fn rotate_x(
        mut _self: Mut<bevy::transform::components::Transform>,
        angle: f32,
    ) -> () {
        let output: () = bevy::transform::components::Transform::rotate_x(
                &mut _self,
                angle,
            )
            .into();
        output
    }
    ///  Rotates this [`Transform`] around the `Y` axis by `angle` (in radians).
    ///  If this [`Transform`] has a parent, the axis is relative to the rotation of the parent.
    fn rotate_y(
        mut _self: Mut<bevy::transform::components::Transform>,
        angle: f32,
    ) -> () {
        let output: () = bevy::transform::components::Transform::rotate_y(
                &mut _self,
                angle,
            )
            .into();
        output
    }
    ///  Rotates this [`Transform`] around the `Z` axis by `angle` (in radians).
    ///  If this [`Transform`] has a parent, the axis is relative to the rotation of the parent.
    fn rotate_z(
        mut _self: Mut<bevy::transform::components::Transform>,
        angle: f32,
    ) -> () {
        let output: () = bevy::transform::components::Transform::rotate_z(
                &mut _self,
                angle,
            )
            .into();
        output
    }
    ///  Get the [isometry] defined by this transform's rotation and translation, ignoring scale.
    ///  [isometry]: Isometry3d
    fn to_isometry(
        _self: Ref<bevy::transform::components::Transform>,
    ) -> Val<bevy::math::Isometry3d> {
        let output: Val<bevy::math::Isometry3d> = bevy::transform::components::Transform::to_isometry(
                &_self,
            )
            .into();
        output
    }
    ///  Transforms the given `point`, applying scale, rotation and translation.
    ///  If this [`Transform`] has an ancestor entity with a [`Transform`] component,
    ///  [`Transform::transform_point`] will transform a point in local space into its
    ///  parent transform's space.
    ///  If this [`Transform`] does not have a parent, [`Transform::transform_point`] will
    ///  transform a point in local space into worldspace coordinates.
    ///  If you always want to transform a point in local space to worldspace, or if you need
    ///  the inverse transformations, see [`GlobalTransform::transform_point()`].
    fn transform_point(
        _self: Ref<bevy::transform::components::Transform>,
        point: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::transform::components::Transform::transform_point(
                &_self,
                point.into_inner(),
            )
            .into();
        output
    }
    ///  Translates this [`Transform`] around a `point` in space.
    ///  If this [`Transform`] has a parent, the `point` is relative to the [`Transform`] of the parent.
    fn translate_around(
        mut _self: Mut<bevy::transform::components::Transform>,
        point: Val<bevy::math::Vec3>,
        rotation: Val<bevy::math::Quat>,
    ) -> () {
        let output: () = bevy::transform::components::Transform::translate_around(
                &mut _self,
                point.into_inner(),
                rotation.into_inner(),
            )
            .into();
        output
    }
    ///  Equivalent to [`local_y()`][Transform::local_y]
    fn up(_self: Ref<bevy::transform::components::Transform>) -> Val<bevy::math::Dir3> {
        let output: Val<bevy::math::Dir3> = bevy::transform::components::Transform::up(
                &_self,
            )
            .into();
        output
    }
    ///  Returns this [`Transform`] with a new rotation.
    fn with_rotation(
        _self: Val<bevy::transform::components::Transform>,
        rotation: Val<bevy::math::Quat>,
    ) -> Val<bevy::transform::components::Transform> {
        let output: Val<bevy::transform::components::Transform> = bevy::transform::components::Transform::with_rotation(
                _self.into_inner(),
                rotation.into_inner(),
            )
            .into();
        output
    }
    ///  Returns this [`Transform`] with a new scale.
    fn with_scale(
        _self: Val<bevy::transform::components::Transform>,
        scale: Val<bevy::math::Vec3>,
    ) -> Val<bevy::transform::components::Transform> {
        let output: Val<bevy::transform::components::Transform> = bevy::transform::components::Transform::with_scale(
                _self.into_inner(),
                scale.into_inner(),
            )
            .into();
        output
    }
    ///  Returns this [`Transform`] with a new translation.
    fn with_translation(
        _self: Val<bevy::transform::components::Transform>,
        translation: Val<bevy::math::Vec3>,
    ) -> Val<bevy::transform::components::Transform> {
        let output: Val<bevy::transform::components::Transform> = bevy::transform::components::Transform::with_translation(
                _self.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "transform_tree_changed_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::transform::components::TransformTreeChanged {
    fn clone(
        _self: Ref<bevy::transform::components::TransformTreeChanged>,
    ) -> Val<bevy::transform::components::TransformTreeChanged> {
        let output: Val<bevy::transform::components::TransformTreeChanged> = <bevy::transform::components::TransformTreeChanged as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<bevy::transform::components::TransformTreeChanged>,
        other: Ref<bevy::transform::components::TransformTreeChanged>,
    ) -> bool {
        let output: bool = <bevy::transform::components::TransformTreeChanged as ::core::cmp::PartialEq<
            bevy::transform::components::TransformTreeChanged,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
impl ::bevy::app::Plugin for BevyTransformScriptingPlugin {
    fn build(&self, app: &mut ::bevy::prelude::App) {
        let mut world = app.world_mut();
        register_global_transform_functions(&mut world);
        register_transform_functions(&mut world);
        register_transform_tree_changed_functions(&mut world);
    }
}
