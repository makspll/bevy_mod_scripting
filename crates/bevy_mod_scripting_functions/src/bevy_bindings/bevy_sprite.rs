// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use bevy_mod_scripting_core::{
    bindings::{
        ReflectReference, 
        function::{from::{Ref, Mut, Val}, namespace::{NamespaceBuilder}}
    }
};
use bevy_ecs::{prelude::*};


use bevy_mod_scripting_derive::script_bindings;


use crate::*;







pub struct BevySpriteScriptingPlugin;


#[script_bindings(
    remote,
    name = "sprite_picking_camera_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_sprite::prelude::SpritePickingCamera {


    
    fn clone (_self:Ref<::bevy_sprite::prelude::SpritePickingCamera>,) -> Val<::bevy_sprite::prelude::SpritePickingCamera> {
        let output: Val<::bevy_sprite::prelude::SpritePickingCamera> =<::bevy_sprite::prelude::SpritePickingCamera as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "sprite_picking_mode_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_sprite::prelude::SpritePickingMode {


    
    fn clone (_self:Ref<::bevy_sprite::prelude::SpritePickingMode>,) -> Val<::bevy_sprite::prelude::SpritePickingMode> {
        let output: Val<::bevy_sprite::prelude::SpritePickingMode> =<::bevy_sprite::prelude::SpritePickingMode as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "sprite_picking_settings_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_sprite::prelude::SpritePickingSettings {
     
}

#[script_bindings(
    remote,
    name = "sprite_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_sprite::prelude::Sprite {


    
    fn clone (_self:Ref<::bevy_sprite::prelude::Sprite>,) -> Val<::bevy_sprite::prelude::Sprite> {
        let output: Val<::bevy_sprite::prelude::Sprite> =<::bevy_sprite::prelude::Sprite as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Create a Sprite with a custom size
    
    fn sized (custom_size:Val<::bevy_math::Vec2>,) -> Val<::bevy_sprite::prelude::Sprite> {
        let output: Val<::bevy_sprite::prelude::Sprite> =::bevy_sprite::prelude::Sprite::sized(custom_size.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "sprite_image_mode_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_sprite::prelude::SpriteImageMode {


    
    fn clone (_self:Ref<::bevy_sprite::prelude::SpriteImageMode>,) -> Val<::bevy_sprite::prelude::SpriteImageMode> {
        let output: Val<::bevy_sprite::prelude::SpriteImageMode> =<::bevy_sprite::prelude::SpriteImageMode as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_sprite::prelude::SpriteImageMode>,other:Ref<::bevy_sprite::prelude::SpriteImageMode>,) -> bool {
        let output: bool =<::bevy_sprite::prelude::SpriteImageMode as ::std::cmp::PartialEq::<::bevy_sprite::prelude::SpriteImageMode>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Returns true if this mode uses slices internally ([`SpriteImageMode::Sliced`] or [`SpriteImageMode::Tiled`])
    
    fn uses_slices (_self:Ref<::bevy_sprite::prelude::SpriteImageMode>,) -> bool {
        let output: bool =::bevy_sprite::prelude::SpriteImageMode::uses_slices(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "border_rect_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_sprite::prelude::BorderRect {


    
    ///  Creates a border with the same `extent` along each edge
    
    fn all (extent:f32,) -> Val<::bevy_sprite::prelude::BorderRect> {
        let output: Val<::bevy_sprite::prelude::BorderRect> =::bevy_sprite::prelude::BorderRect::all(extent,).into();
        output
    }


    
    ///  Creates a new border with the `left` and `right` extents equal to `horizontal`, and `top` and `bottom` extents equal to `vertical`.
    
    fn axes (horizontal:f32,vertical:f32,) -> Val<::bevy_sprite::prelude::BorderRect> {
        let output: Val<::bevy_sprite::prelude::BorderRect> =::bevy_sprite::prelude::BorderRect::axes(horizontal,vertical,).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_sprite::prelude::BorderRect>,) -> Val<::bevy_sprite::prelude::BorderRect> {
        let output: Val<::bevy_sprite::prelude::BorderRect> =<::bevy_sprite::prelude::BorderRect as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_sprite::prelude::BorderRect>,other:Ref<::bevy_sprite::prelude::BorderRect>,) -> bool {
        let output: bool =<::bevy_sprite::prelude::BorderRect as ::std::cmp::PartialEq::<::bevy_sprite::prelude::BorderRect>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "slice_scale_mode_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_sprite::prelude::SliceScaleMode {


    
    fn clone (_self:Ref<::bevy_sprite::prelude::SliceScaleMode>,) -> Val<::bevy_sprite::prelude::SliceScaleMode> {
        let output: Val<::bevy_sprite::prelude::SliceScaleMode> =<::bevy_sprite::prelude::SliceScaleMode as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_sprite::prelude::SliceScaleMode>,other:Ref<::bevy_sprite::prelude::SliceScaleMode>,) -> bool {
        let output: bool =<::bevy_sprite::prelude::SliceScaleMode as ::std::cmp::PartialEq::<::bevy_sprite::prelude::SliceScaleMode>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "texture_slicer_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_sprite::prelude::TextureSlicer {


    
    fn clone (_self:Ref<::bevy_sprite::prelude::TextureSlicer>,) -> Val<::bevy_sprite::prelude::TextureSlicer> {
        let output: Val<::bevy_sprite::prelude::TextureSlicer> =<::bevy_sprite::prelude::TextureSlicer as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_sprite::prelude::TextureSlicer>,other:Ref<::bevy_sprite::prelude::TextureSlicer>,) -> bool {
        let output: bool =<::bevy_sprite::prelude::TextureSlicer as ::std::cmp::PartialEq::<::bevy_sprite::prelude::TextureSlicer>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "color_material_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_sprite::prelude::ColorMaterial {


    
    fn clone (_self:Ref<::bevy_sprite::prelude::ColorMaterial>,) -> Val<::bevy_sprite::prelude::ColorMaterial> {
        let output: Val<::bevy_sprite::prelude::ColorMaterial> =<::bevy_sprite::prelude::ColorMaterial as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "scaling_mode_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_sprite::prelude::ScalingMode {


    
    fn clone (_self:Ref<::bevy_sprite::prelude::ScalingMode>,) -> Val<::bevy_sprite::prelude::ScalingMode> {
        let output: Val<::bevy_sprite::prelude::ScalingMode> =<::bevy_sprite::prelude::ScalingMode as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_sprite::prelude::ScalingMode>,other:Ref<::bevy_sprite::prelude::ScalingMode>,) -> bool {
        let output: bool =<::bevy_sprite::prelude::ScalingMode as ::std::cmp::PartialEq::<::bevy_sprite::prelude::ScalingMode>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "anchor_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_sprite::Anchor {


    
    fn as_vec (_self:Ref<::bevy_sprite::Anchor>,) -> Val<::bevy_math::Vec2> {
        let output: Val<::bevy_math::Vec2> =::bevy_sprite::Anchor::as_vec(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_sprite::Anchor>,) -> Val<::bevy_sprite::Anchor> {
        let output: Val<::bevy_sprite::Anchor> =<::bevy_sprite::Anchor as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_sprite::Anchor>,other:Ref<::bevy_sprite::Anchor>,) -> bool {
        let output: bool =<::bevy_sprite::Anchor as ::std::cmp::PartialEq::<::bevy_sprite::Anchor>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "alpha_mode_2_d_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_sprite::AlphaMode2d {


    
    fn clone (_self:Ref<::bevy_sprite::AlphaMode2d>,) -> Val<::bevy_sprite::AlphaMode2d> {
        let output: Val<::bevy_sprite::AlphaMode2d> =<::bevy_sprite::AlphaMode2d as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_sprite::AlphaMode2d>,other:Ref<::bevy_sprite::AlphaMode2d>,) -> bool {
        let output: bool =<::bevy_sprite::AlphaMode2d as ::std::cmp::PartialEq::<::bevy_sprite::AlphaMode2d>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "wireframe_2_d_material_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_sprite::Wireframe2dMaterial {


    
    fn clone (_self:Ref<::bevy_sprite::Wireframe2dMaterial>,) -> Val<::bevy_sprite::Wireframe2dMaterial> {
        let output: Val<::bevy_sprite::Wireframe2dMaterial> =<::bevy_sprite::Wireframe2dMaterial as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "no_wireframe_2_d_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_sprite::NoWireframe2d {


    
    fn assert_receiver_is_total_eq (_self:Ref<::bevy_sprite::NoWireframe2d>,) -> () {
        let output: () =<::bevy_sprite::NoWireframe2d as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_sprite::NoWireframe2d>,) -> Val<::bevy_sprite::NoWireframe2d> {
        let output: Val<::bevy_sprite::NoWireframe2d> =<::bevy_sprite::NoWireframe2d as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_sprite::NoWireframe2d>,other:Ref<::bevy_sprite::NoWireframe2d>,) -> bool {
        let output: bool =<::bevy_sprite::NoWireframe2d as ::std::cmp::PartialEq::<::bevy_sprite::NoWireframe2d>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "wireframe_2_d_config_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_sprite::Wireframe2dConfig {


    
    fn clone (_self:Ref<::bevy_sprite::Wireframe2dConfig>,) -> Val<::bevy_sprite::Wireframe2dConfig> {
        let output: Val<::bevy_sprite::Wireframe2dConfig> =<::bevy_sprite::Wireframe2dConfig as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "wireframe_2_d_color_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_sprite::Wireframe2dColor {


    
    fn clone (_self:Ref<::bevy_sprite::Wireframe2dColor>,) -> Val<::bevy_sprite::Wireframe2dColor> {
        let output: Val<::bevy_sprite::Wireframe2dColor> =<::bevy_sprite::Wireframe2dColor as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "wireframe_2_d_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_sprite::Wireframe2d {


    
    fn assert_receiver_is_total_eq (_self:Ref<::bevy_sprite::Wireframe2d>,) -> () {
        let output: () =<::bevy_sprite::Wireframe2d as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_sprite::Wireframe2d>,) -> Val<::bevy_sprite::Wireframe2d> {
        let output: Val<::bevy_sprite::Wireframe2d> =<::bevy_sprite::Wireframe2d as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_sprite::Wireframe2d>,other:Ref<::bevy_sprite::Wireframe2d>,) -> bool {
        let output: bool =<::bevy_sprite::Wireframe2d as ::std::cmp::PartialEq::<::bevy_sprite::Wireframe2d>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "mesh_2_d_wireframe_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_sprite::Mesh2dWireframe {


    
    fn assert_receiver_is_total_eq (_self:Ref<::bevy_sprite::Mesh2dWireframe>,) -> () {
        let output: () =<::bevy_sprite::Mesh2dWireframe as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_sprite::Mesh2dWireframe>,) -> Val<::bevy_sprite::Mesh2dWireframe> {
        let output: Val<::bevy_sprite::Mesh2dWireframe> =<::bevy_sprite::Mesh2dWireframe as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_sprite::Mesh2dWireframe>,other:Ref<::bevy_sprite::Mesh2dWireframe>,) -> bool {
        let output: bool =<::bevy_sprite::Mesh2dWireframe as ::std::cmp::PartialEq::<::bevy_sprite::Mesh2dWireframe>>::eq(&_self,&other,).into();
        output
    }
     
}


impl Plugin for BevySpriteScriptingPlugin {
    fn build(&self, app: &mut App) {
        let mut world = app.world_mut();

        
            register_sprite_picking_camera_functions(&mut world);
        
            register_sprite_picking_mode_functions(&mut world);
        
            register_sprite_picking_settings_functions(&mut world);
        
            register_sprite_functions(&mut world);
        
            register_sprite_image_mode_functions(&mut world);
        
            register_border_rect_functions(&mut world);
        
            register_slice_scale_mode_functions(&mut world);
        
            register_texture_slicer_functions(&mut world);
        
            register_color_material_functions(&mut world);
        
            register_scaling_mode_functions(&mut world);
        
            register_anchor_functions(&mut world);
        
            register_alpha_mode_2_d_functions(&mut world);
        
            register_wireframe_2_d_material_functions(&mut world);
        
            register_no_wireframe_2_d_functions(&mut world);
        
            register_wireframe_2_d_config_functions(&mut world);
        
            register_wireframe_2_d_color_functions(&mut world);
        
            register_wireframe_2_d_functions(&mut world);
        
            register_mesh_2_d_wireframe_functions(&mut world);
        
    }
}
