// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use bevy_mod_scripting_core::{
    bindings::{
        ReflectReference, 
        function::{from::{Ref, Mut, Val}, namespace::{NamespaceBuilder}}
    }
};

use bevy_mod_scripting_derive::script_bindings;


use crate::*;







pub struct BevyPbrScriptingPlugin;


#[script_bindings(
    remote,
    name = "fog_volume_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::FogVolume {


    
    fn clone (_self:Ref<bevy::pbr::FogVolume>,) -> Val<bevy::pbr::FogVolume> {
        let output: Val<bevy::pbr::FogVolume> =<bevy::pbr::FogVolume as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "volumetric_fog_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::VolumetricFog {


    
    fn clone (_self:Ref<bevy::pbr::VolumetricFog>,) -> Val<bevy::pbr::VolumetricFog> {
        let output: Val<bevy::pbr::VolumetricFog> =<bevy::pbr::VolumetricFog as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "volumetric_light_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::VolumetricLight {


    
    fn clone (_self:Ref<bevy::pbr::VolumetricLight>,) -> Val<bevy::pbr::VolumetricLight> {
        let output: Val<bevy::pbr::VolumetricLight> =<bevy::pbr::VolumetricLight as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "distance_fog_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::prelude::DistanceFog {


    
    fn clone (_self:Ref<bevy::pbr::prelude::DistanceFog>,) -> Val<bevy::pbr::prelude::DistanceFog> {
        let output: Val<bevy::pbr::prelude::DistanceFog> =<bevy::pbr::prelude::DistanceFog as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "fog_falloff_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::prelude::FogFalloff {


    
    fn clone (_self:Ref<bevy::pbr::prelude::FogFalloff>,) -> Val<bevy::pbr::prelude::FogFalloff> {
        let output: Val<bevy::pbr::prelude::FogFalloff> =<bevy::pbr::prelude::FogFalloff as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a [`FogFalloff::Exponential`] value from the given visibility distance in world units,
    
    ///  using the revised Koschmieder contrast threshold, [`FogFalloff::REVISED_KOSCHMIEDER_CONTRAST_THRESHOLD`].
    
    fn from_visibility (visibility:f32,) -> Val<bevy::pbr::prelude::FogFalloff> {
        let output: Val<bevy::pbr::prelude::FogFalloff> =bevy::pbr::prelude::FogFalloff::from_visibility(visibility,).into();
        output
    }


    
    ///  Creates a [`FogFalloff::Atmospheric`] value from the given visibility distance in world units,
    
    ///  and a shared color for both extinction and inscattering, using the revised Koschmieder contrast threshold,
    
    ///  [`FogFalloff::REVISED_KOSCHMIEDER_CONTRAST_THRESHOLD`].
    
    fn from_visibility_color (visibility:f32,extinction_inscattering_color:Val<bevy::color::Color>,) -> Val<bevy::pbr::prelude::FogFalloff> {
        let output: Val<bevy::pbr::prelude::FogFalloff> =bevy::pbr::prelude::FogFalloff::from_visibility_color(visibility,extinction_inscattering_color.into_inner(),).into();
        output
    }


    
    ///  Creates a [`FogFalloff::Atmospheric`] value from the given visibility distance in world units,
    
    ///  extinction and inscattering colors, using the revised Koschmieder contrast threshold,
    
    ///  [`FogFalloff::REVISED_KOSCHMIEDER_CONTRAST_THRESHOLD`].
    
    ///  ## Tips
    
    ///  - Alpha values of the provided colors can modulate the `extinction` and `inscattering` effects;
    
    ///  - Using an `extinction_color` of [`Color::WHITE`] or [`Color::NONE`] disables the extinction effect;
    
    ///  - Using an `inscattering_color` of [`Color::BLACK`] or [`Color::NONE`] disables the inscattering effect.
    
    fn from_visibility_colors (visibility:f32,extinction_color:Val<bevy::color::Color>,inscattering_color:Val<bevy::color::Color>,) -> Val<bevy::pbr::prelude::FogFalloff> {
        let output: Val<bevy::pbr::prelude::FogFalloff> =bevy::pbr::prelude::FogFalloff::from_visibility_colors(visibility,extinction_color.into_inner(),inscattering_color.into_inner(),).into();
        output
    }


    
    ///  Creates a [`FogFalloff::Exponential`] value from the given visibility distance in world units,
    
    ///  and a given contrast threshold in the range of `0.0` to `1.0`.
    
    fn from_visibility_contrast (visibility:f32,contrast_threshold:f32,) -> Val<bevy::pbr::prelude::FogFalloff> {
        let output: Val<bevy::pbr::prelude::FogFalloff> =bevy::pbr::prelude::FogFalloff::from_visibility_contrast(visibility,contrast_threshold,).into();
        output
    }


    
    ///  Creates a [`FogFalloff::Atmospheric`] value from the given visibility distance in world units,
    
    ///  a contrast threshold in the range of `0.0` to `1.0`, and a shared color for both extinction and inscattering.
    
    fn from_visibility_contrast_color (visibility:f32,contrast_threshold:f32,extinction_inscattering_color:Val<bevy::color::Color>,) -> Val<bevy::pbr::prelude::FogFalloff> {
        let output: Val<bevy::pbr::prelude::FogFalloff> =bevy::pbr::prelude::FogFalloff::from_visibility_contrast_color(visibility,contrast_threshold,extinction_inscattering_color.into_inner(),).into();
        output
    }


    
    ///  Creates a [`FogFalloff::Atmospheric`] value from the given visibility distance in world units,
    
    ///  a contrast threshold in the range of `0.0` to `1.0`, extinction and inscattering colors.
    
    ///  ## Tips
    
    ///  - Alpha values of the provided colors can modulate the `extinction` and `inscattering` effects;
    
    ///  - Using an `extinction_color` of [`Color::WHITE`] or [`Color::NONE`] disables the extinction effect;
    
    ///  - Using an `inscattering_color` of [`Color::BLACK`] or [`Color::NONE`] disables the inscattering effect.
    
    fn from_visibility_contrast_colors (visibility:f32,contrast_threshold:f32,extinction_color:Val<bevy::color::Color>,inscattering_color:Val<bevy::color::Color>,) -> Val<bevy::pbr::prelude::FogFalloff> {
        let output: Val<bevy::pbr::prelude::FogFalloff> =bevy::pbr::prelude::FogFalloff::from_visibility_contrast_colors(visibility,contrast_threshold,extinction_color.into_inner(),inscattering_color.into_inner(),).into();
        output
    }


    
    ///  Creates a [`FogFalloff::ExponentialSquared`] value from the given visibility distance in world units,
    
    ///  and a given contrast threshold in the range of `0.0` to `1.0`.
    
    fn from_visibility_contrast_squared (visibility:f32,contrast_threshold:f32,) -> Val<bevy::pbr::prelude::FogFalloff> {
        let output: Val<bevy::pbr::prelude::FogFalloff> =bevy::pbr::prelude::FogFalloff::from_visibility_contrast_squared(visibility,contrast_threshold,).into();
        output
    }


    
    ///  Creates a [`FogFalloff::ExponentialSquared`] value from the given visibility distance in world units,
    
    ///  using the revised Koschmieder contrast threshold, [`FogFalloff::REVISED_KOSCHMIEDER_CONTRAST_THRESHOLD`].
    
    fn from_visibility_squared (visibility:f32,) -> Val<bevy::pbr::prelude::FogFalloff> {
        let output: Val<bevy::pbr::prelude::FogFalloff> =bevy::pbr::prelude::FogFalloff::from_visibility_squared(visibility,).into();
        output
    }


    
    ///  Calculates the extinction coefficient β, from V and Cₜ, where:
    
    ///  - Cₜ is the contrast threshold, in the range of `0.0` to `1.0`
    
    ///  - V is the visibility distance in which a perfectly black object is still identifiable
    
    ///    against the horizon sky within the contrast threshold
    
    ///  We start with Koschmieder's equation:
    
    ///  ```text
    
    ///        -ln(Cₜ)
    
    ///   V = ─────────
    
    ///           β
    
    ///  ```
    
    ///  Multiplying both sides by β/V, that gives us:
    
    ///  ```text
    
    ///        -ln(Cₜ)
    
    ///   β = ─────────
    
    ///           V
    
    ///  ```
    
    ///  See:
    
    ///  - <https://en.wikipedia.org/wiki/Visibility>
    
    ///  - <https://www.biral.com/wp-content/uploads/2015/02/Introduction_to_visibility-v2-2.pdf>
    
    fn koschmieder (v:f32,c_t:f32,) -> f32 {
        let output: f32 =bevy::pbr::prelude::FogFalloff::koschmieder(v,c_t,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "ambient_light_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::prelude::AmbientLight {


    
    fn clone (_self:Ref<bevy::pbr::prelude::AmbientLight>,) -> Val<bevy::pbr::prelude::AmbientLight> {
        let output: Val<bevy::pbr::prelude::AmbientLight> =<bevy::pbr::prelude::AmbientLight as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "directional_light_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::prelude::DirectionalLight {


    
    fn clone (_self:Ref<bevy::pbr::prelude::DirectionalLight>,) -> Val<bevy::pbr::prelude::DirectionalLight> {
        let output: Val<bevy::pbr::prelude::DirectionalLight> =<bevy::pbr::prelude::DirectionalLight as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "point_light_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::prelude::PointLight {


    
    fn clone (_self:Ref<bevy::pbr::prelude::PointLight>,) -> Val<bevy::pbr::prelude::PointLight> {
        let output: Val<bevy::pbr::prelude::PointLight> =<bevy::pbr::prelude::PointLight as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "spot_light_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::prelude::SpotLight {


    
    fn clone (_self:Ref<bevy::pbr::prelude::SpotLight>,) -> Val<bevy::pbr::prelude::SpotLight> {
        let output: Val<bevy::pbr::prelude::SpotLight> =<bevy::pbr::prelude::SpotLight as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "environment_map_light_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::prelude::EnvironmentMapLight {


    
    fn clone (_self:Ref<bevy::pbr::prelude::EnvironmentMapLight>,) -> Val<bevy::pbr::prelude::EnvironmentMapLight> {
        let output: Val<bevy::pbr::prelude::EnvironmentMapLight> =<bevy::pbr::prelude::EnvironmentMapLight as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "light_probe_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::prelude::LightProbe {


    
    fn clone (_self:Ref<bevy::pbr::prelude::LightProbe>,) -> Val<bevy::pbr::prelude::LightProbe> {
        let output: Val<bevy::pbr::prelude::LightProbe> =<bevy::pbr::prelude::LightProbe as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new light probe component.
    
    fn new () -> Val<bevy::pbr::prelude::LightProbe> {
        let output: Val<bevy::pbr::prelude::LightProbe> =bevy::pbr::prelude::LightProbe::new().into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "parallax_mapping_method_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::prelude::ParallaxMappingMethod {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::pbr::prelude::ParallaxMappingMethod>,) -> () {
        let output: () =<bevy::pbr::prelude::ParallaxMappingMethod as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::pbr::prelude::ParallaxMappingMethod>,) -> Val<bevy::pbr::prelude::ParallaxMappingMethod> {
        let output: Val<bevy::pbr::prelude::ParallaxMappingMethod> =<bevy::pbr::prelude::ParallaxMappingMethod as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::pbr::prelude::ParallaxMappingMethod>,other:Ref<bevy::pbr::prelude::ParallaxMappingMethod>,) -> bool {
        let output: bool =<bevy::pbr::prelude::ParallaxMappingMethod as ::std::cmp::PartialEq::<bevy::pbr::prelude::ParallaxMappingMethod>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "standard_material_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::prelude::StandardMaterial {


    
    fn clone (_self:Ref<bevy::pbr::prelude::StandardMaterial>,) -> Val<bevy::pbr::prelude::StandardMaterial> {
        let output: Val<bevy::pbr::prelude::StandardMaterial> =<bevy::pbr::prelude::StandardMaterial as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Flip the texture coordinates of the material.
    
    fn flip (mut _self:Mut<bevy::pbr::prelude::StandardMaterial>,horizontal:bool,vertical:bool,) -> () {
        let output: () =bevy::pbr::prelude::StandardMaterial::flip(&mut _self,horizontal,vertical,).into();
        output
    }


    
    ///  Consumes the material and returns a material with flipped texture coordinates
    
    fn flipped (_self:Val<bevy::pbr::prelude::StandardMaterial>,horizontal:bool,vertical:bool,) -> Val<bevy::pbr::prelude::StandardMaterial> {
        let output: Val<bevy::pbr::prelude::StandardMaterial> =bevy::pbr::prelude::StandardMaterial::flipped(_self.into_inner(),horizontal,vertical,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "screen_space_ambient_occlusion_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::ScreenSpaceAmbientOcclusion {


    
    fn clone (_self:Ref<bevy::pbr::ScreenSpaceAmbientOcclusion>,) -> Val<bevy::pbr::ScreenSpaceAmbientOcclusion> {
        let output: Val<bevy::pbr::ScreenSpaceAmbientOcclusion> =<bevy::pbr::ScreenSpaceAmbientOcclusion as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::pbr::ScreenSpaceAmbientOcclusion>,other:Ref<bevy::pbr::ScreenSpaceAmbientOcclusion>,) -> bool {
        let output: bool =<bevy::pbr::ScreenSpaceAmbientOcclusion as ::std::cmp::PartialEq::<bevy::pbr::ScreenSpaceAmbientOcclusion>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "screen_space_reflections_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::ScreenSpaceReflections {


    
    fn clone (_self:Ref<bevy::pbr::ScreenSpaceReflections>,) -> Val<bevy::pbr::ScreenSpaceReflections> {
        let output: Val<bevy::pbr::ScreenSpaceReflections> =<bevy::pbr::ScreenSpaceReflections as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cascade_shadow_config_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::CascadeShadowConfig {


    
    fn clone (_self:Ref<bevy::pbr::CascadeShadowConfig>,) -> Val<bevy::pbr::CascadeShadowConfig> {
        let output: Val<bevy::pbr::CascadeShadowConfig> =<bevy::pbr::CascadeShadowConfig as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cascades_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::Cascades {


    
    fn clone (_self:Ref<bevy::pbr::Cascades>,) -> Val<bevy::pbr::Cascades> {
        let output: Val<bevy::pbr::Cascades> =<bevy::pbr::Cascades as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cascades_visible_entities_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::CascadesVisibleEntities {


    
    fn clone (_self:Ref<bevy::pbr::CascadesVisibleEntities>,) -> Val<bevy::pbr::CascadesVisibleEntities> {
        let output: Val<bevy::pbr::CascadesVisibleEntities> =<bevy::pbr::CascadesVisibleEntities as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "visible_mesh_entities_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::VisibleMeshEntities {


    
    fn clone (_self:Ref<bevy::pbr::VisibleMeshEntities>,) -> Val<bevy::pbr::VisibleMeshEntities> {
        let output: Val<bevy::pbr::VisibleMeshEntities> =<bevy::pbr::VisibleMeshEntities as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cluster_config_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::ClusterConfig {


    
    fn clone (_self:Ref<bevy::pbr::ClusterConfig>,) -> Val<bevy::pbr::ClusterConfig> {
        let output: Val<bevy::pbr::ClusterConfig> =<bevy::pbr::ClusterConfig as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cubemap_visible_entities_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::CubemapVisibleEntities {


    
    fn clone (_self:Ref<bevy::pbr::CubemapVisibleEntities>,) -> Val<bevy::pbr::CubemapVisibleEntities> {
        let output: Val<bevy::pbr::CubemapVisibleEntities> =<bevy::pbr::CubemapVisibleEntities as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "directional_light_shadow_map_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::DirectionalLightShadowMap {


    
    fn clone (_self:Ref<bevy::pbr::DirectionalLightShadowMap>,) -> Val<bevy::pbr::DirectionalLightShadowMap> {
        let output: Val<bevy::pbr::DirectionalLightShadowMap> =<bevy::pbr::DirectionalLightShadowMap as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "not_shadow_caster_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::NotShadowCaster {
     
}

#[script_bindings(
    remote,
    name = "not_shadow_receiver_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::NotShadowReceiver {
     
}

#[script_bindings(
    remote,
    name = "point_light_shadow_map_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::PointLightShadowMap {


    
    fn clone (_self:Ref<bevy::pbr::PointLightShadowMap>,) -> Val<bevy::pbr::PointLightShadowMap> {
        let output: Val<bevy::pbr::PointLightShadowMap> =<bevy::pbr::PointLightShadowMap as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "shadow_filtering_method_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::ShadowFilteringMethod {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::pbr::ShadowFilteringMethod>,) -> () {
        let output: () =<bevy::pbr::ShadowFilteringMethod as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::pbr::ShadowFilteringMethod>,) -> Val<bevy::pbr::ShadowFilteringMethod> {
        let output: Val<bevy::pbr::ShadowFilteringMethod> =<bevy::pbr::ShadowFilteringMethod as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::pbr::ShadowFilteringMethod>,other:Ref<bevy::pbr::ShadowFilteringMethod>,) -> bool {
        let output: bool =<bevy::pbr::ShadowFilteringMethod as ::std::cmp::PartialEq::<bevy::pbr::ShadowFilteringMethod>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "default_opaque_renderer_method_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::DefaultOpaqueRendererMethod {


    
    fn clone (_self:Ref<bevy::pbr::DefaultOpaqueRendererMethod>,) -> Val<bevy::pbr::DefaultOpaqueRendererMethod> {
        let output: Val<bevy::pbr::DefaultOpaqueRendererMethod> =<bevy::pbr::DefaultOpaqueRendererMethod as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn deferred () -> Val<bevy::pbr::DefaultOpaqueRendererMethod> {
        let output: Val<bevy::pbr::DefaultOpaqueRendererMethod> =bevy::pbr::DefaultOpaqueRendererMethod::deferred().into();
        output
    }


    
    fn forward () -> Val<bevy::pbr::DefaultOpaqueRendererMethod> {
        let output: Val<bevy::pbr::DefaultOpaqueRendererMethod> =bevy::pbr::DefaultOpaqueRendererMethod::forward().into();
        output
    }


    
    fn set_to_deferred (mut _self:Mut<bevy::pbr::DefaultOpaqueRendererMethod>,) -> () {
        let output: () =bevy::pbr::DefaultOpaqueRendererMethod::set_to_deferred(&mut _self,).into();
        output
    }


    
    fn set_to_forward (mut _self:Mut<bevy::pbr::DefaultOpaqueRendererMethod>,) -> () {
        let output: () =bevy::pbr::DefaultOpaqueRendererMethod::set_to_forward(&mut _self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "wireframe_material_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::wireframe::WireframeMaterial {


    
    fn clone (_self:Ref<bevy::pbr::wireframe::WireframeMaterial>,) -> Val<bevy::pbr::wireframe::WireframeMaterial> {
        let output: Val<bevy::pbr::wireframe::WireframeMaterial> =<bevy::pbr::wireframe::WireframeMaterial as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "no_wireframe_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::wireframe::NoWireframe {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::pbr::wireframe::NoWireframe>,) -> () {
        let output: () =<bevy::pbr::wireframe::NoWireframe as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::pbr::wireframe::NoWireframe>,) -> Val<bevy::pbr::wireframe::NoWireframe> {
        let output: Val<bevy::pbr::wireframe::NoWireframe> =<bevy::pbr::wireframe::NoWireframe as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::pbr::wireframe::NoWireframe>,other:Ref<bevy::pbr::wireframe::NoWireframe>,) -> bool {
        let output: bool =<bevy::pbr::wireframe::NoWireframe as ::std::cmp::PartialEq::<bevy::pbr::wireframe::NoWireframe>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "wireframe_config_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::wireframe::WireframeConfig {


    
    fn clone (_self:Ref<bevy::pbr::wireframe::WireframeConfig>,) -> Val<bevy::pbr::wireframe::WireframeConfig> {
        let output: Val<bevy::pbr::wireframe::WireframeConfig> =<bevy::pbr::wireframe::WireframeConfig as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "wireframe_color_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::wireframe::WireframeColor {


    
    fn clone (_self:Ref<bevy::pbr::wireframe::WireframeColor>,) -> Val<bevy::pbr::wireframe::WireframeColor> {
        let output: Val<bevy::pbr::wireframe::WireframeColor> =<bevy::pbr::wireframe::WireframeColor as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "wireframe_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::wireframe::Wireframe {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::pbr::wireframe::Wireframe>,) -> () {
        let output: () =<bevy::pbr::wireframe::Wireframe as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::pbr::wireframe::Wireframe>,) -> Val<bevy::pbr::wireframe::Wireframe> {
        let output: Val<bevy::pbr::wireframe::Wireframe> =<bevy::pbr::wireframe::Wireframe as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::pbr::wireframe::Wireframe>,other:Ref<bevy::pbr::wireframe::Wireframe>,) -> bool {
        let output: bool =<bevy::pbr::wireframe::Wireframe as ::std::cmp::PartialEq::<bevy::pbr::wireframe::Wireframe>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "mesh_3_d_wireframe_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::wireframe::Mesh3dWireframe {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::pbr::wireframe::Mesh3dWireframe>,) -> () {
        let output: () =<bevy::pbr::wireframe::Mesh3dWireframe as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::pbr::wireframe::Mesh3dWireframe>,) -> Val<bevy::pbr::wireframe::Mesh3dWireframe> {
        let output: Val<bevy::pbr::wireframe::Mesh3dWireframe> =<bevy::pbr::wireframe::Mesh3dWireframe as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::pbr::wireframe::Mesh3dWireframe>,other:Ref<bevy::pbr::wireframe::Mesh3dWireframe>,) -> bool {
        let output: bool =<bevy::pbr::wireframe::Mesh3dWireframe as ::std::cmp::PartialEq::<bevy::pbr::wireframe::Mesh3dWireframe>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "atmosphere_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::Atmosphere {


    
    fn clone (_self:Ref<bevy::pbr::Atmosphere>,) -> Val<bevy::pbr::Atmosphere> {
        let output: Val<bevy::pbr::Atmosphere> =<bevy::pbr::Atmosphere as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn with_density_multiplier (_self:Val<bevy::pbr::Atmosphere>,mult:f32,) -> Val<bevy::pbr::Atmosphere> {
        let output: Val<bevy::pbr::Atmosphere> =bevy::pbr::Atmosphere::with_density_multiplier(_self.into_inner(),mult,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "atmosphere_settings_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::AtmosphereSettings {


    
    fn clone (_self:Ref<bevy::pbr::AtmosphereSettings>,) -> Val<bevy::pbr::AtmosphereSettings> {
        let output: Val<bevy::pbr::AtmosphereSettings> =<bevy::pbr::AtmosphereSettings as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cluster_far_z_mode_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::ClusterFarZMode {


    
    fn clone (_self:Ref<bevy::pbr::ClusterFarZMode>,) -> Val<bevy::pbr::ClusterFarZMode> {
        let output: Val<bevy::pbr::ClusterFarZMode> =<bevy::pbr::ClusterFarZMode as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cluster_z_config_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::ClusterZConfig {


    
    fn clone (_self:Ref<bevy::pbr::ClusterZConfig>,) -> Val<bevy::pbr::ClusterZConfig> {
        let output: Val<bevy::pbr::ClusterZConfig> =<bevy::pbr::ClusterZConfig as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "clustered_decal_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::decal::clustered::ClusteredDecal {


    
    fn clone (_self:Ref<bevy::pbr::decal::clustered::ClusteredDecal>,) -> Val<bevy::pbr::decal::clustered::ClusteredDecal> {
        let output: Val<bevy::pbr::decal::clustered::ClusteredDecal> =<bevy::pbr::decal::clustered::ClusteredDecal as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "irradiance_volume_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::irradiance_volume::IrradianceVolume {


    
    fn clone (_self:Ref<bevy::pbr::irradiance_volume::IrradianceVolume>,) -> Val<bevy::pbr::irradiance_volume::IrradianceVolume> {
        let output: Val<bevy::pbr::irradiance_volume::IrradianceVolume> =<bevy::pbr::irradiance_volume::IrradianceVolume as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "render_visible_mesh_entities_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::RenderVisibleMeshEntities {


    
    fn clone (_self:Ref<bevy::pbr::RenderVisibleMeshEntities>,) -> Val<bevy::pbr::RenderVisibleMeshEntities> {
        let output: Val<bevy::pbr::RenderVisibleMeshEntities> =<bevy::pbr::RenderVisibleMeshEntities as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "render_cubemap_visible_entities_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::RenderCubemapVisibleEntities {


    
    fn clone (_self:Ref<bevy::pbr::RenderCubemapVisibleEntities>,) -> Val<bevy::pbr::RenderCubemapVisibleEntities> {
        let output: Val<bevy::pbr::RenderCubemapVisibleEntities> =<bevy::pbr::RenderCubemapVisibleEntities as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "render_cascades_visible_entities_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::RenderCascadesVisibleEntities {


    
    fn clone (_self:Ref<bevy::pbr::RenderCascadesVisibleEntities>,) -> Val<bevy::pbr::RenderCascadesVisibleEntities> {
        let output: Val<bevy::pbr::RenderCascadesVisibleEntities> =<bevy::pbr::RenderCascadesVisibleEntities as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "forward_decal_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::decal::ForwardDecal {
     
}

#[script_bindings(
    remote,
    name = "opaque_renderer_method_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::OpaqueRendererMethod {


    
    fn clone (_self:Ref<bevy::pbr::OpaqueRendererMethod>,) -> Val<bevy::pbr::OpaqueRendererMethod> {
        let output: Val<bevy::pbr::OpaqueRendererMethod> =<bevy::pbr::OpaqueRendererMethod as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::pbr::OpaqueRendererMethod>,other:Ref<bevy::pbr::OpaqueRendererMethod>,) -> bool {
        let output: bool =<bevy::pbr::OpaqueRendererMethod as ::std::cmp::PartialEq::<bevy::pbr::OpaqueRendererMethod>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cascade_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::Cascade {


    
    fn clone (_self:Ref<bevy::pbr::Cascade>,) -> Val<bevy::pbr::Cascade> {
        let output: Val<bevy::pbr::Cascade> =<bevy::pbr::Cascade as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "transmitted_shadow_receiver_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::TransmittedShadowReceiver {
     
}

#[script_bindings(
    remote,
    name = "lightmap_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::Lightmap {


    
    fn clone (_self:Ref<bevy::pbr::Lightmap>,) -> Val<bevy::pbr::Lightmap> {
        let output: Val<bevy::pbr::Lightmap> =<bevy::pbr::Lightmap as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "material_binding_id_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::MaterialBindingId {


    
    fn clone (_self:Ref<bevy::pbr::MaterialBindingId>,) -> Val<bevy::pbr::MaterialBindingId> {
        let output: Val<bevy::pbr::MaterialBindingId> =<bevy::pbr::MaterialBindingId as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "material_bind_group_slot_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::MaterialBindGroupSlot {


    
    fn clone (_self:Ref<bevy::pbr::MaterialBindGroupSlot>,) -> Val<bevy::pbr::MaterialBindGroupSlot> {
        let output: Val<bevy::pbr::MaterialBindGroupSlot> =<bevy::pbr::MaterialBindGroupSlot as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::pbr::MaterialBindGroupSlot>,other:Ref<bevy::pbr::MaterialBindGroupSlot>,) -> bool {
        let output: bool =<bevy::pbr::MaterialBindGroupSlot as ::std::cmp::PartialEq::<bevy::pbr::MaterialBindGroupSlot>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "material_bind_group_index_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::MaterialBindGroupIndex {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::pbr::MaterialBindGroupIndex>,) -> () {
        let output: () =<bevy::pbr::MaterialBindGroupIndex as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::pbr::MaterialBindGroupIndex>,) -> Val<bevy::pbr::MaterialBindGroupIndex> {
        let output: Val<bevy::pbr::MaterialBindGroupIndex> =<bevy::pbr::MaterialBindGroupIndex as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::pbr::MaterialBindGroupIndex>,other:Ref<bevy::pbr::MaterialBindGroupIndex>,) -> bool {
        let output: bool =<bevy::pbr::MaterialBindGroupIndex as ::std::cmp::PartialEq::<bevy::pbr::MaterialBindGroupIndex>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "uv_channel_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::UvChannel {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::pbr::UvChannel>,) -> () {
        let output: () =<bevy::pbr::UvChannel as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::pbr::UvChannel>,) -> Val<bevy::pbr::UvChannel> {
        let output: Val<bevy::pbr::UvChannel> =<bevy::pbr::UvChannel as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::pbr::UvChannel>,other:Ref<bevy::pbr::UvChannel>,) -> bool {
        let output: bool =<bevy::pbr::UvChannel as ::std::cmp::PartialEq::<bevy::pbr::UvChannel>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "screen_space_ambient_occlusion_quality_level_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::pbr::ScreenSpaceAmbientOcclusionQualityLevel {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::pbr::ScreenSpaceAmbientOcclusionQualityLevel>,) -> () {
        let output: () =<bevy::pbr::ScreenSpaceAmbientOcclusionQualityLevel as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::pbr::ScreenSpaceAmbientOcclusionQualityLevel>,) -> Val<bevy::pbr::ScreenSpaceAmbientOcclusionQualityLevel> {
        let output: Val<bevy::pbr::ScreenSpaceAmbientOcclusionQualityLevel> =<bevy::pbr::ScreenSpaceAmbientOcclusionQualityLevel as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::pbr::ScreenSpaceAmbientOcclusionQualityLevel>,other:Ref<bevy::pbr::ScreenSpaceAmbientOcclusionQualityLevel>,) -> bool {
        let output: bool =<bevy::pbr::ScreenSpaceAmbientOcclusionQualityLevel as ::std::cmp::PartialEq::<bevy::pbr::ScreenSpaceAmbientOcclusionQualityLevel>>::eq(&_self,&other,).into();
        output
    }
     
}


impl ::bevy::app::Plugin for BevyPbrScriptingPlugin {
    fn build(&self, app: &mut ::bevy::prelude::App) {
        let mut world = app.world_mut();

        
            register_fog_volume_functions(&mut world);
        
            register_volumetric_fog_functions(&mut world);
        
            register_volumetric_light_functions(&mut world);
        
            register_distance_fog_functions(&mut world);
        
            register_fog_falloff_functions(&mut world);
        
            register_ambient_light_functions(&mut world);
        
            register_directional_light_functions(&mut world);
        
            register_point_light_functions(&mut world);
        
            register_spot_light_functions(&mut world);
        
            register_environment_map_light_functions(&mut world);
        
            register_light_probe_functions(&mut world);
        
            register_parallax_mapping_method_functions(&mut world);
        
            register_standard_material_functions(&mut world);
        
            register_screen_space_ambient_occlusion_functions(&mut world);
        
            register_screen_space_reflections_functions(&mut world);
        
            register_cascade_shadow_config_functions(&mut world);
        
            register_cascades_functions(&mut world);
        
            register_cascades_visible_entities_functions(&mut world);
        
            register_visible_mesh_entities_functions(&mut world);
        
            register_cluster_config_functions(&mut world);
        
            register_cubemap_visible_entities_functions(&mut world);
        
            register_directional_light_shadow_map_functions(&mut world);
        
            register_not_shadow_caster_functions(&mut world);
        
            register_not_shadow_receiver_functions(&mut world);
        
            register_point_light_shadow_map_functions(&mut world);
        
            register_shadow_filtering_method_functions(&mut world);
        
            register_default_opaque_renderer_method_functions(&mut world);
        
            register_wireframe_material_functions(&mut world);
        
            register_no_wireframe_functions(&mut world);
        
            register_wireframe_config_functions(&mut world);
        
            register_wireframe_color_functions(&mut world);
        
            register_wireframe_functions(&mut world);
        
            register_mesh_3_d_wireframe_functions(&mut world);
        
            register_atmosphere_functions(&mut world);
        
            register_atmosphere_settings_functions(&mut world);
        
            register_cluster_far_z_mode_functions(&mut world);
        
            register_cluster_z_config_functions(&mut world);
        
            register_clustered_decal_functions(&mut world);
        
            register_irradiance_volume_functions(&mut world);
        
            register_render_visible_mesh_entities_functions(&mut world);
        
            register_render_cubemap_visible_entities_functions(&mut world);
        
            register_render_cascades_visible_entities_functions(&mut world);
        
            register_forward_decal_functions(&mut world);
        
            register_opaque_renderer_method_functions(&mut world);
        
            register_cascade_functions(&mut world);
        
            register_transmitted_shadow_receiver_functions(&mut world);
        
            register_lightmap_functions(&mut world);
        
            register_material_binding_id_functions(&mut world);
        
            register_material_bind_group_slot_functions(&mut world);
        
            register_material_bind_group_index_functions(&mut world);
        
            register_uv_channel_functions(&mut world);
        
            register_screen_space_ambient_occlusion_quality_level_functions(&mut world);
        
    }
}
