// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use bevy_mod_scripting_core::{
    bindings::{
        ReflectReference, 
        function::{from::{Ref, Mut, Val}, namespace::{NamespaceBuilder}}
    }
};
use bevy_ecs::{prelude::*};


use bevy_mod_scripting_derive::script_bindings;


use crate::*;







pub struct BevyPbrScriptingPlugin;


#[script_bindings(
    remote,
    name = "fog_volume_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::FogVolume {


    
    fn clone (_self: Ref<::bevy_pbr::FogVolume>,) -> Val<::bevy_pbr::FogVolume> {
        let output: Val<::bevy_pbr::FogVolume> =<::bevy_pbr::FogVolume as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "volumetric_fog_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::VolumetricFog {


    
    fn clone (_self: Ref<::bevy_pbr::VolumetricFog>,) -> Val<::bevy_pbr::VolumetricFog> {
        let output: Val<::bevy_pbr::VolumetricFog> =<::bevy_pbr::VolumetricFog as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "volumetric_light_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::VolumetricLight {


    
    fn clone (_self: Ref<::bevy_pbr::VolumetricLight>,) -> Val<::bevy_pbr::VolumetricLight> {
        let output: Val<::bevy_pbr::VolumetricLight> =<::bevy_pbr::VolumetricLight as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "distance_fog_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::prelude::DistanceFog {


    
    fn clone (_self: Ref<::bevy_pbr::prelude::DistanceFog>,) -> Val<::bevy_pbr::prelude::DistanceFog> {
        let output: Val<::bevy_pbr::prelude::DistanceFog> =<::bevy_pbr::prelude::DistanceFog as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "fog_falloff_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::prelude::FogFalloff {


    
    fn clone (_self: Ref<::bevy_pbr::prelude::FogFalloff>,) -> Val<::bevy_pbr::prelude::FogFalloff> {
        let output: Val<::bevy_pbr::prelude::FogFalloff> =<::bevy_pbr::prelude::FogFalloff as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a [`FogFalloff::Exponential`] value from the given visibility distance in world units,
    
    ///  using the revised Koschmieder contrast threshold, [`FogFalloff::REVISED_KOSCHMIEDER_CONTRAST_THRESHOLD`].
    
    fn from_visibility (visibility: f32,) -> Val<::bevy_pbr::prelude::FogFalloff> {
        let output: Val<::bevy_pbr::prelude::FogFalloff> =::bevy_pbr::prelude::FogFalloff::from_visibility(visibility,).into();
        output
    }


    
    ///  Creates a [`FogFalloff::Atmospheric`] value from the given visibility distance in world units,
    
    ///  and a shared color for both extinction and inscattering, using the revised Koschmieder contrast threshold,
    
    ///  [`FogFalloff::REVISED_KOSCHMIEDER_CONTRAST_THRESHOLD`].
    
    fn from_visibility_color (visibility: f32,extinction_inscattering_color: Val<::bevy_color::Color>,) -> Val<::bevy_pbr::prelude::FogFalloff> {
        let output: Val<::bevy_pbr::prelude::FogFalloff> =::bevy_pbr::prelude::FogFalloff::from_visibility_color(visibility,extinction_inscattering_color.into_inner(),).into();
        output
    }


    
    ///  Creates a [`FogFalloff::Atmospheric`] value from the given visibility distance in world units,
    
    ///  extinction and inscattering colors, using the revised Koschmieder contrast threshold,
    
    ///  [`FogFalloff::REVISED_KOSCHMIEDER_CONTRAST_THRESHOLD`].
    
    ///  ## Tips
    
    ///  - Alpha values of the provided colors can modulate the `extinction` and `inscattering` effects;
    
    ///  - Using an `extinction_color` of [`Color::WHITE`] or [`Color::NONE`] disables the extinction effect;
    
    ///  - Using an `inscattering_color` of [`Color::BLACK`] or [`Color::NONE`] disables the inscattering effect.
    
    fn from_visibility_colors (visibility: f32,extinction_color: Val<::bevy_color::Color>,inscattering_color: Val<::bevy_color::Color>,) -> Val<::bevy_pbr::prelude::FogFalloff> {
        let output: Val<::bevy_pbr::prelude::FogFalloff> =::bevy_pbr::prelude::FogFalloff::from_visibility_colors(visibility,extinction_color.into_inner(),inscattering_color.into_inner(),).into();
        output
    }


    
    ///  Creates a [`FogFalloff::Exponential`] value from the given visibility distance in world units,
    
    ///  and a given contrast threshold in the range of `0.0` to `1.0`.
    
    fn from_visibility_contrast (visibility: f32,contrast_threshold: f32,) -> Val<::bevy_pbr::prelude::FogFalloff> {
        let output: Val<::bevy_pbr::prelude::FogFalloff> =::bevy_pbr::prelude::FogFalloff::from_visibility_contrast(visibility,contrast_threshold,).into();
        output
    }


    
    ///  Creates a [`FogFalloff::Atmospheric`] value from the given visibility distance in world units,
    
    ///  a contrast threshold in the range of `0.0` to `1.0`, and a shared color for both extinction and inscattering.
    
    fn from_visibility_contrast_color (visibility: f32,contrast_threshold: f32,extinction_inscattering_color: Val<::bevy_color::Color>,) -> Val<::bevy_pbr::prelude::FogFalloff> {
        let output: Val<::bevy_pbr::prelude::FogFalloff> =::bevy_pbr::prelude::FogFalloff::from_visibility_contrast_color(visibility,contrast_threshold,extinction_inscattering_color.into_inner(),).into();
        output
    }


    
    ///  Creates a [`FogFalloff::Atmospheric`] value from the given visibility distance in world units,
    
    ///  a contrast threshold in the range of `0.0` to `1.0`, extinction and inscattering colors.
    
    ///  ## Tips
    
    ///  - Alpha values of the provided colors can modulate the `extinction` and `inscattering` effects;
    
    ///  - Using an `extinction_color` of [`Color::WHITE`] or [`Color::NONE`] disables the extinction effect;
    
    ///  - Using an `inscattering_color` of [`Color::BLACK`] or [`Color::NONE`] disables the inscattering effect.
    
    fn from_visibility_contrast_colors (visibility: f32,contrast_threshold: f32,extinction_color: Val<::bevy_color::Color>,inscattering_color: Val<::bevy_color::Color>,) -> Val<::bevy_pbr::prelude::FogFalloff> {
        let output: Val<::bevy_pbr::prelude::FogFalloff> =::bevy_pbr::prelude::FogFalloff::from_visibility_contrast_colors(visibility,contrast_threshold,extinction_color.into_inner(),inscattering_color.into_inner(),).into();
        output
    }


    
    ///  Creates a [`FogFalloff::ExponentialSquared`] value from the given visibility distance in world units,
    
    ///  and a given contrast threshold in the range of `0.0` to `1.0`.
    
    fn from_visibility_contrast_squared (visibility: f32,contrast_threshold: f32,) -> Val<::bevy_pbr::prelude::FogFalloff> {
        let output: Val<::bevy_pbr::prelude::FogFalloff> =::bevy_pbr::prelude::FogFalloff::from_visibility_contrast_squared(visibility,contrast_threshold,).into();
        output
    }


    
    ///  Creates a [`FogFalloff::ExponentialSquared`] value from the given visibility distance in world units,
    
    ///  using the revised Koschmieder contrast threshold, [`FogFalloff::REVISED_KOSCHMIEDER_CONTRAST_THRESHOLD`].
    
    fn from_visibility_squared (visibility: f32,) -> Val<::bevy_pbr::prelude::FogFalloff> {
        let output: Val<::bevy_pbr::prelude::FogFalloff> =::bevy_pbr::prelude::FogFalloff::from_visibility_squared(visibility,).into();
        output
    }


    
    ///  Calculates the extinction coefficient β, from V and Cₜ, where:
    
    ///  - Cₜ is the contrast threshold, in the range of `0.0` to `1.0`
    
    ///  - V is the visibility distance in which a perfectly black object is still identifiable
    
    ///    against the horizon sky within the contrast threshold
    
    ///  We start with Koschmieder's equation:
    
    ///  ```text
    
    ///        -ln(Cₜ)
    
    ///   V = ─────────
    
    ///           β
    
    ///  ```
    
    ///  Multiplying both sides by β/V, that gives us:
    
    ///  ```text
    
    ///        -ln(Cₜ)
    
    ///   β = ─────────
    
    ///           V
    
    ///  ```
    
    ///  See:
    
    ///  - <https://en.wikipedia.org/wiki/Visibility>
    
    ///  - <https://www.biral.com/wp-content/uploads/2015/02/Introduction_to_visibility-v2-2.pdf>
    
    fn koschmieder (v: f32,c_t: f32,) -> f32 {
        let output: f32 =::bevy_pbr::prelude::FogFalloff::koschmieder(v,c_t,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "ambient_light_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::prelude::AmbientLight {


    
    fn clone (_self: Ref<::bevy_pbr::prelude::AmbientLight>,) -> Val<::bevy_pbr::prelude::AmbientLight> {
        let output: Val<::bevy_pbr::prelude::AmbientLight> =<::bevy_pbr::prelude::AmbientLight as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "directional_light_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::prelude::DirectionalLight {


    
    fn clone (_self: Ref<::bevy_pbr::prelude::DirectionalLight>,) -> Val<::bevy_pbr::prelude::DirectionalLight> {
        let output: Val<::bevy_pbr::prelude::DirectionalLight> =<::bevy_pbr::prelude::DirectionalLight as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "point_light_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::prelude::PointLight {


    
    fn clone (_self: Ref<::bevy_pbr::prelude::PointLight>,) -> Val<::bevy_pbr::prelude::PointLight> {
        let output: Val<::bevy_pbr::prelude::PointLight> =<::bevy_pbr::prelude::PointLight as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "spot_light_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::prelude::SpotLight {


    
    fn clone (_self: Ref<::bevy_pbr::prelude::SpotLight>,) -> Val<::bevy_pbr::prelude::SpotLight> {
        let output: Val<::bevy_pbr::prelude::SpotLight> =<::bevy_pbr::prelude::SpotLight as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "environment_map_light_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::prelude::EnvironmentMapLight {


    
    fn clone (_self: Ref<::bevy_pbr::prelude::EnvironmentMapLight>,) -> Val<::bevy_pbr::prelude::EnvironmentMapLight> {
        let output: Val<::bevy_pbr::prelude::EnvironmentMapLight> =<::bevy_pbr::prelude::EnvironmentMapLight as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "light_probe_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::prelude::LightProbe {


    
    fn clone (_self: Ref<::bevy_pbr::prelude::LightProbe>,) -> Val<::bevy_pbr::prelude::LightProbe> {
        let output: Val<::bevy_pbr::prelude::LightProbe> =<::bevy_pbr::prelude::LightProbe as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new light probe component.
    
    fn new () -> Val<::bevy_pbr::prelude::LightProbe> {
        let output: Val<::bevy_pbr::prelude::LightProbe> =::bevy_pbr::prelude::LightProbe::new().into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "parallax_mapping_method_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::prelude::ParallaxMappingMethod {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_pbr::prelude::ParallaxMappingMethod>,) -> () {
        let output: () =<::bevy_pbr::prelude::ParallaxMappingMethod as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_pbr::prelude::ParallaxMappingMethod>,) -> Val<::bevy_pbr::prelude::ParallaxMappingMethod> {
        let output: Val<::bevy_pbr::prelude::ParallaxMappingMethod> =<::bevy_pbr::prelude::ParallaxMappingMethod as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_pbr::prelude::ParallaxMappingMethod>,other: Ref<::bevy_pbr::prelude::ParallaxMappingMethod>,) -> bool {
        let output: bool =<::bevy_pbr::prelude::ParallaxMappingMethod as ::std::cmp::PartialEq::<::bevy_pbr::prelude::ParallaxMappingMethod>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "standard_material_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::prelude::StandardMaterial {


    
    fn clone (_self: Ref<::bevy_pbr::prelude::StandardMaterial>,) -> Val<::bevy_pbr::prelude::StandardMaterial> {
        let output: Val<::bevy_pbr::prelude::StandardMaterial> =<::bevy_pbr::prelude::StandardMaterial as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Flip the texture coordinates of the material.
    
    fn flip (mut _self: Mut<::bevy_pbr::prelude::StandardMaterial>,horizontal: bool,vertical: bool,) -> () {
        let output: () =::bevy_pbr::prelude::StandardMaterial::flip(&mut _self,horizontal,vertical,).into();
        output
    }


    
    ///  Consumes the material and returns a material with flipped texture coordinates
    
    fn flipped (_self: Val<::bevy_pbr::prelude::StandardMaterial>,horizontal: bool,vertical: bool,) -> Val<::bevy_pbr::prelude::StandardMaterial> {
        let output: Val<::bevy_pbr::prelude::StandardMaterial> =::bevy_pbr::prelude::StandardMaterial::flipped(_self.into_inner(),horizontal,vertical,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "screen_space_ambient_occlusion_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::ScreenSpaceAmbientOcclusion {


    
    fn clone (_self: Ref<::bevy_pbr::ScreenSpaceAmbientOcclusion>,) -> Val<::bevy_pbr::ScreenSpaceAmbientOcclusion> {
        let output: Val<::bevy_pbr::ScreenSpaceAmbientOcclusion> =<::bevy_pbr::ScreenSpaceAmbientOcclusion as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_pbr::ScreenSpaceAmbientOcclusion>,other: Ref<::bevy_pbr::ScreenSpaceAmbientOcclusion>,) -> bool {
        let output: bool =<::bevy_pbr::ScreenSpaceAmbientOcclusion as ::std::cmp::PartialEq::<::bevy_pbr::ScreenSpaceAmbientOcclusion>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "screen_space_reflections_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::ScreenSpaceReflections {


    
    fn clone (_self: Ref<::bevy_pbr::ScreenSpaceReflections>,) -> Val<::bevy_pbr::ScreenSpaceReflections> {
        let output: Val<::bevy_pbr::ScreenSpaceReflections> =<::bevy_pbr::ScreenSpaceReflections as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cascade_shadow_config_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::CascadeShadowConfig {


    
    fn clone (_self: Ref<::bevy_pbr::CascadeShadowConfig>,) -> Val<::bevy_pbr::CascadeShadowConfig> {
        let output: Val<::bevy_pbr::CascadeShadowConfig> =<::bevy_pbr::CascadeShadowConfig as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cascades_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::Cascades {


    
    fn clone (_self: Ref<::bevy_pbr::Cascades>,) -> Val<::bevy_pbr::Cascades> {
        let output: Val<::bevy_pbr::Cascades> =<::bevy_pbr::Cascades as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cascades_visible_entities_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::CascadesVisibleEntities {


    
    fn clone (_self: Ref<::bevy_pbr::CascadesVisibleEntities>,) -> Val<::bevy_pbr::CascadesVisibleEntities> {
        let output: Val<::bevy_pbr::CascadesVisibleEntities> =<::bevy_pbr::CascadesVisibleEntities as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "visible_mesh_entities_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::VisibleMeshEntities {


    
    fn clone (_self: Ref<::bevy_pbr::VisibleMeshEntities>,) -> Val<::bevy_pbr::VisibleMeshEntities> {
        let output: Val<::bevy_pbr::VisibleMeshEntities> =<::bevy_pbr::VisibleMeshEntities as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cluster_config_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::ClusterConfig {


    
    fn clone (_self: Ref<::bevy_pbr::ClusterConfig>,) -> Val<::bevy_pbr::ClusterConfig> {
        let output: Val<::bevy_pbr::ClusterConfig> =<::bevy_pbr::ClusterConfig as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cubemap_visible_entities_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::CubemapVisibleEntities {


    
    fn clone (_self: Ref<::bevy_pbr::CubemapVisibleEntities>,) -> Val<::bevy_pbr::CubemapVisibleEntities> {
        let output: Val<::bevy_pbr::CubemapVisibleEntities> =<::bevy_pbr::CubemapVisibleEntities as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "directional_light_shadow_map_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::DirectionalLightShadowMap {


    
    fn clone (_self: Ref<::bevy_pbr::DirectionalLightShadowMap>,) -> Val<::bevy_pbr::DirectionalLightShadowMap> {
        let output: Val<::bevy_pbr::DirectionalLightShadowMap> =<::bevy_pbr::DirectionalLightShadowMap as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "not_shadow_caster_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::NotShadowCaster {
     
}

#[script_bindings(
    remote,
    name = "not_shadow_receiver_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::NotShadowReceiver {
     
}

#[script_bindings(
    remote,
    name = "point_light_shadow_map_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::PointLightShadowMap {


    
    fn clone (_self: Ref<::bevy_pbr::PointLightShadowMap>,) -> Val<::bevy_pbr::PointLightShadowMap> {
        let output: Val<::bevy_pbr::PointLightShadowMap> =<::bevy_pbr::PointLightShadowMap as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "shadow_filtering_method_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::ShadowFilteringMethod {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_pbr::ShadowFilteringMethod>,) -> () {
        let output: () =<::bevy_pbr::ShadowFilteringMethod as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_pbr::ShadowFilteringMethod>,) -> Val<::bevy_pbr::ShadowFilteringMethod> {
        let output: Val<::bevy_pbr::ShadowFilteringMethod> =<::bevy_pbr::ShadowFilteringMethod as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_pbr::ShadowFilteringMethod>,other: Ref<::bevy_pbr::ShadowFilteringMethod>,) -> bool {
        let output: bool =<::bevy_pbr::ShadowFilteringMethod as ::std::cmp::PartialEq::<::bevy_pbr::ShadowFilteringMethod>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "default_opaque_renderer_method_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::DefaultOpaqueRendererMethod {


    
    fn clone (_self: Ref<::bevy_pbr::DefaultOpaqueRendererMethod>,) -> Val<::bevy_pbr::DefaultOpaqueRendererMethod> {
        let output: Val<::bevy_pbr::DefaultOpaqueRendererMethod> =<::bevy_pbr::DefaultOpaqueRendererMethod as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn deferred () -> Val<::bevy_pbr::DefaultOpaqueRendererMethod> {
        let output: Val<::bevy_pbr::DefaultOpaqueRendererMethod> =::bevy_pbr::DefaultOpaqueRendererMethod::deferred().into();
        output
    }


    
    fn forward () -> Val<::bevy_pbr::DefaultOpaqueRendererMethod> {
        let output: Val<::bevy_pbr::DefaultOpaqueRendererMethod> =::bevy_pbr::DefaultOpaqueRendererMethod::forward().into();
        output
    }


    
    fn set_to_deferred (mut _self: Mut<::bevy_pbr::DefaultOpaqueRendererMethod>,) -> () {
        let output: () =::bevy_pbr::DefaultOpaqueRendererMethod::set_to_deferred(&mut _self,).into();
        output
    }


    
    fn set_to_forward (mut _self: Mut<::bevy_pbr::DefaultOpaqueRendererMethod>,) -> () {
        let output: () =::bevy_pbr::DefaultOpaqueRendererMethod::set_to_forward(&mut _self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "wireframe_material_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::wireframe::WireframeMaterial {


    
    fn clone (_self: Ref<::bevy_pbr::wireframe::WireframeMaterial>,) -> Val<::bevy_pbr::wireframe::WireframeMaterial> {
        let output: Val<::bevy_pbr::wireframe::WireframeMaterial> =<::bevy_pbr::wireframe::WireframeMaterial as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "no_wireframe_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::wireframe::NoWireframe {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_pbr::wireframe::NoWireframe>,) -> () {
        let output: () =<::bevy_pbr::wireframe::NoWireframe as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_pbr::wireframe::NoWireframe>,) -> Val<::bevy_pbr::wireframe::NoWireframe> {
        let output: Val<::bevy_pbr::wireframe::NoWireframe> =<::bevy_pbr::wireframe::NoWireframe as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_pbr::wireframe::NoWireframe>,other: Ref<::bevy_pbr::wireframe::NoWireframe>,) -> bool {
        let output: bool =<::bevy_pbr::wireframe::NoWireframe as ::std::cmp::PartialEq::<::bevy_pbr::wireframe::NoWireframe>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "wireframe_config_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::wireframe::WireframeConfig {


    
    fn clone (_self: Ref<::bevy_pbr::wireframe::WireframeConfig>,) -> Val<::bevy_pbr::wireframe::WireframeConfig> {
        let output: Val<::bevy_pbr::wireframe::WireframeConfig> =<::bevy_pbr::wireframe::WireframeConfig as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "wireframe_color_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::wireframe::WireframeColor {


    
    fn clone (_self: Ref<::bevy_pbr::wireframe::WireframeColor>,) -> Val<::bevy_pbr::wireframe::WireframeColor> {
        let output: Val<::bevy_pbr::wireframe::WireframeColor> =<::bevy_pbr::wireframe::WireframeColor as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "wireframe_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::wireframe::Wireframe {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_pbr::wireframe::Wireframe>,) -> () {
        let output: () =<::bevy_pbr::wireframe::Wireframe as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_pbr::wireframe::Wireframe>,) -> Val<::bevy_pbr::wireframe::Wireframe> {
        let output: Val<::bevy_pbr::wireframe::Wireframe> =<::bevy_pbr::wireframe::Wireframe as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_pbr::wireframe::Wireframe>,other: Ref<::bevy_pbr::wireframe::Wireframe>,) -> bool {
        let output: bool =<::bevy_pbr::wireframe::Wireframe as ::std::cmp::PartialEq::<::bevy_pbr::wireframe::Wireframe>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "mesh_3_d_wireframe_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::wireframe::Mesh3dWireframe {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_pbr::wireframe::Mesh3dWireframe>,) -> () {
        let output: () =<::bevy_pbr::wireframe::Mesh3dWireframe as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_pbr::wireframe::Mesh3dWireframe>,) -> Val<::bevy_pbr::wireframe::Mesh3dWireframe> {
        let output: Val<::bevy_pbr::wireframe::Mesh3dWireframe> =<::bevy_pbr::wireframe::Mesh3dWireframe as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_pbr::wireframe::Mesh3dWireframe>,other: Ref<::bevy_pbr::wireframe::Mesh3dWireframe>,) -> bool {
        let output: bool =<::bevy_pbr::wireframe::Mesh3dWireframe as ::std::cmp::PartialEq::<::bevy_pbr::wireframe::Mesh3dWireframe>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "atmosphere_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::Atmosphere {


    
    fn clone (_self: Ref<::bevy_pbr::Atmosphere>,) -> Val<::bevy_pbr::Atmosphere> {
        let output: Val<::bevy_pbr::Atmosphere> =<::bevy_pbr::Atmosphere as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn with_density_multiplier (_self: Val<::bevy_pbr::Atmosphere>,mult: f32,) -> Val<::bevy_pbr::Atmosphere> {
        let output: Val<::bevy_pbr::Atmosphere> =::bevy_pbr::Atmosphere::with_density_multiplier(_self.into_inner(),mult,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "atmosphere_settings_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::AtmosphereSettings {


    
    fn clone (_self: Ref<::bevy_pbr::AtmosphereSettings>,) -> Val<::bevy_pbr::AtmosphereSettings> {
        let output: Val<::bevy_pbr::AtmosphereSettings> =<::bevy_pbr::AtmosphereSettings as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cluster_far_z_mode_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::ClusterFarZMode {


    
    fn clone (_self: Ref<::bevy_pbr::ClusterFarZMode>,) -> Val<::bevy_pbr::ClusterFarZMode> {
        let output: Val<::bevy_pbr::ClusterFarZMode> =<::bevy_pbr::ClusterFarZMode as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cluster_z_config_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::ClusterZConfig {


    
    fn clone (_self: Ref<::bevy_pbr::ClusterZConfig>,) -> Val<::bevy_pbr::ClusterZConfig> {
        let output: Val<::bevy_pbr::ClusterZConfig> =<::bevy_pbr::ClusterZConfig as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "clustered_decal_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::decal::clustered::ClusteredDecal {


    
    fn clone (_self: Ref<::bevy_pbr::decal::clustered::ClusteredDecal>,) -> Val<::bevy_pbr::decal::clustered::ClusteredDecal> {
        let output: Val<::bevy_pbr::decal::clustered::ClusteredDecal> =<::bevy_pbr::decal::clustered::ClusteredDecal as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "irradiance_volume_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::irradiance_volume::IrradianceVolume {


    
    fn clone (_self: Ref<::bevy_pbr::irradiance_volume::IrradianceVolume>,) -> Val<::bevy_pbr::irradiance_volume::IrradianceVolume> {
        let output: Val<::bevy_pbr::irradiance_volume::IrradianceVolume> =<::bevy_pbr::irradiance_volume::IrradianceVolume as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "render_visible_mesh_entities_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::RenderVisibleMeshEntities {


    
    fn clone (_self: Ref<::bevy_pbr::RenderVisibleMeshEntities>,) -> Val<::bevy_pbr::RenderVisibleMeshEntities> {
        let output: Val<::bevy_pbr::RenderVisibleMeshEntities> =<::bevy_pbr::RenderVisibleMeshEntities as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "render_cubemap_visible_entities_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::RenderCubemapVisibleEntities {


    
    fn clone (_self: Ref<::bevy_pbr::RenderCubemapVisibleEntities>,) -> Val<::bevy_pbr::RenderCubemapVisibleEntities> {
        let output: Val<::bevy_pbr::RenderCubemapVisibleEntities> =<::bevy_pbr::RenderCubemapVisibleEntities as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "render_cascades_visible_entities_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::RenderCascadesVisibleEntities {


    
    fn clone (_self: Ref<::bevy_pbr::RenderCascadesVisibleEntities>,) -> Val<::bevy_pbr::RenderCascadesVisibleEntities> {
        let output: Val<::bevy_pbr::RenderCascadesVisibleEntities> =<::bevy_pbr::RenderCascadesVisibleEntities as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "forward_decal_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::decal::ForwardDecal {
     
}

#[script_bindings(
    remote,
    name = "opaque_renderer_method_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::OpaqueRendererMethod {


    
    fn clone (_self: Ref<::bevy_pbr::OpaqueRendererMethod>,) -> Val<::bevy_pbr::OpaqueRendererMethod> {
        let output: Val<::bevy_pbr::OpaqueRendererMethod> =<::bevy_pbr::OpaqueRendererMethod as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_pbr::OpaqueRendererMethod>,other: Ref<::bevy_pbr::OpaqueRendererMethod>,) -> bool {
        let output: bool =<::bevy_pbr::OpaqueRendererMethod as ::std::cmp::PartialEq::<::bevy_pbr::OpaqueRendererMethod>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cascade_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::Cascade {


    
    fn clone (_self: Ref<::bevy_pbr::Cascade>,) -> Val<::bevy_pbr::Cascade> {
        let output: Val<::bevy_pbr::Cascade> =<::bevy_pbr::Cascade as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "transmitted_shadow_receiver_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::TransmittedShadowReceiver {
     
}

#[script_bindings(
    remote,
    name = "lightmap_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::Lightmap {


    
    fn clone (_self: Ref<::bevy_pbr::Lightmap>,) -> Val<::bevy_pbr::Lightmap> {
        let output: Val<::bevy_pbr::Lightmap> =<::bevy_pbr::Lightmap as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "material_binding_id_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::MaterialBindingId {


    
    fn clone (_self: Ref<::bevy_pbr::MaterialBindingId>,) -> Val<::bevy_pbr::MaterialBindingId> {
        let output: Val<::bevy_pbr::MaterialBindingId> =<::bevy_pbr::MaterialBindingId as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "material_bind_group_slot_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::MaterialBindGroupSlot {


    
    fn clone (_self: Ref<::bevy_pbr::MaterialBindGroupSlot>,) -> Val<::bevy_pbr::MaterialBindGroupSlot> {
        let output: Val<::bevy_pbr::MaterialBindGroupSlot> =<::bevy_pbr::MaterialBindGroupSlot as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_pbr::MaterialBindGroupSlot>,other: Ref<::bevy_pbr::MaterialBindGroupSlot>,) -> bool {
        let output: bool =<::bevy_pbr::MaterialBindGroupSlot as ::std::cmp::PartialEq::<::bevy_pbr::MaterialBindGroupSlot>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "material_bind_group_index_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::MaterialBindGroupIndex {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_pbr::MaterialBindGroupIndex>,) -> () {
        let output: () =<::bevy_pbr::MaterialBindGroupIndex as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_pbr::MaterialBindGroupIndex>,) -> Val<::bevy_pbr::MaterialBindGroupIndex> {
        let output: Val<::bevy_pbr::MaterialBindGroupIndex> =<::bevy_pbr::MaterialBindGroupIndex as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_pbr::MaterialBindGroupIndex>,other: Ref<::bevy_pbr::MaterialBindGroupIndex>,) -> bool {
        let output: bool =<::bevy_pbr::MaterialBindGroupIndex as ::std::cmp::PartialEq::<::bevy_pbr::MaterialBindGroupIndex>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "uv_channel_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::UvChannel {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_pbr::UvChannel>,) -> () {
        let output: () =<::bevy_pbr::UvChannel as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_pbr::UvChannel>,) -> Val<::bevy_pbr::UvChannel> {
        let output: Val<::bevy_pbr::UvChannel> =<::bevy_pbr::UvChannel as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_pbr::UvChannel>,other: Ref<::bevy_pbr::UvChannel>,) -> bool {
        let output: bool =<::bevy_pbr::UvChannel as ::std::cmp::PartialEq::<::bevy_pbr::UvChannel>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "screen_space_ambient_occlusion_quality_level_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_pbr::ScreenSpaceAmbientOcclusionQualityLevel {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_pbr::ScreenSpaceAmbientOcclusionQualityLevel>,) -> () {
        let output: () =<::bevy_pbr::ScreenSpaceAmbientOcclusionQualityLevel as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_pbr::ScreenSpaceAmbientOcclusionQualityLevel>,) -> Val<::bevy_pbr::ScreenSpaceAmbientOcclusionQualityLevel> {
        let output: Val<::bevy_pbr::ScreenSpaceAmbientOcclusionQualityLevel> =<::bevy_pbr::ScreenSpaceAmbientOcclusionQualityLevel as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_pbr::ScreenSpaceAmbientOcclusionQualityLevel>,other: Ref<::bevy_pbr::ScreenSpaceAmbientOcclusionQualityLevel>,) -> bool {
        let output: bool =<::bevy_pbr::ScreenSpaceAmbientOcclusionQualityLevel as ::std::cmp::PartialEq::<::bevy_pbr::ScreenSpaceAmbientOcclusionQualityLevel>>::eq(&_self,&other,).into();
        output
    }
     
}


impl Plugin for BevyPbrScriptingPlugin {
    fn build(&self, app: &mut App) {
        let mut world = app.world_mut();

        
            register_fog_volume_functions(&mut world);
        
            register_volumetric_fog_functions(&mut world);
        
            register_volumetric_light_functions(&mut world);
        
            register_distance_fog_functions(&mut world);
        
            register_fog_falloff_functions(&mut world);
        
            register_ambient_light_functions(&mut world);
        
            register_directional_light_functions(&mut world);
        
            register_point_light_functions(&mut world);
        
            register_spot_light_functions(&mut world);
        
            register_environment_map_light_functions(&mut world);
        
            register_light_probe_functions(&mut world);
        
            register_parallax_mapping_method_functions(&mut world);
        
            register_standard_material_functions(&mut world);
        
            register_screen_space_ambient_occlusion_functions(&mut world);
        
            register_screen_space_reflections_functions(&mut world);
        
            register_cascade_shadow_config_functions(&mut world);
        
            register_cascades_functions(&mut world);
        
            register_cascades_visible_entities_functions(&mut world);
        
            register_visible_mesh_entities_functions(&mut world);
        
            register_cluster_config_functions(&mut world);
        
            register_cubemap_visible_entities_functions(&mut world);
        
            register_directional_light_shadow_map_functions(&mut world);
        
            register_not_shadow_caster_functions(&mut world);
        
            register_not_shadow_receiver_functions(&mut world);
        
            register_point_light_shadow_map_functions(&mut world);
        
            register_shadow_filtering_method_functions(&mut world);
        
            register_default_opaque_renderer_method_functions(&mut world);
        
            register_wireframe_material_functions(&mut world);
        
            register_no_wireframe_functions(&mut world);
        
            register_wireframe_config_functions(&mut world);
        
            register_wireframe_color_functions(&mut world);
        
            register_wireframe_functions(&mut world);
        
            register_mesh_3_d_wireframe_functions(&mut world);
        
            register_atmosphere_functions(&mut world);
        
            register_atmosphere_settings_functions(&mut world);
        
            register_cluster_far_z_mode_functions(&mut world);
        
            register_cluster_z_config_functions(&mut world);
        
            register_clustered_decal_functions(&mut world);
        
            register_irradiance_volume_functions(&mut world);
        
            register_render_visible_mesh_entities_functions(&mut world);
        
            register_render_cubemap_visible_entities_functions(&mut world);
        
            register_render_cascades_visible_entities_functions(&mut world);
        
            register_forward_decal_functions(&mut world);
        
            register_opaque_renderer_method_functions(&mut world);
        
            register_cascade_functions(&mut world);
        
            register_transmitted_shadow_receiver_functions(&mut world);
        
            register_lightmap_functions(&mut world);
        
            register_material_binding_id_functions(&mut world);
        
            register_material_bind_group_slot_functions(&mut world);
        
            register_material_bind_group_index_functions(&mut world);
        
            register_uv_channel_functions(&mut world);
        
            register_screen_space_ambient_occlusion_quality_level_functions(&mut world);
        
    }
}
