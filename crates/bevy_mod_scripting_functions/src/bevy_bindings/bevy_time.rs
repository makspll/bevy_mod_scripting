// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use bevy_mod_scripting_core::bindings::{
    ReflectReference,
    function::{
        from::{Ref, Mut, Val},
        namespace::NamespaceBuilder,
    },
};
use bevy_mod_scripting_derive::script_bindings;
use crate::*;
pub struct BevyTimeScriptingPlugin;
#[script_bindings(
    remote,
    name = "fixed_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::time::prelude::Fixed {
    fn clone(_self: Ref<bevy::time::prelude::Fixed>) -> Val<bevy::time::prelude::Fixed> {
        let output: Val<bevy::time::prelude::Fixed> = <bevy::time::prelude::Fixed as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "real_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::time::prelude::Real {
    fn clone(_self: Ref<bevy::time::prelude::Real>) -> Val<bevy::time::prelude::Real> {
        let output: Val<bevy::time::prelude::Real> = <bevy::time::prelude::Real as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "timer_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::time::prelude::Timer {
    fn assert_receiver_is_total_eq(_self: Ref<bevy::time::prelude::Timer>) -> () {
        let output: () = <bevy::time::prelude::Timer as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::time::prelude::Timer>) -> Val<bevy::time::prelude::Timer> {
        let output: Val<bevy::time::prelude::Timer> = <bevy::time::prelude::Timer as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the duration of the timer.
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let timer = Timer::new(Duration::from_secs(1), TimerMode::Once);
    ///  assert_eq!(timer.duration(), Duration::from_secs(1));
    ///  ```
    fn duration(_self: Ref<bevy::time::prelude::Timer>) -> Val<::core::time::Duration> {
        let output: Val<::core::time::Duration> = bevy::time::prelude::Timer::duration(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the time elapsed on the timer. Guaranteed to be between 0.0 and `duration`.
    ///  Will only equal `duration` when the timer is finished and non repeating.
    ///  See also [`Stopwatch::elapsed`](Stopwatch::elapsed).
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
    ///  timer.tick(Duration::from_secs_f32(0.5));
    ///  assert_eq!(timer.elapsed(), Duration::from_secs_f32(0.5));
    ///  ```
    fn elapsed(_self: Ref<bevy::time::prelude::Timer>) -> Val<::core::time::Duration> {
        let output: Val<::core::time::Duration> = bevy::time::prelude::Timer::elapsed(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the time elapsed on the timer as an `f32`.
    ///  See also [`Timer::elapsed`](Timer::elapsed).
    fn elapsed_secs(_self: Ref<bevy::time::prelude::Timer>) -> f32 {
        let output: f32 = bevy::time::prelude::Timer::elapsed_secs(&_self).into();
        output
    }
    ///  Returns the time elapsed on the timer as an `f64`.
    ///  See also [`Timer::elapsed`](Timer::elapsed).
    fn elapsed_secs_f64(_self: Ref<bevy::time::prelude::Timer>) -> f64 {
        let output: f64 = bevy::time::prelude::Timer::elapsed_secs_f64(&_self).into();
        output
    }
    fn eq(
        _self: Ref<bevy::time::prelude::Timer>,
        other: Ref<bevy::time::prelude::Timer>,
    ) -> bool {
        let output: bool = <bevy::time::prelude::Timer as ::core::cmp::PartialEq<
            bevy::time::prelude::Timer,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Returns `true` if the timer has reached its duration.
    ///  For repeating timers, this method behaves identically to [`Timer::just_finished`].
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let mut timer_once = Timer::from_seconds(1.0, TimerMode::Once);
    ///  timer_once.tick(Duration::from_secs_f32(1.5));
    ///  assert!(timer_once.finished());
    ///  timer_once.tick(Duration::from_secs_f32(0.5));
    ///  assert!(timer_once.finished());
    ///  let mut timer_repeating = Timer::from_seconds(1.0, TimerMode::Repeating);
    ///  timer_repeating.tick(Duration::from_secs_f32(1.1));
    ///  assert!(timer_repeating.finished());
    ///  timer_repeating.tick(Duration::from_secs_f32(0.8));
    ///  assert!(!timer_repeating.finished());
    ///  timer_repeating.tick(Duration::from_secs_f32(0.6));
    ///  assert!(timer_repeating.finished());
    ///  ```
    fn finished(_self: Ref<bevy::time::prelude::Timer>) -> bool {
        let output: bool = bevy::time::prelude::Timer::finished(&_self).into();
        output
    }
    ///  Returns the fraction of the timer elapsed time (goes from 0.0 to 1.0).
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let mut timer = Timer::from_seconds(2.0, TimerMode::Once);
    ///  timer.tick(Duration::from_secs_f32(0.5));
    ///  assert_eq!(timer.fraction(), 0.25);
    ///  ```
    fn fraction(_self: Ref<bevy::time::prelude::Timer>) -> f32 {
        let output: f32 = bevy::time::prelude::Timer::fraction(&_self).into();
        output
    }
    ///  Returns the fraction of the timer remaining time (goes from 1.0 to 0.0).
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let mut timer = Timer::from_seconds(2.0, TimerMode::Once);
    ///  timer.tick(Duration::from_secs_f32(0.5));
    ///  assert_eq!(timer.fraction_remaining(), 0.75);
    ///  ```
    fn fraction_remaining(_self: Ref<bevy::time::prelude::Timer>) -> f32 {
        let output: f32 = bevy::time::prelude::Timer::fraction_remaining(&_self).into();
        output
    }
    ///  Creates a new timer with a given duration in seconds.
    ///  # Example
    ///  ```
    ///  # use bevy_time::*;
    ///  let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
    ///  ```
    fn from_seconds(
        duration: f32,
        mode: Val<bevy::time::prelude::TimerMode>,
    ) -> Val<bevy::time::prelude::Timer> {
        let output: Val<bevy::time::prelude::Timer> = bevy::time::prelude::Timer::from_seconds(
                duration,
                mode.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `true` only on the tick the timer reached its duration.
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
    ///  timer.tick(Duration::from_secs_f32(1.5));
    ///  assert!(timer.just_finished());
    ///  timer.tick(Duration::from_secs_f32(0.5));
    ///  assert!(!timer.just_finished());
    ///  ```
    fn just_finished(_self: Ref<bevy::time::prelude::Timer>) -> bool {
        let output: bool = bevy::time::prelude::Timer::just_finished(&_self).into();
        output
    }
    ///  Returns the mode of the timer.
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  let mut timer = Timer::from_seconds(1.0, TimerMode::Repeating);
    ///  assert_eq!(timer.mode(), TimerMode::Repeating);
    ///  ```
    fn mode(
        _self: Ref<bevy::time::prelude::Timer>,
    ) -> Val<bevy::time::prelude::TimerMode> {
        let output: Val<bevy::time::prelude::TimerMode> = bevy::time::prelude::Timer::mode(
                &_self,
            )
            .into();
        output
    }
    ///  Creates a new timer with a given duration.
    ///  See also [`Timer::from_seconds`](Timer::from_seconds).
    fn new(
        duration: Val<::core::time::Duration>,
        mode: Val<bevy::time::prelude::TimerMode>,
    ) -> Val<bevy::time::prelude::Timer> {
        let output: Val<bevy::time::prelude::Timer> = bevy::time::prelude::Timer::new(
                duration.into_inner(),
                mode.into_inner(),
            )
            .into();
        output
    }
    ///  Pauses the Timer. Disables the ticking of the timer.
    ///  See also [`Stopwatch::pause`](Stopwatch::pause).
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
    ///  timer.pause();
    ///  timer.tick(Duration::from_secs_f32(0.5));
    ///  assert_eq!(timer.elapsed_secs(), 0.0);
    ///  ```
    fn pause(mut _self: Mut<bevy::time::prelude::Timer>) -> () {
        let output: () = bevy::time::prelude::Timer::pause(&mut _self).into();
        output
    }
    ///  Returns `true` if the timer is paused.
    ///  See also [`Stopwatch::is_paused`](Stopwatch::is_paused).
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
    ///  assert!(!timer.paused());
    ///  timer.pause();
    ///  assert!(timer.paused());
    ///  timer.unpause();
    ///  assert!(!timer.paused());
    ///  ```
    fn paused(_self: Ref<bevy::time::prelude::Timer>) -> bool {
        let output: bool = bevy::time::prelude::Timer::paused(&_self).into();
        output
    }
    ///  Returns the remaining time using Duration
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let mut timer = Timer::from_seconds(2.0, TimerMode::Once);
    ///  timer.tick(Duration::from_secs_f32(0.5));
    ///  assert_eq!(timer.remaining(), Duration::from_secs_f32(1.5));
    ///  ```
    fn remaining(_self: Ref<bevy::time::prelude::Timer>) -> Val<::core::time::Duration> {
        let output: Val<::core::time::Duration> = bevy::time::prelude::Timer::remaining(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the remaining time in seconds
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::cmp::Ordering;
    ///  use std::time::Duration;
    ///  let mut timer = Timer::from_seconds(2.0, TimerMode::Once);
    ///  timer.tick(Duration::from_secs_f32(0.5));
    ///  let result = timer.remaining_secs().total_cmp(&1.5);
    ///  assert_eq!(Ordering::Equal, result);
    ///  ```
    fn remaining_secs(_self: Ref<bevy::time::prelude::Timer>) -> f32 {
        let output: f32 = bevy::time::prelude::Timer::remaining_secs(&_self).into();
        output
    }
    ///  Resets the timer. The reset doesn't affect the `paused` state of the timer.
    ///  See also [`Stopwatch::reset`](Stopwatch::reset).
    ///  Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
    ///  timer.tick(Duration::from_secs_f32(1.5));
    ///  timer.reset();
    ///  assert!(!timer.finished());
    ///  assert!(!timer.just_finished());
    ///  assert_eq!(timer.elapsed_secs(), 0.0);
    ///  ```
    fn reset(mut _self: Mut<bevy::time::prelude::Timer>) -> () {
        let output: () = bevy::time::prelude::Timer::reset(&mut _self).into();
        output
    }
    ///  Sets the duration of the timer.
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let mut timer = Timer::from_seconds(1.5, TimerMode::Once);
    ///  timer.set_duration(Duration::from_secs(1));
    ///  assert_eq!(timer.duration(), Duration::from_secs(1));
    ///  ```
    fn set_duration(
        mut _self: Mut<bevy::time::prelude::Timer>,
        duration: Val<::core::time::Duration>,
    ) -> () {
        let output: () = bevy::time::prelude::Timer::set_duration(
                &mut _self,
                duration.into_inner(),
            )
            .into();
        output
    }
    ///  Sets the elapsed time of the timer without any other considerations.
    ///  See also [`Stopwatch::set`](Stopwatch::set).
    ///  #
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
    ///  timer.set_elapsed(Duration::from_secs(2));
    ///  assert_eq!(timer.elapsed(), Duration::from_secs(2));
    ///  // the timer is not finished even if the elapsed time is greater than the duration.
    ///  assert!(!timer.finished());
    ///  ```
    fn set_elapsed(
        mut _self: Mut<bevy::time::prelude::Timer>,
        time: Val<::core::time::Duration>,
    ) -> () {
        let output: () = bevy::time::prelude::Timer::set_elapsed(
                &mut _self,
                time.into_inner(),
            )
            .into();
        output
    }
    ///  Sets the mode of the timer.
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  let mut timer = Timer::from_seconds(1.0, TimerMode::Repeating);
    ///  timer.set_mode(TimerMode::Once);
    ///  assert_eq!(timer.mode(), TimerMode::Once);
    ///  ```
    fn set_mode(
        mut _self: Mut<bevy::time::prelude::Timer>,
        mode: Val<bevy::time::prelude::TimerMode>,
    ) -> () {
        let output: () = bevy::time::prelude::Timer::set_mode(
                &mut _self,
                mode.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the number of times a repeating timer
    ///  finished during the last [`tick`](Timer<T>::tick) call.
    ///  For non repeating-timers, this method will only ever
    ///  return 0 or 1.
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let mut timer = Timer::from_seconds(1.0, TimerMode::Repeating);
    ///  timer.tick(Duration::from_secs_f32(6.0));
    ///  assert_eq!(timer.times_finished_this_tick(), 6);
    ///  timer.tick(Duration::from_secs_f32(2.0));
    ///  assert_eq!(timer.times_finished_this_tick(), 2);
    ///  timer.tick(Duration::from_secs_f32(0.5));
    ///  assert_eq!(timer.times_finished_this_tick(), 0);
    ///  ```
    fn times_finished_this_tick(_self: Ref<bevy::time::prelude::Timer>) -> u32 {
        let output: u32 = bevy::time::prelude::Timer::times_finished_this_tick(&_self)
            .into();
        output
    }
    ///  Unpauses the Timer. Resumes the ticking of the timer.
    ///  See also [`Stopwatch::unpause()`](Stopwatch::unpause).
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
    ///  timer.pause();
    ///  timer.tick(Duration::from_secs_f32(0.5));
    ///  timer.unpause();
    ///  timer.tick(Duration::from_secs_f32(0.5));
    ///  assert_eq!(timer.elapsed_secs(), 0.5);
    ///  ```
    fn unpause(mut _self: Mut<bevy::time::prelude::Timer>) -> () {
        let output: () = bevy::time::prelude::Timer::unpause(&mut _self).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "timer_mode_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::time::prelude::TimerMode {
    fn assert_receiver_is_total_eq(_self: Ref<bevy::time::prelude::TimerMode>) -> () {
        let output: () = <bevy::time::prelude::TimerMode as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<bevy::time::prelude::TimerMode>,
    ) -> Val<bevy::time::prelude::TimerMode> {
        let output: Val<bevy::time::prelude::TimerMode> = <bevy::time::prelude::TimerMode as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<bevy::time::prelude::TimerMode>,
        other: Ref<bevy::time::prelude::TimerMode>,
    ) -> bool {
        let output: bool = <bevy::time::prelude::TimerMode as ::core::cmp::PartialEq<
            bevy::time::prelude::TimerMode,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "virtual_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::time::prelude::Virtual {
    fn clone(
        _self: Ref<bevy::time::prelude::Virtual>,
    ) -> Val<bevy::time::prelude::Virtual> {
        let output: Val<bevy::time::prelude::Virtual> = <bevy::time::prelude::Virtual as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "stopwatch_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::time::Stopwatch {
    fn assert_receiver_is_total_eq(_self: Ref<bevy::time::Stopwatch>) -> () {
        let output: () = <bevy::time::Stopwatch as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::time::Stopwatch>) -> Val<bevy::time::Stopwatch> {
        let output: Val<bevy::time::Stopwatch> = <bevy::time::Stopwatch as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the elapsed time since the last [`reset`](Stopwatch::reset)
    ///  of the stopwatch.
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let mut stopwatch = Stopwatch::new();
    ///  stopwatch.tick(Duration::from_secs(1));
    ///  assert_eq!(stopwatch.elapsed(), Duration::from_secs(1));
    ///  ```
    ///  # See Also
    ///  [`elapsed_secs`](Stopwatch::elapsed_secs) - if an `f32` value is desirable instead.
    ///  [`elapsed_secs_f64`](Stopwatch::elapsed_secs_f64) - if an `f64` is desirable instead.
    fn elapsed(_self: Ref<bevy::time::Stopwatch>) -> Val<::core::time::Duration> {
        let output: Val<::core::time::Duration> = bevy::time::Stopwatch::elapsed(&_self)
            .into();
        output
    }
    ///  Returns the elapsed time since the last [`reset`](Stopwatch::reset)
    ///  of the stopwatch, in seconds.
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let mut stopwatch = Stopwatch::new();
    ///  stopwatch.tick(Duration::from_secs(1));
    ///  assert_eq!(stopwatch.elapsed_secs(), 1.0);
    ///  ```
    ///  # See Also
    ///  [`elapsed`](Stopwatch::elapsed) - if a `Duration` is desirable instead.
    ///  [`elapsed_secs_f64`](Stopwatch::elapsed_secs_f64) - if an `f64` is desirable instead.
    fn elapsed_secs(_self: Ref<bevy::time::Stopwatch>) -> f32 {
        let output: f32 = bevy::time::Stopwatch::elapsed_secs(&_self).into();
        output
    }
    ///  Returns the elapsed time since the last [`reset`](Stopwatch::reset)
    ///  of the stopwatch, in seconds, as f64.
    ///  # See Also
    ///  [`elapsed`](Stopwatch::elapsed) - if a `Duration` is desirable instead.
    ///  [`elapsed_secs`](Stopwatch::elapsed_secs) - if an `f32` is desirable instead.
    fn elapsed_secs_f64(_self: Ref<bevy::time::Stopwatch>) -> f64 {
        let output: f64 = bevy::time::Stopwatch::elapsed_secs_f64(&_self).into();
        output
    }
    fn eq(_self: Ref<bevy::time::Stopwatch>, other: Ref<bevy::time::Stopwatch>) -> bool {
        let output: bool = <bevy::time::Stopwatch as ::core::cmp::PartialEq<
            bevy::time::Stopwatch,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Returns `true` if the stopwatch is paused.
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  let mut stopwatch = Stopwatch::new();
    ///  assert!(!stopwatch.is_paused());
    ///  stopwatch.pause();
    ///  assert!(stopwatch.is_paused());
    ///  stopwatch.unpause();
    ///  assert!(!stopwatch.is_paused());
    ///  ```
    fn is_paused(_self: Ref<bevy::time::Stopwatch>) -> bool {
        let output: bool = bevy::time::Stopwatch::is_paused(&_self).into();
        output
    }
    ///  Create a new unpaused `Stopwatch` with no elapsed time.
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  let stopwatch = Stopwatch::new();
    ///  assert_eq!(stopwatch.elapsed_secs(), 0.0);
    ///  assert_eq!(stopwatch.is_paused(), false);
    ///  ```
    fn new() -> Val<bevy::time::Stopwatch> {
        let output: Val<bevy::time::Stopwatch> = bevy::time::Stopwatch::new().into();
        output
    }
    ///  Pauses the stopwatch. Any call to [`tick`](Stopwatch::tick) while
    ///  paused will not have any effect on the elapsed time.
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let mut stopwatch = Stopwatch::new();
    ///  stopwatch.pause();
    ///  stopwatch.tick(Duration::from_secs_f32(1.5));
    ///  assert!(stopwatch.is_paused());
    ///  assert_eq!(stopwatch.elapsed_secs(), 0.0);
    ///  ```
    fn pause(mut _self: Mut<bevy::time::Stopwatch>) -> () {
        let output: () = bevy::time::Stopwatch::pause(&mut _self).into();
        output
    }
    ///  Resets the stopwatch. The reset doesn't affect the paused state of the stopwatch.
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let mut stopwatch = Stopwatch::new();
    ///  stopwatch.tick(Duration::from_secs_f32(1.5));
    ///  stopwatch.reset();
    ///  assert_eq!(stopwatch.elapsed_secs(), 0.0);
    ///  ```
    fn reset(mut _self: Mut<bevy::time::Stopwatch>) -> () {
        let output: () = bevy::time::Stopwatch::reset(&mut _self).into();
        output
    }
    ///  Sets the elapsed time of the stopwatch.
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let mut stopwatch = Stopwatch::new();
    ///  stopwatch.set_elapsed(Duration::from_secs_f32(1.0));
    ///  assert_eq!(stopwatch.elapsed_secs(), 1.0);
    ///  ```
    fn set_elapsed(
        mut _self: Mut<bevy::time::Stopwatch>,
        time: Val<::core::time::Duration>,
    ) -> () {
        let output: () = bevy::time::Stopwatch::set_elapsed(
                &mut _self,
                time.into_inner(),
            )
            .into();
        output
    }
    ///  Unpauses the stopwatch. Resume the effect of ticking on elapsed time.
    ///  # Examples
    ///  ```
    ///  # use bevy_time::*;
    ///  use std::time::Duration;
    ///  let mut stopwatch = Stopwatch::new();
    ///  stopwatch.pause();
    ///  stopwatch.tick(Duration::from_secs_f32(1.0));
    ///  stopwatch.unpause();
    ///  stopwatch.tick(Duration::from_secs_f32(1.0));
    ///  assert!(!stopwatch.is_paused());
    ///  assert_eq!(stopwatch.elapsed_secs(), 1.0);
    ///  ```
    fn unpause(mut _self: Mut<bevy::time::Stopwatch>) -> () {
        let output: () = bevy::time::Stopwatch::unpause(&mut _self).into();
        output
    }
}
impl ::bevy::app::Plugin for BevyTimeScriptingPlugin {
    fn build(&self, app: &mut ::bevy::prelude::App) {
        let mut world = app.world_mut();
        register_fixed_functions(&mut world);
        register_real_functions(&mut world);
        register_timer_functions(&mut world);
        register_timer_mode_functions(&mut world);
        register_virtual_functions(&mut world);
        register_stopwatch_functions(&mut world);
    }
}
