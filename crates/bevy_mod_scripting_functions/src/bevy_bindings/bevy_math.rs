// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use super::bevy_reflect::*;
use bevy_mod_scripting_core::{
    AddContextInitializer, StoreDocumentation,
    bindings::{ReflectReference, function::from::{Ref, Mut, Val}},
};
use crate::*;
pub struct BevyMathScriptingPlugin;
impl ::bevy::app::Plugin for BevyMathScriptingPlugin {
    fn build(&self, app: &mut ::bevy::prelude::App) {
        let mut world = app.world_mut();
        NamespaceBuilder::<::bevy::math::AspectRatio>::new(world)
            .register(
                "ratio",
                |_self: Ref<bevy::math::AspectRatio>| {
                    let output: f32 = bevy::math::AspectRatio::ratio(&_self).into();
                    output
                },
            )
            .register(
                "inverse",
                |_self: Ref<bevy::math::AspectRatio>| {
                    let output: Val<bevy::math::AspectRatio> = bevy::math::AspectRatio::inverse(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_landscape",
                |_self: Ref<bevy::math::AspectRatio>| {
                    let output: bool = bevy::math::AspectRatio::is_landscape(&_self)
                        .into();
                    output
                },
            )
            .register(
                "is_portrait",
                |_self: Ref<bevy::math::AspectRatio>| {
                    let output: bool = bevy::math::AspectRatio::is_portrait(&_self)
                        .into();
                    output
                },
            )
            .register(
                "is_square",
                |_self: Ref<bevy::math::AspectRatio>| {
                    let output: bool = bevy::math::AspectRatio::is_square(&_self).into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::AspectRatio>| {
                    let output: Val<bevy::math::AspectRatio> = <bevy::math::AspectRatio as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::AspectRatio>,
                    other: Ref<bevy::math::AspectRatio>|
                {
                    let output: bool = <bevy::math::AspectRatio as std::cmp::PartialEq<
                        bevy::math::AspectRatio,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::CompassOctant>::new(world)
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::CompassOctant>| {
                    let output: () = <bevy::math::CompassOctant as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::CompassOctant>,
                    other: Ref<bevy::math::CompassOctant>|
                {
                    let output: bool = <bevy::math::CompassOctant as std::cmp::PartialEq<
                        bevy::math::CompassOctant,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::CompassOctant>| {
                    let output: Val<bevy::math::CompassOctant> = <bevy::math::CompassOctant as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::CompassQuadrant>::new(world)
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::CompassQuadrant>,
                    other: Ref<bevy::math::CompassQuadrant>|
                {
                    let output: bool = <bevy::math::CompassQuadrant as std::cmp::PartialEq<
                        bevy::math::CompassQuadrant,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::CompassQuadrant>| {
                    let output: () = <bevy::math::CompassQuadrant as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::CompassQuadrant>| {
                    let output: Val<bevy::math::CompassQuadrant> = <bevy::math::CompassQuadrant as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::Isometry2d>::new(world)
            .register(
                "mul",
                |
                    _self: Val<bevy::math::Isometry2d>,
                    rhs: Val<bevy::math::prelude::Dir2>|
                {
                    let output: Val<bevy::math::prelude::Dir2> = <bevy::math::Isometry2d as std::ops::Mul<
                        bevy::math::prelude::Dir2,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "from_rotation",
                |rotation: Val<bevy::math::Rot2>| {
                    let output: Val<bevy::math::Isometry2d> = bevy::math::Isometry2d::from_rotation(
                            rotation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_xy",
                |x: f32, y: f32| {
                    let output: Val<bevy::math::Isometry2d> = bevy::math::Isometry2d::from_xy(
                            x,
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "inverse",
                |_self: Ref<bevy::math::Isometry2d>| {
                    let output: Val<bevy::math::Isometry2d> = bevy::math::Isometry2d::inverse(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "inverse_mul",
                |_self: Ref<bevy::math::Isometry2d>, rhs: Val<bevy::math::Isometry2d>| {
                    let output: Val<bevy::math::Isometry2d> = bevy::math::Isometry2d::inverse_mul(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::Isometry2d>, other: Ref<bevy::math::Isometry2d>| {
                    let output: bool = <bevy::math::Isometry2d as std::cmp::PartialEq<
                        bevy::math::Isometry2d,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Isometry2d>, rhs: Val<bevy::math::Isometry2d>| {
                    let output: Val<bevy::math::Isometry2d> = <bevy::math::Isometry2d as std::ops::Mul<
                        bevy::math::Isometry2d,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::Isometry2d>| {
                    let output: Val<bevy::math::Isometry2d> = <bevy::math::Isometry2d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::Isometry3d>::new(world)
            .register(
                "clone",
                |_self: Ref<bevy::math::Isometry3d>| {
                    let output: Val<bevy::math::Isometry3d> = <bevy::math::Isometry3d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Isometry3d>, rhs: Val<bevy::math::Isometry3d>| {
                    let output: Val<bevy::math::Isometry3d> = <bevy::math::Isometry3d as std::ops::Mul<
                        bevy::math::Isometry3d,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |
                    _self: Val<bevy::math::Isometry3d>,
                    rhs: Val<bevy::math::prelude::Dir3>|
                {
                    let output: Val<bevy::math::prelude::Dir3> = <bevy::math::Isometry3d as std::ops::Mul<
                        bevy::math::prelude::Dir3,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "from_xyz",
                |x: f32, y: f32, z: f32| {
                    let output: Val<bevy::math::Isometry3d> = bevy::math::Isometry3d::from_xyz(
                            x,
                            y,
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "inverse",
                |_self: Ref<bevy::math::Isometry3d>| {
                    let output: Val<bevy::math::Isometry3d> = bevy::math::Isometry3d::inverse(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "inverse_mul",
                |_self: Ref<bevy::math::Isometry3d>, rhs: Val<bevy::math::Isometry3d>| {
                    let output: Val<bevy::math::Isometry3d> = bevy::math::Isometry3d::inverse_mul(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::Isometry3d>, other: Ref<bevy::math::Isometry3d>| {
                    let output: bool = <bevy::math::Isometry3d as std::cmp::PartialEq<
                        bevy::math::Isometry3d,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::Ray2d>::new(world)
            .register(
                "eq",
                |_self: Ref<bevy::math::Ray2d>, other: Ref<bevy::math::Ray2d>| {
                    let output: bool = <bevy::math::Ray2d as std::cmp::PartialEq<
                        bevy::math::Ray2d,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::Ray2d>| {
                    let output: Val<bevy::math::Ray2d> = <bevy::math::Ray2d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::Ray3d>::new(world)
            .register(
                "eq",
                |_self: Ref<bevy::math::Ray3d>, other: Ref<bevy::math::Ray3d>| {
                    let output: bool = <bevy::math::Ray3d as std::cmp::PartialEq<
                        bevy::math::Ray3d,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::Ray3d>| {
                    let output: Val<bevy::math::Ray3d> = <bevy::math::Ray3d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::Rot2>::new(world)
            .register(
                "radians",
                |radians: f32| {
                    let output: Val<bevy::math::Rot2> = bevy::math::Rot2::radians(
                            radians,
                        )
                        .into();
                    output
                },
            )
            .register(
                "degrees",
                |degrees: f32| {
                    let output: Val<bevy::math::Rot2> = bevy::math::Rot2::degrees(
                            degrees,
                        )
                        .into();
                    output
                },
            )
            .register(
                "turn_fraction",
                |fraction: f32| {
                    let output: Val<bevy::math::Rot2> = bevy::math::Rot2::turn_fraction(
                            fraction,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_sin_cos",
                |sin: f32, cos: f32| {
                    let output: Val<bevy::math::Rot2> = bevy::math::Rot2::from_sin_cos(
                            sin,
                            cos,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_radians",
                |_self: Val<bevy::math::Rot2>| {
                    let output: f32 = bevy::math::Rot2::as_radians(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "as_degrees",
                |_self: Val<bevy::math::Rot2>| {
                    let output: f32 = bevy::math::Rot2::as_degrees(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "as_turn_fraction",
                |_self: Val<bevy::math::Rot2>| {
                    let output: f32 = bevy::math::Rot2::as_turn_fraction(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "sin_cos",
                |_self: Val<bevy::math::Rot2>| {
                    let output: (f32, f32) = bevy::math::Rot2::sin_cos(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "length",
                |_self: Val<bevy::math::Rot2>| {
                    let output: f32 = bevy::math::Rot2::length(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::Rot2>| {
                    let output: f32 = bevy::math::Rot2::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "length_recip",
                |_self: Val<bevy::math::Rot2>| {
                    let output: f32 = bevy::math::Rot2::length_recip(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "normalize",
                |_self: Val<bevy::math::Rot2>| {
                    let output: Val<bevy::math::Rot2> = bevy::math::Rot2::normalize(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "fast_renormalize",
                |_self: Val<bevy::math::Rot2>| {
                    let output: Val<bevy::math::Rot2> = bevy::math::Rot2::fast_renormalize(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Val<bevy::math::Rot2>| {
                    let output: bool = bevy::math::Rot2::is_finite(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Val<bevy::math::Rot2>| {
                    let output: bool = bevy::math::Rot2::is_nan(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_normalized",
                |_self: Val<bevy::math::Rot2>| {
                    let output: bool = bevy::math::Rot2::is_normalized(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_near_identity",
                |_self: Val<bevy::math::Rot2>| {
                    let output: bool = bevy::math::Rot2::is_near_identity(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "angle_between",
                |_self: Val<bevy::math::Rot2>, other: Val<bevy::math::Rot2>| {
                    let output: f32 = bevy::math::Rot2::angle_between(
                            _self.into_inner(),
                            other.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "angle_to",
                |_self: Val<bevy::math::Rot2>, other: Val<bevy::math::Rot2>| {
                    let output: f32 = bevy::math::Rot2::angle_to(
                            _self.into_inner(),
                            other.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "inverse",
                |_self: Val<bevy::math::Rot2>| {
                    let output: Val<bevy::math::Rot2> = bevy::math::Rot2::inverse(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "nlerp",
                |_self: Val<bevy::math::Rot2>, end: Val<bevy::math::Rot2>, s: f32| {
                    let output: Val<bevy::math::Rot2> = bevy::math::Rot2::nlerp(
                            _self.into_inner(),
                            end.into_inner(),
                            s,
                        )
                        .into();
                    output
                },
            )
            .register(
                "slerp",
                |_self: Val<bevy::math::Rot2>, end: Val<bevy::math::Rot2>, s: f32| {
                    let output: Val<bevy::math::Rot2> = bevy::math::Rot2::slerp(
                            _self.into_inner(),
                            end.into_inner(),
                            s,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |
                    _self: Val<bevy::math::Rot2>,
                    direction: Val<bevy::math::prelude::Dir2>|
                {
                    let output: Val<bevy::math::prelude::Dir2> = <bevy::math::Rot2 as std::ops::Mul<
                        bevy::math::prelude::Dir2,
                    >>::mul(_self.into_inner(), direction.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::Rot2>, other: Ref<bevy::math::Rot2>| {
                    let output: bool = <bevy::math::Rot2 as std::cmp::PartialEq<
                        bevy::math::Rot2,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Rot2>, rhs: Val<bevy::math::Rot2>| {
                    let output: Val<bevy::math::Rot2> = <bevy::math::Rot2 as std::ops::Mul<
                        bevy::math::Rot2,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::Rot2>| {
                    let output: Val<bevy::math::Rot2> = <bevy::math::Rot2 as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::prelude::Dir2>::new(world)
            .register(
                "clone",
                |_self: Ref<bevy::math::prelude::Dir2>| {
                    let output: Val<bevy::math::prelude::Dir2> = <bevy::math::prelude::Dir2 as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_xy_unchecked",
                |x: f32, y: f32| {
                    let output: Val<bevy::math::prelude::Dir2> = bevy::math::prelude::Dir2::from_xy_unchecked(
                            x,
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "slerp",
                |
                    _self: Val<bevy::math::prelude::Dir2>,
                    rhs: Val<bevy::math::prelude::Dir2>,
                    s: f32|
                {
                    let output: Val<bevy::math::prelude::Dir2> = bevy::math::prelude::Dir2::slerp(
                            _self.into_inner(),
                            rhs.into_inner(),
                            s,
                        )
                        .into();
                    output
                },
            )
            .register(
                "rotation_to",
                |
                    _self: Val<bevy::math::prelude::Dir2>,
                    other: Val<bevy::math::prelude::Dir2>|
                {
                    let output: Val<bevy::math::Rot2> = bevy::math::prelude::Dir2::rotation_to(
                            _self.into_inner(),
                            other.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rotation_from",
                |
                    _self: Val<bevy::math::prelude::Dir2>,
                    other: Val<bevy::math::prelude::Dir2>|
                {
                    let output: Val<bevy::math::Rot2> = bevy::math::prelude::Dir2::rotation_from(
                            _self.into_inner(),
                            other.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rotation_from_x",
                |_self: Val<bevy::math::prelude::Dir2>| {
                    let output: Val<bevy::math::Rot2> = bevy::math::prelude::Dir2::rotation_from_x(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rotation_to_x",
                |_self: Val<bevy::math::prelude::Dir2>| {
                    let output: Val<bevy::math::Rot2> = bevy::math::prelude::Dir2::rotation_to_x(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rotation_from_y",
                |_self: Val<bevy::math::prelude::Dir2>| {
                    let output: Val<bevy::math::Rot2> = bevy::math::prelude::Dir2::rotation_from_y(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rotation_to_y",
                |_self: Val<bevy::math::prelude::Dir2>| {
                    let output: Val<bevy::math::Rot2> = bevy::math::prelude::Dir2::rotation_to_y(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "fast_renormalize",
                |_self: Val<bevy::math::prelude::Dir2>| {
                    let output: Val<bevy::math::prelude::Dir2> = bevy::math::prelude::Dir2::fast_renormalize(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::prelude::Dir2>| {
                    let output: Val<bevy::math::prelude::Dir2> = <bevy::math::prelude::Dir2 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::prelude::Dir2>,
                    other: Ref<bevy::math::prelude::Dir2>|
                {
                    let output: bool = <bevy::math::prelude::Dir2 as std::cmp::PartialEq<
                        bevy::math::prelude::Dir2,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::prelude::Dir3>::new(world)
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::prelude::Dir3>,
                    other: Ref<bevy::math::prelude::Dir3>|
                {
                    let output: bool = <bevy::math::prelude::Dir3 as std::cmp::PartialEq<
                        bevy::math::prelude::Dir3,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::prelude::Dir3>| {
                    let output: Val<bevy::math::prelude::Dir3> = <bevy::math::prelude::Dir3 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::prelude::Dir3>| {
                    let output: Val<bevy::math::prelude::Dir3> = <bevy::math::prelude::Dir3 as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_xyz_unchecked",
                |x: f32, y: f32, z: f32| {
                    let output: Val<bevy::math::prelude::Dir3> = bevy::math::prelude::Dir3::from_xyz_unchecked(
                            x,
                            y,
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "slerp",
                |
                    _self: Val<bevy::math::prelude::Dir3>,
                    rhs: Val<bevy::math::prelude::Dir3>,
                    s: f32|
                {
                    let output: Val<bevy::math::prelude::Dir3> = bevy::math::prelude::Dir3::slerp(
                            _self.into_inner(),
                            rhs.into_inner(),
                            s,
                        )
                        .into();
                    output
                },
            )
            .register(
                "fast_renormalize",
                |_self: Val<bevy::math::prelude::Dir3>| {
                    let output: Val<bevy::math::prelude::Dir3> = bevy::math::prelude::Dir3::fast_renormalize(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::prelude::Dir3A>::new(world)
            .register(
                "from_xyz_unchecked",
                |x: f32, y: f32, z: f32| {
                    let output: Val<bevy::math::prelude::Dir3A> = bevy::math::prelude::Dir3A::from_xyz_unchecked(
                            x,
                            y,
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "slerp",
                |
                    _self: Val<bevy::math::prelude::Dir3A>,
                    rhs: Val<bevy::math::prelude::Dir3A>,
                    s: f32|
                {
                    let output: Val<bevy::math::prelude::Dir3A> = bevy::math::prelude::Dir3A::slerp(
                            _self.into_inner(),
                            rhs.into_inner(),
                            s,
                        )
                        .into();
                    output
                },
            )
            .register(
                "fast_renormalize",
                |_self: Val<bevy::math::prelude::Dir3A>| {
                    let output: Val<bevy::math::prelude::Dir3A> = bevy::math::prelude::Dir3A::fast_renormalize(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::prelude::Dir3A>| {
                    let output: Val<bevy::math::prelude::Dir3A> = <bevy::math::prelude::Dir3A as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::prelude::Dir3A>,
                    other: Ref<bevy::math::prelude::Dir3A>|
                {
                    let output: bool = <bevy::math::prelude::Dir3A as std::cmp::PartialEq<
                        bevy::math::prelude::Dir3A,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::prelude::Dir3A>| {
                    let output: Val<bevy::math::prelude::Dir3A> = <bevy::math::prelude::Dir3A as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::prelude::IRect>::new(world)
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::prelude::IRect>| {
                    let output: () = <bevy::math::prelude::IRect as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::prelude::IRect>| {
                    let output: Val<bevy::math::prelude::IRect> = <bevy::math::prelude::IRect as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x0: i32, y0: i32, x1: i32, y1: i32| {
                    let output: Val<bevy::math::prelude::IRect> = bevy::math::prelude::IRect::new(
                            x0,
                            y0,
                            x1,
                            y1,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_empty",
                |_self: Ref<bevy::math::prelude::IRect>| {
                    let output: bool = bevy::math::prelude::IRect::is_empty(&_self)
                        .into();
                    output
                },
            )
            .register(
                "width",
                |_self: Ref<bevy::math::prelude::IRect>| {
                    let output: i32 = bevy::math::prelude::IRect::width(&_self).into();
                    output
                },
            )
            .register(
                "height",
                |_self: Ref<bevy::math::prelude::IRect>| {
                    let output: i32 = bevy::math::prelude::IRect::height(&_self).into();
                    output
                },
            )
            .register(
                "union",
                |
                    _self: Ref<bevy::math::prelude::IRect>,
                    other: Val<bevy::math::prelude::IRect>|
                {
                    let output: Val<bevy::math::prelude::IRect> = bevy::math::prelude::IRect::union(
                            &_self,
                            other.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "intersect",
                |
                    _self: Ref<bevy::math::prelude::IRect>,
                    other: Val<bevy::math::prelude::IRect>|
                {
                    let output: Val<bevy::math::prelude::IRect> = bevy::math::prelude::IRect::intersect(
                            &_self,
                            other.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "inflate",
                |_self: Ref<bevy::math::prelude::IRect>, expansion: i32| {
                    let output: Val<bevy::math::prelude::IRect> = bevy::math::prelude::IRect::inflate(
                            &_self,
                            expansion,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_rect",
                |_self: Ref<bevy::math::prelude::IRect>| {
                    let output: Val<bevy::math::prelude::Rect> = bevy::math::prelude::IRect::as_rect(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_urect",
                |_self: Ref<bevy::math::prelude::IRect>| {
                    let output: Val<bevy::math::prelude::URect> = bevy::math::prelude::IRect::as_urect(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::prelude::IRect>,
                    other: Ref<bevy::math::prelude::IRect>|
                {
                    let output: bool = <bevy::math::prelude::IRect as std::cmp::PartialEq<
                        bevy::math::prelude::IRect,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::prelude::Rect>::new(world)
            .register(
                "new",
                |x0: f32, y0: f32, x1: f32, y1: f32| {
                    let output: Val<bevy::math::prelude::Rect> = bevy::math::prelude::Rect::new(
                            x0,
                            y0,
                            x1,
                            y1,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_empty",
                |_self: Ref<bevy::math::prelude::Rect>| {
                    let output: bool = bevy::math::prelude::Rect::is_empty(&_self)
                        .into();
                    output
                },
            )
            .register(
                "width",
                |_self: Ref<bevy::math::prelude::Rect>| {
                    let output: f32 = bevy::math::prelude::Rect::width(&_self).into();
                    output
                },
            )
            .register(
                "height",
                |_self: Ref<bevy::math::prelude::Rect>| {
                    let output: f32 = bevy::math::prelude::Rect::height(&_self).into();
                    output
                },
            )
            .register(
                "union",
                |
                    _self: Ref<bevy::math::prelude::Rect>,
                    other: Val<bevy::math::prelude::Rect>|
                {
                    let output: Val<bevy::math::prelude::Rect> = bevy::math::prelude::Rect::union(
                            &_self,
                            other.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "intersect",
                |
                    _self: Ref<bevy::math::prelude::Rect>,
                    other: Val<bevy::math::prelude::Rect>|
                {
                    let output: Val<bevy::math::prelude::Rect> = bevy::math::prelude::Rect::intersect(
                            &_self,
                            other.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "inflate",
                |_self: Ref<bevy::math::prelude::Rect>, expansion: f32| {
                    let output: Val<bevy::math::prelude::Rect> = bevy::math::prelude::Rect::inflate(
                            &_self,
                            expansion,
                        )
                        .into();
                    output
                },
            )
            .register(
                "normalize",
                |
                    _self: Ref<bevy::math::prelude::Rect>,
                    other: Val<bevy::math::prelude::Rect>|
                {
                    let output: Val<bevy::math::prelude::Rect> = bevy::math::prelude::Rect::normalize(
                            &_self,
                            other.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_irect",
                |_self: Ref<bevy::math::prelude::Rect>| {
                    let output: Val<bevy::math::prelude::IRect> = bevy::math::prelude::Rect::as_irect(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_urect",
                |_self: Ref<bevy::math::prelude::Rect>| {
                    let output: Val<bevy::math::prelude::URect> = bevy::math::prelude::Rect::as_urect(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::prelude::Rect>,
                    other: Ref<bevy::math::prelude::Rect>|
                {
                    let output: bool = <bevy::math::prelude::Rect as std::cmp::PartialEq<
                        bevy::math::prelude::Rect,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::prelude::Rect>| {
                    let output: Val<bevy::math::prelude::Rect> = <bevy::math::prelude::Rect as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::prelude::URect>::new(world)
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::prelude::URect>,
                    other: Ref<bevy::math::prelude::URect>|
                {
                    let output: bool = <bevy::math::prelude::URect as std::cmp::PartialEq<
                        bevy::math::prelude::URect,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::prelude::URect>| {
                    let output: Val<bevy::math::prelude::URect> = <bevy::math::prelude::URect as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x0: u32, y0: u32, x1: u32, y1: u32| {
                    let output: Val<bevy::math::prelude::URect> = bevy::math::prelude::URect::new(
                            x0,
                            y0,
                            x1,
                            y1,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_empty",
                |_self: Ref<bevy::math::prelude::URect>| {
                    let output: bool = bevy::math::prelude::URect::is_empty(&_self)
                        .into();
                    output
                },
            )
            .register(
                "width",
                |_self: Ref<bevy::math::prelude::URect>| {
                    let output: u32 = bevy::math::prelude::URect::width(&_self).into();
                    output
                },
            )
            .register(
                "height",
                |_self: Ref<bevy::math::prelude::URect>| {
                    let output: u32 = bevy::math::prelude::URect::height(&_self).into();
                    output
                },
            )
            .register(
                "union",
                |
                    _self: Ref<bevy::math::prelude::URect>,
                    other: Val<bevy::math::prelude::URect>|
                {
                    let output: Val<bevy::math::prelude::URect> = bevy::math::prelude::URect::union(
                            &_self,
                            other.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "intersect",
                |
                    _self: Ref<bevy::math::prelude::URect>,
                    other: Val<bevy::math::prelude::URect>|
                {
                    let output: Val<bevy::math::prelude::URect> = bevy::math::prelude::URect::intersect(
                            &_self,
                            other.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "inflate",
                |_self: Ref<bevy::math::prelude::URect>, expansion: i32| {
                    let output: Val<bevy::math::prelude::URect> = bevy::math::prelude::URect::inflate(
                            &_self,
                            expansion,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_rect",
                |_self: Ref<bevy::math::prelude::URect>| {
                    let output: Val<bevy::math::prelude::Rect> = bevy::math::prelude::URect::as_rect(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_irect",
                |_self: Ref<bevy::math::prelude::URect>| {
                    let output: Val<bevy::math::prelude::IRect> = bevy::math::prelude::URect::as_irect(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::prelude::URect>| {
                    let output: () = <bevy::math::prelude::URect as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::Affine3>::new(world);
        NamespaceBuilder::<::bevy::math::bounding::Aabb2d>::new(world)
            .register(
                "bounding_circle",
                |_self: Ref<bevy::math::bounding::Aabb2d>| {
                    let output: Val<bevy::math::bounding::BoundingCircle> = bevy::math::bounding::Aabb2d::bounding_circle(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::bounding::Aabb2d>| {
                    let output: Val<bevy::math::bounding::Aabb2d> = <bevy::math::bounding::Aabb2d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::bounding::BoundingCircle>::new(world)
            .register(
                "clone",
                |_self: Ref<bevy::math::bounding::BoundingCircle>| {
                    let output: Val<bevy::math::bounding::BoundingCircle> = <bevy::math::bounding::BoundingCircle as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "radius",
                |_self: Ref<bevy::math::bounding::BoundingCircle>| {
                    let output: f32 = bevy::math::bounding::BoundingCircle::radius(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "aabb_2d",
                |_self: Ref<bevy::math::bounding::BoundingCircle>| {
                    let output: Val<bevy::math::bounding::Aabb2d> = bevy::math::bounding::BoundingCircle::aabb_2d(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Circle>::new(world)
            .register(
                "new",
                |radius: f32| {
                    let output: Val<bevy::math::primitives::Circle> = bevy::math::primitives::Circle::new(
                            radius,
                        )
                        .into();
                    output
                },
            )
            .register(
                "diameter",
                |_self: Ref<bevy::math::primitives::Circle>| {
                    let output: f32 = bevy::math::primitives::Circle::diameter(&_self)
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Circle>,
                    other: Ref<bevy::math::primitives::Circle>|
                {
                    let output: bool = <bevy::math::primitives::Circle as std::cmp::PartialEq<
                        bevy::math::primitives::Circle,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Circle>| {
                    let output: Val<bevy::math::primitives::Circle> = <bevy::math::primitives::Circle as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Annulus>::new(world)
            .register(
                "new",
                |inner_radius: f32, outer_radius: f32| {
                    let output: Val<bevy::math::primitives::Annulus> = bevy::math::primitives::Annulus::new(
                            inner_radius,
                            outer_radius,
                        )
                        .into();
                    output
                },
            )
            .register(
                "diameter",
                |_self: Ref<bevy::math::primitives::Annulus>| {
                    let output: f32 = bevy::math::primitives::Annulus::diameter(&_self)
                        .into();
                    output
                },
            )
            .register(
                "thickness",
                |_self: Ref<bevy::math::primitives::Annulus>| {
                    let output: f32 = bevy::math::primitives::Annulus::thickness(&_self)
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Annulus>| {
                    let output: Val<bevy::math::primitives::Annulus> = <bevy::math::primitives::Annulus as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Annulus>,
                    other: Ref<bevy::math::primitives::Annulus>|
                {
                    let output: bool = <bevy::math::primitives::Annulus as std::cmp::PartialEq<
                        bevy::math::primitives::Annulus,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Arc2d>::new(world)
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Arc2d>,
                    other: Ref<bevy::math::primitives::Arc2d>|
                {
                    let output: bool = <bevy::math::primitives::Arc2d as std::cmp::PartialEq<
                        bevy::math::primitives::Arc2d,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Arc2d>| {
                    let output: Val<bevy::math::primitives::Arc2d> = <bevy::math::primitives::Arc2d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |radius: f32, half_angle: f32| {
                    let output: Val<bevy::math::primitives::Arc2d> = bevy::math::primitives::Arc2d::new(
                            radius,
                            half_angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_radians",
                |radius: f32, angle: f32| {
                    let output: Val<bevy::math::primitives::Arc2d> = bevy::math::primitives::Arc2d::from_radians(
                            radius,
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_degrees",
                |radius: f32, angle: f32| {
                    let output: Val<bevy::math::primitives::Arc2d> = bevy::math::primitives::Arc2d::from_degrees(
                            radius,
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_turns",
                |radius: f32, fraction: f32| {
                    let output: Val<bevy::math::primitives::Arc2d> = bevy::math::primitives::Arc2d::from_turns(
                            radius,
                            fraction,
                        )
                        .into();
                    output
                },
            )
            .register(
                "angle",
                |_self: Ref<bevy::math::primitives::Arc2d>| {
                    let output: f32 = bevy::math::primitives::Arc2d::angle(&_self)
                        .into();
                    output
                },
            )
            .register(
                "length",
                |_self: Ref<bevy::math::primitives::Arc2d>| {
                    let output: f32 = bevy::math::primitives::Arc2d::length(&_self)
                        .into();
                    output
                },
            )
            .register(
                "half_chord_length",
                |_self: Ref<bevy::math::primitives::Arc2d>| {
                    let output: f32 = bevy::math::primitives::Arc2d::half_chord_length(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "chord_length",
                |_self: Ref<bevy::math::primitives::Arc2d>| {
                    let output: f32 = bevy::math::primitives::Arc2d::chord_length(&_self)
                        .into();
                    output
                },
            )
            .register(
                "apothem",
                |_self: Ref<bevy::math::primitives::Arc2d>| {
                    let output: f32 = bevy::math::primitives::Arc2d::apothem(&_self)
                        .into();
                    output
                },
            )
            .register(
                "sagitta",
                |_self: Ref<bevy::math::primitives::Arc2d>| {
                    let output: f32 = bevy::math::primitives::Arc2d::sagitta(&_self)
                        .into();
                    output
                },
            )
            .register(
                "is_minor",
                |_self: Ref<bevy::math::primitives::Arc2d>| {
                    let output: bool = bevy::math::primitives::Arc2d::is_minor(&_self)
                        .into();
                    output
                },
            )
            .register(
                "is_major",
                |_self: Ref<bevy::math::primitives::Arc2d>| {
                    let output: bool = bevy::math::primitives::Arc2d::is_major(&_self)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Capsule2d>::new(world)
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Capsule2d>,
                    other: Ref<bevy::math::primitives::Capsule2d>|
                {
                    let output: bool = <bevy::math::primitives::Capsule2d as std::cmp::PartialEq<
                        bevy::math::primitives::Capsule2d,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "new",
                |radius: f32, length: f32| {
                    let output: Val<bevy::math::primitives::Capsule2d> = bevy::math::primitives::Capsule2d::new(
                            radius,
                            length,
                        )
                        .into();
                    output
                },
            )
            .register(
                "to_inner_rectangle",
                |_self: Ref<bevy::math::primitives::Capsule2d>| {
                    let output: Val<bevy::math::primitives::Rectangle> = bevy::math::primitives::Capsule2d::to_inner_rectangle(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Capsule2d>| {
                    let output: Val<bevy::math::primitives::Capsule2d> = <bevy::math::primitives::Capsule2d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::CircularSector>::new(world)
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::CircularSector>| {
                    let output: Val<bevy::math::primitives::CircularSector> = <bevy::math::primitives::CircularSector as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::CircularSector>,
                    other: Ref<bevy::math::primitives::CircularSector>|
                {
                    let output: bool = <bevy::math::primitives::CircularSector as std::cmp::PartialEq<
                        bevy::math::primitives::CircularSector,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "new",
                |radius: f32, angle: f32| {
                    let output: Val<bevy::math::primitives::CircularSector> = bevy::math::primitives::CircularSector::new(
                            radius,
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_radians",
                |radius: f32, angle: f32| {
                    let output: Val<bevy::math::primitives::CircularSector> = bevy::math::primitives::CircularSector::from_radians(
                            radius,
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_degrees",
                |radius: f32, angle: f32| {
                    let output: Val<bevy::math::primitives::CircularSector> = bevy::math::primitives::CircularSector::from_degrees(
                            radius,
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_turns",
                |radius: f32, fraction: f32| {
                    let output: Val<bevy::math::primitives::CircularSector> = bevy::math::primitives::CircularSector::from_turns(
                            radius,
                            fraction,
                        )
                        .into();
                    output
                },
            )
            .register(
                "half_angle",
                |_self: Ref<bevy::math::primitives::CircularSector>| {
                    let output: f32 = bevy::math::primitives::CircularSector::half_angle(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "angle",
                |_self: Ref<bevy::math::primitives::CircularSector>| {
                    let output: f32 = bevy::math::primitives::CircularSector::angle(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "radius",
                |_self: Ref<bevy::math::primitives::CircularSector>| {
                    let output: f32 = bevy::math::primitives::CircularSector::radius(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "arc_length",
                |_self: Ref<bevy::math::primitives::CircularSector>| {
                    let output: f32 = bevy::math::primitives::CircularSector::arc_length(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "half_chord_length",
                |_self: Ref<bevy::math::primitives::CircularSector>| {
                    let output: f32 = bevy::math::primitives::CircularSector::half_chord_length(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "chord_length",
                |_self: Ref<bevy::math::primitives::CircularSector>| {
                    let output: f32 = bevy::math::primitives::CircularSector::chord_length(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "apothem",
                |_self: Ref<bevy::math::primitives::CircularSector>| {
                    let output: f32 = bevy::math::primitives::CircularSector::apothem(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "sagitta",
                |_self: Ref<bevy::math::primitives::CircularSector>| {
                    let output: f32 = bevy::math::primitives::CircularSector::sagitta(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::CircularSegment>::new(world)
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::CircularSegment>,
                    other: Ref<bevy::math::primitives::CircularSegment>|
                {
                    let output: bool = <bevy::math::primitives::CircularSegment as std::cmp::PartialEq<
                        bevy::math::primitives::CircularSegment,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::CircularSegment>| {
                    let output: Val<bevy::math::primitives::CircularSegment> = <bevy::math::primitives::CircularSegment as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |radius: f32, angle: f32| {
                    let output: Val<bevy::math::primitives::CircularSegment> = bevy::math::primitives::CircularSegment::new(
                            radius,
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_radians",
                |radius: f32, angle: f32| {
                    let output: Val<bevy::math::primitives::CircularSegment> = bevy::math::primitives::CircularSegment::from_radians(
                            radius,
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_degrees",
                |radius: f32, angle: f32| {
                    let output: Val<bevy::math::primitives::CircularSegment> = bevy::math::primitives::CircularSegment::from_degrees(
                            radius,
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_turns",
                |radius: f32, fraction: f32| {
                    let output: Val<bevy::math::primitives::CircularSegment> = bevy::math::primitives::CircularSegment::from_turns(
                            radius,
                            fraction,
                        )
                        .into();
                    output
                },
            )
            .register(
                "half_angle",
                |_self: Ref<bevy::math::primitives::CircularSegment>| {
                    let output: f32 = bevy::math::primitives::CircularSegment::half_angle(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "angle",
                |_self: Ref<bevy::math::primitives::CircularSegment>| {
                    let output: f32 = bevy::math::primitives::CircularSegment::angle(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "radius",
                |_self: Ref<bevy::math::primitives::CircularSegment>| {
                    let output: f32 = bevy::math::primitives::CircularSegment::radius(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "arc_length",
                |_self: Ref<bevy::math::primitives::CircularSegment>| {
                    let output: f32 = bevy::math::primitives::CircularSegment::arc_length(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "half_chord_length",
                |_self: Ref<bevy::math::primitives::CircularSegment>| {
                    let output: f32 = bevy::math::primitives::CircularSegment::half_chord_length(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "chord_length",
                |_self: Ref<bevy::math::primitives::CircularSegment>| {
                    let output: f32 = bevy::math::primitives::CircularSegment::chord_length(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "apothem",
                |_self: Ref<bevy::math::primitives::CircularSegment>| {
                    let output: f32 = bevy::math::primitives::CircularSegment::apothem(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "sagitta",
                |_self: Ref<bevy::math::primitives::CircularSegment>| {
                    let output: f32 = bevy::math::primitives::CircularSegment::sagitta(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Ellipse>::new(world)
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Ellipse>| {
                    let output: Val<bevy::math::primitives::Ellipse> = <bevy::math::primitives::Ellipse as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |half_width: f32, half_height: f32| {
                    let output: Val<bevy::math::primitives::Ellipse> = bevy::math::primitives::Ellipse::new(
                            half_width,
                            half_height,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eccentricity",
                |_self: Ref<bevy::math::primitives::Ellipse>| {
                    let output: f32 = bevy::math::primitives::Ellipse::eccentricity(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "focal_length",
                |_self: Ref<bevy::math::primitives::Ellipse>| {
                    let output: f32 = bevy::math::primitives::Ellipse::focal_length(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "semi_major",
                |_self: Ref<bevy::math::primitives::Ellipse>| {
                    let output: f32 = bevy::math::primitives::Ellipse::semi_major(&_self)
                        .into();
                    output
                },
            )
            .register(
                "semi_minor",
                |_self: Ref<bevy::math::primitives::Ellipse>| {
                    let output: f32 = bevy::math::primitives::Ellipse::semi_minor(&_self)
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Ellipse>,
                    other: Ref<bevy::math::primitives::Ellipse>|
                {
                    let output: bool = <bevy::math::primitives::Ellipse as std::cmp::PartialEq<
                        bevy::math::primitives::Ellipse,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Line2d>::new(world)
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Line2d>,
                    other: Ref<bevy::math::primitives::Line2d>|
                {
                    let output: bool = <bevy::math::primitives::Line2d as std::cmp::PartialEq<
                        bevy::math::primitives::Line2d,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Line2d>| {
                    let output: Val<bevy::math::primitives::Line2d> = <bevy::math::primitives::Line2d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Plane2d>::new(world)
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Plane2d>,
                    other: Ref<bevy::math::primitives::Plane2d>|
                {
                    let output: bool = <bevy::math::primitives::Plane2d as std::cmp::PartialEq<
                        bevy::math::primitives::Plane2d,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Plane2d>| {
                    let output: Val<bevy::math::primitives::Plane2d> = <bevy::math::primitives::Plane2d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Rectangle>::new(world)
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Rectangle>| {
                    let output: Val<bevy::math::primitives::Rectangle> = <bevy::math::primitives::Rectangle as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Rectangle>,
                    other: Ref<bevy::math::primitives::Rectangle>|
                {
                    let output: bool = <bevy::math::primitives::Rectangle as std::cmp::PartialEq<
                        bevy::math::primitives::Rectangle,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "new",
                |width: f32, height: f32| {
                    let output: Val<bevy::math::primitives::Rectangle> = bevy::math::primitives::Rectangle::new(
                            width,
                            height,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_length",
                |length: f32| {
                    let output: Val<bevy::math::primitives::Rectangle> = bevy::math::primitives::Rectangle::from_length(
                            length,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::RegularPolygon>::new(world)
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::RegularPolygon>,
                    other: Ref<bevy::math::primitives::RegularPolygon>|
                {
                    let output: bool = <bevy::math::primitives::RegularPolygon as std::cmp::PartialEq<
                        bevy::math::primitives::RegularPolygon,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "new",
                |circumradius: f32, sides: u32| {
                    let output: Val<bevy::math::primitives::RegularPolygon> = bevy::math::primitives::RegularPolygon::new(
                            circumradius,
                            sides,
                        )
                        .into();
                    output
                },
            )
            .register(
                "circumradius",
                |_self: Ref<bevy::math::primitives::RegularPolygon>| {
                    let output: f32 = bevy::math::primitives::RegularPolygon::circumradius(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "inradius",
                |_self: Ref<bevy::math::primitives::RegularPolygon>| {
                    let output: f32 = bevy::math::primitives::RegularPolygon::inradius(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "side_length",
                |_self: Ref<bevy::math::primitives::RegularPolygon>| {
                    let output: f32 = bevy::math::primitives::RegularPolygon::side_length(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "internal_angle_degrees",
                |_self: Ref<bevy::math::primitives::RegularPolygon>| {
                    let output: f32 = bevy::math::primitives::RegularPolygon::internal_angle_degrees(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "internal_angle_radians",
                |_self: Ref<bevy::math::primitives::RegularPolygon>| {
                    let output: f32 = bevy::math::primitives::RegularPolygon::internal_angle_radians(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "external_angle_degrees",
                |_self: Ref<bevy::math::primitives::RegularPolygon>| {
                    let output: f32 = bevy::math::primitives::RegularPolygon::external_angle_degrees(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "external_angle_radians",
                |_self: Ref<bevy::math::primitives::RegularPolygon>| {
                    let output: f32 = bevy::math::primitives::RegularPolygon::external_angle_radians(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::RegularPolygon>| {
                    let output: Val<bevy::math::primitives::RegularPolygon> = <bevy::math::primitives::RegularPolygon as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Rhombus>::new(world)
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Rhombus>,
                    other: Ref<bevy::math::primitives::Rhombus>|
                {
                    let output: bool = <bevy::math::primitives::Rhombus as std::cmp::PartialEq<
                        bevy::math::primitives::Rhombus,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "new",
                |horizontal_diagonal: f32, vertical_diagonal: f32| {
                    let output: Val<bevy::math::primitives::Rhombus> = bevy::math::primitives::Rhombus::new(
                            horizontal_diagonal,
                            vertical_diagonal,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_side",
                |side: f32| {
                    let output: Val<bevy::math::primitives::Rhombus> = bevy::math::primitives::Rhombus::from_side(
                            side,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_inradius",
                |inradius: f32| {
                    let output: Val<bevy::math::primitives::Rhombus> = bevy::math::primitives::Rhombus::from_inradius(
                            inradius,
                        )
                        .into();
                    output
                },
            )
            .register(
                "side",
                |_self: Ref<bevy::math::primitives::Rhombus>| {
                    let output: f32 = bevy::math::primitives::Rhombus::side(&_self)
                        .into();
                    output
                },
            )
            .register(
                "circumradius",
                |_self: Ref<bevy::math::primitives::Rhombus>| {
                    let output: f32 = bevy::math::primitives::Rhombus::circumradius(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "inradius",
                |_self: Ref<bevy::math::primitives::Rhombus>| {
                    let output: f32 = bevy::math::primitives::Rhombus::inradius(&_self)
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Rhombus>| {
                    let output: Val<bevy::math::primitives::Rhombus> = <bevy::math::primitives::Rhombus as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Segment2d>::new(world)
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Segment2d>| {
                    let output: Val<bevy::math::primitives::Segment2d> = <bevy::math::primitives::Segment2d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |direction: Val<bevy::math::prelude::Dir2>, length: f32| {
                    let output: Val<bevy::math::primitives::Segment2d> = bevy::math::primitives::Segment2d::new(
                            direction.into_inner(),
                            length,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Segment2d>,
                    other: Ref<bevy::math::primitives::Segment2d>|
                {
                    let output: bool = <bevy::math::primitives::Segment2d as std::cmp::PartialEq<
                        bevy::math::primitives::Segment2d,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Triangle2d>::new(world)
            .register(
                "is_degenerate",
                |_self: Ref<bevy::math::primitives::Triangle2d>| {
                    let output: bool = bevy::math::primitives::Triangle2d::is_degenerate(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_acute",
                |_self: Ref<bevy::math::primitives::Triangle2d>| {
                    let output: bool = bevy::math::primitives::Triangle2d::is_acute(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_obtuse",
                |_self: Ref<bevy::math::primitives::Triangle2d>| {
                    let output: bool = bevy::math::primitives::Triangle2d::is_obtuse(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "reverse",
                |mut _self: Mut<bevy::math::primitives::Triangle2d>| {
                    let output: () = bevy::math::primitives::Triangle2d::reverse(
                            &mut _self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "reversed",
                |_self: Val<bevy::math::primitives::Triangle2d>| {
                    let output: Val<bevy::math::primitives::Triangle2d> = bevy::math::primitives::Triangle2d::reversed(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Triangle2d>| {
                    let output: Val<bevy::math::primitives::Triangle2d> = <bevy::math::primitives::Triangle2d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Triangle2d>,
                    other: Ref<bevy::math::primitives::Triangle2d>|
                {
                    let output: bool = <bevy::math::primitives::Triangle2d as std::cmp::PartialEq<
                        bevy::math::primitives::Triangle2d,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::bounding::Aabb3d>::new(world)
            .register(
                "clone",
                |_self: Ref<bevy::math::bounding::Aabb3d>| {
                    let output: Val<bevy::math::bounding::Aabb3d> = <bevy::math::bounding::Aabb3d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "bounding_sphere",
                |_self: Ref<bevy::math::bounding::Aabb3d>| {
                    let output: Val<bevy::math::bounding::BoundingSphere> = bevy::math::bounding::Aabb3d::bounding_sphere(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::bounding::BoundingSphere>::new(world)
            .register(
                "radius",
                |_self: Ref<bevy::math::bounding::BoundingSphere>| {
                    let output: f32 = bevy::math::bounding::BoundingSphere::radius(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "aabb_3d",
                |_self: Ref<bevy::math::bounding::BoundingSphere>| {
                    let output: Val<bevy::math::bounding::Aabb3d> = bevy::math::bounding::BoundingSphere::aabb_3d(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::bounding::BoundingSphere>| {
                    let output: Val<bevy::math::bounding::BoundingSphere> = <bevy::math::bounding::BoundingSphere as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Sphere>::new(world)
            .register(
                "new",
                |radius: f32| {
                    let output: Val<bevy::math::primitives::Sphere> = bevy::math::primitives::Sphere::new(
                            radius,
                        )
                        .into();
                    output
                },
            )
            .register(
                "diameter",
                |_self: Ref<bevy::math::primitives::Sphere>| {
                    let output: f32 = bevy::math::primitives::Sphere::diameter(&_self)
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Sphere>,
                    other: Ref<bevy::math::primitives::Sphere>|
                {
                    let output: bool = <bevy::math::primitives::Sphere as std::cmp::PartialEq<
                        bevy::math::primitives::Sphere,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Sphere>| {
                    let output: Val<bevy::math::primitives::Sphere> = <bevy::math::primitives::Sphere as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Cuboid>::new(world)
            .register(
                "new",
                |x_length: f32, y_length: f32, z_length: f32| {
                    let output: Val<bevy::math::primitives::Cuboid> = bevy::math::primitives::Cuboid::new(
                            x_length,
                            y_length,
                            z_length,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_length",
                |length: f32| {
                    let output: Val<bevy::math::primitives::Cuboid> = bevy::math::primitives::Cuboid::from_length(
                            length,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Cuboid>| {
                    let output: Val<bevy::math::primitives::Cuboid> = <bevy::math::primitives::Cuboid as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Cuboid>,
                    other: Ref<bevy::math::primitives::Cuboid>|
                {
                    let output: bool = <bevy::math::primitives::Cuboid as std::cmp::PartialEq<
                        bevy::math::primitives::Cuboid,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Cylinder>::new(world)
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Cylinder>| {
                    let output: Val<bevy::math::primitives::Cylinder> = <bevy::math::primitives::Cylinder as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |radius: f32, height: f32| {
                    let output: Val<bevy::math::primitives::Cylinder> = bevy::math::primitives::Cylinder::new(
                            radius,
                            height,
                        )
                        .into();
                    output
                },
            )
            .register(
                "base",
                |_self: Ref<bevy::math::primitives::Cylinder>| {
                    let output: Val<bevy::math::primitives::Circle> = bevy::math::primitives::Cylinder::base(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "lateral_area",
                |_self: Ref<bevy::math::primitives::Cylinder>| {
                    let output: f32 = bevy::math::primitives::Cylinder::lateral_area(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "base_area",
                |_self: Ref<bevy::math::primitives::Cylinder>| {
                    let output: f32 = bevy::math::primitives::Cylinder::base_area(&_self)
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Cylinder>,
                    other: Ref<bevy::math::primitives::Cylinder>|
                {
                    let output: bool = <bevy::math::primitives::Cylinder as std::cmp::PartialEq<
                        bevy::math::primitives::Cylinder,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Capsule3d>::new(world)
            .register(
                "new",
                |radius: f32, length: f32| {
                    let output: Val<bevy::math::primitives::Capsule3d> = bevy::math::primitives::Capsule3d::new(
                            radius,
                            length,
                        )
                        .into();
                    output
                },
            )
            .register(
                "to_cylinder",
                |_self: Ref<bevy::math::primitives::Capsule3d>| {
                    let output: Val<bevy::math::primitives::Cylinder> = bevy::math::primitives::Capsule3d::to_cylinder(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Capsule3d>,
                    other: Ref<bevy::math::primitives::Capsule3d>|
                {
                    let output: bool = <bevy::math::primitives::Capsule3d as std::cmp::PartialEq<
                        bevy::math::primitives::Capsule3d,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Capsule3d>| {
                    let output: Val<bevy::math::primitives::Capsule3d> = <bevy::math::primitives::Capsule3d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Cone>::new(world)
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Cone>| {
                    let output: Val<bevy::math::primitives::Cone> = <bevy::math::primitives::Cone as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Cone>,
                    other: Ref<bevy::math::primitives::Cone>|
                {
                    let output: bool = <bevy::math::primitives::Cone as std::cmp::PartialEq<
                        bevy::math::primitives::Cone,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "new",
                |radius: f32, height: f32| {
                    let output: Val<bevy::math::primitives::Cone> = bevy::math::primitives::Cone::new(
                            radius,
                            height,
                        )
                        .into();
                    output
                },
            )
            .register(
                "base",
                |_self: Ref<bevy::math::primitives::Cone>| {
                    let output: Val<bevy::math::primitives::Circle> = bevy::math::primitives::Cone::base(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "slant_height",
                |_self: Ref<bevy::math::primitives::Cone>| {
                    let output: f32 = bevy::math::primitives::Cone::slant_height(&_self)
                        .into();
                    output
                },
            )
            .register(
                "lateral_area",
                |_self: Ref<bevy::math::primitives::Cone>| {
                    let output: f32 = bevy::math::primitives::Cone::lateral_area(&_self)
                        .into();
                    output
                },
            )
            .register(
                "base_area",
                |_self: Ref<bevy::math::primitives::Cone>| {
                    let output: f32 = bevy::math::primitives::Cone::base_area(&_self)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::ConicalFrustum>::new(world)
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::ConicalFrustum>,
                    other: Ref<bevy::math::primitives::ConicalFrustum>|
                {
                    let output: bool = <bevy::math::primitives::ConicalFrustum as std::cmp::PartialEq<
                        bevy::math::primitives::ConicalFrustum,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::ConicalFrustum>| {
                    let output: Val<bevy::math::primitives::ConicalFrustum> = <bevy::math::primitives::ConicalFrustum as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::InfinitePlane3d>::new(world)
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::InfinitePlane3d>,
                    other: Ref<bevy::math::primitives::InfinitePlane3d>|
                {
                    let output: bool = <bevy::math::primitives::InfinitePlane3d as std::cmp::PartialEq<
                        bevy::math::primitives::InfinitePlane3d,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::InfinitePlane3d>| {
                    let output: Val<bevy::math::primitives::InfinitePlane3d> = <bevy::math::primitives::InfinitePlane3d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Line3d>::new(world)
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Line3d>| {
                    let output: Val<bevy::math::primitives::Line3d> = <bevy::math::primitives::Line3d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Line3d>,
                    other: Ref<bevy::math::primitives::Line3d>|
                {
                    let output: bool = <bevy::math::primitives::Line3d as std::cmp::PartialEq<
                        bevy::math::primitives::Line3d,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Segment3d>::new(world)
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Segment3d>| {
                    let output: Val<bevy::math::primitives::Segment3d> = <bevy::math::primitives::Segment3d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |direction: Val<bevy::math::prelude::Dir3>, length: f32| {
                    let output: Val<bevy::math::primitives::Segment3d> = bevy::math::primitives::Segment3d::new(
                            direction.into_inner(),
                            length,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Segment3d>,
                    other: Ref<bevy::math::primitives::Segment3d>|
                {
                    let output: bool = <bevy::math::primitives::Segment3d as std::cmp::PartialEq<
                        bevy::math::primitives::Segment3d,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Torus>::new(world)
            .register(
                "new",
                |inner_radius: f32, outer_radius: f32| {
                    let output: Val<bevy::math::primitives::Torus> = bevy::math::primitives::Torus::new(
                            inner_radius,
                            outer_radius,
                        )
                        .into();
                    output
                },
            )
            .register(
                "inner_radius",
                |_self: Ref<bevy::math::primitives::Torus>| {
                    let output: f32 = bevy::math::primitives::Torus::inner_radius(&_self)
                        .into();
                    output
                },
            )
            .register(
                "outer_radius",
                |_self: Ref<bevy::math::primitives::Torus>| {
                    let output: f32 = bevy::math::primitives::Torus::outer_radius(&_self)
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Torus>,
                    other: Ref<bevy::math::primitives::Torus>|
                {
                    let output: bool = <bevy::math::primitives::Torus as std::cmp::PartialEq<
                        bevy::math::primitives::Torus,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Torus>| {
                    let output: Val<bevy::math::primitives::Torus> = <bevy::math::primitives::Torus as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Triangle3d>::new(world)
            .register(
                "is_degenerate",
                |_self: Ref<bevy::math::primitives::Triangle3d>| {
                    let output: bool = bevy::math::primitives::Triangle3d::is_degenerate(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_acute",
                |_self: Ref<bevy::math::primitives::Triangle3d>| {
                    let output: bool = bevy::math::primitives::Triangle3d::is_acute(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_obtuse",
                |_self: Ref<bevy::math::primitives::Triangle3d>| {
                    let output: bool = bevy::math::primitives::Triangle3d::is_obtuse(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "reverse",
                |mut _self: Mut<bevy::math::primitives::Triangle3d>| {
                    let output: () = bevy::math::primitives::Triangle3d::reverse(
                            &mut _self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "reversed",
                |_self: Val<bevy::math::primitives::Triangle3d>| {
                    let output: Val<bevy::math::primitives::Triangle3d> = bevy::math::primitives::Triangle3d::reversed(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Triangle3d>| {
                    let output: Val<bevy::math::primitives::Triangle3d> = <bevy::math::primitives::Triangle3d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Triangle3d>,
                    other: Ref<bevy::math::primitives::Triangle3d>|
                {
                    let output: bool = <bevy::math::primitives::Triangle3d as std::cmp::PartialEq<
                        bevy::math::primitives::Triangle3d,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::bounding::RayCast2d>::new(world)
            .register(
                "clone",
                |_self: Ref<bevy::math::bounding::RayCast2d>| {
                    let output: Val<bevy::math::bounding::RayCast2d> = <bevy::math::bounding::RayCast2d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_ray",
                |ray: Val<bevy::math::Ray2d>, max: f32| {
                    let output: Val<bevy::math::bounding::RayCast2d> = bevy::math::bounding::RayCast2d::from_ray(
                            ray.into_inner(),
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "aabb_intersection_at",
                |
                    _self: Ref<bevy::math::bounding::RayCast2d>,
                    aabb: Ref<bevy::math::bounding::Aabb2d>|
                {
                    let output: std::option::Option<f32> = bevy::math::bounding::RayCast2d::aabb_intersection_at(
                            &_self,
                            &aabb,
                        )
                        .into();
                    output
                },
            )
            .register(
                "circle_intersection_at",
                |
                    _self: Ref<bevy::math::bounding::RayCast2d>,
                    circle: Ref<bevy::math::bounding::BoundingCircle>|
                {
                    let output: std::option::Option<f32> = bevy::math::bounding::RayCast2d::circle_intersection_at(
                            &_self,
                            &circle,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::bounding::AabbCast2d>::new(world)
            .register(
                "from_ray",
                |
                    aabb: Val<bevy::math::bounding::Aabb2d>,
                    ray: Val<bevy::math::Ray2d>,
                    max: f32|
                {
                    let output: Val<bevy::math::bounding::AabbCast2d> = bevy::math::bounding::AabbCast2d::from_ray(
                            aabb.into_inner(),
                            ray.into_inner(),
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "aabb_collision_at",
                |
                    _self: Ref<bevy::math::bounding::AabbCast2d>,
                    aabb: Val<bevy::math::bounding::Aabb2d>|
                {
                    let output: std::option::Option<f32> = bevy::math::bounding::AabbCast2d::aabb_collision_at(
                            &_self,
                            aabb.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::bounding::AabbCast2d>| {
                    let output: Val<bevy::math::bounding::AabbCast2d> = <bevy::math::bounding::AabbCast2d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::bounding::BoundingCircleCast>::new(world)
            .register(
                "clone",
                |_self: Ref<bevy::math::bounding::BoundingCircleCast>| {
                    let output: Val<bevy::math::bounding::BoundingCircleCast> = <bevy::math::bounding::BoundingCircleCast as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_ray",
                |
                    circle: Val<bevy::math::bounding::BoundingCircle>,
                    ray: Val<bevy::math::Ray2d>,
                    max: f32|
                {
                    let output: Val<bevy::math::bounding::BoundingCircleCast> = bevy::math::bounding::BoundingCircleCast::from_ray(
                            circle.into_inner(),
                            ray.into_inner(),
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "circle_collision_at",
                |
                    _self: Ref<bevy::math::bounding::BoundingCircleCast>,
                    circle: Val<bevy::math::bounding::BoundingCircle>|
                {
                    let output: std::option::Option<f32> = bevy::math::bounding::BoundingCircleCast::circle_collision_at(
                            &_self,
                            circle.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::bounding::RayCast3d>::new(world)
            .register(
                "clone",
                |_self: Ref<bevy::math::bounding::RayCast3d>| {
                    let output: Val<bevy::math::bounding::RayCast3d> = <bevy::math::bounding::RayCast3d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_ray",
                |ray: Val<bevy::math::Ray3d>, max: f32| {
                    let output: Val<bevy::math::bounding::RayCast3d> = bevy::math::bounding::RayCast3d::from_ray(
                            ray.into_inner(),
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "aabb_intersection_at",
                |
                    _self: Ref<bevy::math::bounding::RayCast3d>,
                    aabb: Ref<bevy::math::bounding::Aabb3d>|
                {
                    let output: std::option::Option<f32> = bevy::math::bounding::RayCast3d::aabb_intersection_at(
                            &_self,
                            &aabb,
                        )
                        .into();
                    output
                },
            )
            .register(
                "sphere_intersection_at",
                |
                    _self: Ref<bevy::math::bounding::RayCast3d>,
                    sphere: Ref<bevy::math::bounding::BoundingSphere>|
                {
                    let output: std::option::Option<f32> = bevy::math::bounding::RayCast3d::sphere_intersection_at(
                            &_self,
                            &sphere,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::bounding::AabbCast3d>::new(world)
            .register(
                "from_ray",
                |
                    aabb: Val<bevy::math::bounding::Aabb3d>,
                    ray: Val<bevy::math::Ray3d>,
                    max: f32|
                {
                    let output: Val<bevy::math::bounding::AabbCast3d> = bevy::math::bounding::AabbCast3d::from_ray(
                            aabb.into_inner(),
                            ray.into_inner(),
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "aabb_collision_at",
                |
                    _self: Ref<bevy::math::bounding::AabbCast3d>,
                    aabb: Val<bevy::math::bounding::Aabb3d>|
                {
                    let output: std::option::Option<f32> = bevy::math::bounding::AabbCast3d::aabb_collision_at(
                            &_self,
                            aabb.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::bounding::AabbCast3d>| {
                    let output: Val<bevy::math::bounding::AabbCast3d> = <bevy::math::bounding::AabbCast3d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::bounding::BoundingSphereCast>::new(world)
            .register(
                "from_ray",
                |
                    sphere: Val<bevy::math::bounding::BoundingSphere>,
                    ray: Val<bevy::math::Ray3d>,
                    max: f32|
                {
                    let output: Val<bevy::math::bounding::BoundingSphereCast> = bevy::math::bounding::BoundingSphereCast::from_ray(
                            sphere.into_inner(),
                            ray.into_inner(),
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "sphere_collision_at",
                |
                    _self: Ref<bevy::math::bounding::BoundingSphereCast>,
                    sphere: Val<bevy::math::bounding::BoundingSphere>|
                {
                    let output: std::option::Option<f32> = bevy::math::bounding::BoundingSphereCast::sphere_collision_at(
                            &_self,
                            sphere.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::bounding::BoundingSphereCast>| {
                    let output: Val<bevy::math::bounding::BoundingSphereCast> = <bevy::math::bounding::BoundingSphereCast as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::curve::interval::Interval>::new(world)
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::curve::interval::Interval>,
                    other: Ref<bevy::math::curve::interval::Interval>|
                {
                    let output: bool = <bevy::math::curve::interval::Interval as std::cmp::PartialEq<
                        bevy::math::curve::interval::Interval,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "start",
                |_self: Val<bevy::math::curve::interval::Interval>| {
                    let output: f32 = bevy::math::curve::interval::Interval::start(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "end",
                |_self: Val<bevy::math::curve::interval::Interval>| {
                    let output: f32 = bevy::math::curve::interval::Interval::end(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "length",
                |_self: Val<bevy::math::curve::interval::Interval>| {
                    let output: f32 = bevy::math::curve::interval::Interval::length(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_bounded",
                |_self: Val<bevy::math::curve::interval::Interval>| {
                    let output: bool = bevy::math::curve::interval::Interval::is_bounded(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "has_finite_start",
                |_self: Val<bevy::math::curve::interval::Interval>| {
                    let output: bool = bevy::math::curve::interval::Interval::has_finite_start(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "has_finite_end",
                |_self: Val<bevy::math::curve::interval::Interval>| {
                    let output: bool = bevy::math::curve::interval::Interval::has_finite_end(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "contains",
                |_self: Val<bevy::math::curve::interval::Interval>, item: f32| {
                    let output: bool = bevy::math::curve::interval::Interval::contains(
                            _self.into_inner(),
                            item,
                        )
                        .into();
                    output
                },
            )
            .register(
                "contains_interval",
                |
                    _self: Val<bevy::math::curve::interval::Interval>,
                    other: Val<bevy::math::curve::interval::Interval>|
                {
                    let output: bool = bevy::math::curve::interval::Interval::contains_interval(
                            _self.into_inner(),
                            other.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |_self: Val<bevy::math::curve::interval::Interval>, value: f32| {
                    let output: f32 = bevy::math::curve::interval::Interval::clamp(
                            _self.into_inner(),
                            value,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::curve::interval::Interval>| {
                    let output: Val<bevy::math::curve::interval::Interval> = <bevy::math::curve::interval::Interval as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::FloatOrd>::new(world)
            .register(
                "clone",
                |_self: Ref<bevy::math::FloatOrd>| {
                    let output: Val<bevy::math::FloatOrd> = <bevy::math::FloatOrd as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::FloatOrd>, other: Ref<bevy::math::FloatOrd>| {
                    let output: bool = <bevy::math::FloatOrd as std::cmp::PartialEq<
                        bevy::math::FloatOrd,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::FloatOrd>| {
                    let output: Val<bevy::math::FloatOrd> = <bevy::math::FloatOrd as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "lt",
                |_self: Ref<bevy::math::FloatOrd>, other: Ref<bevy::math::FloatOrd>| {
                    let output: bool = <bevy::math::FloatOrd as std::cmp::PartialOrd<
                        bevy::math::FloatOrd,
                    >>::lt(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "le",
                |_self: Ref<bevy::math::FloatOrd>, other: Ref<bevy::math::FloatOrd>| {
                    let output: bool = <bevy::math::FloatOrd as std::cmp::PartialOrd<
                        bevy::math::FloatOrd,
                    >>::le(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "gt",
                |_self: Ref<bevy::math::FloatOrd>, other: Ref<bevy::math::FloatOrd>| {
                    let output: bool = <bevy::math::FloatOrd as std::cmp::PartialOrd<
                        bevy::math::FloatOrd,
                    >>::gt(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "ge",
                |_self: Ref<bevy::math::FloatOrd>, other: Ref<bevy::math::FloatOrd>| {
                    let output: bool = <bevy::math::FloatOrd as std::cmp::PartialOrd<
                        bevy::math::FloatOrd,
                    >>::ge(&_self, &other)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Plane3d>::new(world)
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Plane3d>| {
                    let output: Val<bevy::math::primitives::Plane3d> = <bevy::math::primitives::Plane3d as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Plane3d>,
                    other: Ref<bevy::math::primitives::Plane3d>|
                {
                    let output: bool = <bevy::math::primitives::Plane3d as std::cmp::PartialEq<
                        bevy::math::primitives::Plane3d,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::primitives::Tetrahedron>::new(world)
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::primitives::Tetrahedron>,
                    other: Ref<bevy::math::primitives::Tetrahedron>|
                {
                    let output: bool = <bevy::math::primitives::Tetrahedron as std::cmp::PartialEq<
                        bevy::math::primitives::Tetrahedron,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "signed_volume",
                |_self: Ref<bevy::math::primitives::Tetrahedron>| {
                    let output: f32 = bevy::math::primitives::Tetrahedron::signed_volume(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::primitives::Tetrahedron>| {
                    let output: Val<bevy::math::primitives::Tetrahedron> = <bevy::math::primitives::Tetrahedron as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::curve::easing::EaseFunction>::new(world)
            .register(
                "eq",
                |
                    _self: Ref<bevy::math::curve::easing::EaseFunction>,
                    other: Ref<bevy::math::curve::easing::EaseFunction>|
                {
                    let output: bool = <bevy::math::curve::easing::EaseFunction as std::cmp::PartialEq<
                        bevy::math::curve::easing::EaseFunction,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::curve::easing::EaseFunction>| {
                    let output: Val<bevy::math::curve::easing::EaseFunction> = <bevy::math::curve::easing::EaseFunction as std::clone::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            );
    }
}
