// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use bevy_mod_scripting_core::bindings::{
    ReflectReference,
    function::{
        from::{Ref, Mut, Val},
        namespace::NamespaceBuilder,
    },
};
use bevy_mod_scripting_derive::script_bindings;
use crate::*;
pub struct BevyInputScriptingPlugin;
#[script_bindings(
    remote,
    name = "gamepad_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::Gamepad {
    ///  Returns the directional pad as a [`Vec2`].
    fn dpad(_self: Ref<bevy::input::gamepad::Gamepad>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::input::gamepad::Gamepad::dpad(&_self)
            .into();
        output
    }
    ///  Returns `true` if the [`GamepadButton`] has been pressed during the current frame.
    ///  Note: This function does not imply information regarding the current state of [`ButtonInput::pressed`] or [`ButtonInput::just_released`].
    fn just_pressed(
        _self: Ref<bevy::input::gamepad::Gamepad>,
        button_type: Val<bevy::input::gamepad::GamepadButton>,
    ) -> bool {
        let output: bool = bevy::input::gamepad::Gamepad::just_pressed(
                &_self,
                button_type.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `true` if the [`GamepadButton`] has been released during the current frame.
    ///  Note: This function does not imply information regarding the current state of [`ButtonInput::pressed`] or [`ButtonInput::just_pressed`].
    fn just_released(
        _self: Ref<bevy::input::gamepad::Gamepad>,
        button_type: Val<bevy::input::gamepad::GamepadButton>,
    ) -> bool {
        let output: bool = bevy::input::gamepad::Gamepad::just_released(
                &_self,
                button_type.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the left stick as a [`Vec2`].
    fn left_stick(_self: Ref<bevy::input::gamepad::Gamepad>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::input::gamepad::Gamepad::left_stick(
                &_self,
            )
            .into();
        output
    }
    ///  Returns `true` if the [`GamepadButton`] has been pressed.
    fn pressed(
        _self: Ref<bevy::input::gamepad::Gamepad>,
        button_type: Val<bevy::input::gamepad::GamepadButton>,
    ) -> bool {
        let output: bool = bevy::input::gamepad::Gamepad::pressed(
                &_self,
                button_type.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the USB product ID as assigned by the [vendor], if available.
    ///  [vendor]: Self::vendor_id
    fn product_id(
        _self: Ref<bevy::input::gamepad::Gamepad>,
    ) -> ::core::option::Option<u16> {
        let output: ::core::option::Option<u16> = bevy::input::gamepad::Gamepad::product_id(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the right stick as a [`Vec2`].
    fn right_stick(_self: Ref<bevy::input::gamepad::Gamepad>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::input::gamepad::Gamepad::right_stick(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the USB vendor ID as assigned by the USB-IF, if available.
    fn vendor_id(
        _self: Ref<bevy::input::gamepad::Gamepad>,
    ) -> ::core::option::Option<u16> {
        let output: ::core::option::Option<u16> = bevy::input::gamepad::Gamepad::vendor_id(
                &_self,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "gamepad_axis_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::GamepadAxis {}
#[script_bindings(
    remote,
    name = "gamepad_button_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::GamepadButton {}
#[script_bindings(
    remote,
    name = "gamepad_settings_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::GamepadSettings {}
#[script_bindings(
    remote,
    name = "key_code_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::keyboard::KeyCode {}
#[script_bindings(
    remote,
    name = "mouse_button_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::mouse::MouseButton {}
#[script_bindings(
    remote,
    name = "touch_input_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::touch::TouchInput {}
#[script_bindings(
    remote,
    name = "keyboard_focus_lost_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::keyboard::KeyboardFocusLost {}
#[script_bindings(
    remote,
    name = "keyboard_input_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::keyboard::KeyboardInput {}
#[script_bindings(
    remote,
    name = "accumulated_mouse_motion_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::mouse::AccumulatedMouseMotion {}
#[script_bindings(
    remote,
    name = "accumulated_mouse_scroll_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::mouse::AccumulatedMouseScroll {}
#[script_bindings(
    remote,
    name = "mouse_button_input_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::mouse::MouseButtonInput {}
#[script_bindings(
    remote,
    name = "mouse_motion_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::mouse::MouseMotion {}
#[script_bindings(
    remote,
    name = "mouse_wheel_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::mouse::MouseWheel {}
#[script_bindings(
    remote,
    name = "gamepad_axis_changed_event_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::GamepadAxisChangedEvent {
    ///  Creates a new [`GamepadAxisChangedEvent`].
    fn new(
        entity: Val<bevy::ecs::entity::Entity>,
        axis: Val<bevy::input::gamepad::GamepadAxis>,
        value: f32,
    ) -> Val<bevy::input::gamepad::GamepadAxisChangedEvent> {
        let output: Val<bevy::input::gamepad::GamepadAxisChangedEvent> = bevy::input::gamepad::GamepadAxisChangedEvent::new(
                entity.into_inner(),
                axis.into_inner(),
                value,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "gamepad_button_changed_event_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::GamepadButtonChangedEvent {
    ///  Creates a new [`GamepadButtonChangedEvent`].
    fn new(
        entity: Val<bevy::ecs::entity::Entity>,
        button: Val<bevy::input::gamepad::GamepadButton>,
        state: Val<bevy::input::ButtonState>,
        value: f32,
    ) -> Val<bevy::input::gamepad::GamepadButtonChangedEvent> {
        let output: Val<bevy::input::gamepad::GamepadButtonChangedEvent> = bevy::input::gamepad::GamepadButtonChangedEvent::new(
                entity.into_inner(),
                button.into_inner(),
                state.into_inner(),
                value,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "gamepad_button_state_changed_event_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::GamepadButtonStateChangedEvent {
    ///  Creates a new [`GamepadButtonStateChangedEvent`].
    fn new(
        entity: Val<bevy::ecs::entity::Entity>,
        button: Val<bevy::input::gamepad::GamepadButton>,
        state: Val<bevy::input::ButtonState>,
    ) -> Val<bevy::input::gamepad::GamepadButtonStateChangedEvent> {
        let output: Val<bevy::input::gamepad::GamepadButtonStateChangedEvent> = bevy::input::gamepad::GamepadButtonStateChangedEvent::new(
                entity.into_inner(),
                button.into_inner(),
                state.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "gamepad_connection_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::GamepadConnection {}
#[script_bindings(
    remote,
    name = "gamepad_connection_event_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::GamepadConnectionEvent {
    ///  Whether the gamepad is connected.
    fn connected(_self: Ref<bevy::input::gamepad::GamepadConnectionEvent>) -> bool {
        let output: bool = bevy::input::gamepad::GamepadConnectionEvent::connected(
                &_self,
            )
            .into();
        output
    }
    ///  Whether the gamepad is disconnected.
    fn disconnected(_self: Ref<bevy::input::gamepad::GamepadConnectionEvent>) -> bool {
        let output: bool = bevy::input::gamepad::GamepadConnectionEvent::disconnected(
                &_self,
            )
            .into();
        output
    }
    ///  Creates a [`GamepadConnectionEvent`].
    fn new(
        gamepad: Val<bevy::ecs::entity::Entity>,
        connection: Val<bevy::input::gamepad::GamepadConnection>,
    ) -> Val<bevy::input::gamepad::GamepadConnectionEvent> {
        let output: Val<bevy::input::gamepad::GamepadConnectionEvent> = bevy::input::gamepad::GamepadConnectionEvent::new(
                gamepad.into_inner(),
                connection.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "gamepad_event_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::GamepadEvent {}
#[script_bindings(
    remote,
    name = "gamepad_input_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::GamepadInput {}
#[script_bindings(
    remote,
    name = "gamepad_rumble_request_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::GamepadRumbleRequest {
    ///  Get the [`Entity`] associated with this request.
    fn gamepad(
        _self: Ref<bevy::input::gamepad::GamepadRumbleRequest>,
    ) -> Val<bevy::ecs::entity::Entity> {
        let output: Val<bevy::ecs::entity::Entity> = bevy::input::gamepad::GamepadRumbleRequest::gamepad(
                &_self,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "raw_gamepad_axis_changed_event_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::RawGamepadAxisChangedEvent {
    ///  Creates a [`RawGamepadAxisChangedEvent`].
    fn new(
        gamepad: Val<bevy::ecs::entity::Entity>,
        axis_type: Val<bevy::input::gamepad::GamepadAxis>,
        value: f32,
    ) -> Val<bevy::input::gamepad::RawGamepadAxisChangedEvent> {
        let output: Val<bevy::input::gamepad::RawGamepadAxisChangedEvent> = bevy::input::gamepad::RawGamepadAxisChangedEvent::new(
                gamepad.into_inner(),
                axis_type.into_inner(),
                value,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "raw_gamepad_button_changed_event_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::RawGamepadButtonChangedEvent {
    ///  Creates a [`RawGamepadButtonChangedEvent`].
    fn new(
        gamepad: Val<bevy::ecs::entity::Entity>,
        button_type: Val<bevy::input::gamepad::GamepadButton>,
        value: f32,
    ) -> Val<bevy::input::gamepad::RawGamepadButtonChangedEvent> {
        let output: Val<bevy::input::gamepad::RawGamepadButtonChangedEvent> = bevy::input::gamepad::RawGamepadButtonChangedEvent::new(
                gamepad.into_inner(),
                button_type.into_inner(),
                value,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "raw_gamepad_event_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::RawGamepadEvent {}
#[script_bindings(
    remote,
    name = "pinch_gesture_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gestures::PinchGesture {}
#[script_bindings(
    remote,
    name = "rotation_gesture_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gestures::RotationGesture {}
#[script_bindings(
    remote,
    name = "double_tap_gesture_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gestures::DoubleTapGesture {}
#[script_bindings(
    remote,
    name = "pan_gesture_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gestures::PanGesture {}
#[script_bindings(
    remote,
    name = "button_state_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::ButtonState {
    ///  Is this button pressed?
    fn is_pressed(_self: Ref<bevy::input::ButtonState>) -> bool {
        let output: bool = bevy::input::ButtonState::is_pressed(&_self).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "button_settings_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::ButtonSettings {
    ///  Returns `true` if the button is pressed.
    ///  A button is considered pressed if the `value` passed is greater than or equal to the press threshold.
    fn is_pressed(_self: Ref<bevy::input::gamepad::ButtonSettings>, value: f32) -> bool {
        let output: bool = bevy::input::gamepad::ButtonSettings::is_pressed(
                &_self,
                value,
            )
            .into();
        output
    }
    ///  Returns `true` if the button is released.
    ///  A button is considered released if the `value` passed is lower than or equal to the release threshold.
    fn is_released(
        _self: Ref<bevy::input::gamepad::ButtonSettings>,
        value: f32,
    ) -> bool {
        let output: bool = bevy::input::gamepad::ButtonSettings::is_released(
                &_self,
                value,
            )
            .into();
        output
    }
    ///  Get the button input threshold above which the button is considered pressed.
    fn press_threshold(_self: Ref<bevy::input::gamepad::ButtonSettings>) -> f32 {
        let output: f32 = bevy::input::gamepad::ButtonSettings::press_threshold(&_self)
            .into();
        output
    }
    ///  Get the button input threshold below which the button is considered released.
    fn release_threshold(_self: Ref<bevy::input::gamepad::ButtonSettings>) -> f32 {
        let output: f32 = bevy::input::gamepad::ButtonSettings::release_threshold(&_self)
            .into();
        output
    }
    ///  Try to set the button input threshold above which the button is considered pressed.
    ///  If the value passed is outside the range [release threshold..=1.0], the value will not be changed.
    ///  Returns the new value of the press threshold.
    fn set_press_threshold(
        mut _self: Mut<bevy::input::gamepad::ButtonSettings>,
        value: f32,
    ) -> f32 {
        let output: f32 = bevy::input::gamepad::ButtonSettings::set_press_threshold(
                &mut _self,
                value,
            )
            .into();
        output
    }
    ///  Try to set the button input threshold below which the button is considered released. If the
    ///  value passed is outside the range [0.0..=press threshold], the value will not be changed.
    ///  Returns the new value of the release threshold.
    fn set_release_threshold(
        mut _self: Mut<bevy::input::gamepad::ButtonSettings>,
        value: f32,
    ) -> f32 {
        let output: f32 = bevy::input::gamepad::ButtonSettings::set_release_threshold(
                &mut _self,
                value,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "axis_settings_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::AxisSettings {
    ///  Clamps the `raw_value` according to the `AxisSettings`.
    fn clamp(_self: Ref<bevy::input::gamepad::AxisSettings>, raw_value: f32) -> f32 {
        let output: f32 = bevy::input::gamepad::AxisSettings::clamp(&_self, raw_value)
            .into();
        output
    }
    ///  Get the value above which inputs will be rounded up to 0.0.
    fn deadzone_lowerbound(_self: Ref<bevy::input::gamepad::AxisSettings>) -> f32 {
        let output: f32 = bevy::input::gamepad::AxisSettings::deadzone_lowerbound(&_self)
            .into();
        output
    }
    ///  Get the value below which positive inputs will be rounded down to 0.0.
    fn deadzone_upperbound(_self: Ref<bevy::input::gamepad::AxisSettings>) -> f32 {
        let output: f32 = bevy::input::gamepad::AxisSettings::deadzone_upperbound(&_self)
            .into();
        output
    }
    ///  Get the value below which negative inputs will be rounded down to -1.0.
    fn livezone_lowerbound(_self: Ref<bevy::input::gamepad::AxisSettings>) -> f32 {
        let output: f32 = bevy::input::gamepad::AxisSettings::livezone_lowerbound(&_self)
            .into();
        output
    }
    ///  Get the value above which inputs will be rounded up to 1.0.
    fn livezone_upperbound(_self: Ref<bevy::input::gamepad::AxisSettings>) -> f32 {
        let output: f32 = bevy::input::gamepad::AxisSettings::livezone_upperbound(&_self)
            .into();
        output
    }
    ///  Try to set the value above which inputs will be rounded up to 0.0.
    ///  If the value passed is less than -1.0 or less than `livezone_lowerbound`,
    ///  the value will not be changed.
    ///  Returns the new value of `deadzone_lowerbound`.
    fn set_deadzone_lowerbound(
        mut _self: Mut<bevy::input::gamepad::AxisSettings>,
        value: f32,
    ) -> f32 {
        let output: f32 = bevy::input::gamepad::AxisSettings::set_deadzone_lowerbound(
                &mut _self,
                value,
            )
            .into();
        output
    }
    ///  Try to set the value below which positive inputs will be rounded down to 0.0.
    ///  If the value passed is negative or greater than `livezone_upperbound`,
    ///  the value will not be changed.
    ///  Returns the new value of `deadzone_upperbound`.
    fn set_deadzone_upperbound(
        mut _self: Mut<bevy::input::gamepad::AxisSettings>,
        value: f32,
    ) -> f32 {
        let output: f32 = bevy::input::gamepad::AxisSettings::set_deadzone_upperbound(
                &mut _self,
                value,
            )
            .into();
        output
    }
    ///  Try to set the value below which negative inputs will be rounded down to -1.0.
    ///  If the value passed is positive or greater than `deadzone_lowerbound`,
    ///  the value will not be changed.
    ///  Returns the new value of `livezone_lowerbound`.
    fn set_livezone_lowerbound(
        mut _self: Mut<bevy::input::gamepad::AxisSettings>,
        value: f32,
    ) -> f32 {
        let output: f32 = bevy::input::gamepad::AxisSettings::set_livezone_lowerbound(
                &mut _self,
                value,
            )
            .into();
        output
    }
    ///  Try to set the value above which inputs will be rounded up to 1.0.
    ///  If the value passed is negative or less than `deadzone_upperbound`,
    ///  the value will not be changed.
    ///  Returns the new value of `livezone_upperbound`.
    fn set_livezone_upperbound(
        mut _self: Mut<bevy::input::gamepad::AxisSettings>,
        value: f32,
    ) -> f32 {
        let output: f32 = bevy::input::gamepad::AxisSettings::set_livezone_upperbound(
                &mut _self,
                value,
            )
            .into();
        output
    }
    ///  Try to set the minimum value by which input must change before the changes will be applied.
    ///  If the value passed is not within [0.0..=2.0], the value will not be changed.
    ///  Returns the new value of threshold.
    fn set_threshold(
        mut _self: Mut<bevy::input::gamepad::AxisSettings>,
        value: f32,
    ) -> f32 {
        let output: f32 = bevy::input::gamepad::AxisSettings::set_threshold(
                &mut _self,
                value,
            )
            .into();
        output
    }
    ///  Get the minimum value by which input must change before the change is registered.
    fn threshold(_self: Ref<bevy::input::gamepad::AxisSettings>) -> f32 {
        let output: f32 = bevy::input::gamepad::AxisSettings::threshold(&_self).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "button_axis_settings_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::ButtonAxisSettings {}
#[script_bindings(
    remote,
    name = "gamepad_rumble_intensity_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::gamepad::GamepadRumbleIntensity {
    ///  Creates a new rumble intensity with strong motor intensity set to the given value.
    ///  Clamped within the `0.0` to `1.0` range.
    fn strong_motor(
        intensity: f32,
    ) -> Val<bevy::input::gamepad::GamepadRumbleIntensity> {
        let output: Val<bevy::input::gamepad::GamepadRumbleIntensity> = bevy::input::gamepad::GamepadRumbleIntensity::strong_motor(
                intensity,
            )
            .into();
        output
    }
    ///  Creates a new rumble intensity with weak motor intensity set to the given value.
    ///  Clamped within the `0.0` to `1.0` range.
    fn weak_motor(intensity: f32) -> Val<bevy::input::gamepad::GamepadRumbleIntensity> {
        let output: Val<bevy::input::gamepad::GamepadRumbleIntensity> = bevy::input::gamepad::GamepadRumbleIntensity::weak_motor(
                intensity,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "key_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::keyboard::Key {}
#[script_bindings(
    remote,
    name = "native_key_code_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::keyboard::NativeKeyCode {}
#[script_bindings(
    remote,
    name = "native_key_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::keyboard::NativeKey {}
#[script_bindings(
    remote,
    name = "mouse_scroll_unit_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::mouse::MouseScrollUnit {}
#[script_bindings(
    remote,
    name = "touch_phase_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::touch::TouchPhase {}
#[script_bindings(
    remote,
    name = "force_touch_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::input::touch::ForceTouch {}
impl ::bevy::app::Plugin for BevyInputScriptingPlugin {
    fn build(&self, app: &mut ::bevy::prelude::App) {
        let mut world = app.world_mut();
        register_gamepad_functions(&mut world);
        register_gamepad_axis_functions(&mut world);
        register_gamepad_button_functions(&mut world);
        register_gamepad_settings_functions(&mut world);
        register_key_code_functions(&mut world);
        register_mouse_button_functions(&mut world);
        register_touch_input_functions(&mut world);
        register_keyboard_focus_lost_functions(&mut world);
        register_keyboard_input_functions(&mut world);
        register_accumulated_mouse_motion_functions(&mut world);
        register_accumulated_mouse_scroll_functions(&mut world);
        register_mouse_button_input_functions(&mut world);
        register_mouse_motion_functions(&mut world);
        register_mouse_wheel_functions(&mut world);
        register_gamepad_axis_changed_event_functions(&mut world);
        register_gamepad_button_changed_event_functions(&mut world);
        register_gamepad_button_state_changed_event_functions(&mut world);
        register_gamepad_connection_functions(&mut world);
        register_gamepad_connection_event_functions(&mut world);
        register_gamepad_event_functions(&mut world);
        register_gamepad_input_functions(&mut world);
        register_gamepad_rumble_request_functions(&mut world);
        register_raw_gamepad_axis_changed_event_functions(&mut world);
        register_raw_gamepad_button_changed_event_functions(&mut world);
        register_raw_gamepad_event_functions(&mut world);
        register_pinch_gesture_functions(&mut world);
        register_rotation_gesture_functions(&mut world);
        register_double_tap_gesture_functions(&mut world);
        register_pan_gesture_functions(&mut world);
        register_button_state_functions(&mut world);
        register_button_settings_functions(&mut world);
        register_axis_settings_functions(&mut world);
        register_button_axis_settings_functions(&mut world);
        register_gamepad_rumble_intensity_functions(&mut world);
        register_key_functions(&mut world);
        register_native_key_code_functions(&mut world);
        register_native_key_functions(&mut world);
        register_mouse_scroll_unit_functions(&mut world);
        register_touch_phase_functions(&mut world);
        register_force_touch_functions(&mut world);
    }
}
