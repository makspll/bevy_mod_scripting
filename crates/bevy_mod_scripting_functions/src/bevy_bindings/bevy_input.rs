// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use bevy_mod_scripting_core::bindings::{
    ReflectReference,
    function::{
        from::{Ref, Mut, Val},
        namespace::NamespaceBuilder,
    },
};
use bevy_ecs::prelude::*;
use bevy_mod_scripting_derive::script_bindings;
use crate::*;
pub struct BevyInputScriptingPlugin;
#[script_bindings(
    remote,
    name = "gamepad_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::Gamepad {
    ///  Returns the directional pad as a [`Vec2`].
    fn dpad(_self: Ref<::bevy_input::gamepad::Gamepad>) -> Val<::bevy_math::Vec2> {
        let output: Val<::bevy_math::Vec2> = ::bevy_input::gamepad::Gamepad::dpad(&_self)
            .into();
        output
    }
    ///  Returns `true` if the [`GamepadButton`] has been pressed during the current frame.
    ///  Note: This function does not imply information regarding the current state of [`ButtonInput::pressed`] or [`ButtonInput::just_released`].
    fn just_pressed(
        _self: Ref<::bevy_input::gamepad::Gamepad>,
        button_type: Val<::bevy_input::gamepad::GamepadButton>,
    ) -> bool {
        let output: bool = ::bevy_input::gamepad::Gamepad::just_pressed(
                &_self,
                button_type.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `true` if the [`GamepadButton`] has been released during the current frame.
    ///  Note: This function does not imply information regarding the current state of [`ButtonInput::pressed`] or [`ButtonInput::just_pressed`].
    fn just_released(
        _self: Ref<::bevy_input::gamepad::Gamepad>,
        button_type: Val<::bevy_input::gamepad::GamepadButton>,
    ) -> bool {
        let output: bool = ::bevy_input::gamepad::Gamepad::just_released(
                &_self,
                button_type.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the left stick as a [`Vec2`].
    fn left_stick(_self: Ref<::bevy_input::gamepad::Gamepad>) -> Val<::bevy_math::Vec2> {
        let output: Val<::bevy_math::Vec2> = ::bevy_input::gamepad::Gamepad::left_stick(
                &_self,
            )
            .into();
        output
    }
    ///  Returns `true` if the [`GamepadButton`] has been pressed.
    fn pressed(
        _self: Ref<::bevy_input::gamepad::Gamepad>,
        button_type: Val<::bevy_input::gamepad::GamepadButton>,
    ) -> bool {
        let output: bool = ::bevy_input::gamepad::Gamepad::pressed(
                &_self,
                button_type.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the USB product ID as assigned by the [vendor], if available.
    ///  [vendor]: Self::vendor_id
    fn product_id(
        _self: Ref<::bevy_input::gamepad::Gamepad>,
    ) -> ::core::option::Option<u16> {
        let output: ::core::option::Option<u16> = ::bevy_input::gamepad::Gamepad::product_id(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the right stick as a [`Vec2`].
    fn right_stick(
        _self: Ref<::bevy_input::gamepad::Gamepad>,
    ) -> Val<::bevy_math::Vec2> {
        let output: Val<::bevy_math::Vec2> = ::bevy_input::gamepad::Gamepad::right_stick(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the USB vendor ID as assigned by the USB-IF, if available.
    fn vendor_id(
        _self: Ref<::bevy_input::gamepad::Gamepad>,
    ) -> ::core::option::Option<u16> {
        let output: ::core::option::Option<u16> = ::bevy_input::gamepad::Gamepad::vendor_id(
                &_self,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "gamepad_axis_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::GamepadAxis {
    fn assert_receiver_is_total_eq(
        _self: Ref<::bevy_input::gamepad::GamepadAxis>,
    ) -> () {
        let output: () = <::bevy_input::gamepad::GamepadAxis as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<::bevy_input::gamepad::GamepadAxis>,
    ) -> Val<::bevy_input::gamepad::GamepadAxis> {
        let output: Val<::bevy_input::gamepad::GamepadAxis> = <::bevy_input::gamepad::GamepadAxis as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gamepad::GamepadAxis>,
        other: Ref<::bevy_input::gamepad::GamepadAxis>,
    ) -> bool {
        let output: bool = <::bevy_input::gamepad::GamepadAxis as ::core::cmp::PartialEq<
            ::bevy_input::gamepad::GamepadAxis,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "gamepad_button_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::GamepadButton {
    fn assert_receiver_is_total_eq(
        _self: Ref<::bevy_input::gamepad::GamepadButton>,
    ) -> () {
        let output: () = <::bevy_input::gamepad::GamepadButton as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<::bevy_input::gamepad::GamepadButton>,
    ) -> Val<::bevy_input::gamepad::GamepadButton> {
        let output: Val<::bevy_input::gamepad::GamepadButton> = <::bevy_input::gamepad::GamepadButton as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gamepad::GamepadButton>,
        other: Ref<::bevy_input::gamepad::GamepadButton>,
    ) -> bool {
        let output: bool = <::bevy_input::gamepad::GamepadButton as ::core::cmp::PartialEq<
            ::bevy_input::gamepad::GamepadButton,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "gamepad_settings_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::GamepadSettings {
    fn clone(
        _self: Ref<::bevy_input::gamepad::GamepadSettings>,
    ) -> Val<::bevy_input::gamepad::GamepadSettings> {
        let output: Val<::bevy_input::gamepad::GamepadSettings> = <::bevy_input::gamepad::GamepadSettings as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "key_code_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::keyboard::KeyCode {
    fn assert_receiver_is_total_eq(_self: Ref<::bevy_input::keyboard::KeyCode>) -> () {
        let output: () = <::bevy_input::keyboard::KeyCode as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<::bevy_input::keyboard::KeyCode>,
    ) -> Val<::bevy_input::keyboard::KeyCode> {
        let output: Val<::bevy_input::keyboard::KeyCode> = <::bevy_input::keyboard::KeyCode as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::keyboard::KeyCode>,
        other: Ref<::bevy_input::keyboard::KeyCode>,
    ) -> bool {
        let output: bool = <::bevy_input::keyboard::KeyCode as ::core::cmp::PartialEq<
            ::bevy_input::keyboard::KeyCode,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "mouse_button_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::mouse::MouseButton {
    fn assert_receiver_is_total_eq(_self: Ref<::bevy_input::mouse::MouseButton>) -> () {
        let output: () = <::bevy_input::mouse::MouseButton as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<::bevy_input::mouse::MouseButton>,
    ) -> Val<::bevy_input::mouse::MouseButton> {
        let output: Val<::bevy_input::mouse::MouseButton> = <::bevy_input::mouse::MouseButton as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::mouse::MouseButton>,
        other: Ref<::bevy_input::mouse::MouseButton>,
    ) -> bool {
        let output: bool = <::bevy_input::mouse::MouseButton as ::core::cmp::PartialEq<
            ::bevy_input::mouse::MouseButton,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "touch_input_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::touch::TouchInput {
    fn clone(
        _self: Ref<::bevy_input::touch::TouchInput>,
    ) -> Val<::bevy_input::touch::TouchInput> {
        let output: Val<::bevy_input::touch::TouchInput> = <::bevy_input::touch::TouchInput as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::touch::TouchInput>,
        other: Ref<::bevy_input::touch::TouchInput>,
    ) -> bool {
        let output: bool = <::bevy_input::touch::TouchInput as ::core::cmp::PartialEq<
            ::bevy_input::touch::TouchInput,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "keyboard_focus_lost_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::keyboard::KeyboardFocusLost {
    fn assert_receiver_is_total_eq(
        _self: Ref<::bevy_input::keyboard::KeyboardFocusLost>,
    ) -> () {
        let output: () = <::bevy_input::keyboard::KeyboardFocusLost as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<::bevy_input::keyboard::KeyboardFocusLost>,
    ) -> Val<::bevy_input::keyboard::KeyboardFocusLost> {
        let output: Val<::bevy_input::keyboard::KeyboardFocusLost> = <::bevy_input::keyboard::KeyboardFocusLost as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::keyboard::KeyboardFocusLost>,
        other: Ref<::bevy_input::keyboard::KeyboardFocusLost>,
    ) -> bool {
        let output: bool = <::bevy_input::keyboard::KeyboardFocusLost as ::core::cmp::PartialEq<
            ::bevy_input::keyboard::KeyboardFocusLost,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "keyboard_input_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::keyboard::KeyboardInput {
    fn assert_receiver_is_total_eq(
        _self: Ref<::bevy_input::keyboard::KeyboardInput>,
    ) -> () {
        let output: () = <::bevy_input::keyboard::KeyboardInput as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<::bevy_input::keyboard::KeyboardInput>,
    ) -> Val<::bevy_input::keyboard::KeyboardInput> {
        let output: Val<::bevy_input::keyboard::KeyboardInput> = <::bevy_input::keyboard::KeyboardInput as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::keyboard::KeyboardInput>,
        other: Ref<::bevy_input::keyboard::KeyboardInput>,
    ) -> bool {
        let output: bool = <::bevy_input::keyboard::KeyboardInput as ::core::cmp::PartialEq<
            ::bevy_input::keyboard::KeyboardInput,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "accumulated_mouse_motion_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::mouse::AccumulatedMouseMotion {
    fn clone(
        _self: Ref<::bevy_input::mouse::AccumulatedMouseMotion>,
    ) -> Val<::bevy_input::mouse::AccumulatedMouseMotion> {
        let output: Val<::bevy_input::mouse::AccumulatedMouseMotion> = <::bevy_input::mouse::AccumulatedMouseMotion as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::mouse::AccumulatedMouseMotion>,
        other: Ref<::bevy_input::mouse::AccumulatedMouseMotion>,
    ) -> bool {
        let output: bool = <::bevy_input::mouse::AccumulatedMouseMotion as ::core::cmp::PartialEq<
            ::bevy_input::mouse::AccumulatedMouseMotion,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "accumulated_mouse_scroll_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::mouse::AccumulatedMouseScroll {
    fn clone(
        _self: Ref<::bevy_input::mouse::AccumulatedMouseScroll>,
    ) -> Val<::bevy_input::mouse::AccumulatedMouseScroll> {
        let output: Val<::bevy_input::mouse::AccumulatedMouseScroll> = <::bevy_input::mouse::AccumulatedMouseScroll as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::mouse::AccumulatedMouseScroll>,
        other: Ref<::bevy_input::mouse::AccumulatedMouseScroll>,
    ) -> bool {
        let output: bool = <::bevy_input::mouse::AccumulatedMouseScroll as ::core::cmp::PartialEq<
            ::bevy_input::mouse::AccumulatedMouseScroll,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "mouse_button_input_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::mouse::MouseButtonInput {
    fn assert_receiver_is_total_eq(
        _self: Ref<::bevy_input::mouse::MouseButtonInput>,
    ) -> () {
        let output: () = <::bevy_input::mouse::MouseButtonInput as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<::bevy_input::mouse::MouseButtonInput>,
    ) -> Val<::bevy_input::mouse::MouseButtonInput> {
        let output: Val<::bevy_input::mouse::MouseButtonInput> = <::bevy_input::mouse::MouseButtonInput as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::mouse::MouseButtonInput>,
        other: Ref<::bevy_input::mouse::MouseButtonInput>,
    ) -> bool {
        let output: bool = <::bevy_input::mouse::MouseButtonInput as ::core::cmp::PartialEq<
            ::bevy_input::mouse::MouseButtonInput,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "mouse_motion_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::mouse::MouseMotion {
    fn clone(
        _self: Ref<::bevy_input::mouse::MouseMotion>,
    ) -> Val<::bevy_input::mouse::MouseMotion> {
        let output: Val<::bevy_input::mouse::MouseMotion> = <::bevy_input::mouse::MouseMotion as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::mouse::MouseMotion>,
        other: Ref<::bevy_input::mouse::MouseMotion>,
    ) -> bool {
        let output: bool = <::bevy_input::mouse::MouseMotion as ::core::cmp::PartialEq<
            ::bevy_input::mouse::MouseMotion,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "mouse_wheel_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::mouse::MouseWheel {
    fn clone(
        _self: Ref<::bevy_input::mouse::MouseWheel>,
    ) -> Val<::bevy_input::mouse::MouseWheel> {
        let output: Val<::bevy_input::mouse::MouseWheel> = <::bevy_input::mouse::MouseWheel as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::mouse::MouseWheel>,
        other: Ref<::bevy_input::mouse::MouseWheel>,
    ) -> bool {
        let output: bool = <::bevy_input::mouse::MouseWheel as ::core::cmp::PartialEq<
            ::bevy_input::mouse::MouseWheel,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "gamepad_axis_changed_event_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::GamepadAxisChangedEvent {
    fn clone(
        _self: Ref<::bevy_input::gamepad::GamepadAxisChangedEvent>,
    ) -> Val<::bevy_input::gamepad::GamepadAxisChangedEvent> {
        let output: Val<::bevy_input::gamepad::GamepadAxisChangedEvent> = <::bevy_input::gamepad::GamepadAxisChangedEvent as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gamepad::GamepadAxisChangedEvent>,
        other: Ref<::bevy_input::gamepad::GamepadAxisChangedEvent>,
    ) -> bool {
        let output: bool = <::bevy_input::gamepad::GamepadAxisChangedEvent as ::core::cmp::PartialEq<
            ::bevy_input::gamepad::GamepadAxisChangedEvent,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a new [`GamepadAxisChangedEvent`].
    fn new(
        entity: Val<::bevy_ecs::entity::Entity>,
        axis: Val<::bevy_input::gamepad::GamepadAxis>,
        value: f32,
    ) -> Val<::bevy_input::gamepad::GamepadAxisChangedEvent> {
        let output: Val<::bevy_input::gamepad::GamepadAxisChangedEvent> = ::bevy_input::gamepad::GamepadAxisChangedEvent::new(
                entity.into_inner(),
                axis.into_inner(),
                value,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "gamepad_button_changed_event_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::GamepadButtonChangedEvent {
    fn clone(
        _self: Ref<::bevy_input::gamepad::GamepadButtonChangedEvent>,
    ) -> Val<::bevy_input::gamepad::GamepadButtonChangedEvent> {
        let output: Val<::bevy_input::gamepad::GamepadButtonChangedEvent> = <::bevy_input::gamepad::GamepadButtonChangedEvent as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gamepad::GamepadButtonChangedEvent>,
        other: Ref<::bevy_input::gamepad::GamepadButtonChangedEvent>,
    ) -> bool {
        let output: bool = <::bevy_input::gamepad::GamepadButtonChangedEvent as ::core::cmp::PartialEq<
            ::bevy_input::gamepad::GamepadButtonChangedEvent,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a new [`GamepadButtonChangedEvent`].
    fn new(
        entity: Val<::bevy_ecs::entity::Entity>,
        button: Val<::bevy_input::gamepad::GamepadButton>,
        state: Val<::bevy_input::ButtonState>,
        value: f32,
    ) -> Val<::bevy_input::gamepad::GamepadButtonChangedEvent> {
        let output: Val<::bevy_input::gamepad::GamepadButtonChangedEvent> = ::bevy_input::gamepad::GamepadButtonChangedEvent::new(
                entity.into_inner(),
                button.into_inner(),
                state.into_inner(),
                value,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "gamepad_button_state_changed_event_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::GamepadButtonStateChangedEvent {
    fn assert_receiver_is_total_eq(
        _self: Ref<::bevy_input::gamepad::GamepadButtonStateChangedEvent>,
    ) -> () {
        let output: () = <::bevy_input::gamepad::GamepadButtonStateChangedEvent as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<::bevy_input::gamepad::GamepadButtonStateChangedEvent>,
    ) -> Val<::bevy_input::gamepad::GamepadButtonStateChangedEvent> {
        let output: Val<::bevy_input::gamepad::GamepadButtonStateChangedEvent> = <::bevy_input::gamepad::GamepadButtonStateChangedEvent as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gamepad::GamepadButtonStateChangedEvent>,
        other: Ref<::bevy_input::gamepad::GamepadButtonStateChangedEvent>,
    ) -> bool {
        let output: bool = <::bevy_input::gamepad::GamepadButtonStateChangedEvent as ::core::cmp::PartialEq<
            ::bevy_input::gamepad::GamepadButtonStateChangedEvent,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a new [`GamepadButtonStateChangedEvent`].
    fn new(
        entity: Val<::bevy_ecs::entity::Entity>,
        button: Val<::bevy_input::gamepad::GamepadButton>,
        state: Val<::bevy_input::ButtonState>,
    ) -> Val<::bevy_input::gamepad::GamepadButtonStateChangedEvent> {
        let output: Val<::bevy_input::gamepad::GamepadButtonStateChangedEvent> = ::bevy_input::gamepad::GamepadButtonStateChangedEvent::new(
                entity.into_inner(),
                button.into_inner(),
                state.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "gamepad_connection_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::GamepadConnection {
    fn clone(
        _self: Ref<::bevy_input::gamepad::GamepadConnection>,
    ) -> Val<::bevy_input::gamepad::GamepadConnection> {
        let output: Val<::bevy_input::gamepad::GamepadConnection> = <::bevy_input::gamepad::GamepadConnection as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gamepad::GamepadConnection>,
        other: Ref<::bevy_input::gamepad::GamepadConnection>,
    ) -> bool {
        let output: bool = <::bevy_input::gamepad::GamepadConnection as ::core::cmp::PartialEq<
            ::bevy_input::gamepad::GamepadConnection,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "gamepad_connection_event_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::GamepadConnectionEvent {
    fn clone(
        _self: Ref<::bevy_input::gamepad::GamepadConnectionEvent>,
    ) -> Val<::bevy_input::gamepad::GamepadConnectionEvent> {
        let output: Val<::bevy_input::gamepad::GamepadConnectionEvent> = <::bevy_input::gamepad::GamepadConnectionEvent as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Whether the gamepad is connected.
    fn connected(_self: Ref<::bevy_input::gamepad::GamepadConnectionEvent>) -> bool {
        let output: bool = ::bevy_input::gamepad::GamepadConnectionEvent::connected(
                &_self,
            )
            .into();
        output
    }
    ///  Whether the gamepad is disconnected.
    fn disconnected(_self: Ref<::bevy_input::gamepad::GamepadConnectionEvent>) -> bool {
        let output: bool = ::bevy_input::gamepad::GamepadConnectionEvent::disconnected(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gamepad::GamepadConnectionEvent>,
        other: Ref<::bevy_input::gamepad::GamepadConnectionEvent>,
    ) -> bool {
        let output: bool = <::bevy_input::gamepad::GamepadConnectionEvent as ::core::cmp::PartialEq<
            ::bevy_input::gamepad::GamepadConnectionEvent,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a [`GamepadConnectionEvent`].
    fn new(
        gamepad: Val<::bevy_ecs::entity::Entity>,
        connection: Val<::bevy_input::gamepad::GamepadConnection>,
    ) -> Val<::bevy_input::gamepad::GamepadConnectionEvent> {
        let output: Val<::bevy_input::gamepad::GamepadConnectionEvent> = ::bevy_input::gamepad::GamepadConnectionEvent::new(
                gamepad.into_inner(),
                connection.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "gamepad_event_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::GamepadEvent {
    fn clone(
        _self: Ref<::bevy_input::gamepad::GamepadEvent>,
    ) -> Val<::bevy_input::gamepad::GamepadEvent> {
        let output: Val<::bevy_input::gamepad::GamepadEvent> = <::bevy_input::gamepad::GamepadEvent as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gamepad::GamepadEvent>,
        other: Ref<::bevy_input::gamepad::GamepadEvent>,
    ) -> bool {
        let output: bool = <::bevy_input::gamepad::GamepadEvent as ::core::cmp::PartialEq<
            ::bevy_input::gamepad::GamepadEvent,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "gamepad_input_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::GamepadInput {
    fn assert_receiver_is_total_eq(
        _self: Ref<::bevy_input::gamepad::GamepadInput>,
    ) -> () {
        let output: () = <::bevy_input::gamepad::GamepadInput as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<::bevy_input::gamepad::GamepadInput>,
    ) -> Val<::bevy_input::gamepad::GamepadInput> {
        let output: Val<::bevy_input::gamepad::GamepadInput> = <::bevy_input::gamepad::GamepadInput as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gamepad::GamepadInput>,
        other: Ref<::bevy_input::gamepad::GamepadInput>,
    ) -> bool {
        let output: bool = <::bevy_input::gamepad::GamepadInput as ::core::cmp::PartialEq<
            ::bevy_input::gamepad::GamepadInput,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "gamepad_rumble_request_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::GamepadRumbleRequest {
    fn clone(
        _self: Ref<::bevy_input::gamepad::GamepadRumbleRequest>,
    ) -> Val<::bevy_input::gamepad::GamepadRumbleRequest> {
        let output: Val<::bevy_input::gamepad::GamepadRumbleRequest> = <::bevy_input::gamepad::GamepadRumbleRequest as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Get the [`Entity`] associated with this request.
    fn gamepad(
        _self: Ref<::bevy_input::gamepad::GamepadRumbleRequest>,
    ) -> Val<::bevy_ecs::entity::Entity> {
        let output: Val<::bevy_ecs::entity::Entity> = ::bevy_input::gamepad::GamepadRumbleRequest::gamepad(
                &_self,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "raw_gamepad_axis_changed_event_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::RawGamepadAxisChangedEvent {
    fn clone(
        _self: Ref<::bevy_input::gamepad::RawGamepadAxisChangedEvent>,
    ) -> Val<::bevy_input::gamepad::RawGamepadAxisChangedEvent> {
        let output: Val<::bevy_input::gamepad::RawGamepadAxisChangedEvent> = <::bevy_input::gamepad::RawGamepadAxisChangedEvent as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gamepad::RawGamepadAxisChangedEvent>,
        other: Ref<::bevy_input::gamepad::RawGamepadAxisChangedEvent>,
    ) -> bool {
        let output: bool = <::bevy_input::gamepad::RawGamepadAxisChangedEvent as ::core::cmp::PartialEq<
            ::bevy_input::gamepad::RawGamepadAxisChangedEvent,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a [`RawGamepadAxisChangedEvent`].
    fn new(
        gamepad: Val<::bevy_ecs::entity::Entity>,
        axis_type: Val<::bevy_input::gamepad::GamepadAxis>,
        value: f32,
    ) -> Val<::bevy_input::gamepad::RawGamepadAxisChangedEvent> {
        let output: Val<::bevy_input::gamepad::RawGamepadAxisChangedEvent> = ::bevy_input::gamepad::RawGamepadAxisChangedEvent::new(
                gamepad.into_inner(),
                axis_type.into_inner(),
                value,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "raw_gamepad_button_changed_event_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::RawGamepadButtonChangedEvent {
    fn clone(
        _self: Ref<::bevy_input::gamepad::RawGamepadButtonChangedEvent>,
    ) -> Val<::bevy_input::gamepad::RawGamepadButtonChangedEvent> {
        let output: Val<::bevy_input::gamepad::RawGamepadButtonChangedEvent> = <::bevy_input::gamepad::RawGamepadButtonChangedEvent as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gamepad::RawGamepadButtonChangedEvent>,
        other: Ref<::bevy_input::gamepad::RawGamepadButtonChangedEvent>,
    ) -> bool {
        let output: bool = <::bevy_input::gamepad::RawGamepadButtonChangedEvent as ::core::cmp::PartialEq<
            ::bevy_input::gamepad::RawGamepadButtonChangedEvent,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a [`RawGamepadButtonChangedEvent`].
    fn new(
        gamepad: Val<::bevy_ecs::entity::Entity>,
        button_type: Val<::bevy_input::gamepad::GamepadButton>,
        value: f32,
    ) -> Val<::bevy_input::gamepad::RawGamepadButtonChangedEvent> {
        let output: Val<::bevy_input::gamepad::RawGamepadButtonChangedEvent> = ::bevy_input::gamepad::RawGamepadButtonChangedEvent::new(
                gamepad.into_inner(),
                button_type.into_inner(),
                value,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "raw_gamepad_event_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::RawGamepadEvent {
    fn clone(
        _self: Ref<::bevy_input::gamepad::RawGamepadEvent>,
    ) -> Val<::bevy_input::gamepad::RawGamepadEvent> {
        let output: Val<::bevy_input::gamepad::RawGamepadEvent> = <::bevy_input::gamepad::RawGamepadEvent as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gamepad::RawGamepadEvent>,
        other: Ref<::bevy_input::gamepad::RawGamepadEvent>,
    ) -> bool {
        let output: bool = <::bevy_input::gamepad::RawGamepadEvent as ::core::cmp::PartialEq<
            ::bevy_input::gamepad::RawGamepadEvent,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "pinch_gesture_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gestures::PinchGesture {
    fn clone(
        _self: Ref<::bevy_input::gestures::PinchGesture>,
    ) -> Val<::bevy_input::gestures::PinchGesture> {
        let output: Val<::bevy_input::gestures::PinchGesture> = <::bevy_input::gestures::PinchGesture as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gestures::PinchGesture>,
        other: Ref<::bevy_input::gestures::PinchGesture>,
    ) -> bool {
        let output: bool = <::bevy_input::gestures::PinchGesture as ::core::cmp::PartialEq<
            ::bevy_input::gestures::PinchGesture,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "rotation_gesture_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gestures::RotationGesture {
    fn clone(
        _self: Ref<::bevy_input::gestures::RotationGesture>,
    ) -> Val<::bevy_input::gestures::RotationGesture> {
        let output: Val<::bevy_input::gestures::RotationGesture> = <::bevy_input::gestures::RotationGesture as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gestures::RotationGesture>,
        other: Ref<::bevy_input::gestures::RotationGesture>,
    ) -> bool {
        let output: bool = <::bevy_input::gestures::RotationGesture as ::core::cmp::PartialEq<
            ::bevy_input::gestures::RotationGesture,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "double_tap_gesture_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gestures::DoubleTapGesture {
    fn clone(
        _self: Ref<::bevy_input::gestures::DoubleTapGesture>,
    ) -> Val<::bevy_input::gestures::DoubleTapGesture> {
        let output: Val<::bevy_input::gestures::DoubleTapGesture> = <::bevy_input::gestures::DoubleTapGesture as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gestures::DoubleTapGesture>,
        other: Ref<::bevy_input::gestures::DoubleTapGesture>,
    ) -> bool {
        let output: bool = <::bevy_input::gestures::DoubleTapGesture as ::core::cmp::PartialEq<
            ::bevy_input::gestures::DoubleTapGesture,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "pan_gesture_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gestures::PanGesture {
    fn clone(
        _self: Ref<::bevy_input::gestures::PanGesture>,
    ) -> Val<::bevy_input::gestures::PanGesture> {
        let output: Val<::bevy_input::gestures::PanGesture> = <::bevy_input::gestures::PanGesture as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gestures::PanGesture>,
        other: Ref<::bevy_input::gestures::PanGesture>,
    ) -> bool {
        let output: bool = <::bevy_input::gestures::PanGesture as ::core::cmp::PartialEq<
            ::bevy_input::gestures::PanGesture,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "button_state_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::ButtonState {
    fn assert_receiver_is_total_eq(_self: Ref<::bevy_input::ButtonState>) -> () {
        let output: () = <::bevy_input::ButtonState as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(_self: Ref<::bevy_input::ButtonState>) -> Val<::bevy_input::ButtonState> {
        let output: Val<::bevy_input::ButtonState> = <::bevy_input::ButtonState as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::ButtonState>,
        other: Ref<::bevy_input::ButtonState>,
    ) -> bool {
        let output: bool = <::bevy_input::ButtonState as ::core::cmp::PartialEq<
            ::bevy_input::ButtonState,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Is this button pressed?
    fn is_pressed(_self: Ref<::bevy_input::ButtonState>) -> bool {
        let output: bool = ::bevy_input::ButtonState::is_pressed(&_self).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "button_settings_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::ButtonSettings {
    fn clone(
        _self: Ref<::bevy_input::gamepad::ButtonSettings>,
    ) -> Val<::bevy_input::gamepad::ButtonSettings> {
        let output: Val<::bevy_input::gamepad::ButtonSettings> = <::bevy_input::gamepad::ButtonSettings as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gamepad::ButtonSettings>,
        other: Ref<::bevy_input::gamepad::ButtonSettings>,
    ) -> bool {
        let output: bool = <::bevy_input::gamepad::ButtonSettings as ::core::cmp::PartialEq<
            ::bevy_input::gamepad::ButtonSettings,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Returns `true` if the button is pressed.
    ///  A button is considered pressed if the `value` passed is greater than or equal to the press threshold.
    fn is_pressed(
        _self: Ref<::bevy_input::gamepad::ButtonSettings>,
        value: f32,
    ) -> bool {
        let output: bool = ::bevy_input::gamepad::ButtonSettings::is_pressed(
                &_self,
                value,
            )
            .into();
        output
    }
    ///  Returns `true` if the button is released.
    ///  A button is considered released if the `value` passed is lower than or equal to the release threshold.
    fn is_released(
        _self: Ref<::bevy_input::gamepad::ButtonSettings>,
        value: f32,
    ) -> bool {
        let output: bool = ::bevy_input::gamepad::ButtonSettings::is_released(
                &_self,
                value,
            )
            .into();
        output
    }
    ///  Get the button input threshold above which the button is considered pressed.
    fn press_threshold(_self: Ref<::bevy_input::gamepad::ButtonSettings>) -> f32 {
        let output: f32 = ::bevy_input::gamepad::ButtonSettings::press_threshold(&_self)
            .into();
        output
    }
    ///  Get the button input threshold below which the button is considered released.
    fn release_threshold(_self: Ref<::bevy_input::gamepad::ButtonSettings>) -> f32 {
        let output: f32 = ::bevy_input::gamepad::ButtonSettings::release_threshold(
                &_self,
            )
            .into();
        output
    }
    ///  Try to set the button input threshold above which the button is considered pressed.
    ///  If the value passed is outside the range [release threshold..=1.0], the value will not be changed.
    ///  Returns the new value of the press threshold.
    fn set_press_threshold(
        mut _self: Mut<::bevy_input::gamepad::ButtonSettings>,
        value: f32,
    ) -> f32 {
        let output: f32 = ::bevy_input::gamepad::ButtonSettings::set_press_threshold(
                &mut _self,
                value,
            )
            .into();
        output
    }
    ///  Try to set the button input threshold below which the button is considered released. If the
    ///  value passed is outside the range [0.0..=press threshold], the value will not be changed.
    ///  Returns the new value of the release threshold.
    fn set_release_threshold(
        mut _self: Mut<::bevy_input::gamepad::ButtonSettings>,
        value: f32,
    ) -> f32 {
        let output: f32 = ::bevy_input::gamepad::ButtonSettings::set_release_threshold(
                &mut _self,
                value,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "axis_settings_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::AxisSettings {
    ///  Clamps the `raw_value` according to the `AxisSettings`.
    fn clamp(_self: Ref<::bevy_input::gamepad::AxisSettings>, raw_value: f32) -> f32 {
        let output: f32 = ::bevy_input::gamepad::AxisSettings::clamp(&_self, raw_value)
            .into();
        output
    }
    fn clone(
        _self: Ref<::bevy_input::gamepad::AxisSettings>,
    ) -> Val<::bevy_input::gamepad::AxisSettings> {
        let output: Val<::bevy_input::gamepad::AxisSettings> = <::bevy_input::gamepad::AxisSettings as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Get the value above which inputs will be rounded up to 0.0.
    fn deadzone_lowerbound(_self: Ref<::bevy_input::gamepad::AxisSettings>) -> f32 {
        let output: f32 = ::bevy_input::gamepad::AxisSettings::deadzone_lowerbound(
                &_self,
            )
            .into();
        output
    }
    ///  Get the value below which positive inputs will be rounded down to 0.0.
    fn deadzone_upperbound(_self: Ref<::bevy_input::gamepad::AxisSettings>) -> f32 {
        let output: f32 = ::bevy_input::gamepad::AxisSettings::deadzone_upperbound(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gamepad::AxisSettings>,
        other: Ref<::bevy_input::gamepad::AxisSettings>,
    ) -> bool {
        let output: bool = <::bevy_input::gamepad::AxisSettings as ::core::cmp::PartialEq<
            ::bevy_input::gamepad::AxisSettings,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Get the value below which negative inputs will be rounded down to -1.0.
    fn livezone_lowerbound(_self: Ref<::bevy_input::gamepad::AxisSettings>) -> f32 {
        let output: f32 = ::bevy_input::gamepad::AxisSettings::livezone_lowerbound(
                &_self,
            )
            .into();
        output
    }
    ///  Get the value above which inputs will be rounded up to 1.0.
    fn livezone_upperbound(_self: Ref<::bevy_input::gamepad::AxisSettings>) -> f32 {
        let output: f32 = ::bevy_input::gamepad::AxisSettings::livezone_upperbound(
                &_self,
            )
            .into();
        output
    }
    ///  Try to set the value above which inputs will be rounded up to 0.0.
    ///  If the value passed is less than -1.0 or less than `livezone_lowerbound`,
    ///  the value will not be changed.
    ///  Returns the new value of `deadzone_lowerbound`.
    fn set_deadzone_lowerbound(
        mut _self: Mut<::bevy_input::gamepad::AxisSettings>,
        value: f32,
    ) -> f32 {
        let output: f32 = ::bevy_input::gamepad::AxisSettings::set_deadzone_lowerbound(
                &mut _self,
                value,
            )
            .into();
        output
    }
    ///  Try to set the value below which positive inputs will be rounded down to 0.0.
    ///  If the value passed is negative or greater than `livezone_upperbound`,
    ///  the value will not be changed.
    ///  Returns the new value of `deadzone_upperbound`.
    fn set_deadzone_upperbound(
        mut _self: Mut<::bevy_input::gamepad::AxisSettings>,
        value: f32,
    ) -> f32 {
        let output: f32 = ::bevy_input::gamepad::AxisSettings::set_deadzone_upperbound(
                &mut _self,
                value,
            )
            .into();
        output
    }
    ///  Try to set the value below which negative inputs will be rounded down to -1.0.
    ///  If the value passed is positive or greater than `deadzone_lowerbound`,
    ///  the value will not be changed.
    ///  Returns the new value of `livezone_lowerbound`.
    fn set_livezone_lowerbound(
        mut _self: Mut<::bevy_input::gamepad::AxisSettings>,
        value: f32,
    ) -> f32 {
        let output: f32 = ::bevy_input::gamepad::AxisSettings::set_livezone_lowerbound(
                &mut _self,
                value,
            )
            .into();
        output
    }
    ///  Try to set the value above which inputs will be rounded up to 1.0.
    ///  If the value passed is negative or less than `deadzone_upperbound`,
    ///  the value will not be changed.
    ///  Returns the new value of `livezone_upperbound`.
    fn set_livezone_upperbound(
        mut _self: Mut<::bevy_input::gamepad::AxisSettings>,
        value: f32,
    ) -> f32 {
        let output: f32 = ::bevy_input::gamepad::AxisSettings::set_livezone_upperbound(
                &mut _self,
                value,
            )
            .into();
        output
    }
    ///  Try to set the minimum value by which input must change before the changes will be applied.
    ///  If the value passed is not within [0.0..=2.0], the value will not be changed.
    ///  Returns the new value of threshold.
    fn set_threshold(
        mut _self: Mut<::bevy_input::gamepad::AxisSettings>,
        value: f32,
    ) -> f32 {
        let output: f32 = ::bevy_input::gamepad::AxisSettings::set_threshold(
                &mut _self,
                value,
            )
            .into();
        output
    }
    ///  Get the minimum value by which input must change before the change is registered.
    fn threshold(_self: Ref<::bevy_input::gamepad::AxisSettings>) -> f32 {
        let output: f32 = ::bevy_input::gamepad::AxisSettings::threshold(&_self).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "button_axis_settings_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::ButtonAxisSettings {
    fn clone(
        _self: Ref<::bevy_input::gamepad::ButtonAxisSettings>,
    ) -> Val<::bevy_input::gamepad::ButtonAxisSettings> {
        let output: Val<::bevy_input::gamepad::ButtonAxisSettings> = <::bevy_input::gamepad::ButtonAxisSettings as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "gamepad_rumble_intensity_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::gamepad::GamepadRumbleIntensity {
    fn clone(
        _self: Ref<::bevy_input::gamepad::GamepadRumbleIntensity>,
    ) -> Val<::bevy_input::gamepad::GamepadRumbleIntensity> {
        let output: Val<::bevy_input::gamepad::GamepadRumbleIntensity> = <::bevy_input::gamepad::GamepadRumbleIntensity as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::gamepad::GamepadRumbleIntensity>,
        other: Ref<::bevy_input::gamepad::GamepadRumbleIntensity>,
    ) -> bool {
        let output: bool = <::bevy_input::gamepad::GamepadRumbleIntensity as ::core::cmp::PartialEq<
            ::bevy_input::gamepad::GamepadRumbleIntensity,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a new rumble intensity with strong motor intensity set to the given value.
    ///  Clamped within the `0.0` to `1.0` range.
    fn strong_motor(
        intensity: f32,
    ) -> Val<::bevy_input::gamepad::GamepadRumbleIntensity> {
        let output: Val<::bevy_input::gamepad::GamepadRumbleIntensity> = ::bevy_input::gamepad::GamepadRumbleIntensity::strong_motor(
                intensity,
            )
            .into();
        output
    }
    ///  Creates a new rumble intensity with weak motor intensity set to the given value.
    ///  Clamped within the `0.0` to `1.0` range.
    fn weak_motor(intensity: f32) -> Val<::bevy_input::gamepad::GamepadRumbleIntensity> {
        let output: Val<::bevy_input::gamepad::GamepadRumbleIntensity> = ::bevy_input::gamepad::GamepadRumbleIntensity::weak_motor(
                intensity,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "key_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::keyboard::Key {
    fn assert_receiver_is_total_eq(_self: Ref<::bevy_input::keyboard::Key>) -> () {
        let output: () = <::bevy_input::keyboard::Key as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<::bevy_input::keyboard::Key>,
    ) -> Val<::bevy_input::keyboard::Key> {
        let output: Val<::bevy_input::keyboard::Key> = <::bevy_input::keyboard::Key as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::keyboard::Key>,
        other: Ref<::bevy_input::keyboard::Key>,
    ) -> bool {
        let output: bool = <::bevy_input::keyboard::Key as ::core::cmp::PartialEq<
            ::bevy_input::keyboard::Key,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "native_key_code_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::keyboard::NativeKeyCode {
    fn assert_receiver_is_total_eq(
        _self: Ref<::bevy_input::keyboard::NativeKeyCode>,
    ) -> () {
        let output: () = <::bevy_input::keyboard::NativeKeyCode as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<::bevy_input::keyboard::NativeKeyCode>,
    ) -> Val<::bevy_input::keyboard::NativeKeyCode> {
        let output: Val<::bevy_input::keyboard::NativeKeyCode> = <::bevy_input::keyboard::NativeKeyCode as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::keyboard::NativeKeyCode>,
        other: Ref<::bevy_input::keyboard::NativeKeyCode>,
    ) -> bool {
        let output: bool = <::bevy_input::keyboard::NativeKeyCode as ::core::cmp::PartialEq<
            ::bevy_input::keyboard::NativeKeyCode,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "native_key_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::keyboard::NativeKey {
    fn assert_receiver_is_total_eq(_self: Ref<::bevy_input::keyboard::NativeKey>) -> () {
        let output: () = <::bevy_input::keyboard::NativeKey as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<::bevy_input::keyboard::NativeKey>,
    ) -> Val<::bevy_input::keyboard::NativeKey> {
        let output: Val<::bevy_input::keyboard::NativeKey> = <::bevy_input::keyboard::NativeKey as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::keyboard::NativeKey>,
        other: Ref<::bevy_input::keyboard::NativeKey>,
    ) -> bool {
        let output: bool = <::bevy_input::keyboard::NativeKey as ::core::cmp::PartialEq<
            ::bevy_input::keyboard::NativeKey,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "mouse_scroll_unit_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::mouse::MouseScrollUnit {
    fn assert_receiver_is_total_eq(
        _self: Ref<::bevy_input::mouse::MouseScrollUnit>,
    ) -> () {
        let output: () = <::bevy_input::mouse::MouseScrollUnit as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<::bevy_input::mouse::MouseScrollUnit>,
    ) -> Val<::bevy_input::mouse::MouseScrollUnit> {
        let output: Val<::bevy_input::mouse::MouseScrollUnit> = <::bevy_input::mouse::MouseScrollUnit as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::mouse::MouseScrollUnit>,
        other: Ref<::bevy_input::mouse::MouseScrollUnit>,
    ) -> bool {
        let output: bool = <::bevy_input::mouse::MouseScrollUnit as ::core::cmp::PartialEq<
            ::bevy_input::mouse::MouseScrollUnit,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "touch_phase_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::touch::TouchPhase {
    fn assert_receiver_is_total_eq(_self: Ref<::bevy_input::touch::TouchPhase>) -> () {
        let output: () = <::bevy_input::touch::TouchPhase as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<::bevy_input::touch::TouchPhase>,
    ) -> Val<::bevy_input::touch::TouchPhase> {
        let output: Val<::bevy_input::touch::TouchPhase> = <::bevy_input::touch::TouchPhase as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::touch::TouchPhase>,
        other: Ref<::bevy_input::touch::TouchPhase>,
    ) -> bool {
        let output: bool = <::bevy_input::touch::TouchPhase as ::core::cmp::PartialEq<
            ::bevy_input::touch::TouchPhase,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "force_touch_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl ::bevy_input::touch::ForceTouch {
    fn clone(
        _self: Ref<::bevy_input::touch::ForceTouch>,
    ) -> Val<::bevy_input::touch::ForceTouch> {
        let output: Val<::bevy_input::touch::ForceTouch> = <::bevy_input::touch::ForceTouch as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<::bevy_input::touch::ForceTouch>,
        other: Ref<::bevy_input::touch::ForceTouch>,
    ) -> bool {
        let output: bool = <::bevy_input::touch::ForceTouch as ::core::cmp::PartialEq<
            ::bevy_input::touch::ForceTouch,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
impl Plugin for BevyInputScriptingPlugin {
    fn build(&self, app: &mut App) {
        let mut world = app.world_mut();
        register_gamepad_functions(&mut world);
        register_gamepad_axis_functions(&mut world);
        register_gamepad_button_functions(&mut world);
        register_gamepad_settings_functions(&mut world);
        register_key_code_functions(&mut world);
        register_mouse_button_functions(&mut world);
        register_touch_input_functions(&mut world);
        register_keyboard_focus_lost_functions(&mut world);
        register_keyboard_input_functions(&mut world);
        register_accumulated_mouse_motion_functions(&mut world);
        register_accumulated_mouse_scroll_functions(&mut world);
        register_mouse_button_input_functions(&mut world);
        register_mouse_motion_functions(&mut world);
        register_mouse_wheel_functions(&mut world);
        register_gamepad_axis_changed_event_functions(&mut world);
        register_gamepad_button_changed_event_functions(&mut world);
        register_gamepad_button_state_changed_event_functions(&mut world);
        register_gamepad_connection_functions(&mut world);
        register_gamepad_connection_event_functions(&mut world);
        register_gamepad_event_functions(&mut world);
        register_gamepad_input_functions(&mut world);
        register_gamepad_rumble_request_functions(&mut world);
        register_raw_gamepad_axis_changed_event_functions(&mut world);
        register_raw_gamepad_button_changed_event_functions(&mut world);
        register_raw_gamepad_event_functions(&mut world);
        register_pinch_gesture_functions(&mut world);
        register_rotation_gesture_functions(&mut world);
        register_double_tap_gesture_functions(&mut world);
        register_pan_gesture_functions(&mut world);
        register_button_state_functions(&mut world);
        register_button_settings_functions(&mut world);
        register_axis_settings_functions(&mut world);
        register_button_axis_settings_functions(&mut world);
        register_gamepad_rumble_intensity_functions(&mut world);
        register_key_functions(&mut world);
        register_native_key_code_functions(&mut world);
        register_native_key_functions(&mut world);
        register_mouse_scroll_unit_functions(&mut world);
        register_touch_phase_functions(&mut world);
        register_force_touch_functions(&mut world);
    }
}
