// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use bevy_mod_scripting_core::bindings::{
    ReflectReference,
    function::{
        from::{Ref, Mut, Val},
        namespace::NamespaceBuilder,
    },
};
use bevy_mod_scripting_derive::script_bindings;
use crate::*;
pub struct BevyEcsScriptingPlugin;
#[script_bindings(
    remote,
    name = "entity_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::entity::Entity {
    fn clone(_self: Ref<bevy::ecs::entity::Entity>) -> Val<bevy::ecs::entity::Entity> {
        let output: Val<bevy::ecs::entity::Entity> = <bevy::ecs::entity::Entity as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<bevy::ecs::entity::Entity>,
        other: Ref<bevy::ecs::entity::Entity>,
    ) -> bool {
        let output: bool = <bevy::ecs::entity::Entity as ::core::cmp::PartialEq<
            bevy::ecs::entity::Entity,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Reconstruct an `Entity` previously destructured with [`Entity::to_bits`].
    ///  Only useful when applied to results from `to_bits` in the same instance of an application.
    ///  # Panics
    ///  This method will likely panic if given `u64` values that did not come from [`Entity::to_bits`].
    fn from_bits(bits: u64) -> Val<bevy::ecs::entity::Entity> {
        let output: Val<bevy::ecs::entity::Entity> = bevy::ecs::entity::Entity::from_bits(
                bits,
            )
            .into();
        output
    }
    ///  Creates a new entity ID with the specified `index` and a generation of 1.
    ///  # Note
    ///  Spawning a specific `entity` value is __rarely the right choice__. Most apps should favor
    ///  [`Commands::spawn`](crate::system::Commands::spawn). This method should generally
    ///  only be used for sharing entities across apps, and only when they have a scheme
    ///  worked out to share an index space (which doesn't happen by default).
    ///  In general, one should not try to synchronize the ECS by attempting to ensure that
    ///  `Entity` lines up between instances, but instead insert a secondary identifier as
    ///  a component.
    fn from_raw(index: u32) -> Val<bevy::ecs::entity::Entity> {
        let output: Val<bevy::ecs::entity::Entity> = bevy::ecs::entity::Entity::from_raw(
                index,
            )
            .into();
        output
    }
    ///  Returns the generation of this Entity's index. The generation is incremented each time an
    ///  entity with a given index is despawned. This serves as a "count" of the number of times a
    ///  given index has been reused (index, generation) pairs uniquely identify a given Entity.
    fn generation(_self: Val<bevy::ecs::entity::Entity>) -> u32 {
        let output: u32 = bevy::ecs::entity::Entity::generation(_self.into_inner())
            .into();
        output
    }
    ///  Return a transiently unique identifier.
    ///  No two simultaneously-live entities share the same index, but dead entities' indices may collide
    ///  with both live and dead entities. Useful for compactly representing entities within a
    ///  specific snapshot of the world, such as when serializing.
    fn index(_self: Val<bevy::ecs::entity::Entity>) -> u32 {
        let output: u32 = bevy::ecs::entity::Entity::index(_self.into_inner()).into();
        output
    }
    ///  Convert to a form convenient for passing outside of rust.
    ///  Only useful for identifying entities within the same instance of an application. Do not use
    ///  for serialization between runs.
    ///  No particular structure is guaranteed for the returned bits.
    fn to_bits(_self: Val<bevy::ecs::entity::Entity>) -> u64 {
        let output: u64 = bevy::ecs::entity::Entity::to_bits(_self.into_inner()).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "child_of_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::hierarchy::ChildOf {
    fn assert_receiver_is_total_eq(_self: Ref<bevy::ecs::hierarchy::ChildOf>) -> () {
        let output: () = <bevy::ecs::hierarchy::ChildOf as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<bevy::ecs::hierarchy::ChildOf>,
    ) -> Val<bevy::ecs::hierarchy::ChildOf> {
        let output: Val<bevy::ecs::hierarchy::ChildOf> = <bevy::ecs::hierarchy::ChildOf as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<bevy::ecs::hierarchy::ChildOf>,
        other: Ref<bevy::ecs::hierarchy::ChildOf>,
    ) -> bool {
        let output: bool = <bevy::ecs::hierarchy::ChildOf as ::core::cmp::PartialEq<
            bevy::ecs::hierarchy::ChildOf,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  The parent entity of this child entity.
    fn get(_self: Ref<bevy::ecs::hierarchy::ChildOf>) -> Val<bevy::ecs::entity::Entity> {
        let output: Val<bevy::ecs::entity::Entity> = bevy::ecs::hierarchy::ChildOf::get(
                &_self,
            )
            .into();
        output
    }
    ///  The parent entity of this child entity.
    fn parent(
        _self: Ref<bevy::ecs::hierarchy::ChildOf>,
    ) -> Val<bevy::ecs::entity::Entity> {
        let output: Val<bevy::ecs::entity::Entity> = bevy::ecs::hierarchy::ChildOf::parent(
                &_self,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "children_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::hierarchy::Children {
    fn assert_receiver_is_total_eq(_self: Ref<bevy::ecs::hierarchy::Children>) -> () {
        let output: () = <bevy::ecs::hierarchy::Children as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<bevy::ecs::hierarchy::Children>,
        other: Ref<bevy::ecs::hierarchy::Children>,
    ) -> bool {
        let output: bool = <bevy::ecs::hierarchy::Children as ::core::cmp::PartialEq<
            bevy::ecs::hierarchy::Children,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Swaps the child at `a_index` with the child at `b_index`.
    fn swap(
        mut _self: Mut<bevy::ecs::hierarchy::Children>,
        a_index: usize,
        b_index: usize,
    ) -> () {
        let output: () = bevy::ecs::hierarchy::Children::swap(
                &mut _self,
                a_index,
                b_index,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "name_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::name::Name {
    fn clone(_self: Ref<bevy::ecs::name::Name>) -> Val<bevy::ecs::name::Name> {
        let output: Val<bevy::ecs::name::Name> = <bevy::ecs::name::Name as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::ecs::name::Name>, other: Ref<bevy::ecs::name::Name>) -> bool {
        let output: bool = <bevy::ecs::name::Name as ::core::cmp::PartialEq<
            bevy::ecs::name::Name,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "on_add_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::world::OnAdd {}
#[script_bindings(
    remote,
    name = "on_insert_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::world::OnInsert {}
#[script_bindings(
    remote,
    name = "on_remove_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::world::OnRemove {}
#[script_bindings(
    remote,
    name = "on_replace_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::world::OnReplace {}
#[script_bindings(
    remote,
    name = "component_id_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::component::ComponentId {
    fn assert_receiver_is_total_eq(_self: Ref<bevy::ecs::component::ComponentId>) -> () {
        let output: () = <bevy::ecs::component::ComponentId as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<bevy::ecs::component::ComponentId>,
    ) -> Val<bevy::ecs::component::ComponentId> {
        let output: Val<bevy::ecs::component::ComponentId> = <bevy::ecs::component::ComponentId as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<bevy::ecs::component::ComponentId>,
        other: Ref<bevy::ecs::component::ComponentId>,
    ) -> bool {
        let output: bool = <bevy::ecs::component::ComponentId as ::core::cmp::PartialEq<
            bevy::ecs::component::ComponentId,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Returns the index of the current component.
    fn index(_self: Val<bevy::ecs::component::ComponentId>) -> usize {
        let output: usize = bevy::ecs::component::ComponentId::index(_self.into_inner())
            .into();
        output
    }
    ///  Creates a new [`ComponentId`].
    ///  The `index` is a unique value associated with each type of component in a given world.
    ///  Usually, this value is taken from a counter incremented for each type of component registered with the world.
    fn new(index: usize) -> Val<bevy::ecs::component::ComponentId> {
        let output: Val<bevy::ecs::component::ComponentId> = bevy::ecs::component::ComponentId::new(
                index,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "default_query_filters_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::entity_disabling::DefaultQueryFilters {
    ///  Creates a new, completely empty [`DefaultQueryFilters`].
    ///  This is provided as an escape hatch; in most cases you should initialize this using [`FromWorld`],
    ///  which is automatically called when creating a new [`World`].
    fn empty() -> Val<bevy::ecs::entity_disabling::DefaultQueryFilters> {
        let output: Val<bevy::ecs::entity_disabling::DefaultQueryFilters> = bevy::ecs::entity_disabling::DefaultQueryFilters::empty()
            .into();
        output
    }
    ///  Adds this [`ComponentId`] to the set of [`DefaultQueryFilters`],
    ///  causing entities with this component to be excluded from queries.
    ///  This method is idempotent, and will not add the same component multiple times.
    ///  # Warning
    ///  This method should only be called before the app starts, as it will not affect queries
    ///  initialized before it is called.
    ///  As discussed in the [module docs](crate::entity_disabling), this can have performance implications,
    ///  as well as create interoperability issues, and should be used with caution.
    fn register_disabling_component(
        mut _self: Mut<bevy::ecs::entity_disabling::DefaultQueryFilters>,
        component_id: Val<bevy::ecs::component::ComponentId>,
    ) -> () {
        let output: () = bevy::ecs::entity_disabling::DefaultQueryFilters::register_disabling_component(
                &mut _self,
                component_id.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "tick_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::component::Tick {
    fn assert_receiver_is_total_eq(_self: Ref<bevy::ecs::component::Tick>) -> () {
        let output: () = <bevy::ecs::component::Tick as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::ecs::component::Tick>) -> Val<bevy::ecs::component::Tick> {
        let output: Val<bevy::ecs::component::Tick> = <bevy::ecs::component::Tick as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<bevy::ecs::component::Tick>,
        other: Ref<bevy::ecs::component::Tick>,
    ) -> bool {
        let output: bool = <bevy::ecs::component::Tick as ::core::cmp::PartialEq<
            bevy::ecs::component::Tick,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Gets the value of this change tick.
    fn get(_self: Val<bevy::ecs::component::Tick>) -> u32 {
        let output: u32 = bevy::ecs::component::Tick::get(_self.into_inner()).into();
        output
    }
    ///  Returns `true` if this `Tick` occurred since the system's `last_run`.
    ///  `this_run` is the current tick of the system, used as a reference to help deal with wraparound.
    fn is_newer_than(
        _self: Val<bevy::ecs::component::Tick>,
        last_run: Val<bevy::ecs::component::Tick>,
        this_run: Val<bevy::ecs::component::Tick>,
    ) -> bool {
        let output: bool = bevy::ecs::component::Tick::is_newer_than(
                _self.into_inner(),
                last_run.into_inner(),
                this_run.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new [`Tick`] wrapping the given value.
    fn new(tick: u32) -> Val<bevy::ecs::component::Tick> {
        let output: Val<bevy::ecs::component::Tick> = bevy::ecs::component::Tick::new(
                tick,
            )
            .into();
        output
    }
    ///  Sets the value of this change tick.
    fn set(mut _self: Mut<bevy::ecs::component::Tick>, tick: u32) -> () {
        let output: () = bevy::ecs::component::Tick::set(&mut _self, tick).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "component_ticks_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::component::ComponentTicks {
    fn clone(
        _self: Ref<bevy::ecs::component::ComponentTicks>,
    ) -> Val<bevy::ecs::component::ComponentTicks> {
        let output: Val<bevy::ecs::component::ComponentTicks> = <bevy::ecs::component::ComponentTicks as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns `true` if the component or resource was added after the system last ran
    ///  (or the system is running for the first time).
    fn is_added(
        _self: Ref<bevy::ecs::component::ComponentTicks>,
        last_run: Val<bevy::ecs::component::Tick>,
        this_run: Val<bevy::ecs::component::Tick>,
    ) -> bool {
        let output: bool = bevy::ecs::component::ComponentTicks::is_added(
                &_self,
                last_run.into_inner(),
                this_run.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `true` if the component or resource was added or mutably dereferenced after the system last ran
    ///  (or the system is running for the first time).
    fn is_changed(
        _self: Ref<bevy::ecs::component::ComponentTicks>,
        last_run: Val<bevy::ecs::component::Tick>,
        this_run: Val<bevy::ecs::component::Tick>,
    ) -> bool {
        let output: bool = bevy::ecs::component::ComponentTicks::is_changed(
                &_self,
                last_run.into_inner(),
                this_run.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new instance with the same change tick for `added` and `changed`.
    fn new(
        change_tick: Val<bevy::ecs::component::Tick>,
    ) -> Val<bevy::ecs::component::ComponentTicks> {
        let output: Val<bevy::ecs::component::ComponentTicks> = bevy::ecs::component::ComponentTicks::new(
                change_tick.into_inner(),
            )
            .into();
        output
    }
    ///  Manually sets the change tick.
    ///  This is normally done automatically via the [`DerefMut`] implementation
    ///  on [`Mut<T>`](crate::change_detection::Mut), [`ResMut<T>`](crate::change_detection::ResMut), etc.
    ///  However, components and resources that make use of interior mutability might require manual updates.
    ///  # Example
    ///  ```no_run
    ///  # use bevy_ecs::{world::World, component::ComponentTicks};
    ///  let world: World = unimplemented!();
    ///  let component_ticks: ComponentTicks = unimplemented!();
    ///  component_ticks.set_changed(world.read_change_tick());
    ///  ```
    fn set_changed(
        mut _self: Mut<bevy::ecs::component::ComponentTicks>,
        change_tick: Val<bevy::ecs::component::Tick>,
    ) -> () {
        let output: () = bevy::ecs::component::ComponentTicks::set_changed(
                &mut _self,
                change_tick.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "entity_hash_set_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::entity::hash_set::EntityHashSet {
    fn assert_receiver_is_total_eq(
        _self: Ref<bevy::ecs::entity::hash_set::EntityHashSet>,
    ) -> () {
        let output: () = <bevy::ecs::entity::hash_set::EntityHashSet as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<bevy::ecs::entity::hash_set::EntityHashSet>,
    ) -> Val<bevy::ecs::entity::hash_set::EntityHashSet> {
        let output: Val<bevy::ecs::entity::hash_set::EntityHashSet> = <bevy::ecs::entity::hash_set::EntityHashSet as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<bevy::ecs::entity::hash_set::EntityHashSet>,
        other: Ref<bevy::ecs::entity::hash_set::EntityHashSet>,
    ) -> bool {
        let output: bool = <bevy::ecs::entity::hash_set::EntityHashSet as ::core::cmp::PartialEq<
            bevy::ecs::entity::hash_set::EntityHashSet,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Returns `true` if the set contains no elements.
    fn is_empty(_self: Ref<bevy::ecs::entity::hash_set::EntityHashSet>) -> bool {
        let output: bool = bevy::ecs::entity::hash_set::EntityHashSet::is_empty(&_self)
            .into();
        output
    }
    ///  Returns the number of elements in the set.
    fn len(_self: Ref<bevy::ecs::entity::hash_set::EntityHashSet>) -> usize {
        let output: usize = bevy::ecs::entity::hash_set::EntityHashSet::len(&_self)
            .into();
        output
    }
    ///  Creates an empty `EntityHashSet`.
    ///  Equivalent to [`HashSet::with_hasher(EntityHash)`].
    ///  [`HashSet::with_hasher(EntityHash)`]: HashSet::with_hasher
    fn new() -> Val<bevy::ecs::entity::hash_set::EntityHashSet> {
        let output: Val<bevy::ecs::entity::hash_set::EntityHashSet> = bevy::ecs::entity::hash_set::EntityHashSet::new()
            .into();
        output
    }
    ///  Creates an empty `EntityHashSet` with the specified capacity.
    ///  Equivalent to [`HashSet::with_capacity_and_hasher(n, EntityHash)`].
    ///  [`HashSet::with_capacity_and_hasher(n, EntityHash)`]: HashSet::with_capacity_and_hasher
    fn with_capacity(n: usize) -> Val<bevy::ecs::entity::hash_set::EntityHashSet> {
        let output: Val<bevy::ecs::entity::hash_set::EntityHashSet> = bevy::ecs::entity::hash_set::EntityHashSet::with_capacity(
                n,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "identifier_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::identifier::Identifier {
    fn clone(
        _self: Ref<bevy::ecs::identifier::Identifier>,
    ) -> Val<bevy::ecs::identifier::Identifier> {
        let output: Val<bevy::ecs::identifier::Identifier> = <bevy::ecs::identifier::Identifier as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<bevy::ecs::identifier::Identifier>,
        other: Ref<bevy::ecs::identifier::Identifier>,
    ) -> bool {
        let output: bool = <bevy::ecs::identifier::Identifier as ::core::cmp::PartialEq<
            bevy::ecs::identifier::Identifier,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Convert a `u64` into an [`Identifier`].
    ///  # Panics
    ///  This method will likely panic if given `u64` values that did not come from [`Identifier::to_bits`].
    fn from_bits(value: u64) -> Val<bevy::ecs::identifier::Identifier> {
        let output: Val<bevy::ecs::identifier::Identifier> = bevy::ecs::identifier::Identifier::from_bits(
                value,
            )
            .into();
        output
    }
    ///  Returns the value of the low segment of the [`Identifier`].
    fn low(_self: Val<bevy::ecs::identifier::Identifier>) -> u32 {
        let output: u32 = bevy::ecs::identifier::Identifier::low(_self.into_inner())
            .into();
        output
    }
    ///  Returns the masked value of the high segment of the [`Identifier`].
    ///  Does not include the flag bits.
    fn masked_high(_self: Val<bevy::ecs::identifier::Identifier>) -> u32 {
        let output: u32 = bevy::ecs::identifier::Identifier::masked_high(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Convert the [`Identifier`] into a `u64`.
    fn to_bits(_self: Val<bevy::ecs::identifier::Identifier>) -> u64 {
        let output: u64 = bevy::ecs::identifier::Identifier::to_bits(_self.into_inner())
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "entity_hash_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::entity::EntityHash {
    fn clone(
        _self: Ref<bevy::ecs::entity::EntityHash>,
    ) -> Val<bevy::ecs::entity::EntityHash> {
        let output: Val<bevy::ecs::entity::EntityHash> = <bevy::ecs::entity::EntityHash as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "disabled_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::entity_disabling::Disabled {
    fn clone(
        _self: Ref<bevy::ecs::entity_disabling::Disabled>,
    ) -> Val<bevy::ecs::entity_disabling::Disabled> {
        let output: Val<bevy::ecs::entity_disabling::Disabled> = <bevy::ecs::entity_disabling::Disabled as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "removed_component_entity_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::removal_detection::RemovedComponentEntity {
    fn clone(
        _self: Ref<bevy::ecs::removal_detection::RemovedComponentEntity>,
    ) -> Val<bevy::ecs::removal_detection::RemovedComponentEntity> {
        let output: Val<bevy::ecs::removal_detection::RemovedComponentEntity> = <bevy::ecs::removal_detection::RemovedComponentEntity as ::core::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "system_id_marker_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::system::SystemIdMarker {}
#[script_bindings(
    remote,
    name = "on_despawn_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::ecs::world::OnDespawn {}
impl ::bevy::app::Plugin for BevyEcsScriptingPlugin {
    fn build(&self, app: &mut ::bevy::prelude::App) {
        let mut world = app.world_mut();
        register_entity_functions(&mut world);
        register_child_of_functions(&mut world);
        register_children_functions(&mut world);
        register_name_functions(&mut world);
        register_on_add_functions(&mut world);
        register_on_insert_functions(&mut world);
        register_on_remove_functions(&mut world);
        register_on_replace_functions(&mut world);
        register_component_id_functions(&mut world);
        register_default_query_filters_functions(&mut world);
        register_tick_functions(&mut world);
        register_component_ticks_functions(&mut world);
        register_entity_hash_set_functions(&mut world);
        register_identifier_functions(&mut world);
        register_entity_hash_functions(&mut world);
        register_disabled_functions(&mut world);
        register_removed_component_entity_functions(&mut world);
        register_system_id_marker_functions(&mut world);
        register_on_despawn_functions(&mut world);
    }
}
