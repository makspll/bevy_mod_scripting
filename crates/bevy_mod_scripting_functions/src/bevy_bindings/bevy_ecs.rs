// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use bevy_mod_scripting_core::bindings::{
    ReflectReference,
    function::{
        from::{Ref, Mut, Val},
        namespace::NamespaceBuilder,
    },
};
use bevy_mod_scripting_derive::script_bindings;
use crate::*;
pub struct BevyEcsScriptingPlugin;
#[script_bindings(
    remote,
    name = "entity_functions",
    bms_core_path = "bevy_mod_scripting_core"
)]
impl bevy::ecs::entity::Entity {
    fn clone(_self: Ref<bevy::ecs::entity::Entity>) -> Val<bevy::ecs::entity::Entity> {
        let output: Val<bevy::ecs::entity::Entity> = <bevy::ecs::entity::Entity as std::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<bevy::ecs::entity::Entity>,
        other: Ref<bevy::ecs::entity::Entity>,
    ) -> bool {
        let output: bool = <bevy::ecs::entity::Entity as std::cmp::PartialEq<
            bevy::ecs::entity::Entity,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Reconstruct an `Entity` previously destructured with [`Entity::to_bits`].
    ///  Only useful when applied to results from `to_bits` in the same instance of an application.
    ///  # Panics
    ///  This method will likely panic if given `u64` values that did not come from [`Entity::to_bits`].
    fn from_bits(bits: u64) -> Val<bevy::ecs::entity::Entity> {
        let output: Val<bevy::ecs::entity::Entity> = bevy::ecs::entity::Entity::from_bits(
                bits,
            )
            .into();
        output
    }
    ///  Creates a new entity ID with the specified `index` and a generation of 1.
    ///  # Note
    ///  Spawning a specific `entity` value is __rarely the right choice__. Most apps should favor
    ///  [`Commands::spawn`](crate::system::Commands::spawn). This method should generally
    ///  only be used for sharing entities across apps, and only when they have a scheme
    ///  worked out to share an index space (which doesn't happen by default).
    ///  In general, one should not try to synchronize the ECS by attempting to ensure that
    ///  `Entity` lines up between instances, but instead insert a secondary identifier as
    ///  a component.
    fn from_raw(index: u32) -> Val<bevy::ecs::entity::Entity> {
        let output: Val<bevy::ecs::entity::Entity> = bevy::ecs::entity::Entity::from_raw(
                index,
            )
            .into();
        output
    }
    ///  Returns the generation of this Entity's index. The generation is incremented each time an
    ///  entity with a given index is despawned. This serves as a "count" of the number of times a
    ///  given index has been reused (index, generation) pairs uniquely identify a given Entity.
    fn generation(_self: Val<bevy::ecs::entity::Entity>) -> u32 {
        let output: u32 = bevy::ecs::entity::Entity::generation(_self.into_inner())
            .into();
        output
    }
    ///  Return a transiently unique identifier.
    ///  No two simultaneously-live entities share the same index, but dead entities' indices may collide
    ///  with both live and dead entities. Useful for compactly representing entities within a
    ///  specific snapshot of the world, such as when serializing.
    fn index(_self: Val<bevy::ecs::entity::Entity>) -> u32 {
        let output: u32 = bevy::ecs::entity::Entity::index(_self.into_inner()).into();
        output
    }
    ///  Convert to a form convenient for passing outside of rust.
    ///  Only useful for identifying entities within the same instance of an application. Do not use
    ///  for serialization between runs.
    ///  No particular structure is guaranteed for the returned bits.
    fn to_bits(_self: Val<bevy::ecs::entity::Entity>) -> u64 {
        let output: u64 = bevy::ecs::entity::Entity::to_bits(_self.into_inner()).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "on_add_functions",
    bms_core_path = "bevy_mod_scripting_core"
)]
impl bevy::ecs::world::OnAdd {}
#[script_bindings(
    remote,
    name = "on_insert_functions",
    bms_core_path = "bevy_mod_scripting_core"
)]
impl bevy::ecs::world::OnInsert {}
#[script_bindings(
    remote,
    name = "on_remove_functions",
    bms_core_path = "bevy_mod_scripting_core"
)]
impl bevy::ecs::world::OnRemove {}
#[script_bindings(
    remote,
    name = "on_replace_functions",
    bms_core_path = "bevy_mod_scripting_core"
)]
impl bevy::ecs::world::OnReplace {}
#[script_bindings(
    remote,
    name = "component_id_functions",
    bms_core_path = "bevy_mod_scripting_core"
)]
impl bevy::ecs::component::ComponentId {
    fn assert_receiver_is_total_eq(_self: Ref<bevy::ecs::component::ComponentId>) -> () {
        let output: () = <bevy::ecs::component::ComponentId as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(
        _self: Ref<bevy::ecs::component::ComponentId>,
    ) -> Val<bevy::ecs::component::ComponentId> {
        let output: Val<bevy::ecs::component::ComponentId> = <bevy::ecs::component::ComponentId as std::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<bevy::ecs::component::ComponentId>,
        other: Ref<bevy::ecs::component::ComponentId>,
    ) -> bool {
        let output: bool = <bevy::ecs::component::ComponentId as std::cmp::PartialEq<
            bevy::ecs::component::ComponentId,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Returns the index of the current component.
    fn index(_self: Val<bevy::ecs::component::ComponentId>) -> usize {
        let output: usize = bevy::ecs::component::ComponentId::index(_self.into_inner())
            .into();
        output
    }
    ///  Creates a new [`ComponentId`].
    ///  The `index` is a unique value associated with each type of component in a given world.
    ///  Usually, this value is taken from a counter incremented for each type of component registered with the world.
    fn new(index: usize) -> Val<bevy::ecs::component::ComponentId> {
        let output: Val<bevy::ecs::component::ComponentId> = bevy::ecs::component::ComponentId::new(
                index,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "tick_functions",
    bms_core_path = "bevy_mod_scripting_core"
)]
impl bevy::ecs::component::Tick {
    fn assert_receiver_is_total_eq(_self: Ref<bevy::ecs::component::Tick>) -> () {
        let output: () = <bevy::ecs::component::Tick as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::ecs::component::Tick>) -> Val<bevy::ecs::component::Tick> {
        let output: Val<bevy::ecs::component::Tick> = <bevy::ecs::component::Tick as std::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<bevy::ecs::component::Tick>,
        other: Ref<bevy::ecs::component::Tick>,
    ) -> bool {
        let output: bool = <bevy::ecs::component::Tick as std::cmp::PartialEq<
            bevy::ecs::component::Tick,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Gets the value of this change tick.
    fn get(_self: Val<bevy::ecs::component::Tick>) -> u32 {
        let output: u32 = bevy::ecs::component::Tick::get(_self.into_inner()).into();
        output
    }
    ///  Returns `true` if this `Tick` occurred since the system's `last_run`.
    ///  `this_run` is the current tick of the system, used as a reference to help deal with wraparound.
    fn is_newer_than(
        _self: Val<bevy::ecs::component::Tick>,
        last_run: Val<bevy::ecs::component::Tick>,
        this_run: Val<bevy::ecs::component::Tick>,
    ) -> bool {
        let output: bool = bevy::ecs::component::Tick::is_newer_than(
                _self.into_inner(),
                last_run.into_inner(),
                this_run.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new [`Tick`] wrapping the given value.
    fn new(tick: u32) -> Val<bevy::ecs::component::Tick> {
        let output: Val<bevy::ecs::component::Tick> = bevy::ecs::component::Tick::new(
                tick,
            )
            .into();
        output
    }
    ///  Sets the value of this change tick.
    fn set(mut _self: Mut<bevy::ecs::component::Tick>, tick: u32) -> () {
        let output: () = bevy::ecs::component::Tick::set(&mut _self, tick).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "component_ticks_functions",
    bms_core_path = "bevy_mod_scripting_core"
)]
impl bevy::ecs::component::ComponentTicks {
    fn clone(
        _self: Ref<bevy::ecs::component::ComponentTicks>,
    ) -> Val<bevy::ecs::component::ComponentTicks> {
        let output: Val<bevy::ecs::component::ComponentTicks> = <bevy::ecs::component::ComponentTicks as std::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns `true` if the component or resource was added after the system last ran
    ///  (or the system is running for the first time).
    fn is_added(
        _self: Ref<bevy::ecs::component::ComponentTicks>,
        last_run: Val<bevy::ecs::component::Tick>,
        this_run: Val<bevy::ecs::component::Tick>,
    ) -> bool {
        let output: bool = bevy::ecs::component::ComponentTicks::is_added(
                &_self,
                last_run.into_inner(),
                this_run.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `true` if the component or resource was added or mutably dereferenced after the system last ran
    ///  (or the system is running for the first time).
    fn is_changed(
        _self: Ref<bevy::ecs::component::ComponentTicks>,
        last_run: Val<bevy::ecs::component::Tick>,
        this_run: Val<bevy::ecs::component::Tick>,
    ) -> bool {
        let output: bool = bevy::ecs::component::ComponentTicks::is_changed(
                &_self,
                last_run.into_inner(),
                this_run.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new instance with the same change tick for `added` and `changed`.
    fn new(
        change_tick: Val<bevy::ecs::component::Tick>,
    ) -> Val<bevy::ecs::component::ComponentTicks> {
        let output: Val<bevy::ecs::component::ComponentTicks> = bevy::ecs::component::ComponentTicks::new(
                change_tick.into_inner(),
            )
            .into();
        output
    }
    ///  Manually sets the change tick.
    ///  This is normally done automatically via the [`DerefMut`](std::ops::DerefMut) implementation
    ///  on [`Mut<T>`](crate::change_detection::Mut), [`ResMut<T>`](crate::change_detection::ResMut), etc.
    ///  However, components and resources that make use of interior mutability might require manual updates.
    ///  # Example
    ///  ```no_run
    ///  # use bevy_ecs::{world::World, component::ComponentTicks};
    ///  let world: World = unimplemented!();
    ///  let component_ticks: ComponentTicks = unimplemented!();
    ///  component_ticks.set_changed(world.read_change_tick());
    ///  ```
    fn set_changed(
        mut _self: Mut<bevy::ecs::component::ComponentTicks>,
        change_tick: Val<bevy::ecs::component::Tick>,
    ) -> () {
        let output: () = bevy::ecs::component::ComponentTicks::set_changed(
                &mut _self,
                change_tick.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "identifier_functions",
    bms_core_path = "bevy_mod_scripting_core"
)]
impl bevy::ecs::identifier::Identifier {
    fn clone(
        _self: Ref<bevy::ecs::identifier::Identifier>,
    ) -> Val<bevy::ecs::identifier::Identifier> {
        let output: Val<bevy::ecs::identifier::Identifier> = <bevy::ecs::identifier::Identifier as std::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(
        _self: Ref<bevy::ecs::identifier::Identifier>,
        other: Ref<bevy::ecs::identifier::Identifier>,
    ) -> bool {
        let output: bool = <bevy::ecs::identifier::Identifier as std::cmp::PartialEq<
            bevy::ecs::identifier::Identifier,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Convert a `u64` into an [`Identifier`].
    ///  # Panics
    ///  This method will likely panic if given `u64` values that did not come from [`Identifier::to_bits`].
    fn from_bits(value: u64) -> Val<bevy::ecs::identifier::Identifier> {
        let output: Val<bevy::ecs::identifier::Identifier> = bevy::ecs::identifier::Identifier::from_bits(
                value,
            )
            .into();
        output
    }
    ///  Returns the value of the low segment of the [`Identifier`].
    fn low(_self: Val<bevy::ecs::identifier::Identifier>) -> u32 {
        let output: u32 = bevy::ecs::identifier::Identifier::low(_self.into_inner())
            .into();
        output
    }
    ///  Returns the masked value of the high segment of the [`Identifier`].
    ///  Does not include the flag bits.
    fn masked_high(_self: Val<bevy::ecs::identifier::Identifier>) -> u32 {
        let output: u32 = bevy::ecs::identifier::Identifier::masked_high(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Convert the [`Identifier`] into a `u64`.
    fn to_bits(_self: Val<bevy::ecs::identifier::Identifier>) -> u64 {
        let output: u64 = bevy::ecs::identifier::Identifier::to_bits(_self.into_inner())
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "entity_hash_functions",
    bms_core_path = "bevy_mod_scripting_core"
)]
impl bevy::ecs::entity::EntityHash {
    fn clone(
        _self: Ref<bevy::ecs::entity::EntityHash>,
    ) -> Val<bevy::ecs::entity::EntityHash> {
        let output: Val<bevy::ecs::entity::EntityHash> = <bevy::ecs::entity::EntityHash as std::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "removed_component_entity_functions",
    bms_core_path = "bevy_mod_scripting_core"
)]
impl bevy::ecs::removal_detection::RemovedComponentEntity {
    fn clone(
        _self: Ref<bevy::ecs::removal_detection::RemovedComponentEntity>,
    ) -> Val<bevy::ecs::removal_detection::RemovedComponentEntity> {
        let output: Val<bevy::ecs::removal_detection::RemovedComponentEntity> = <bevy::ecs::removal_detection::RemovedComponentEntity as std::clone::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "system_id_marker_functions",
    bms_core_path = "bevy_mod_scripting_core"
)]
impl bevy::ecs::system::SystemIdMarker {}
impl ::bevy::app::Plugin for BevyEcsScriptingPlugin {
    fn build(&self, app: &mut ::bevy::prelude::App) {
        let mut world = app.world_mut();
        register_entity_functions(&mut world);
        register_on_add_functions(&mut world);
        register_on_insert_functions(&mut world);
        register_on_remove_functions(&mut world);
        register_on_replace_functions(&mut world);
        register_component_id_functions(&mut world);
        register_tick_functions(&mut world);
        register_component_ticks_functions(&mut world);
        register_identifier_functions(&mut world);
        register_entity_hash_functions(&mut world);
        register_removed_component_entity_functions(&mut world);
        register_system_id_marker_functions(&mut world);
    }
}
