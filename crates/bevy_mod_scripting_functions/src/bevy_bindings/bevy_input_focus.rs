// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use bevy_mod_scripting_core::{
    bindings::{
        ReflectReference, 
        function::{from::{Ref, Mut, Val}, namespace::{NamespaceBuilder}}
    }
};

use bevy_mod_scripting_derive::script_bindings;


use crate::*;







pub struct BevyInputFocusScriptingPlugin;


#[script_bindings(
    remote,
    name = "input_focus_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::input_focus::InputFocus {


    
    ///  Clears input focus.
    
    fn clear (mut _self:Mut<bevy::input_focus::InputFocus>,) -> () {
        let output: () =bevy::input_focus::InputFocus::clear(&mut _self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::input_focus::InputFocus>,) -> Val<bevy::input_focus::InputFocus> {
        let output: Val<bevy::input_focus::InputFocus> =<bevy::input_focus::InputFocus as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Create a new [`InputFocus`] resource with the given entity.
    
    ///  This is mostly useful for tests.
    
    fn from_entity (entity:Val<bevy::ecs::entity::Entity>,) -> Val<bevy::input_focus::InputFocus> {
        let output: Val<bevy::input_focus::InputFocus> =bevy::input_focus::InputFocus::from_entity(entity.into_inner(),).into();
        output
    }


    
    ///  Set the entity with input focus.
    
    fn set (mut _self:Mut<bevy::input_focus::InputFocus>,entity:Val<bevy::ecs::entity::Entity>,) -> () {
        let output: () =bevy::input_focus::InputFocus::set(&mut _self,entity.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "input_focus_visible_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::input_focus::InputFocusVisible {


    
    fn clone (_self:Ref<bevy::input_focus::InputFocusVisible>,) -> Val<bevy::input_focus::InputFocusVisible> {
        let output: Val<bevy::input_focus::InputFocusVisible> =<bevy::input_focus::InputFocusVisible as ::core::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "auto_focus_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::input_focus::AutoFocus {


    
    fn clone (_self:Ref<bevy::input_focus::AutoFocus>,) -> Val<bevy::input_focus::AutoFocus> {
        let output: Val<bevy::input_focus::AutoFocus> =<bevy::input_focus::AutoFocus as ::core::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "directional_navigation_map_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::input_focus::directional_navigation::DirectionalNavigationMap {


    
    ///  Adds an edge between two entities in the navigation map.
    
    ///  Any existing edge from A in the provided direction will be overwritten.
    
    ///  The reverse edge will not be added, so navigation will only be possible in one direction.
    
    ///  If you want to add a symmetrical edge, use [`add_symmetrical_edge`](Self::add_symmetrical_edge) instead.
    
    fn add_edge (mut _self:Mut<bevy::input_focus::directional_navigation::DirectionalNavigationMap>,a:Val<bevy::ecs::entity::Entity>,b:Val<bevy::ecs::entity::Entity>,direction:Val<bevy::math::CompassOctant>,) -> () {
        let output: () =bevy::input_focus::directional_navigation::DirectionalNavigationMap::add_edge(&mut _self,a.into_inner(),b.into_inner(),direction.into_inner(),).into();
        output
    }


    
    ///  Adds a symmetrical edge between two entities in the navigation map.
    
    ///  The A -> B path will use the provided direction, while B -> A will use the [`CompassOctant::opposite`] variant.
    
    ///  Any existing connections between the two entities will be overwritten.
    
    fn add_symmetrical_edge (mut _self:Mut<bevy::input_focus::directional_navigation::DirectionalNavigationMap>,a:Val<bevy::ecs::entity::Entity>,b:Val<bevy::ecs::entity::Entity>,direction:Val<bevy::math::CompassOctant>,) -> () {
        let output: () =bevy::input_focus::directional_navigation::DirectionalNavigationMap::add_symmetrical_edge(&mut _self,a.into_inner(),b.into_inner(),direction.into_inner(),).into();
        output
    }


    
    ///  Completely clears the navigation map, removing all entities and connections.
    
    fn clear (mut _self:Mut<bevy::input_focus::directional_navigation::DirectionalNavigationMap>,) -> () {
        let output: () =bevy::input_focus::directional_navigation::DirectionalNavigationMap::clear(&mut _self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::input_focus::directional_navigation::DirectionalNavigationMap>,) -> Val<bevy::input_focus::directional_navigation::DirectionalNavigationMap> {
        let output: Val<bevy::input_focus::directional_navigation::DirectionalNavigationMap> =<bevy::input_focus::directional_navigation::DirectionalNavigationMap as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::input_focus::directional_navigation::DirectionalNavigationMap>,other:Ref<bevy::input_focus::directional_navigation::DirectionalNavigationMap>,) -> bool {
        let output: bool =<bevy::input_focus::directional_navigation::DirectionalNavigationMap as ::core::cmp::PartialEq::<bevy::input_focus::directional_navigation::DirectionalNavigationMap>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Adds a new entity to the navigation map, overwriting any existing neighbors for that entity.
    
    ///  Removes an entity from the navigation map, including all connections to and from it.
    
    ///  Note that this is an O(n) operation, where n is the number of entities in the map,
    
    ///  as we must iterate over each entity to check for connections to the removed entity.
    
    ///  If you are removing multiple entities, consider using [`remove_multiple`](Self::remove_multiple) instead.
    
    fn remove (mut _self:Mut<bevy::input_focus::directional_navigation::DirectionalNavigationMap>,entity:Val<bevy::ecs::entity::Entity>,) -> () {
        let output: () =bevy::input_focus::directional_navigation::DirectionalNavigationMap::remove(&mut _self,entity.into_inner(),).into();
        output
    }


    
    ///  Removes a collection of entities from the navigation map.
    
    ///  While this is still an O(n) operation, where n is the number of entities in the map,
    
    ///  it is more efficient than calling [`remove`](Self::remove) multiple times,
    
    ///  as we can check for connections to all removed entities in a single pass.
    
    ///  An [`EntityHashSet`] must be provided as it is noticeably faster than the standard hasher or a [`Vec`](`alloc::vec::Vec`).
    
    fn remove_multiple (mut _self:Mut<bevy::input_focus::directional_navigation::DirectionalNavigationMap>,entities:Val<bevy::ecs::entity::EntityHashSet>,) -> () {
        let output: () =bevy::input_focus::directional_navigation::DirectionalNavigationMap::remove_multiple(&mut _self,entities.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "nav_neighbors_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::input_focus::directional_navigation::NavNeighbors {


    
    fn clone (_self:Ref<bevy::input_focus::directional_navigation::NavNeighbors>,) -> Val<bevy::input_focus::directional_navigation::NavNeighbors> {
        let output: Val<bevy::input_focus::directional_navigation::NavNeighbors> =<bevy::input_focus::directional_navigation::NavNeighbors as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::input_focus::directional_navigation::NavNeighbors>,other:Ref<bevy::input_focus::directional_navigation::NavNeighbors>,) -> bool {
        let output: bool =<bevy::input_focus::directional_navigation::NavNeighbors as ::core::cmp::PartialEq::<bevy::input_focus::directional_navigation::NavNeighbors>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Set the neighbor for a given [`CompassOctant`].
    
    fn set (mut _self:Mut<bevy::input_focus::directional_navigation::NavNeighbors>,octant:Val<bevy::math::CompassOctant>,entity:Val<bevy::ecs::entity::Entity>,) -> () {
        let output: () =bevy::input_focus::directional_navigation::NavNeighbors::set(&mut _self,octant.into_inner(),entity.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "tab_index_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::input_focus::tab_navigation::TabIndex {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::input_focus::tab_navigation::TabIndex>,) -> () {
        let output: () =<bevy::input_focus::tab_navigation::TabIndex as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::input_focus::tab_navigation::TabIndex>,) -> Val<bevy::input_focus::tab_navigation::TabIndex> {
        let output: Val<bevy::input_focus::tab_navigation::TabIndex> =<bevy::input_focus::tab_navigation::TabIndex as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::input_focus::tab_navigation::TabIndex>,other:Ref<bevy::input_focus::tab_navigation::TabIndex>,) -> bool {
        let output: bool =<bevy::input_focus::tab_navigation::TabIndex as ::core::cmp::PartialEq::<bevy::input_focus::tab_navigation::TabIndex>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "tab_group_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::input_focus::tab_navigation::TabGroup {


    
    fn clone (_self:Ref<bevy::input_focus::tab_navigation::TabGroup>,) -> Val<bevy::input_focus::tab_navigation::TabGroup> {
        let output: Val<bevy::input_focus::tab_navigation::TabGroup> =<bevy::input_focus::tab_navigation::TabGroup as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Create a modal tab group.
    
    fn modal () -> Val<bevy::input_focus::tab_navigation::TabGroup> {
        let output: Val<bevy::input_focus::tab_navigation::TabGroup> =bevy::input_focus::tab_navigation::TabGroup::modal().into();
        output
    }


    
    ///  Create a new tab group with the given order.
    
    fn new (order:i32,) -> Val<bevy::input_focus::tab_navigation::TabGroup> {
        let output: Val<bevy::input_focus::tab_navigation::TabGroup> =bevy::input_focus::tab_navigation::TabGroup::new(order,).into();
        output
    }
     
}


impl ::bevy::app::Plugin for BevyInputFocusScriptingPlugin {
    fn build(&self, app: &mut ::bevy::prelude::App) {
        let mut world = app.world_mut();

        
            register_input_focus_functions(&mut world);
        
            register_input_focus_visible_functions(&mut world);
        
            register_auto_focus_functions(&mut world);
        
            register_directional_navigation_map_functions(&mut world);
        
            register_nav_neighbors_functions(&mut world);
        
            register_tab_index_functions(&mut world);
        
            register_tab_group_functions(&mut world);
        
    }
}
