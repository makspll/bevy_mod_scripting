// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use bevy_mod_scripting_core::{
    bindings::{
        ReflectReference, 
        function::{from::{Ref, Mut, Val}, namespace::{NamespaceBuilder}}
    }
};
use bevy_ecs::{prelude::*};


use bevy_mod_scripting_derive::script_bindings;


use crate::*;







pub struct BevyTextScriptingPlugin;


#[script_bindings(
    remote,
    name = "justify_text_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_text::prelude::JustifyText {


    
    fn assert_receiver_is_total_eq (_self:Ref<::bevy_text::prelude::JustifyText>,) -> () {
        let output: () =<::bevy_text::prelude::JustifyText as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_text::prelude::JustifyText>,) -> Val<::bevy_text::prelude::JustifyText> {
        let output: Val<::bevy_text::prelude::JustifyText> =<::bevy_text::prelude::JustifyText as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_text::prelude::JustifyText>,other:Ref<::bevy_text::prelude::JustifyText>,) -> bool {
        let output: bool =<::bevy_text::prelude::JustifyText as ::std::cmp::PartialEq::<::bevy_text::prelude::JustifyText>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "line_break_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_text::prelude::LineBreak {


    
    fn assert_receiver_is_total_eq (_self:Ref<::bevy_text::prelude::LineBreak>,) -> () {
        let output: () =<::bevy_text::prelude::LineBreak as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_text::prelude::LineBreak>,) -> Val<::bevy_text::prelude::LineBreak> {
        let output: Val<::bevy_text::prelude::LineBreak> =<::bevy_text::prelude::LineBreak as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_text::prelude::LineBreak>,other:Ref<::bevy_text::prelude::LineBreak>,) -> bool {
        let output: bool =<::bevy_text::prelude::LineBreak as ::std::cmp::PartialEq::<::bevy_text::prelude::LineBreak>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "text_2_d_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_text::prelude::Text2d {


    
    fn clone (_self:Ref<::bevy_text::prelude::Text2d>,) -> Val<::bevy_text::prelude::Text2d> {
        let output: Val<::bevy_text::prelude::Text2d> =<::bevy_text::prelude::Text2d as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "text_color_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_text::prelude::TextColor {


    
    fn clone (_self:Ref<::bevy_text::prelude::TextColor>,) -> Val<::bevy_text::prelude::TextColor> {
        let output: Val<::bevy_text::prelude::TextColor> =<::bevy_text::prelude::TextColor as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_text::prelude::TextColor>,other:Ref<::bevy_text::prelude::TextColor>,) -> bool {
        let output: bool =<::bevy_text::prelude::TextColor as ::std::cmp::PartialEq::<::bevy_text::prelude::TextColor>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "text_font_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_text::prelude::TextFont {


    
    fn clone (_self:Ref<::bevy_text::prelude::TextFont>,) -> Val<::bevy_text::prelude::TextFont> {
        let output: Val<::bevy_text::prelude::TextFont> =<::bevy_text::prelude::TextFont as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Returns a new [`TextFont`] with the specified font size.
    
    fn from_font_size (font_size:f32,) -> Val<::bevy_text::prelude::TextFont> {
        let output: Val<::bevy_text::prelude::TextFont> =::bevy_text::prelude::TextFont::from_font_size(font_size,).into();
        output
    }


    
    ///  Returns this [`TextFont`] with the specified font size.
    
    fn with_font_size (_self:Val<::bevy_text::prelude::TextFont>,font_size:f32,) -> Val<::bevy_text::prelude::TextFont> {
        let output: Val<::bevy_text::prelude::TextFont> =::bevy_text::prelude::TextFont::with_font_size(_self.into_inner(),font_size,).into();
        output
    }


    
    ///  Returns this [`TextFont`] with the specified [`FontSmoothing`].
    
    fn with_font_smoothing (_self:Val<::bevy_text::prelude::TextFont>,font_smoothing:Val<::bevy_text::FontSmoothing>,) -> Val<::bevy_text::prelude::TextFont> {
        let output: Val<::bevy_text::prelude::TextFont> =::bevy_text::prelude::TextFont::with_font_smoothing(_self.into_inner(),font_smoothing.into_inner(),).into();
        output
    }


    
    ///  Returns this [`TextFont`] with the specified [`LineHeight`].
    
    fn with_line_height (_self:Val<::bevy_text::prelude::TextFont>,line_height:Val<::bevy_text::LineHeight>,) -> Val<::bevy_text::prelude::TextFont> {
        let output: Val<::bevy_text::prelude::TextFont> =::bevy_text::prelude::TextFont::with_line_height(_self.into_inner(),line_height.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "text_layout_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_text::prelude::TextLayout {


    
    fn clone (_self:Ref<::bevy_text::prelude::TextLayout>,) -> Val<::bevy_text::prelude::TextLayout> {
        let output: Val<::bevy_text::prelude::TextLayout> =<::bevy_text::prelude::TextLayout as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Makes a new [`TextLayout`].
    
    fn new (justify:Val<::bevy_text::prelude::JustifyText>,linebreak:Val<::bevy_text::prelude::LineBreak>,) -> Val<::bevy_text::prelude::TextLayout> {
        let output: Val<::bevy_text::prelude::TextLayout> =::bevy_text::prelude::TextLayout::new(justify.into_inner(),linebreak.into_inner(),).into();
        output
    }


    
    ///  Makes a new [`TextLayout`] with the specified [`JustifyText`].
    
    fn new_with_justify (justify:Val<::bevy_text::prelude::JustifyText>,) -> Val<::bevy_text::prelude::TextLayout> {
        let output: Val<::bevy_text::prelude::TextLayout> =::bevy_text::prelude::TextLayout::new_with_justify(justify.into_inner(),).into();
        output
    }


    
    ///  Makes a new [`TextLayout`] with the specified [`LineBreak`].
    
    fn new_with_linebreak (linebreak:Val<::bevy_text::prelude::LineBreak>,) -> Val<::bevy_text::prelude::TextLayout> {
        let output: Val<::bevy_text::prelude::TextLayout> =::bevy_text::prelude::TextLayout::new_with_linebreak(linebreak.into_inner(),).into();
        output
    }


    
    ///  Makes a new [`TextLayout`] with soft wrapping disabled.
    
    ///  Hard wrapping, where text contains an explicit linebreak such as the escape sequence `\n`, will still occur.
    
    fn new_with_no_wrap () -> Val<::bevy_text::prelude::TextLayout> {
        let output: Val<::bevy_text::prelude::TextLayout> =::bevy_text::prelude::TextLayout::new_with_no_wrap().into();
        output
    }


    
    ///  Returns this [`TextLayout`] with the specified [`JustifyText`].
    
    fn with_justify (_self:Val<::bevy_text::prelude::TextLayout>,justify:Val<::bevy_text::prelude::JustifyText>,) -> Val<::bevy_text::prelude::TextLayout> {
        let output: Val<::bevy_text::prelude::TextLayout> =::bevy_text::prelude::TextLayout::with_justify(_self.into_inner(),justify.into_inner(),).into();
        output
    }


    
    ///  Returns this [`TextLayout`] with the specified [`LineBreak`].
    
    fn with_linebreak (_self:Val<::bevy_text::prelude::TextLayout>,linebreak:Val<::bevy_text::prelude::LineBreak>,) -> Val<::bevy_text::prelude::TextLayout> {
        let output: Val<::bevy_text::prelude::TextLayout> =::bevy_text::prelude::TextLayout::with_linebreak(_self.into_inner(),linebreak.into_inner(),).into();
        output
    }


    
    ///  Returns this [`TextLayout`] with soft wrapping disabled.
    
    ///  Hard wrapping, where text contains an explicit linebreak such as the escape sequence `\n`, will still occur.
    
    fn with_no_wrap (_self:Val<::bevy_text::prelude::TextLayout>,) -> Val<::bevy_text::prelude::TextLayout> {
        let output: Val<::bevy_text::prelude::TextLayout> =::bevy_text::prelude::TextLayout::with_no_wrap(_self.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "text_span_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_text::prelude::TextSpan {


    
    fn clone (_self:Ref<::bevy_text::prelude::TextSpan>,) -> Val<::bevy_text::prelude::TextSpan> {
        let output: Val<::bevy_text::prelude::TextSpan> =<::bevy_text::prelude::TextSpan as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "line_height_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_text::LineHeight {


    
    fn clone (_self:Ref<::bevy_text::LineHeight>,) -> Val<::bevy_text::LineHeight> {
        let output: Val<::bevy_text::LineHeight> =<::bevy_text::LineHeight as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "text_bounds_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_text::TextBounds {


    
    fn clone (_self:Ref<::bevy_text::TextBounds>,) -> Val<::bevy_text::TextBounds> {
        let output: Val<::bevy_text::TextBounds> =<::bevy_text::TextBounds as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new `TextBounds`, bounded with the specified width and height values.
    
    fn new (width:f32,height:f32,) -> Val<::bevy_text::TextBounds> {
        let output: Val<::bevy_text::TextBounds> =::bevy_text::TextBounds::new(width,height,).into();
        output
    }


    
    ///  Creates a new `TextBounds`, bounded with the specified width value and unbounded on height.
    
    fn new_horizontal (width:f32,) -> Val<::bevy_text::TextBounds> {
        let output: Val<::bevy_text::TextBounds> =::bevy_text::TextBounds::new_horizontal(width,).into();
        output
    }


    
    ///  Creates a new `TextBounds`, bounded with the specified height value and unbounded on width.
    
    fn new_vertical (height:f32,) -> Val<::bevy_text::TextBounds> {
        let output: Val<::bevy_text::TextBounds> =::bevy_text::TextBounds::new_vertical(height,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "computed_text_block_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_text::ComputedTextBlock {


    
    fn clone (_self:Ref<::bevy_text::ComputedTextBlock>,) -> Val<::bevy_text::ComputedTextBlock> {
        let output: Val<::bevy_text::ComputedTextBlock> =<::bevy_text::ComputedTextBlock as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Indicates if the text needs to be refreshed in [`TextLayoutInfo`].
    
    ///  Updated automatically by [`detect_text_needs_rerender`] and cleared
    
    ///  by [`TextPipeline`](crate::TextPipeline) methods.
    
    fn needs_rerender (_self:Ref<::bevy_text::ComputedTextBlock>,) -> bool {
        let output: bool =::bevy_text::ComputedTextBlock::needs_rerender(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "text_entity_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_text::TextEntity {


    
    fn clone (_self:Ref<::bevy_text::TextEntity>,) -> Val<::bevy_text::TextEntity> {
        let output: Val<::bevy_text::TextEntity> =<::bevy_text::TextEntity as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "font_smoothing_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_text::FontSmoothing {


    
    fn assert_receiver_is_total_eq (_self:Ref<::bevy_text::FontSmoothing>,) -> () {
        let output: () =<::bevy_text::FontSmoothing as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_text::FontSmoothing>,) -> Val<::bevy_text::FontSmoothing> {
        let output: Val<::bevy_text::FontSmoothing> =<::bevy_text::FontSmoothing as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_text::FontSmoothing>,other:Ref<::bevy_text::FontSmoothing>,) -> bool {
        let output: bool =<::bevy_text::FontSmoothing as ::std::cmp::PartialEq::<::bevy_text::FontSmoothing>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "glyph_atlas_location_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_text::GlyphAtlasLocation {


    
    fn clone (_self:Ref<::bevy_text::GlyphAtlasLocation>,) -> Val<::bevy_text::GlyphAtlasLocation> {
        let output: Val<::bevy_text::GlyphAtlasLocation> =<::bevy_text::GlyphAtlasLocation as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "glyph_atlas_info_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_text::GlyphAtlasInfo {


    
    fn clone (_self:Ref<::bevy_text::GlyphAtlasInfo>,) -> Val<::bevy_text::GlyphAtlasInfo> {
        let output: Val<::bevy_text::GlyphAtlasInfo> =<::bevy_text::GlyphAtlasInfo as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "positioned_glyph_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_text::PositionedGlyph {


    
    fn clone (_self:Ref<::bevy_text::PositionedGlyph>,) -> Val<::bevy_text::PositionedGlyph> {
        let output: Val<::bevy_text::PositionedGlyph> =<::bevy_text::PositionedGlyph as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "text_layout_info_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_text::TextLayoutInfo {


    
    fn clone (_self:Ref<::bevy_text::TextLayoutInfo>,) -> Val<::bevy_text::TextLayoutInfo> {
        let output: Val<::bevy_text::TextLayoutInfo> =<::bevy_text::TextLayoutInfo as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}


impl Plugin for BevyTextScriptingPlugin {
    fn build(&self, app: &mut App) {
        let mut world = app.world_mut();

        
            register_justify_text_functions(&mut world);
        
            register_line_break_functions(&mut world);
        
            register_text_2_d_functions(&mut world);
        
            register_text_color_functions(&mut world);
        
            register_text_font_functions(&mut world);
        
            register_text_layout_functions(&mut world);
        
            register_text_span_functions(&mut world);
        
            register_line_height_functions(&mut world);
        
            register_text_bounds_functions(&mut world);
        
            register_computed_text_block_functions(&mut world);
        
            register_text_entity_functions(&mut world);
        
            register_font_smoothing_functions(&mut world);
        
            register_glyph_atlas_location_functions(&mut world);
        
            register_glyph_atlas_info_functions(&mut world);
        
            register_positioned_glyph_functions(&mut world);
        
            register_text_layout_info_functions(&mut world);
        
    }
}
