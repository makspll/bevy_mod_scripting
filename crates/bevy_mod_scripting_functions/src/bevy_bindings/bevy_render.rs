// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use bevy_mod_scripting_core::{
    bindings::{
        ReflectReference, 
        function::{from::{Ref, Mut, Val}, namespace::{NamespaceBuilder}}
    }
};
use bevy_ecs::{prelude::*};


use bevy_mod_scripting_derive::script_bindings;


use crate::*;







pub struct BevyRenderScriptingPlugin;


#[script_bindings(
    remote,
    name = "alpha_mode_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::alpha::AlphaMode {


    
    fn clone (_self: Ref<::bevy_render::alpha::AlphaMode>,) -> Val<::bevy_render::alpha::AlphaMode> {
        let output: Val<::bevy_render::alpha::AlphaMode> =<::bevy_render::alpha::AlphaMode as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_render::alpha::AlphaMode>,other: Ref<::bevy_render::alpha::AlphaMode>,) -> bool {
        let output: bool =<::bevy_render::alpha::AlphaMode as ::std::cmp::PartialEq::<::bevy_render::alpha::AlphaMode>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "camera_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::Camera {


    
    ///  The projection matrix computed using this camera's [`CameraProjection`].
    
    fn clip_from_view (_self: Ref<::bevy_render::camera::Camera>,) -> Val<::bevy_math::Mat4> {
        let output: Val<::bevy_math::Mat4> =::bevy_render::camera::Camera::clip_from_view(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_render::camera::Camera>,) -> Val<::bevy_render::camera::Camera> {
        let output: Val<::bevy_render::camera::Camera> =<::bevy_render::camera::Camera as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Converts the depth in Normalized Device Coordinates
    
    ///  to linear view z for perspective projections.
    
    ///  Note: Depth values in front of the camera will be negative as -z is forward
    
    fn depth_ndc_to_view_z (_self: Ref<::bevy_render::camera::Camera>,ndc_depth: f32,) -> f32 {
        let output: f32 =::bevy_render::camera::Camera::depth_ndc_to_view_z(&_self,ndc_depth,).into();
        output
    }


    
    ///  Converts the depth in Normalized Device Coordinates
    
    ///  to linear view z for orthographic projections.
    
    ///  Note: Depth values in front of the camera will be negative as -z is forward
    
    fn depth_ndc_to_view_z_2d (_self: Ref<::bevy_render::camera::Camera>,ndc_depth: f32,) -> f32 {
        let output: f32 =::bevy_render::camera::Camera::depth_ndc_to_view_z_2d(&_self,ndc_depth,).into();
        output
    }


    
    fn target_scaling_factor (_self: Ref<::bevy_render::camera::Camera>,) -> ::std::option::Option<f32> {
        let output: ::std::option::Option<f32> =::bevy_render::camera::Camera::target_scaling_factor(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "clear_color_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::ClearColor {


    
    fn clone (_self: Ref<::bevy_render::camera::ClearColor>,) -> Val<::bevy_render::camera::ClearColor> {
        let output: Val<::bevy_render::camera::ClearColor> =<::bevy_render::camera::ClearColor as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "clear_color_config_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::ClearColorConfig {


    
    fn clone (_self: Ref<::bevy_render::camera::ClearColorConfig>,) -> Val<::bevy_render::camera::ClearColorConfig> {
        let output: Val<::bevy_render::camera::ClearColorConfig> =<::bevy_render::camera::ClearColorConfig as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "orthographic_projection_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::OrthographicProjection {


    
    fn clone (_self: Ref<::bevy_render::camera::OrthographicProjection>,) -> Val<::bevy_render::camera::OrthographicProjection> {
        let output: Val<::bevy_render::camera::OrthographicProjection> =<::bevy_render::camera::OrthographicProjection as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Returns the default orthographic projection for a 2D context.
    
    ///  The near plane is set to a negative value so that the camera can still
    
    ///  render the scene when using positive z coordinates to order foreground elements.
    
    fn default_2d () -> Val<::bevy_render::camera::OrthographicProjection> {
        let output: Val<::bevy_render::camera::OrthographicProjection> =::bevy_render::camera::OrthographicProjection::default_2d().into();
        output
    }


    
    ///  Returns the default orthographic projection for a 3D context.
    
    ///  The near plane is set to 0.0 so that the camera doesn't render
    
    ///  objects that are behind it.
    
    fn default_3d () -> Val<::bevy_render::camera::OrthographicProjection> {
        let output: Val<::bevy_render::camera::OrthographicProjection> =::bevy_render::camera::OrthographicProjection::default_3d().into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "perspective_projection_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::PerspectiveProjection {


    
    fn clone (_self: Ref<::bevy_render::camera::PerspectiveProjection>,) -> Val<::bevy_render::camera::PerspectiveProjection> {
        let output: Val<::bevy_render::camera::PerspectiveProjection> =<::bevy_render::camera::PerspectiveProjection as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "projection_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::Projection {


    
    fn clone (_self: Ref<::bevy_render::camera::Projection>,) -> Val<::bevy_render::camera::Projection> {
        let output: Val<::bevy_render::camera::Projection> =<::bevy_render::camera::Projection as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "mesh_2_d_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::mesh::Mesh2d {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_render::mesh::Mesh2d>,) -> () {
        let output: () =<::bevy_render::mesh::Mesh2d as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_render::mesh::Mesh2d>,) -> Val<::bevy_render::mesh::Mesh2d> {
        let output: Val<::bevy_render::mesh::Mesh2d> =<::bevy_render::mesh::Mesh2d as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_render::mesh::Mesh2d>,other: Ref<::bevy_render::mesh::Mesh2d>,) -> bool {
        let output: bool =<::bevy_render::mesh::Mesh2d as ::std::cmp::PartialEq::<::bevy_render::mesh::Mesh2d>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "mesh_3_d_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::mesh::Mesh3d {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_render::mesh::Mesh3d>,) -> () {
        let output: () =<::bevy_render::mesh::Mesh3d as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_render::mesh::Mesh3d>,) -> Val<::bevy_render::mesh::Mesh3d> {
        let output: Val<::bevy_render::mesh::Mesh3d> =<::bevy_render::mesh::Mesh3d as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_render::mesh::Mesh3d>,other: Ref<::bevy_render::mesh::Mesh3d>,) -> bool {
        let output: bool =<::bevy_render::mesh::Mesh3d as ::std::cmp::PartialEq::<::bevy_render::mesh::Mesh3d>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "inherited_visibility_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::view::visibility::InheritedVisibility {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_render::view::visibility::InheritedVisibility>,) -> () {
        let output: () =<::bevy_render::view::visibility::InheritedVisibility as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_render::view::visibility::InheritedVisibility>,) -> Val<::bevy_render::view::visibility::InheritedVisibility> {
        let output: Val<::bevy_render::view::visibility::InheritedVisibility> =<::bevy_render::view::visibility::InheritedVisibility as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_render::view::visibility::InheritedVisibility>,other: Ref<::bevy_render::view::visibility::InheritedVisibility>,) -> bool {
        let output: bool =<::bevy_render::view::visibility::InheritedVisibility as ::std::cmp::PartialEq::<::bevy_render::view::visibility::InheritedVisibility>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Returns `true` if the entity is visible in the hierarchy.
    
    ///  Otherwise, returns `false`.
    
    fn get (_self: Val<::bevy_render::view::visibility::InheritedVisibility>,) -> bool {
        let output: bool =::bevy_render::view::visibility::InheritedVisibility::get(_self.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "msaa_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::view::Msaa {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_render::view::Msaa>,) -> () {
        let output: () =<::bevy_render::view::Msaa as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_render::view::Msaa>,) -> Val<::bevy_render::view::Msaa> {
        let output: Val<::bevy_render::view::Msaa> =<::bevy_render::view::Msaa as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_render::view::Msaa>,other: Ref<::bevy_render::view::Msaa>,) -> bool {
        let output: bool =<::bevy_render::view::Msaa as ::std::cmp::PartialEq::<::bevy_render::view::Msaa>>::eq(&_self,&other,).into();
        output
    }


    
    fn from_samples (samples: u32,) -> Val<::bevy_render::view::Msaa> {
        let output: Val<::bevy_render::view::Msaa> =::bevy_render::view::Msaa::from_samples(samples,).into();
        output
    }


    
    fn samples (_self: Ref<::bevy_render::view::Msaa>,) -> u32 {
        let output: u32 =::bevy_render::view::Msaa::samples(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "view_visibility_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::view::visibility::ViewVisibility {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_render::view::visibility::ViewVisibility>,) -> () {
        let output: () =<::bevy_render::view::visibility::ViewVisibility as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_render::view::visibility::ViewVisibility>,) -> Val<::bevy_render::view::visibility::ViewVisibility> {
        let output: Val<::bevy_render::view::visibility::ViewVisibility> =<::bevy_render::view::visibility::ViewVisibility as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_render::view::visibility::ViewVisibility>,other: Ref<::bevy_render::view::visibility::ViewVisibility>,) -> bool {
        let output: bool =<::bevy_render::view::visibility::ViewVisibility as ::std::cmp::PartialEq::<::bevy_render::view::visibility::ViewVisibility>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Returns `true` if the entity is visible in any view.
    
    ///  Otherwise, returns `false`.
    
    fn get (_self: Val<::bevy_render::view::visibility::ViewVisibility>,) -> bool {
        let output: bool =::bevy_render::view::visibility::ViewVisibility::get(_self.into_inner(),).into();
        output
    }


    
    ///  Sets the visibility to `true`. This should not be considered reversible for a given frame,
    
    ///  as this component tracks whether or not the entity visible in _any_ view.
    
    ///  This will be automatically reset to `false` every frame in [`VisibilityPropagate`] and then set
    
    ///  to the proper value in [`CheckVisibility`].
    
    ///  You should only manually set this if you are defining a custom visibility system,
    
    ///  in which case the system should be placed in the [`CheckVisibility`] set.
    
    ///  For normal user-defined entity visibility, see [`Visibility`].
    
    ///  [`VisibilityPropagate`]: VisibilitySystems::VisibilityPropagate
    
    ///  [`CheckVisibility`]: VisibilitySystems::CheckVisibility
    
    fn set (mut _self: Mut<::bevy_render::view::visibility::ViewVisibility>,) -> () {
        let output: () =::bevy_render::view::visibility::ViewVisibility::set(&mut _self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "visibility_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::view::visibility::Visibility {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_render::view::visibility::Visibility>,) -> () {
        let output: () =<::bevy_render::view::visibility::Visibility as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_render::view::visibility::Visibility>,) -> Val<::bevy_render::view::visibility::Visibility> {
        let output: Val<::bevy_render::view::visibility::Visibility> =<::bevy_render::view::visibility::Visibility as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_render::view::visibility::Visibility>,other: Ref<::bevy_render::view::visibility::Visibility>,) -> bool {
        let output: bool =<::bevy_render::view::visibility::Visibility as ::std::cmp::PartialEq::<::bevy_render::view::visibility::Visibility>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Toggles between `Visibility::Inherited` and `Visibility::Hidden`.
    
    ///  If the value is `Visibility::Visible`, it remains unaffected.
    
    fn toggle_inherited_hidden (mut _self: Mut<::bevy_render::view::visibility::Visibility>,) -> () {
        let output: () =::bevy_render::view::visibility::Visibility::toggle_inherited_hidden(&mut _self,).into();
        output
    }


    
    ///  Toggles between `Visibility::Inherited` and `Visibility::Visible`.
    
    ///  If the value is `Visibility::Hidden`, it remains unaffected.
    
    fn toggle_inherited_visible (mut _self: Mut<::bevy_render::view::visibility::Visibility>,) -> () {
        let output: () =::bevy_render::view::visibility::Visibility::toggle_inherited_visible(&mut _self,).into();
        output
    }


    
    ///  Toggles between `Visibility::Visible` and `Visibility::Hidden`.
    
    ///  If the value is `Visibility::Inherited`, it remains unaffected.
    
    fn toggle_visible_hidden (mut _self: Mut<::bevy_render::view::visibility::Visibility>,) -> () {
        let output: () =::bevy_render::view::visibility::Visibility::toggle_visible_hidden(&mut _self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "sync_to_render_world_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::sync_world::SyncToRenderWorld {


    
    fn clone (_self: Ref<::bevy_render::sync_world::SyncToRenderWorld>,) -> Val<::bevy_render::sync_world::SyncToRenderWorld> {
        let output: Val<::bevy_render::sync_world::SyncToRenderWorld> =<::bevy_render::sync_world::SyncToRenderWorld as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "aabb_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::primitives::Aabb {


    
    fn clone (_self: Ref<::bevy_render::primitives::Aabb>,) -> Val<::bevy_render::primitives::Aabb> {
        let output: Val<::bevy_render::primitives::Aabb> =<::bevy_render::primitives::Aabb as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_render::primitives::Aabb>,other: Ref<::bevy_render::primitives::Aabb>,) -> bool {
        let output: bool =<::bevy_render::primitives::Aabb as ::std::cmp::PartialEq::<::bevy_render::primitives::Aabb>>::eq(&_self,&other,).into();
        output
    }


    
    fn from_min_max (minimum: Val<::bevy_math::Vec3>,maximum: Val<::bevy_math::Vec3>,) -> Val<::bevy_render::primitives::Aabb> {
        let output: Val<::bevy_render::primitives::Aabb> =::bevy_render::primitives::Aabb::from_min_max(minimum.into_inner(),maximum.into_inner(),).into();
        output
    }


    
    fn max (_self: Ref<::bevy_render::primitives::Aabb>,) -> Val<::bevy_math::Vec3A> {
        let output: Val<::bevy_math::Vec3A> =::bevy_render::primitives::Aabb::max(&_self,).into();
        output
    }


    
    fn min (_self: Ref<::bevy_render::primitives::Aabb>,) -> Val<::bevy_math::Vec3A> {
        let output: Val<::bevy_math::Vec3A> =::bevy_render::primitives::Aabb::min(&_self,).into();
        output
    }


    
    ///  Calculate the relative radius of the AABB with respect to a plane
    
    fn relative_radius (_self: Ref<::bevy_render::primitives::Aabb>,p_normal: Ref<::bevy_math::Vec3A>,world_from_local: Ref<::bevy_math::Mat3A>,) -> f32 {
        let output: f32 =::bevy_render::primitives::Aabb::relative_radius(&_self,&p_normal,&world_from_local,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cascades_frusta_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::primitives::CascadesFrusta {


    
    fn clone (_self: Ref<::bevy_render::primitives::CascadesFrusta>,) -> Val<::bevy_render::primitives::CascadesFrusta> {
        let output: Val<::bevy_render::primitives::CascadesFrusta> =<::bevy_render::primitives::CascadesFrusta as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cubemap_frusta_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::primitives::CubemapFrusta {


    
    fn clone (_self: Ref<::bevy_render::primitives::CubemapFrusta>,) -> Val<::bevy_render::primitives::CubemapFrusta> {
        let output: Val<::bevy_render::primitives::CubemapFrusta> =<::bevy_render::primitives::CubemapFrusta as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "frustum_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::primitives::Frustum {


    
    fn clone (_self: Ref<::bevy_render::primitives::Frustum>,) -> Val<::bevy_render::primitives::Frustum> {
        let output: Val<::bevy_render::primitives::Frustum> =<::bevy_render::primitives::Frustum as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Check if the frustum contains the Axis-Aligned Bounding Box (AABB).
    
    ///  Referenced from: [Frustum Culling](https://learnopengl.com/Guest-Articles/2021/Scene/Frustum-Culling)
    
    fn contains_aabb (_self: Ref<::bevy_render::primitives::Frustum>,aabb: Ref<::bevy_render::primitives::Aabb>,world_from_local: Ref<::bevy_math::Affine3A>,) -> bool {
        let output: bool =::bevy_render::primitives::Frustum::contains_aabb(&_self,&aabb,&world_from_local,).into();
        output
    }


    
    ///  Returns a frustum derived from `clip_from_world`.
    
    fn from_clip_from_world (clip_from_world: Ref<::bevy_math::Mat4>,) -> Val<::bevy_render::primitives::Frustum> {
        let output: Val<::bevy_render::primitives::Frustum> =::bevy_render::primitives::Frustum::from_clip_from_world(&clip_from_world,).into();
        output
    }


    
    ///  Returns a frustum derived from `clip_from_world`,
    
    ///  but with a custom far plane.
    
    fn from_clip_from_world_custom_far (clip_from_world: Ref<::bevy_math::Mat4>,view_translation: Ref<::bevy_math::Vec3>,view_backward: Ref<::bevy_math::Vec3>,far: f32,) -> Val<::bevy_render::primitives::Frustum> {
        let output: Val<::bevy_render::primitives::Frustum> =::bevy_render::primitives::Frustum::from_clip_from_world_custom_far(&clip_from_world,&view_translation,&view_backward,far,).into();
        output
    }


    
    ///  Checks if an Oriented Bounding Box (obb) intersects the frustum.
    
    fn intersects_obb (_self: Ref<::bevy_render::primitives::Frustum>,aabb: Ref<::bevy_render::primitives::Aabb>,world_from_local: Ref<::bevy_math::Affine3A>,intersect_near: bool,intersect_far: bool,) -> bool {
        let output: bool =::bevy_render::primitives::Frustum::intersects_obb(&_self,&aabb,&world_from_local,intersect_near,intersect_far,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "occlusion_culling_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::experimental::occlusion_culling::OcclusionCulling {


    
    fn clone (_self: Ref<::bevy_render::experimental::occlusion_culling::OcclusionCulling>,) -> Val<::bevy_render::experimental::occlusion_culling::OcclusionCulling> {
        let output: Val<::bevy_render::experimental::occlusion_culling::OcclusionCulling> =<::bevy_render::experimental::occlusion_culling::OcclusionCulling as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "camera_render_graph_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::CameraRenderGraph {


    
    fn clone (_self: Ref<::bevy_render::camera::CameraRenderGraph>,) -> Val<::bevy_render::camera::CameraRenderGraph> {
        let output: Val<::bevy_render::camera::CameraRenderGraph> =<::bevy_render::camera::CameraRenderGraph as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "camera_main_texture_usages_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::CameraMainTextureUsages {


    
    fn clone (_self: Ref<::bevy_render::camera::CameraMainTextureUsages>,) -> Val<::bevy_render::camera::CameraMainTextureUsages> {
        let output: Val<::bevy_render::camera::CameraMainTextureUsages> =<::bevy_render::camera::CameraMainTextureUsages as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "exposure_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::Exposure {


    
    fn clone (_self: Ref<::bevy_render::camera::Exposure>,) -> Val<::bevy_render::camera::Exposure> {
        let output: Val<::bevy_render::camera::Exposure> =<::bevy_render::camera::Exposure as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Converts EV100 values to exposure values.
    
    ///  <https://google.github.io/filament/Filament.md.html#imagingpipeline/physicallybasedcamera/exposure>
    
    fn exposure (_self: Ref<::bevy_render::camera::Exposure>,) -> f32 {
        let output: f32 =::bevy_render::camera::Exposure::exposure(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "temporal_jitter_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::TemporalJitter {


    
    fn clone (_self: Ref<::bevy_render::camera::TemporalJitter>,) -> Val<::bevy_render::camera::TemporalJitter> {
        let output: Val<::bevy_render::camera::TemporalJitter> =<::bevy_render::camera::TemporalJitter as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn jitter_projection (_self: Ref<::bevy_render::camera::TemporalJitter>,mut clip_from_view: Mut<::bevy_math::Mat4>,view_size: Val<::bevy_math::Vec2>,) -> () {
        let output: () =::bevy_render::camera::TemporalJitter::jitter_projection(&_self,&mut clip_from_view,view_size.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "mip_bias_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::MipBias {
     
}

#[script_bindings(
    remote,
    name = "manual_texture_view_handle_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::ManualTextureViewHandle {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_render::camera::ManualTextureViewHandle>,) -> () {
        let output: () =<::bevy_render::camera::ManualTextureViewHandle as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_render::camera::ManualTextureViewHandle>,) -> Val<::bevy_render::camera::ManualTextureViewHandle> {
        let output: Val<::bevy_render::camera::ManualTextureViewHandle> =<::bevy_render::camera::ManualTextureViewHandle as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_render::camera::ManualTextureViewHandle>,other: Ref<::bevy_render::camera::ManualTextureViewHandle>,) -> bool {
        let output: bool =<::bevy_render::camera::ManualTextureViewHandle as ::std::cmp::PartialEq::<::bevy_render::camera::ManualTextureViewHandle>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "color_grading_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::view::ColorGrading {


    
    fn clone (_self: Ref<::bevy_render::view::ColorGrading>,) -> Val<::bevy_render::view::ColorGrading> {
        let output: Val<::bevy_render::view::ColorGrading> =<::bevy_render::view::ColorGrading as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new [`ColorGrading`] instance in which shadows, midtones, and
    
    ///  highlights all have the same set of color grading values.
    
    fn with_identical_sections (global: Val<::bevy_render::view::ColorGradingGlobal>,section: Val<::bevy_render::view::ColorGradingSection>,) -> Val<::bevy_render::view::ColorGrading> {
        let output: Val<::bevy_render::view::ColorGrading> =::bevy_render::view::ColorGrading::with_identical_sections(global.into_inner(),section.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "render_layers_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::view::visibility::RenderLayers {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_render::view::visibility::RenderLayers>,) -> () {
        let output: () =<::bevy_render::view::visibility::RenderLayers as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_render::view::visibility::RenderLayers>,) -> Val<::bevy_render::view::visibility::RenderLayers> {
        let output: Val<::bevy_render::view::visibility::RenderLayers> =<::bevy_render::view::visibility::RenderLayers as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_render::view::visibility::RenderLayers>,other: Ref<::bevy_render::view::visibility::RenderLayers>,) -> bool {
        let output: bool =<::bevy_render::view::visibility::RenderLayers as ::std::cmp::PartialEq::<::bevy_render::view::visibility::RenderLayers>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Returns the set of [layers](Layer) shared by two instances of [`RenderLayers`].
    
    ///  This corresponds to the `self & other` operation.
    
    fn intersection (_self: Ref<::bevy_render::view::visibility::RenderLayers>,other: Ref<::bevy_render::view::visibility::RenderLayers>,) -> Val<::bevy_render::view::visibility::RenderLayers> {
        let output: Val<::bevy_render::view::visibility::RenderLayers> =::bevy_render::view::visibility::RenderLayers::intersection(&_self,&other,).into();
        output
    }


    
    ///  Determine if a `RenderLayers` intersects another.
    
    ///  `RenderLayers`s intersect if they share any common layers.
    
    ///  A `RenderLayers` with no layers will not match any other
    
    ///  `RenderLayers`, even another with no layers.
    
    fn intersects (_self: Ref<::bevy_render::view::visibility::RenderLayers>,other: Ref<::bevy_render::view::visibility::RenderLayers>,) -> bool {
        let output: bool =::bevy_render::view::visibility::RenderLayers::intersects(&_self,&other,).into();
        output
    }


    
    ///  Create a new `RenderLayers` belonging to the given layer.
    
    ///  This `const` constructor is limited to `size_of::<usize>()` layers.
    
    ///  If you need to support an arbitrary number of layers, use [`with`](RenderLayers::with)
    
    ///  or [`from_layers`](RenderLayers::from_layers).
    
    fn layer (n: usize,) -> Val<::bevy_render::view::visibility::RenderLayers> {
        let output: Val<::bevy_render::view::visibility::RenderLayers> =::bevy_render::view::visibility::RenderLayers::layer(n,).into();
        output
    }


    
    ///  Create a new `RenderLayers` that belongs to no layers.
    
    ///  This is distinct from [`RenderLayers::default`], which belongs to the first layer.
    
    fn none () -> Val<::bevy_render::view::visibility::RenderLayers> {
        let output: Val<::bevy_render::view::visibility::RenderLayers> =::bevy_render::view::visibility::RenderLayers::none().into();
        output
    }


    
    ///  Returns all [layers](Layer) included in exactly one of the instances of [`RenderLayers`].
    
    ///  This corresponds to the "exclusive or" (XOR) operation: `self ^ other`.
    
    fn symmetric_difference (_self: Ref<::bevy_render::view::visibility::RenderLayers>,other: Ref<::bevy_render::view::visibility::RenderLayers>,) -> Val<::bevy_render::view::visibility::RenderLayers> {
        let output: Val<::bevy_render::view::visibility::RenderLayers> =::bevy_render::view::visibility::RenderLayers::symmetric_difference(&_self,&other,).into();
        output
    }


    
    ///  Returns all [layers](Layer) included in either instance of [`RenderLayers`].
    
    ///  This corresponds to the `self | other` operation.
    
    fn union (_self: Ref<::bevy_render::view::visibility::RenderLayers>,other: Ref<::bevy_render::view::visibility::RenderLayers>,) -> Val<::bevy_render::view::visibility::RenderLayers> {
        let output: Val<::bevy_render::view::visibility::RenderLayers> =::bevy_render::view::visibility::RenderLayers::union(&_self,&other,).into();
        output
    }


    
    ///  Add the given layer.
    
    ///  This may be called multiple times to allow an entity to belong
    
    ///  to multiple rendering layers.
    
    fn with (_self: Val<::bevy_render::view::visibility::RenderLayers>,layer: usize,) -> Val<::bevy_render::view::visibility::RenderLayers> {
        let output: Val<::bevy_render::view::visibility::RenderLayers> =::bevy_render::view::visibility::RenderLayers::with(_self.into_inner(),layer,).into();
        output
    }


    
    ///  Removes the given rendering layer.
    
    fn without (_self: Val<::bevy_render::view::visibility::RenderLayers>,layer: usize,) -> Val<::bevy_render::view::visibility::RenderLayers> {
        let output: Val<::bevy_render::view::visibility::RenderLayers> =::bevy_render::view::visibility::RenderLayers::without(_self.into_inner(),layer,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "render_visible_entities_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::view::visibility::RenderVisibleEntities {


    
    fn clone (_self: Ref<::bevy_render::view::visibility::RenderVisibleEntities>,) -> Val<::bevy_render::view::visibility::RenderVisibleEntities> {
        let output: Val<::bevy_render::view::visibility::RenderVisibleEntities> =<::bevy_render::view::visibility::RenderVisibleEntities as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "visible_entities_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::view::visibility::VisibleEntities {


    
    fn clear (mut _self: Mut<::bevy_render::view::visibility::VisibleEntities>,type_id: Val<::std::any::TypeId>,) -> () {
        let output: () =::bevy_render::view::visibility::VisibleEntities::clear(&mut _self,type_id.into_inner(),).into();
        output
    }


    
    fn clear_all (mut _self: Mut<::bevy_render::view::visibility::VisibleEntities>,) -> () {
        let output: () =::bevy_render::view::visibility::VisibleEntities::clear_all(&mut _self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_render::view::visibility::VisibleEntities>,) -> Val<::bevy_render::view::visibility::VisibleEntities> {
        let output: Val<::bevy_render::view::visibility::VisibleEntities> =<::bevy_render::view::visibility::VisibleEntities as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn is_empty (_self: Ref<::bevy_render::view::visibility::VisibleEntities>,type_id: Val<::std::any::TypeId>,) -> bool {
        let output: bool =::bevy_render::view::visibility::VisibleEntities::is_empty(&_self,type_id.into_inner(),).into();
        output
    }


    
    fn len (_self: Ref<::bevy_render::view::visibility::VisibleEntities>,type_id: Val<::std::any::TypeId>,) -> usize {
        let output: usize =::bevy_render::view::visibility::VisibleEntities::len(&_self,type_id.into_inner(),).into();
        output
    }


    
    fn push (mut _self: Mut<::bevy_render::view::visibility::VisibleEntities>,entity: Val<::bevy_ecs::entity::Entity>,type_id: Val<::std::any::TypeId>,) -> () {
        let output: () =::bevy_render::view::visibility::VisibleEntities::push(&mut _self,entity.into_inner(),type_id.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "viewport_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::Viewport {


    
    ///  Cut the viewport rectangle so that it lies inside a rectangle of the
    
    ///  given size.
    
    ///  If either of the viewport's position coordinates lies outside the given
    
    ///  dimensions, it will be moved just inside first. If either of the given
    
    ///  dimensions is zero, the position and size of the viewport rectangle will
    
    ///  both be set to zero in that dimension.
    
    fn clamp_to_size (mut _self: Mut<::bevy_render::camera::Viewport>,size: Val<::bevy_math::UVec2>,) -> () {
        let output: () =::bevy_render::camera::Viewport::clamp_to_size(&mut _self,size.into_inner(),).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_render::camera::Viewport>,) -> Val<::bevy_render::camera::Viewport> {
        let output: Val<::bevy_render::camera::Viewport> =<::bevy_render::camera::Viewport as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "sub_camera_view_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::SubCameraView {


    
    fn clone (_self: Ref<::bevy_render::camera::SubCameraView>,) -> Val<::bevy_render::camera::SubCameraView> {
        let output: Val<::bevy_render::camera::SubCameraView> =<::bevy_render::camera::SubCameraView as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_render::camera::SubCameraView>,other: Ref<::bevy_render::camera::SubCameraView>,) -> bool {
        let output: bool =<::bevy_render::camera::SubCameraView as ::std::cmp::PartialEq::<::bevy_render::camera::SubCameraView>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "render_target_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::RenderTarget {


    
    fn clone (_self: Ref<::bevy_render::camera::RenderTarget>,) -> Val<::bevy_render::camera::RenderTarget> {
        let output: Val<::bevy_render::camera::RenderTarget> =<::bevy_render::camera::RenderTarget as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "image_render_target_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::ImageRenderTarget {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_render::camera::ImageRenderTarget>,) -> () {
        let output: () =<::bevy_render::camera::ImageRenderTarget as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_render::camera::ImageRenderTarget>,) -> Val<::bevy_render::camera::ImageRenderTarget> {
        let output: Val<::bevy_render::camera::ImageRenderTarget> =<::bevy_render::camera::ImageRenderTarget as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_render::camera::ImageRenderTarget>,other: Ref<::bevy_render::camera::ImageRenderTarget>,) -> bool {
        let output: bool =<::bevy_render::camera::ImageRenderTarget as ::std::cmp::PartialEq::<::bevy_render::camera::ImageRenderTarget>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "normalized_render_target_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::NormalizedRenderTarget {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_render::camera::NormalizedRenderTarget>,) -> () {
        let output: () =<::bevy_render::camera::NormalizedRenderTarget as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_render::camera::NormalizedRenderTarget>,) -> Val<::bevy_render::camera::NormalizedRenderTarget> {
        let output: Val<::bevy_render::camera::NormalizedRenderTarget> =<::bevy_render::camera::NormalizedRenderTarget as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_render::camera::NormalizedRenderTarget>,other: Ref<::bevy_render::camera::NormalizedRenderTarget>,) -> bool {
        let output: bool =<::bevy_render::camera::NormalizedRenderTarget as ::std::cmp::PartialEq::<::bevy_render::camera::NormalizedRenderTarget>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "custom_projection_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::CustomProjection {


    
    fn clone (_self: Ref<::bevy_render::camera::CustomProjection>,) -> Val<::bevy_render::camera::CustomProjection> {
        let output: Val<::bevy_render::camera::CustomProjection> =<::bevy_render::camera::CustomProjection as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "scaling_mode_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::camera::ScalingMode {


    
    fn clone (_self: Ref<::bevy_render::camera::ScalingMode>,) -> Val<::bevy_render::camera::ScalingMode> {
        let output: Val<::bevy_render::camera::ScalingMode> =<::bevy_render::camera::ScalingMode as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "globals_uniform_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::globals::GlobalsUniform {


    
    fn clone (_self: Ref<::bevy_render::globals::GlobalsUniform>,) -> Val<::bevy_render::globals::GlobalsUniform> {
        let output: Val<::bevy_render::globals::GlobalsUniform> =<::bevy_render::globals::GlobalsUniform as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "shader_storage_buffer_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::storage::ShaderStorageBuffer {


    
    fn clone (_self: Ref<::bevy_render::storage::ShaderStorageBuffer>,) -> Val<::bevy_render::storage::ShaderStorageBuffer> {
        let output: Val<::bevy_render::storage::ShaderStorageBuffer> =<::bevy_render::storage::ShaderStorageBuffer as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new storage buffer with the given size and asset usage.
    
    fn with_size (size: usize,asset_usage: Val<::bevy_render::render_asset::RenderAssetUsages>,) -> Val<::bevy_render::storage::ShaderStorageBuffer> {
        let output: Val<::bevy_render::storage::ShaderStorageBuffer> =::bevy_render::storage::ShaderStorageBuffer::with_size(size,asset_usage.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "readback_complete_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::gpu_readback::ReadbackComplete {
     
}

#[script_bindings(
    remote,
    name = "mesh_tag_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::mesh::MeshTag {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_render::mesh::MeshTag>,) -> () {
        let output: () =<::bevy_render::mesh::MeshTag as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_render::mesh::MeshTag>,) -> Val<::bevy_render::mesh::MeshTag> {
        let output: Val<::bevy_render::mesh::MeshTag> =<::bevy_render::mesh::MeshTag as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_render::mesh::MeshTag>,other: Ref<::bevy_render::mesh::MeshTag>,) -> bool {
        let output: bool =<::bevy_render::mesh::MeshTag as ::std::cmp::PartialEq::<::bevy_render::mesh::MeshTag>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "visibility_class_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::view::visibility::VisibilityClass {


    
    fn clone (_self: Ref<::bevy_render::view::visibility::VisibilityClass>,) -> Val<::bevy_render::view::visibility::VisibilityClass> {
        let output: Val<::bevy_render::view::visibility::VisibilityClass> =<::bevy_render::view::visibility::VisibilityClass as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "temporary_render_entity_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::sync_world::TemporaryRenderEntity {


    
    fn clone (_self: Ref<::bevy_render::sync_world::TemporaryRenderEntity>,) -> Val<::bevy_render::sync_world::TemporaryRenderEntity> {
        let output: Val<::bevy_render::sync_world::TemporaryRenderEntity> =<::bevy_render::sync_world::TemporaryRenderEntity as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "no_frustum_culling_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::view::visibility::NoFrustumCulling {
     
}

#[script_bindings(
    remote,
    name = "color_grading_global_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::view::ColorGradingGlobal {


    
    fn clone (_self: Ref<::bevy_render::view::ColorGradingGlobal>,) -> Val<::bevy_render::view::ColorGradingGlobal> {
        let output: Val<::bevy_render::view::ColorGradingGlobal> =<::bevy_render::view::ColorGradingGlobal as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "color_grading_section_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::view::ColorGradingSection {


    
    fn clone (_self: Ref<::bevy_render::view::ColorGradingSection>,) -> Val<::bevy_render::view::ColorGradingSection> {
        let output: Val<::bevy_render::view::ColorGradingSection> =<::bevy_render::view::ColorGradingSection as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_render::view::ColorGradingSection>,other: Ref<::bevy_render::view::ColorGradingSection>,) -> bool {
        let output: bool =<::bevy_render::view::ColorGradingSection as ::std::cmp::PartialEq::<::bevy_render::view::ColorGradingSection>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "visibility_range_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::view::visibility::VisibilityRange {


    
    ///  Creates a new *abrupt* visibility range, with no crossfade.
    
    ///  There will be no crossfade; the object will immediately vanish if the
    
    ///  camera is closer than `start` units or farther than `end` units from the
    
    ///  model.
    
    ///  The `start` value must be less than or equal to the `end` value.
    
    fn abrupt (start: f32,end: f32,) -> Val<::bevy_render::view::visibility::VisibilityRange> {
        let output: Val<::bevy_render::view::visibility::VisibilityRange> =::bevy_render::view::visibility::VisibilityRange::abrupt(start,end,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_render::view::visibility::VisibilityRange>,) -> Val<::bevy_render::view::visibility::VisibilityRange> {
        let output: Val<::bevy_render::view::visibility::VisibilityRange> =<::bevy_render::view::visibility::VisibilityRange as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_render::view::visibility::VisibilityRange>,other: Ref<::bevy_render::view::visibility::VisibilityRange>,) -> bool {
        let output: bool =<::bevy_render::view::visibility::VisibilityRange as ::std::cmp::PartialEq::<::bevy_render::view::visibility::VisibilityRange>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Returns true if both the start and end transitions for this range are
    
    ///  abrupt: that is, there is no crossfading.
    
    fn is_abrupt (_self: Ref<::bevy_render::view::visibility::VisibilityRange>,) -> bool {
        let output: bool =::bevy_render::view::visibility::VisibilityRange::is_abrupt(&_self,).into();
        output
    }


    
    ///  Returns true if the object is completely invisible, given a camera
    
    ///  `camera_distance` units away.
    
    ///  This is equivalent to `!VisibilityRange::is_visible_at_all()`.
    
    fn is_culled (_self: Ref<::bevy_render::view::visibility::VisibilityRange>,camera_distance: f32,) -> bool {
        let output: bool =::bevy_render::view::visibility::VisibilityRange::is_culled(&_self,camera_distance,).into();
        output
    }


    
    ///  Returns true if the object will be visible at all, given a camera
    
    ///  `camera_distance` units away.
    
    ///  Any amount of visibility, even with the heaviest dithering applied, is
    
    ///  considered visible according to this check.
    
    fn is_visible_at_all (_self: Ref<::bevy_render::view::visibility::VisibilityRange>,camera_distance: f32,) -> bool {
        let output: bool =::bevy_render::view::visibility::VisibilityRange::is_visible_at_all(&_self,camera_distance,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "screenshot_captured_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::view::window::screenshot::ScreenshotCaptured {
     
}

#[script_bindings(
    remote,
    name = "screenshot_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_render::view::window::screenshot::Screenshot {


    
    ///  Capture a screenshot of the primary window, if one exists.
    
    fn primary_window () -> Val<::bevy_render::view::window::screenshot::Screenshot> {
        let output: Val<::bevy_render::view::window::screenshot::Screenshot> =::bevy_render::view::window::screenshot::Screenshot::primary_window().into();
        output
    }


    
    ///  Capture a screenshot of the provided manual texture view.
    
    fn texture_view (texture_view: Val<::bevy_render::camera::ManualTextureViewHandle>,) -> Val<::bevy_render::view::window::screenshot::Screenshot> {
        let output: Val<::bevy_render::view::window::screenshot::Screenshot> =::bevy_render::view::window::screenshot::Screenshot::texture_view(texture_view.into_inner(),).into();
        output
    }


    
    ///  Capture a screenshot of the provided window entity.
    
    fn window (window: Val<::bevy_ecs::entity::Entity>,) -> Val<::bevy_render::view::window::screenshot::Screenshot> {
        let output: Val<::bevy_render::view::window::screenshot::Screenshot> =::bevy_render::view::window::screenshot::Screenshot::window(window.into_inner(),).into();
        output
    }
     
}


impl Plugin for BevyRenderScriptingPlugin {
    fn build(&self, app: &mut App) {
        let mut world = app.world_mut();

        
            register_alpha_mode_functions(&mut world);
        
            register_camera_functions(&mut world);
        
            register_clear_color_functions(&mut world);
        
            register_clear_color_config_functions(&mut world);
        
            register_orthographic_projection_functions(&mut world);
        
            register_perspective_projection_functions(&mut world);
        
            register_projection_functions(&mut world);
        
            register_mesh_2_d_functions(&mut world);
        
            register_mesh_3_d_functions(&mut world);
        
            register_inherited_visibility_functions(&mut world);
        
            register_msaa_functions(&mut world);
        
            register_view_visibility_functions(&mut world);
        
            register_visibility_functions(&mut world);
        
            register_sync_to_render_world_functions(&mut world);
        
            register_aabb_functions(&mut world);
        
            register_cascades_frusta_functions(&mut world);
        
            register_cubemap_frusta_functions(&mut world);
        
            register_frustum_functions(&mut world);
        
            register_occlusion_culling_functions(&mut world);
        
            register_camera_render_graph_functions(&mut world);
        
            register_camera_main_texture_usages_functions(&mut world);
        
            register_exposure_functions(&mut world);
        
            register_temporal_jitter_functions(&mut world);
        
            register_mip_bias_functions(&mut world);
        
            register_manual_texture_view_handle_functions(&mut world);
        
            register_color_grading_functions(&mut world);
        
            register_render_layers_functions(&mut world);
        
            register_render_visible_entities_functions(&mut world);
        
            register_visible_entities_functions(&mut world);
        
            register_viewport_functions(&mut world);
        
            register_sub_camera_view_functions(&mut world);
        
            register_render_target_functions(&mut world);
        
            register_image_render_target_functions(&mut world);
        
            register_normalized_render_target_functions(&mut world);
        
            register_custom_projection_functions(&mut world);
        
            register_scaling_mode_functions(&mut world);
        
            register_globals_uniform_functions(&mut world);
        
            register_shader_storage_buffer_functions(&mut world);
        
            register_readback_complete_functions(&mut world);
        
            register_mesh_tag_functions(&mut world);
        
            register_visibility_class_functions(&mut world);
        
            register_temporary_render_entity_functions(&mut world);
        
            register_no_frustum_culling_functions(&mut world);
        
            register_color_grading_global_functions(&mut world);
        
            register_color_grading_section_functions(&mut world);
        
            register_visibility_range_functions(&mut world);
        
            register_screenshot_captured_functions(&mut world);
        
            register_screenshot_functions(&mut world);
        
    }
}
