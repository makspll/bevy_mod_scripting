// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use bevy_mod_scripting_core::{
    bindings::{
        ReflectReference, 
        function::{from::{Ref, Mut, Val}, namespace::{NamespaceBuilder}}
    }
};
use bevy_ecs::{prelude::*};


use bevy_mod_scripting_derive::script_bindings;


use crate::*;







pub struct BevyAssetScriptingPlugin;


#[script_bindings(
    remote,
    name = "asset_index_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_asset::AssetIndex {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_asset::AssetIndex>,) -> () {
        let output: () =<::bevy_asset::AssetIndex as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_asset::AssetIndex>,) -> Val<::bevy_asset::AssetIndex> {
        let output: Val<::bevy_asset::AssetIndex> =<::bevy_asset::AssetIndex as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_asset::AssetIndex>,other: Ref<::bevy_asset::AssetIndex>,) -> bool {
        let output: bool =<::bevy_asset::AssetIndex as ::core::cmp::PartialEq::<::bevy_asset::AssetIndex>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Convert an opaque `u64` acquired from [`AssetIndex::to_bits`] back into an [`AssetIndex`]. This should not be used with any inputs other than those
    
    ///  derived from [`AssetIndex::to_bits`], as there are no guarantees for what will happen with such inputs.
    
    fn from_bits (bits: u64,) -> Val<::bevy_asset::AssetIndex> {
        let output: Val<::bevy_asset::AssetIndex> =::bevy_asset::AssetIndex::from_bits(bits,).into();
        output
    }


    
    ///  Convert the [`AssetIndex`] into an opaque blob of bits to transport it in circumstances where carrying a strongly typed index isn't possible.
    
    ///  The result of this function should not be relied upon for anything except putting it back into [`AssetIndex::from_bits`] to recover the index.
    
    fn to_bits (_self: Val<::bevy_asset::AssetIndex>,) -> u64 {
        let output: u64 =::bevy_asset::AssetIndex::to_bits(_self.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "render_asset_usages_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_asset::RenderAssetUsages {


    
    ///  Get a flags value with all known bits set.
    
    fn all () -> Val<::bevy_asset::RenderAssetUsages> {
        let output: Val<::bevy_asset::RenderAssetUsages> =::bevy_asset::RenderAssetUsages::all().into();
        output
    }


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_asset::RenderAssetUsages>,) -> () {
        let output: () =<::bevy_asset::RenderAssetUsages as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    ///  Get the underlying bits value.
    
    ///  The returned value is exactly the bits set in this flags value.
    
    fn bits (_self: Ref<::bevy_asset::RenderAssetUsages>,) -> u8 {
        let output: u8 =::bevy_asset::RenderAssetUsages::bits(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_asset::RenderAssetUsages>,) -> Val<::bevy_asset::RenderAssetUsages> {
        let output: Val<::bevy_asset::RenderAssetUsages> =<::bevy_asset::RenderAssetUsages as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  The bitwise negation (`!`) of the bits in a flags value, truncating the result.
    
    fn complement (_self: Val<::bevy_asset::RenderAssetUsages>,) -> Val<::bevy_asset::RenderAssetUsages> {
        let output: Val<::bevy_asset::RenderAssetUsages> =::bevy_asset::RenderAssetUsages::complement(_self.into_inner(),).into();
        output
    }


    
    ///  Whether all set bits in a source flags value are also set in a target flags value.
    
    fn contains (_self: Ref<::bevy_asset::RenderAssetUsages>,other: Val<::bevy_asset::RenderAssetUsages>,) -> bool {
        let output: bool =::bevy_asset::RenderAssetUsages::contains(&_self,other.into_inner(),).into();
        output
    }


    
    ///  The intersection of a source flags value with the complement of a target flags
    
    ///  value (`&!`).
    
    ///  This method is not equivalent to `self & !other` when `other` has unknown bits set.
    
    ///  `difference` won't truncate `other`, but the `!` operator will.
    
    fn difference (_self: Val<::bevy_asset::RenderAssetUsages>,other: Val<::bevy_asset::RenderAssetUsages>,) -> Val<::bevy_asset::RenderAssetUsages> {
        let output: Val<::bevy_asset::RenderAssetUsages> =::bevy_asset::RenderAssetUsages::difference(_self.into_inner(),other.into_inner(),).into();
        output
    }


    
    ///  Get a flags value with all bits unset.
    
    fn empty () -> Val<::bevy_asset::RenderAssetUsages> {
        let output: Val<::bevy_asset::RenderAssetUsages> =::bevy_asset::RenderAssetUsages::empty().into();
        output
    }


    
    fn eq (_self: Ref<::bevy_asset::RenderAssetUsages>,other: Ref<::bevy_asset::RenderAssetUsages>,) -> bool {
        let output: bool =<::bevy_asset::RenderAssetUsages as ::core::cmp::PartialEq::<::bevy_asset::RenderAssetUsages>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Convert from a bits value exactly.
    
    fn from_bits_retain (bits: u8,) -> Val<::bevy_asset::RenderAssetUsages> {
        let output: Val<::bevy_asset::RenderAssetUsages> =::bevy_asset::RenderAssetUsages::from_bits_retain(bits,).into();
        output
    }


    
    ///  Convert from a bits value, unsetting any unknown bits.
    
    fn from_bits_truncate (bits: u8,) -> Val<::bevy_asset::RenderAssetUsages> {
        let output: Val<::bevy_asset::RenderAssetUsages> =::bevy_asset::RenderAssetUsages::from_bits_truncate(bits,).into();
        output
    }


    
    ///  The bitwise or (`|`) of the bits in two flags values.
    
    fn insert (mut _self: Mut<::bevy_asset::RenderAssetUsages>,other: Val<::bevy_asset::RenderAssetUsages>,) -> () {
        let output: () =::bevy_asset::RenderAssetUsages::insert(&mut _self,other.into_inner(),).into();
        output
    }


    
    ///  The bitwise and (`&`) of the bits in two flags values.
    
    fn intersection (_self: Val<::bevy_asset::RenderAssetUsages>,other: Val<::bevy_asset::RenderAssetUsages>,) -> Val<::bevy_asset::RenderAssetUsages> {
        let output: Val<::bevy_asset::RenderAssetUsages> =::bevy_asset::RenderAssetUsages::intersection(_self.into_inner(),other.into_inner(),).into();
        output
    }


    
    ///  Whether any set bits in a source flags value are also set in a target flags value.
    
    fn intersects (_self: Ref<::bevy_asset::RenderAssetUsages>,other: Val<::bevy_asset::RenderAssetUsages>,) -> bool {
        let output: bool =::bevy_asset::RenderAssetUsages::intersects(&_self,other.into_inner(),).into();
        output
    }


    
    ///  Whether all known bits in this flags value are set.
    
    fn is_all (_self: Ref<::bevy_asset::RenderAssetUsages>,) -> bool {
        let output: bool =::bevy_asset::RenderAssetUsages::is_all(&_self,).into();
        output
    }


    
    ///  Whether all bits in this flags value are unset.
    
    fn is_empty (_self: Ref<::bevy_asset::RenderAssetUsages>,) -> bool {
        let output: bool =::bevy_asset::RenderAssetUsages::is_empty(&_self,).into();
        output
    }


    
    ///  The intersection of a source flags value with the complement of a target flags
    
    ///  value (`&!`).
    
    ///  This method is not equivalent to `self & !other` when `other` has unknown bits set.
    
    ///  `remove` won't truncate `other`, but the `!` operator will.
    
    fn remove (mut _self: Mut<::bevy_asset::RenderAssetUsages>,other: Val<::bevy_asset::RenderAssetUsages>,) -> () {
        let output: () =::bevy_asset::RenderAssetUsages::remove(&mut _self,other.into_inner(),).into();
        output
    }


    
    ///  Call `insert` when `value` is `true` or `remove` when `value` is `false`.
    
    fn set (mut _self: Mut<::bevy_asset::RenderAssetUsages>,other: Val<::bevy_asset::RenderAssetUsages>,value: bool,) -> () {
        let output: () =::bevy_asset::RenderAssetUsages::set(&mut _self,other.into_inner(),value,).into();
        output
    }


    
    ///  The intersection of a source flags value with the complement of a target flags value (`&!`).
    
    ///  This method is not equivalent to `self & !other` when `other` has unknown bits set.
    
    ///  `difference` won't truncate `other`, but the `!` operator will.
    
    fn sub (_self: Val<::bevy_asset::RenderAssetUsages>,other: Val<::bevy_asset::RenderAssetUsages>,) -> Val<::bevy_asset::RenderAssetUsages> {
        let output: Val<::bevy_asset::RenderAssetUsages> =<::bevy_asset::RenderAssetUsages as ::core::ops::Sub::<::bevy_asset::RenderAssetUsages>>::sub(_self.into_inner(),other.into_inner(),).into();
        output
    }


    
    ///  The bitwise exclusive-or (`^`) of the bits in two flags values.
    
    fn symmetric_difference (_self: Val<::bevy_asset::RenderAssetUsages>,other: Val<::bevy_asset::RenderAssetUsages>,) -> Val<::bevy_asset::RenderAssetUsages> {
        let output: Val<::bevy_asset::RenderAssetUsages> =::bevy_asset::RenderAssetUsages::symmetric_difference(_self.into_inner(),other.into_inner(),).into();
        output
    }


    
    ///  The bitwise exclusive-or (`^`) of the bits in two flags values.
    
    fn toggle (mut _self: Mut<::bevy_asset::RenderAssetUsages>,other: Val<::bevy_asset::RenderAssetUsages>,) -> () {
        let output: () =::bevy_asset::RenderAssetUsages::toggle(&mut _self,other.into_inner(),).into();
        output
    }


    
    ///  The bitwise or (`|`) of the bits in two flags values.
    
    fn union (_self: Val<::bevy_asset::RenderAssetUsages>,other: Val<::bevy_asset::RenderAssetUsages>,) -> Val<::bevy_asset::RenderAssetUsages> {
        let output: Val<::bevy_asset::RenderAssetUsages> =::bevy_asset::RenderAssetUsages::union(_self.into_inner(),other.into_inner(),).into();
        output
    }
     
}


impl Plugin for BevyAssetScriptingPlugin {
    fn build(&self, app: &mut App) {
        let mut world = app.world_mut();

        
            register_asset_index_functions(&mut world);
        
            register_render_asset_usages_functions(&mut world);
        
    }
}
