// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use bevy_mod_scripting_core::{
    bindings::{
        ReflectReference, 
        function::{from::{Ref, Mut, Val}, namespace::{NamespaceBuilder}}
    }
};

use bevy_mod_scripting_derive::script_bindings;


use crate::*;







pub struct BevyColorScriptingPlugin;


#[script_bindings(
    remote,
    name = "color_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::color::prelude::Color {


    
    fn clone (_self:Ref<bevy::color::prelude::Color>,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =<bevy::color::prelude::Color as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::color::prelude::Color>,other:Ref<bevy::color::prelude::Color>,) -> bool {
        let output: bool =<bevy::color::prelude::Color as ::core::cmp::PartialEq::<bevy::color::prelude::Color>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Hsla`] color with an alpha of 1.0.
    
    ///  # Arguments
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    ///  * `saturation` - Saturation channel. [0.0, 1.0]
    
    ///  * `lightness` - Lightness channel. [0.0, 1.0]
    
    fn hsl (hue:f32,saturation:f32,lightness:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::hsl(hue,saturation,lightness,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Hsla`] color.
    
    ///  # Arguments
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    ///  * `saturation` - Saturation channel. [0.0, 1.0]
    
    ///  * `lightness` - Lightness channel. [0.0, 1.0]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn hsla (hue:f32,saturation:f32,lightness:f32,alpha:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::hsla(hue,saturation,lightness,alpha,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Hsva`] color with an alpha of 1.0.
    
    ///  # Arguments
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    ///  * `saturation` - Saturation channel. [0.0, 1.0]
    
    ///  * `value` - Value channel. [0.0, 1.0]
    
    fn hsv (hue:f32,saturation:f32,value:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::hsv(hue,saturation,value,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Hsva`] color.
    
    ///  # Arguments
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    ///  * `saturation` - Saturation channel. [0.0, 1.0]
    
    ///  * `value` - Value channel. [0.0, 1.0]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn hsva (hue:f32,saturation:f32,value:f32,alpha:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::hsva(hue,saturation,value,alpha,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Hwba`] color with an alpha of 1.0.
    
    ///  # Arguments
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    ///  * `whiteness` - Whiteness channel. [0.0, 1.0]
    
    ///  * `blackness` - Blackness channel. [0.0, 1.0]
    
    fn hwb (hue:f32,whiteness:f32,blackness:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::hwb(hue,whiteness,blackness,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Hwba`] color.
    
    ///  # Arguments
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    ///  * `whiteness` - Whiteness channel. [0.0, 1.0]
    
    ///  * `blackness` - Blackness channel. [0.0, 1.0]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn hwba (hue:f32,whiteness:f32,blackness:f32,alpha:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::hwba(hue,whiteness,blackness,alpha,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Laba`] color with an alpha of 1.0.
    
    ///  # Arguments
    
    ///  * `lightness` - Lightness channel. [0.0, 1.5]
    
    ///  * `a` - a axis. [-1.5, 1.5]
    
    ///  * `b` - b axis. [-1.5, 1.5]
    
    fn lab (lightness:f32,a:f32,b:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::lab(lightness,a,b,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Laba`] color.
    
    ///  # Arguments
    
    ///  * `lightness` - Lightness channel. [0.0, 1.5]
    
    ///  * `a` - a axis. [-1.5, 1.5]
    
    ///  * `b` - b axis. [-1.5, 1.5]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn laba (lightness:f32,a:f32,b:f32,alpha:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::laba(lightness,a,b,alpha,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Lcha`] color with an alpha of 1.0.
    
    ///  # Arguments
    
    ///  * `lightness` - Lightness channel. [0.0, 1.5]
    
    ///  * `chroma` - Chroma channel. [0.0, 1.5]
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    fn lch (lightness:f32,chroma:f32,hue:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::lch(lightness,chroma,hue,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Lcha`] color.
    
    ///  # Arguments
    
    ///  * `lightness` - Lightness channel. [0.0, 1.5]
    
    ///  * `chroma` - Chroma channel. [0.0, 1.5]
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn lcha (lightness:f32,chroma:f32,hue:f32,alpha:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::lcha(lightness,chroma,hue,alpha,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`LinearRgba`] color with an alpha of 1.0.
    
    ///  # Arguments
    
    ///  * `red` - Red channel. [0.0, 1.0]
    
    ///  * `green` - Green channel. [0.0, 1.0]
    
    ///  * `blue` - Blue channel. [0.0, 1.0]
    
    fn linear_rgb (red:f32,green:f32,blue:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::linear_rgb(red,green,blue,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`LinearRgba`] color.
    
    ///  # Arguments
    
    ///  * `red` - Red channel. [0.0, 1.0]
    
    ///  * `green` - Green channel. [0.0, 1.0]
    
    ///  * `blue` - Blue channel. [0.0, 1.0]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn linear_rgba (red:f32,green:f32,blue:f32,alpha:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::linear_rgba(red,green,blue,alpha,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Oklaba`] color with an alpha of 1.0.
    
    ///  # Arguments
    
    ///  * `lightness` - Lightness channel. [0.0, 1.0]
    
    ///  * `a` - Green-red channel. [-1.0, 1.0]
    
    ///  * `b` - Blue-yellow channel. [-1.0, 1.0]
    
    fn oklab (lightness:f32,a:f32,b:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::oklab(lightness,a,b,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Oklaba`] color.
    
    ///  # Arguments
    
    ///  * `lightness` - Lightness channel. [0.0, 1.0]
    
    ///  * `a` - Green-red channel. [-1.0, 1.0]
    
    ///  * `b` - Blue-yellow channel. [-1.0, 1.0]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn oklaba (lightness:f32,a:f32,b:f32,alpha:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::oklaba(lightness,a,b,alpha,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Oklcha`] color with an alpha of 1.0.
    
    ///  # Arguments
    
    ///  * `lightness` - Lightness channel. [0.0, 1.0]
    
    ///  * `chroma` - Chroma channel. [0.0, 1.0]
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    fn oklch (lightness:f32,chroma:f32,hue:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::oklch(lightness,chroma,hue,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Oklcha`] color.
    
    ///  # Arguments
    
    ///  * `lightness` - Lightness channel. [0.0, 1.0]
    
    ///  * `chroma` - Chroma channel. [0.0, 1.0]
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn oklcha (lightness:f32,chroma:f32,hue:f32,alpha:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::oklcha(lightness,chroma,hue,alpha,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Srgba`] color with an alpha of 1.0.
    
    ///  # Arguments
    
    ///  * `red` - Red channel. [0.0, 1.0]
    
    ///  * `green` - Green channel. [0.0, 1.0]
    
    ///  * `blue` - Blue channel. [0.0, 1.0]
    
    fn srgb (red:f32,green:f32,blue:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::srgb(red,green,blue,).into();
        output
    }


    
    ///  Reads an array of floats to creates a new [`Color`] object storing a [`Srgba`] color with an alpha of 1.0.
    
    ///  # Arguments
    
    ///  * `array` - Red, Green and Blue channels. Each channel is in the range [0.0, 1.0]
    
    fn srgb_from_array (array:[f32;3],) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::srgb_from_array(array,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Srgba`] color from [`u8`] values with an alpha of 1.0.
    
    ///  # Arguments
    
    ///  * `red` - Red channel. [0, 255]
    
    ///  * `green` - Green channel. [0, 255]
    
    ///  * `blue` - Blue channel. [0, 255]
    
    fn srgb_u8 (red:u8,green:u8,blue:u8,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::srgb_u8(red,green,blue,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Srgba`] color.
    
    ///  # Arguments
    
    ///  * `red` - Red channel. [0.0, 1.0]
    
    ///  * `green` - Green channel. [0.0, 1.0]
    
    ///  * `blue` - Blue channel. [0.0, 1.0]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn srgba (red:f32,green:f32,blue:f32,alpha:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::srgba(red,green,blue,alpha,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Srgba`] color from [`u8`] values.
    
    ///  # Arguments
    
    ///  * `red` - Red channel. [0, 255]
    
    ///  * `green` - Green channel. [0, 255]
    
    ///  * `blue` - Blue channel. [0, 255]
    
    ///  * `alpha` - Alpha channel. [0, 255]
    
    fn srgba_u8 (red:u8,green:u8,blue:u8,alpha:u8,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::srgba_u8(red,green,blue,alpha,).into();
        output
    }


    
    ///  Return the color as a linear RGBA color.
    
    fn to_linear (_self:Ref<bevy::color::prelude::Color>,) -> Val<bevy::color::prelude::LinearRgba> {
        let output: Val<bevy::color::prelude::LinearRgba> =bevy::color::prelude::Color::to_linear(&_self,).into();
        output
    }


    
    ///  Return the color as an SRGBA color.
    
    fn to_srgba (_self:Ref<bevy::color::prelude::Color>,) -> Val<bevy::color::prelude::Srgba> {
        let output: Val<bevy::color::prelude::Srgba> =bevy::color::prelude::Color::to_srgba(&_self,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Xyza`] color with an alpha of 1.0.
    
    ///  # Arguments
    
    ///  * `x` - x-axis. [0.0, 1.0]
    
    ///  * `y` - y-axis. [0.0, 1.0]
    
    ///  * `z` - z-axis. [0.0, 1.0]
    
    fn xyz (x:f32,y:f32,z:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::xyz(x,y,z,).into();
        output
    }


    
    ///  Creates a new [`Color`] object storing a [`Xyza`] color.
    
    ///  # Arguments
    
    ///  * `x` - x-axis. [0.0, 1.0]
    
    ///  * `y` - y-axis. [0.0, 1.0]
    
    ///  * `z` - z-axis. [0.0, 1.0]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn xyza (x:f32,y:f32,z:f32,alpha:f32,) -> Val<bevy::color::prelude::Color> {
        let output: Val<bevy::color::prelude::Color> =bevy::color::prelude::Color::xyza(x,y,z,alpha,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "srgba_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::color::prelude::Srgba {


    
    fn add (_self:Val<bevy::color::prelude::Srgba>,rhs:Val<bevy::color::prelude::Srgba>,) -> Val<bevy::color::prelude::Srgba> {
        let output: Val<bevy::color::prelude::Srgba> =<bevy::color::prelude::Srgba as ::core::ops::Add::<bevy::color::prelude::Srgba>>::add(_self.into_inner(),rhs.into_inner(),).into();
        output
    }


    
    fn clone (_self:Ref<bevy::color::prelude::Srgba>,) -> Val<bevy::color::prelude::Srgba> {
        let output: Val<bevy::color::prelude::Srgba> =<bevy::color::prelude::Srgba as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn div (_self:Val<bevy::color::prelude::Srgba>,rhs:f32,) -> Val<bevy::color::prelude::Srgba> {
        let output: Val<bevy::color::prelude::Srgba> =<bevy::color::prelude::Srgba as ::core::ops::Div::<f32>>::div(_self.into_inner(),rhs,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::color::prelude::Srgba>,other:Ref<bevy::color::prelude::Srgba>,) -> bool {
        let output: bool =<bevy::color::prelude::Srgba as ::core::cmp::PartialEq::<bevy::color::prelude::Srgba>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Converts a non-linear sRGB value to a linear one via [gamma correction](https://en.wikipedia.org/wiki/Gamma_correction).
    
    fn gamma_function (value:f32,) -> f32 {
        let output: f32 =bevy::color::prelude::Srgba::gamma_function(value,).into();
        output
    }


    
    ///  Converts a linear sRGB value to a non-linear one via [gamma correction](https://en.wikipedia.org/wiki/Gamma_correction).
    
    fn gamma_function_inverse (value:f32,) -> f32 {
        let output: f32 =bevy::color::prelude::Srgba::gamma_function_inverse(value,).into();
        output
    }


    
    fn mul (_self:Val<bevy::color::prelude::Srgba>,rhs:f32,) -> Val<bevy::color::prelude::Srgba> {
        let output: Val<bevy::color::prelude::Srgba> =<bevy::color::prelude::Srgba as ::core::ops::Mul::<f32>>::mul(_self.into_inner(),rhs,).into();
        output
    }


    
    fn neg (_self:Val<bevy::color::prelude::Srgba>,) -> Val<bevy::color::prelude::Srgba> {
        let output: Val<bevy::color::prelude::Srgba> =<bevy::color::prelude::Srgba as ::core::ops::Neg>::neg(_self.into_inner(),).into();
        output
    }


    
    ///  Construct a new [`Srgba`] color from components.
    
    ///  # Arguments
    
    ///  * `red` - Red channel. [0.0, 1.0]
    
    ///  * `green` - Green channel. [0.0, 1.0]
    
    ///  * `blue` - Blue channel. [0.0, 1.0]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn new (red:f32,green:f32,blue:f32,alpha:f32,) -> Val<bevy::color::prelude::Srgba> {
        let output: Val<bevy::color::prelude::Srgba> =bevy::color::prelude::Srgba::new(red,green,blue,alpha,).into();
        output
    }


    
    ///  Construct a new [`Srgba`] color from (r, g, b) components, with the default alpha (1.0).
    
    ///  # Arguments
    
    ///  * `red` - Red channel. [0.0, 1.0]
    
    ///  * `green` - Green channel. [0.0, 1.0]
    
    ///  * `blue` - Blue channel. [0.0, 1.0]
    
    fn rgb (red:f32,green:f32,blue:f32,) -> Val<bevy::color::prelude::Srgba> {
        let output: Val<bevy::color::prelude::Srgba> =bevy::color::prelude::Srgba::rgb(red,green,blue,).into();
        output
    }


    
    ///  New `Srgba` from sRGB colorspace.
    
    ///  # Arguments
    
    ///  * `r` - Red channel. [0, 255]
    
    ///  * `g` - Green channel. [0, 255]
    
    ///  * `b` - Blue channel. [0, 255]
    
    ///  See also [`Srgba::new`], [`Srgba::rgba_u8`], [`Srgba::hex`].
    
    fn rgb_u8 (r:u8,g:u8,b:u8,) -> Val<bevy::color::prelude::Srgba> {
        let output: Val<bevy::color::prelude::Srgba> =bevy::color::prelude::Srgba::rgb_u8(r,g,b,).into();
        output
    }


    
    ///  New `Srgba` from sRGB colorspace.
    
    ///  # Arguments
    
    ///  * `r` - Red channel. [0, 255]
    
    ///  * `g` - Green channel. [0, 255]
    
    ///  * `b` - Blue channel. [0, 255]
    
    ///  * `a` - Alpha channel. [0, 255]
    
    ///  See also [`Srgba::new`], [`Srgba::rgb_u8`], [`Srgba::hex`].
    
    fn rgba_u8 (r:u8,g:u8,b:u8,a:u8,) -> Val<bevy::color::prelude::Srgba> {
        let output: Val<bevy::color::prelude::Srgba> =bevy::color::prelude::Srgba::rgba_u8(r,g,b,a,).into();
        output
    }


    
    fn sub (_self:Val<bevy::color::prelude::Srgba>,rhs:Val<bevy::color::prelude::Srgba>,) -> Val<bevy::color::prelude::Srgba> {
        let output: Val<bevy::color::prelude::Srgba> =<bevy::color::prelude::Srgba as ::core::ops::Sub::<bevy::color::prelude::Srgba>>::sub(_self.into_inner(),rhs.into_inner(),).into();
        output
    }


    
    ///  Convert this color to CSS-style hexadecimal notation.
    
    fn to_hex (_self:Ref<bevy::color::prelude::Srgba>,) -> ::std::string::String {
        let output: ::std::string::String =bevy::color::prelude::Srgba::to_hex(&_self,).into();
        output
    }


    
    ///  Return a copy of this color with the blue channel set to the given value.
    
    fn with_blue (_self:Val<bevy::color::prelude::Srgba>,blue:f32,) -> Val<bevy::color::prelude::Srgba> {
        let output: Val<bevy::color::prelude::Srgba> =bevy::color::prelude::Srgba::with_blue(_self.into_inner(),blue,).into();
        output
    }


    
    ///  Return a copy of this color with the green channel set to the given value.
    
    fn with_green (_self:Val<bevy::color::prelude::Srgba>,green:f32,) -> Val<bevy::color::prelude::Srgba> {
        let output: Val<bevy::color::prelude::Srgba> =bevy::color::prelude::Srgba::with_green(_self.into_inner(),green,).into();
        output
    }


    
    ///  Return a copy of this color with the red channel set to the given value.
    
    fn with_red (_self:Val<bevy::color::prelude::Srgba>,red:f32,) -> Val<bevy::color::prelude::Srgba> {
        let output: Val<bevy::color::prelude::Srgba> =bevy::color::prelude::Srgba::with_red(_self.into_inner(),red,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "linear_rgba_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::color::prelude::LinearRgba {


    
    fn add (_self:Val<bevy::color::prelude::LinearRgba>,rhs:Val<bevy::color::prelude::LinearRgba>,) -> Val<bevy::color::prelude::LinearRgba> {
        let output: Val<bevy::color::prelude::LinearRgba> =<bevy::color::prelude::LinearRgba as ::core::ops::Add::<bevy::color::prelude::LinearRgba>>::add(_self.into_inner(),rhs.into_inner(),).into();
        output
    }


    
    ///  Converts this color to a u32.
    
    ///  Maps the RGBA channels in RGBA order to a little-endian byte array (GPUs are little-endian).
    
    ///  `A` will be the most significant byte and `R` the least significant.
    
    fn as_u32 (_self:Ref<bevy::color::prelude::LinearRgba>,) -> u32 {
        let output: u32 =bevy::color::prelude::LinearRgba::as_u32(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::color::prelude::LinearRgba>,) -> Val<bevy::color::prelude::LinearRgba> {
        let output: Val<bevy::color::prelude::LinearRgba> =<bevy::color::prelude::LinearRgba as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn div (_self:Val<bevy::color::prelude::LinearRgba>,rhs:f32,) -> Val<bevy::color::prelude::LinearRgba> {
        let output: Val<bevy::color::prelude::LinearRgba> =<bevy::color::prelude::LinearRgba as ::core::ops::Div::<f32>>::div(_self.into_inner(),rhs,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::color::prelude::LinearRgba>,other:Ref<bevy::color::prelude::LinearRgba>,) -> bool {
        let output: bool =<bevy::color::prelude::LinearRgba as ::core::cmp::PartialEq::<bevy::color::prelude::LinearRgba>>::eq(&_self,&other,).into();
        output
    }


    
    fn mul (_self:Val<bevy::color::prelude::LinearRgba>,rhs:f32,) -> Val<bevy::color::prelude::LinearRgba> {
        let output: Val<bevy::color::prelude::LinearRgba> =<bevy::color::prelude::LinearRgba as ::core::ops::Mul::<f32>>::mul(_self.into_inner(),rhs,).into();
        output
    }


    
    fn neg (_self:Val<bevy::color::prelude::LinearRgba>,) -> Val<bevy::color::prelude::LinearRgba> {
        let output: Val<bevy::color::prelude::LinearRgba> =<bevy::color::prelude::LinearRgba as ::core::ops::Neg>::neg(_self.into_inner(),).into();
        output
    }


    
    ///  Construct a new [`LinearRgba`] color from components.
    
    fn new (red:f32,green:f32,blue:f32,alpha:f32,) -> Val<bevy::color::prelude::LinearRgba> {
        let output: Val<bevy::color::prelude::LinearRgba> =bevy::color::prelude::LinearRgba::new(red,green,blue,alpha,).into();
        output
    }


    
    ///  Construct a new [`LinearRgba`] color from (r, g, b) components, with the default alpha (1.0).
    
    ///  # Arguments
    
    ///  * `red` - Red channel. [0.0, 1.0]
    
    ///  * `green` - Green channel. [0.0, 1.0]
    
    ///  * `blue` - Blue channel. [0.0, 1.0]
    
    fn rgb (red:f32,green:f32,blue:f32,) -> Val<bevy::color::prelude::LinearRgba> {
        let output: Val<bevy::color::prelude::LinearRgba> =bevy::color::prelude::LinearRgba::rgb(red,green,blue,).into();
        output
    }


    
    fn sub (_self:Val<bevy::color::prelude::LinearRgba>,rhs:Val<bevy::color::prelude::LinearRgba>,) -> Val<bevy::color::prelude::LinearRgba> {
        let output: Val<bevy::color::prelude::LinearRgba> =<bevy::color::prelude::LinearRgba as ::core::ops::Sub::<bevy::color::prelude::LinearRgba>>::sub(_self.into_inner(),rhs.into_inner(),).into();
        output
    }


    
    ///  Return a copy of this color with the blue channel set to the given value.
    
    fn with_blue (_self:Val<bevy::color::prelude::LinearRgba>,blue:f32,) -> Val<bevy::color::prelude::LinearRgba> {
        let output: Val<bevy::color::prelude::LinearRgba> =bevy::color::prelude::LinearRgba::with_blue(_self.into_inner(),blue,).into();
        output
    }


    
    ///  Return a copy of this color with the green channel set to the given value.
    
    fn with_green (_self:Val<bevy::color::prelude::LinearRgba>,green:f32,) -> Val<bevy::color::prelude::LinearRgba> {
        let output: Val<bevy::color::prelude::LinearRgba> =bevy::color::prelude::LinearRgba::with_green(_self.into_inner(),green,).into();
        output
    }


    
    ///  Return a copy of this color with the red channel set to the given value.
    
    fn with_red (_self:Val<bevy::color::prelude::LinearRgba>,red:f32,) -> Val<bevy::color::prelude::LinearRgba> {
        let output: Val<bevy::color::prelude::LinearRgba> =bevy::color::prelude::LinearRgba::with_red(_self.into_inner(),red,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "hsla_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::color::prelude::Hsla {


    
    fn clone (_self:Ref<bevy::color::prelude::Hsla>,) -> Val<bevy::color::prelude::Hsla> {
        let output: Val<bevy::color::prelude::Hsla> =<bevy::color::prelude::Hsla as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::color::prelude::Hsla>,other:Ref<bevy::color::prelude::Hsla>,) -> bool {
        let output: bool =<bevy::color::prelude::Hsla as ::core::cmp::PartialEq::<bevy::color::prelude::Hsla>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Construct a new [`Hsla`] color from (h, s, l) components, with the default alpha (1.0).
    
    ///  # Arguments
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    ///  * `saturation` - Saturation channel. [0.0, 1.0]
    
    ///  * `lightness` - Lightness channel. [0.0, 1.0]
    
    fn hsl (hue:f32,saturation:f32,lightness:f32,) -> Val<bevy::color::prelude::Hsla> {
        let output: Val<bevy::color::prelude::Hsla> =bevy::color::prelude::Hsla::hsl(hue,saturation,lightness,).into();
        output
    }


    
    ///  Construct a new [`Hsla`] color from components.
    
    ///  # Arguments
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    ///  * `saturation` - Saturation channel. [0.0, 1.0]
    
    ///  * `lightness` - Lightness channel. [0.0, 1.0]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn new (hue:f32,saturation:f32,lightness:f32,alpha:f32,) -> Val<bevy::color::prelude::Hsla> {
        let output: Val<bevy::color::prelude::Hsla> =bevy::color::prelude::Hsla::new(hue,saturation,lightness,alpha,).into();
        output
    }


    
    ///  Generate a deterministic but [quasi-randomly distributed](https://en.wikipedia.org/wiki/Low-discrepancy_sequence)
    
    ///  color from a provided `index`.
    
    ///  This can be helpful for generating debug colors.
    
    ///  # Examples
    
    ///  ```rust
    
    ///  # use bevy_color::Hsla;
    
    ///  // Unique color for an entity
    
    ///  # let entity_index = 123;
    
    ///  // let entity_index = entity.index();
    
    ///  let color = Hsla::sequential_dispersed(entity_index);
    
    ///  // Palette with 5 distinct hues
    
    ///  let palette = (0..5).map(Hsla::sequential_dispersed).collect::<Vec<_>>();
    
    ///  ```
    
    fn sequential_dispersed (index:u32,) -> Val<bevy::color::prelude::Hsla> {
        let output: Val<bevy::color::prelude::Hsla> =bevy::color::prelude::Hsla::sequential_dispersed(index,).into();
        output
    }


    
    ///  Return a copy of this color with the lightness channel set to the given value.
    
    fn with_lightness (_self:Val<bevy::color::prelude::Hsla>,lightness:f32,) -> Val<bevy::color::prelude::Hsla> {
        let output: Val<bevy::color::prelude::Hsla> =bevy::color::prelude::Hsla::with_lightness(_self.into_inner(),lightness,).into();
        output
    }


    
    ///  Return a copy of this color with the saturation channel set to the given value.
    
    fn with_saturation (_self:Val<bevy::color::prelude::Hsla>,saturation:f32,) -> Val<bevy::color::prelude::Hsla> {
        let output: Val<bevy::color::prelude::Hsla> =bevy::color::prelude::Hsla::with_saturation(_self.into_inner(),saturation,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "hsva_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::color::prelude::Hsva {


    
    fn clone (_self:Ref<bevy::color::prelude::Hsva>,) -> Val<bevy::color::prelude::Hsva> {
        let output: Val<bevy::color::prelude::Hsva> =<bevy::color::prelude::Hsva as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::color::prelude::Hsva>,other:Ref<bevy::color::prelude::Hsva>,) -> bool {
        let output: bool =<bevy::color::prelude::Hsva as ::core::cmp::PartialEq::<bevy::color::prelude::Hsva>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Construct a new [`Hsva`] color from (h, s, v) components, with the default alpha (1.0).
    
    ///  # Arguments
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    ///  * `saturation` - Saturation channel. [0.0, 1.0]
    
    ///  * `value` - Value channel. [0.0, 1.0]
    
    fn hsv (hue:f32,saturation:f32,value:f32,) -> Val<bevy::color::prelude::Hsva> {
        let output: Val<bevy::color::prelude::Hsva> =bevy::color::prelude::Hsva::hsv(hue,saturation,value,).into();
        output
    }


    
    ///  Construct a new [`Hsva`] color from components.
    
    ///  # Arguments
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    ///  * `saturation` - Saturation channel. [0.0, 1.0]
    
    ///  * `value` - Value channel. [0.0, 1.0]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn new (hue:f32,saturation:f32,value:f32,alpha:f32,) -> Val<bevy::color::prelude::Hsva> {
        let output: Val<bevy::color::prelude::Hsva> =bevy::color::prelude::Hsva::new(hue,saturation,value,alpha,).into();
        output
    }


    
    ///  Return a copy of this color with the saturation channel set to the given value.
    
    fn with_saturation (_self:Val<bevy::color::prelude::Hsva>,saturation:f32,) -> Val<bevy::color::prelude::Hsva> {
        let output: Val<bevy::color::prelude::Hsva> =bevy::color::prelude::Hsva::with_saturation(_self.into_inner(),saturation,).into();
        output
    }


    
    ///  Return a copy of this color with the value channel set to the given value.
    
    fn with_value (_self:Val<bevy::color::prelude::Hsva>,value:f32,) -> Val<bevy::color::prelude::Hsva> {
        let output: Val<bevy::color::prelude::Hsva> =bevy::color::prelude::Hsva::with_value(_self.into_inner(),value,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "hwba_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::color::prelude::Hwba {


    
    fn clone (_self:Ref<bevy::color::prelude::Hwba>,) -> Val<bevy::color::prelude::Hwba> {
        let output: Val<bevy::color::prelude::Hwba> =<bevy::color::prelude::Hwba as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::color::prelude::Hwba>,other:Ref<bevy::color::prelude::Hwba>,) -> bool {
        let output: bool =<bevy::color::prelude::Hwba as ::core::cmp::PartialEq::<bevy::color::prelude::Hwba>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Construct a new [`Hwba`] color from (h, s, l) components, with the default alpha (1.0).
    
    ///  # Arguments
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    ///  * `whiteness` - Whiteness channel. [0.0, 1.0]
    
    ///  * `blackness` - Blackness channel. [0.0, 1.0]
    
    fn hwb (hue:f32,whiteness:f32,blackness:f32,) -> Val<bevy::color::prelude::Hwba> {
        let output: Val<bevy::color::prelude::Hwba> =bevy::color::prelude::Hwba::hwb(hue,whiteness,blackness,).into();
        output
    }


    
    ///  Construct a new [`Hwba`] color from components.
    
    ///  # Arguments
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    ///  * `whiteness` - Whiteness channel. [0.0, 1.0]
    
    ///  * `blackness` - Blackness channel. [0.0, 1.0]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn new (hue:f32,whiteness:f32,blackness:f32,alpha:f32,) -> Val<bevy::color::prelude::Hwba> {
        let output: Val<bevy::color::prelude::Hwba> =bevy::color::prelude::Hwba::new(hue,whiteness,blackness,alpha,).into();
        output
    }


    
    ///  Return a copy of this color with the blackness channel set to the given value.
    
    fn with_blackness (_self:Val<bevy::color::prelude::Hwba>,blackness:f32,) -> Val<bevy::color::prelude::Hwba> {
        let output: Val<bevy::color::prelude::Hwba> =bevy::color::prelude::Hwba::with_blackness(_self.into_inner(),blackness,).into();
        output
    }


    
    ///  Return a copy of this color with the whiteness channel set to the given value.
    
    fn with_whiteness (_self:Val<bevy::color::prelude::Hwba>,whiteness:f32,) -> Val<bevy::color::prelude::Hwba> {
        let output: Val<bevy::color::prelude::Hwba> =bevy::color::prelude::Hwba::with_whiteness(_self.into_inner(),whiteness,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "laba_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::color::prelude::Laba {


    
    fn add (_self:Val<bevy::color::prelude::Laba>,rhs:Val<bevy::color::prelude::Laba>,) -> Val<bevy::color::prelude::Laba> {
        let output: Val<bevy::color::prelude::Laba> =<bevy::color::prelude::Laba as ::core::ops::Add::<bevy::color::prelude::Laba>>::add(_self.into_inner(),rhs.into_inner(),).into();
        output
    }


    
    fn clone (_self:Ref<bevy::color::prelude::Laba>,) -> Val<bevy::color::prelude::Laba> {
        let output: Val<bevy::color::prelude::Laba> =<bevy::color::prelude::Laba as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn div (_self:Val<bevy::color::prelude::Laba>,rhs:f32,) -> Val<bevy::color::prelude::Laba> {
        let output: Val<bevy::color::prelude::Laba> =<bevy::color::prelude::Laba as ::core::ops::Div::<f32>>::div(_self.into_inner(),rhs,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::color::prelude::Laba>,other:Ref<bevy::color::prelude::Laba>,) -> bool {
        let output: bool =<bevy::color::prelude::Laba as ::core::cmp::PartialEq::<bevy::color::prelude::Laba>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Construct a new [`Laba`] color from (l, a, b) components, with the default alpha (1.0).
    
    ///  # Arguments
    
    ///  * `lightness` - Lightness channel. [0.0, 1.5]
    
    ///  * `a` - a axis. [-1.5, 1.5]
    
    ///  * `b` - b axis. [-1.5, 1.5]
    
    fn lab (lightness:f32,a:f32,b:f32,) -> Val<bevy::color::prelude::Laba> {
        let output: Val<bevy::color::prelude::Laba> =bevy::color::prelude::Laba::lab(lightness,a,b,).into();
        output
    }


    
    fn mul (_self:Val<bevy::color::prelude::Laba>,rhs:f32,) -> Val<bevy::color::prelude::Laba> {
        let output: Val<bevy::color::prelude::Laba> =<bevy::color::prelude::Laba as ::core::ops::Mul::<f32>>::mul(_self.into_inner(),rhs,).into();
        output
    }


    
    fn neg (_self:Val<bevy::color::prelude::Laba>,) -> Val<bevy::color::prelude::Laba> {
        let output: Val<bevy::color::prelude::Laba> =<bevy::color::prelude::Laba as ::core::ops::Neg>::neg(_self.into_inner(),).into();
        output
    }


    
    ///  Construct a new [`Laba`] color from components.
    
    ///  # Arguments
    
    ///  * `lightness` - Lightness channel. [0.0, 1.5]
    
    ///  * `a` - a axis. [-1.5, 1.5]
    
    ///  * `b` - b axis. [-1.5, 1.5]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn new (lightness:f32,a:f32,b:f32,alpha:f32,) -> Val<bevy::color::prelude::Laba> {
        let output: Val<bevy::color::prelude::Laba> =bevy::color::prelude::Laba::new(lightness,a,b,alpha,).into();
        output
    }


    
    fn sub (_self:Val<bevy::color::prelude::Laba>,rhs:Val<bevy::color::prelude::Laba>,) -> Val<bevy::color::prelude::Laba> {
        let output: Val<bevy::color::prelude::Laba> =<bevy::color::prelude::Laba as ::core::ops::Sub::<bevy::color::prelude::Laba>>::sub(_self.into_inner(),rhs.into_inner(),).into();
        output
    }


    
    ///  Return a copy of this color with the lightness channel set to the given value.
    
    fn with_lightness (_self:Val<bevy::color::prelude::Laba>,lightness:f32,) -> Val<bevy::color::prelude::Laba> {
        let output: Val<bevy::color::prelude::Laba> =bevy::color::prelude::Laba::with_lightness(_self.into_inner(),lightness,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "lcha_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::color::prelude::Lcha {


    
    fn clone (_self:Ref<bevy::color::prelude::Lcha>,) -> Val<bevy::color::prelude::Lcha> {
        let output: Val<bevy::color::prelude::Lcha> =<bevy::color::prelude::Lcha as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::color::prelude::Lcha>,other:Ref<bevy::color::prelude::Lcha>,) -> bool {
        let output: bool =<bevy::color::prelude::Lcha as ::core::cmp::PartialEq::<bevy::color::prelude::Lcha>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Construct a new [`Lcha`] color from (h, s, l) components, with the default alpha (1.0).
    
    ///  # Arguments
    
    ///  * `lightness` - Lightness channel. [0.0, 1.5]
    
    ///  * `chroma` - Chroma channel. [0.0, 1.5]
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    fn lch (lightness:f32,chroma:f32,hue:f32,) -> Val<bevy::color::prelude::Lcha> {
        let output: Val<bevy::color::prelude::Lcha> =bevy::color::prelude::Lcha::lch(lightness,chroma,hue,).into();
        output
    }


    
    ///  Construct a new [`Lcha`] color from components.
    
    ///  # Arguments
    
    ///  * `lightness` - Lightness channel. [0.0, 1.5]
    
    ///  * `chroma` - Chroma channel. [0.0, 1.5]
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn new (lightness:f32,chroma:f32,hue:f32,alpha:f32,) -> Val<bevy::color::prelude::Lcha> {
        let output: Val<bevy::color::prelude::Lcha> =bevy::color::prelude::Lcha::new(lightness,chroma,hue,alpha,).into();
        output
    }


    
    ///  Generate a deterministic but [quasi-randomly distributed](https://en.wikipedia.org/wiki/Low-discrepancy_sequence)
    
    ///  color from a provided `index`.
    
    ///  This can be helpful for generating debug colors.
    
    ///  # Examples
    
    ///  ```rust
    
    ///  # use bevy_color::Lcha;
    
    ///  // Unique color for an entity
    
    ///  # let entity_index = 123;
    
    ///  // let entity_index = entity.index();
    
    ///  let color = Lcha::sequential_dispersed(entity_index);
    
    ///  // Palette with 5 distinct hues
    
    ///  let palette = (0..5).map(Lcha::sequential_dispersed).collect::<Vec<_>>();
    
    ///  ```
    
    fn sequential_dispersed (index:u32,) -> Val<bevy::color::prelude::Lcha> {
        let output: Val<bevy::color::prelude::Lcha> =bevy::color::prelude::Lcha::sequential_dispersed(index,).into();
        output
    }


    
    ///  Return a copy of this color with the chroma channel set to the given value.
    
    fn with_chroma (_self:Val<bevy::color::prelude::Lcha>,chroma:f32,) -> Val<bevy::color::prelude::Lcha> {
        let output: Val<bevy::color::prelude::Lcha> =bevy::color::prelude::Lcha::with_chroma(_self.into_inner(),chroma,).into();
        output
    }


    
    ///  Return a copy of this color with the lightness channel set to the given value.
    
    fn with_lightness (_self:Val<bevy::color::prelude::Lcha>,lightness:f32,) -> Val<bevy::color::prelude::Lcha> {
        let output: Val<bevy::color::prelude::Lcha> =bevy::color::prelude::Lcha::with_lightness(_self.into_inner(),lightness,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "oklaba_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::color::prelude::Oklaba {


    
    fn add (_self:Val<bevy::color::prelude::Oklaba>,rhs:Val<bevy::color::prelude::Oklaba>,) -> Val<bevy::color::prelude::Oklaba> {
        let output: Val<bevy::color::prelude::Oklaba> =<bevy::color::prelude::Oklaba as ::core::ops::Add::<bevy::color::prelude::Oklaba>>::add(_self.into_inner(),rhs.into_inner(),).into();
        output
    }


    
    fn clone (_self:Ref<bevy::color::prelude::Oklaba>,) -> Val<bevy::color::prelude::Oklaba> {
        let output: Val<bevy::color::prelude::Oklaba> =<bevy::color::prelude::Oklaba as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn div (_self:Val<bevy::color::prelude::Oklaba>,rhs:f32,) -> Val<bevy::color::prelude::Oklaba> {
        let output: Val<bevy::color::prelude::Oklaba> =<bevy::color::prelude::Oklaba as ::core::ops::Div::<f32>>::div(_self.into_inner(),rhs,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::color::prelude::Oklaba>,other:Ref<bevy::color::prelude::Oklaba>,) -> bool {
        let output: bool =<bevy::color::prelude::Oklaba as ::core::cmp::PartialEq::<bevy::color::prelude::Oklaba>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Construct a new [`Oklaba`] color from (l, a, b) components, with the default alpha (1.0).
    
    ///  # Arguments
    
    ///  * `lightness` - Lightness channel. [0.0, 1.0]
    
    ///  * `a` - Green-red channel. [-1.0, 1.0]
    
    ///  * `b` - Blue-yellow channel. [-1.0, 1.0]
    
    fn lab (lightness:f32,a:f32,b:f32,) -> Val<bevy::color::prelude::Oklaba> {
        let output: Val<bevy::color::prelude::Oklaba> =bevy::color::prelude::Oklaba::lab(lightness,a,b,).into();
        output
    }


    
    fn mul (_self:Val<bevy::color::prelude::Oklaba>,rhs:f32,) -> Val<bevy::color::prelude::Oklaba> {
        let output: Val<bevy::color::prelude::Oklaba> =<bevy::color::prelude::Oklaba as ::core::ops::Mul::<f32>>::mul(_self.into_inner(),rhs,).into();
        output
    }


    
    fn neg (_self:Val<bevy::color::prelude::Oklaba>,) -> Val<bevy::color::prelude::Oklaba> {
        let output: Val<bevy::color::prelude::Oklaba> =<bevy::color::prelude::Oklaba as ::core::ops::Neg>::neg(_self.into_inner(),).into();
        output
    }


    
    ///  Construct a new [`Oklaba`] color from components.
    
    ///  # Arguments
    
    ///  * `lightness` - Lightness channel. [0.0, 1.0]
    
    ///  * `a` - Green-red channel. [-1.0, 1.0]
    
    ///  * `b` - Blue-yellow channel. [-1.0, 1.0]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn new (lightness:f32,a:f32,b:f32,alpha:f32,) -> Val<bevy::color::prelude::Oklaba> {
        let output: Val<bevy::color::prelude::Oklaba> =bevy::color::prelude::Oklaba::new(lightness,a,b,alpha,).into();
        output
    }


    
    fn sub (_self:Val<bevy::color::prelude::Oklaba>,rhs:Val<bevy::color::prelude::Oklaba>,) -> Val<bevy::color::prelude::Oklaba> {
        let output: Val<bevy::color::prelude::Oklaba> =<bevy::color::prelude::Oklaba as ::core::ops::Sub::<bevy::color::prelude::Oklaba>>::sub(_self.into_inner(),rhs.into_inner(),).into();
        output
    }


    
    ///  Return a copy of this color with the 'a' channel set to the given value.
    
    fn with_a (_self:Val<bevy::color::prelude::Oklaba>,a:f32,) -> Val<bevy::color::prelude::Oklaba> {
        let output: Val<bevy::color::prelude::Oklaba> =bevy::color::prelude::Oklaba::with_a(_self.into_inner(),a,).into();
        output
    }


    
    ///  Return a copy of this color with the 'b' channel set to the given value.
    
    fn with_b (_self:Val<bevy::color::prelude::Oklaba>,b:f32,) -> Val<bevy::color::prelude::Oklaba> {
        let output: Val<bevy::color::prelude::Oklaba> =bevy::color::prelude::Oklaba::with_b(_self.into_inner(),b,).into();
        output
    }


    
    ///  Return a copy of this color with the 'lightness' channel set to the given value.
    
    fn with_lightness (_self:Val<bevy::color::prelude::Oklaba>,lightness:f32,) -> Val<bevy::color::prelude::Oklaba> {
        let output: Val<bevy::color::prelude::Oklaba> =bevy::color::prelude::Oklaba::with_lightness(_self.into_inner(),lightness,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "oklcha_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::color::prelude::Oklcha {


    
    fn clone (_self:Ref<bevy::color::prelude::Oklcha>,) -> Val<bevy::color::prelude::Oklcha> {
        let output: Val<bevy::color::prelude::Oklcha> =<bevy::color::prelude::Oklcha as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::color::prelude::Oklcha>,other:Ref<bevy::color::prelude::Oklcha>,) -> bool {
        let output: bool =<bevy::color::prelude::Oklcha as ::core::cmp::PartialEq::<bevy::color::prelude::Oklcha>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Construct a new [`Oklcha`] color from (l, c, h) components, with the default alpha (1.0).
    
    ///  # Arguments
    
    ///  * `lightness` - Lightness channel. [0.0, 1.0]
    
    ///  * `chroma` - Chroma channel. [0.0, 1.0]
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn lch (lightness:f32,chroma:f32,hue:f32,) -> Val<bevy::color::prelude::Oklcha> {
        let output: Val<bevy::color::prelude::Oklcha> =bevy::color::prelude::Oklcha::lch(lightness,chroma,hue,).into();
        output
    }


    
    ///  Construct a new [`Oklcha`] color from components.
    
    ///  # Arguments
    
    ///  * `lightness` - Lightness channel. [0.0, 1.0]
    
    ///  * `chroma` - Chroma channel. [0.0, 1.0]
    
    ///  * `hue` - Hue channel. [0.0, 360.0]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn new (lightness:f32,chroma:f32,hue:f32,alpha:f32,) -> Val<bevy::color::prelude::Oklcha> {
        let output: Val<bevy::color::prelude::Oklcha> =bevy::color::prelude::Oklcha::new(lightness,chroma,hue,alpha,).into();
        output
    }


    
    ///  Generate a deterministic but [quasi-randomly distributed](https://en.wikipedia.org/wiki/Low-discrepancy_sequence)
    
    ///  color from a provided `index`.
    
    ///  This can be helpful for generating debug colors.
    
    ///  # Examples
    
    ///  ```rust
    
    ///  # use bevy_color::Oklcha;
    
    ///  // Unique color for an entity
    
    ///  # let entity_index = 123;
    
    ///  // let entity_index = entity.index();
    
    ///  let color = Oklcha::sequential_dispersed(entity_index);
    
    ///  // Palette with 5 distinct hues
    
    ///  let palette = (0..5).map(Oklcha::sequential_dispersed).collect::<Vec<_>>();
    
    ///  ```
    
    fn sequential_dispersed (index:u32,) -> Val<bevy::color::prelude::Oklcha> {
        let output: Val<bevy::color::prelude::Oklcha> =bevy::color::prelude::Oklcha::sequential_dispersed(index,).into();
        output
    }


    
    ///  Return a copy of this color with the 'chroma' channel set to the given value.
    
    fn with_chroma (_self:Val<bevy::color::prelude::Oklcha>,chroma:f32,) -> Val<bevy::color::prelude::Oklcha> {
        let output: Val<bevy::color::prelude::Oklcha> =bevy::color::prelude::Oklcha::with_chroma(_self.into_inner(),chroma,).into();
        output
    }


    
    ///  Return a copy of this color with the 'lightness' channel set to the given value.
    
    fn with_lightness (_self:Val<bevy::color::prelude::Oklcha>,lightness:f32,) -> Val<bevy::color::prelude::Oklcha> {
        let output: Val<bevy::color::prelude::Oklcha> =bevy::color::prelude::Oklcha::with_lightness(_self.into_inner(),lightness,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "xyza_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::color::prelude::Xyza {


    
    fn add (_self:Val<bevy::color::prelude::Xyza>,rhs:Val<bevy::color::prelude::Xyza>,) -> Val<bevy::color::prelude::Xyza> {
        let output: Val<bevy::color::prelude::Xyza> =<bevy::color::prelude::Xyza as ::core::ops::Add::<bevy::color::prelude::Xyza>>::add(_self.into_inner(),rhs.into_inner(),).into();
        output
    }


    
    fn clone (_self:Ref<bevy::color::prelude::Xyza>,) -> Val<bevy::color::prelude::Xyza> {
        let output: Val<bevy::color::prelude::Xyza> =<bevy::color::prelude::Xyza as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn div (_self:Val<bevy::color::prelude::Xyza>,rhs:f32,) -> Val<bevy::color::prelude::Xyza> {
        let output: Val<bevy::color::prelude::Xyza> =<bevy::color::prelude::Xyza as ::core::ops::Div::<f32>>::div(_self.into_inner(),rhs,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::color::prelude::Xyza>,other:Ref<bevy::color::prelude::Xyza>,) -> bool {
        let output: bool =<bevy::color::prelude::Xyza as ::core::cmp::PartialEq::<bevy::color::prelude::Xyza>>::eq(&_self,&other,).into();
        output
    }


    
    fn mul (_self:Val<bevy::color::prelude::Xyza>,rhs:f32,) -> Val<bevy::color::prelude::Xyza> {
        let output: Val<bevy::color::prelude::Xyza> =<bevy::color::prelude::Xyza as ::core::ops::Mul::<f32>>::mul(_self.into_inner(),rhs,).into();
        output
    }


    
    fn neg (_self:Val<bevy::color::prelude::Xyza>,) -> Val<bevy::color::prelude::Xyza> {
        let output: Val<bevy::color::prelude::Xyza> =<bevy::color::prelude::Xyza as ::core::ops::Neg>::neg(_self.into_inner(),).into();
        output
    }


    
    ///  Construct a new [`Xyza`] color from components.
    
    ///  # Arguments
    
    ///  * `x` - x-axis. [0.0, 1.0]
    
    ///  * `y` - y-axis. [0.0, 1.0]
    
    ///  * `z` - z-axis. [0.0, 1.0]
    
    ///  * `alpha` - Alpha channel. [0.0, 1.0]
    
    fn new (x:f32,y:f32,z:f32,alpha:f32,) -> Val<bevy::color::prelude::Xyza> {
        let output: Val<bevy::color::prelude::Xyza> =bevy::color::prelude::Xyza::new(x,y,z,alpha,).into();
        output
    }


    
    fn sub (_self:Val<bevy::color::prelude::Xyza>,rhs:Val<bevy::color::prelude::Xyza>,) -> Val<bevy::color::prelude::Xyza> {
        let output: Val<bevy::color::prelude::Xyza> =<bevy::color::prelude::Xyza as ::core::ops::Sub::<bevy::color::prelude::Xyza>>::sub(_self.into_inner(),rhs.into_inner(),).into();
        output
    }


    
    ///  Return a copy of this color with the 'x' channel set to the given value.
    
    fn with_x (_self:Val<bevy::color::prelude::Xyza>,x:f32,) -> Val<bevy::color::prelude::Xyza> {
        let output: Val<bevy::color::prelude::Xyza> =bevy::color::prelude::Xyza::with_x(_self.into_inner(),x,).into();
        output
    }


    
    ///  Return a copy of this color with the 'y' channel set to the given value.
    
    fn with_y (_self:Val<bevy::color::prelude::Xyza>,y:f32,) -> Val<bevy::color::prelude::Xyza> {
        let output: Val<bevy::color::prelude::Xyza> =bevy::color::prelude::Xyza::with_y(_self.into_inner(),y,).into();
        output
    }


    
    ///  Return a copy of this color with the 'z' channel set to the given value.
    
    fn with_z (_self:Val<bevy::color::prelude::Xyza>,z:f32,) -> Val<bevy::color::prelude::Xyza> {
        let output: Val<bevy::color::prelude::Xyza> =bevy::color::prelude::Xyza::with_z(_self.into_inner(),z,).into();
        output
    }


    
    ///  Construct a new [`Xyza`] color from (x, y, z) components, with the default alpha (1.0).
    
    ///  # Arguments
    
    ///  * `x` - x-axis. [0.0, 1.0]
    
    ///  * `y` - y-axis. [0.0, 1.0]
    
    ///  * `z` - z-axis. [0.0, 1.0]
    
    fn xyz (x:f32,y:f32,z:f32,) -> Val<bevy::color::prelude::Xyza> {
        let output: Val<bevy::color::prelude::Xyza> =bevy::color::prelude::Xyza::xyz(x,y,z,).into();
        output
    }
     
}


impl ::bevy::app::Plugin for BevyColorScriptingPlugin {
    fn build(&self, app: &mut ::bevy::prelude::App) {
        let mut world = app.world_mut();

        
            register_color_functions(&mut world);
        
            register_srgba_functions(&mut world);
        
            register_linear_rgba_functions(&mut world);
        
            register_hsla_functions(&mut world);
        
            register_hsva_functions(&mut world);
        
            register_hwba_functions(&mut world);
        
            register_laba_functions(&mut world);
        
            register_lcha_functions(&mut world);
        
            register_oklaba_functions(&mut world);
        
            register_oklcha_functions(&mut world);
        
            register_xyza_functions(&mut world);
        
    }
}
