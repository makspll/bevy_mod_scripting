// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use bevy_mod_scripting_core::{
    bindings::{
        ReflectReference, 
        function::{from::{Ref, Mut, Val}, namespace::{NamespaceBuilder}}
    }
};
use bevy_ecs::{prelude::*};


use bevy_mod_scripting_derive::script_bindings;


use crate::*;







pub struct BevyCorePipelineScriptingPlugin;


#[script_bindings(
    remote,
    name = "skybox_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::Skybox {


    
    fn clone (_self:Ref<::bevy_core_pipeline::Skybox>,) -> Val<::bevy_core_pipeline::Skybox> {
        let output: Val<::bevy_core_pipeline::Skybox> =<::bevy_core_pipeline::Skybox as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "camera_2_d_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::core_2d::Camera2d {


    
    fn clone (_self:Ref<::bevy_core_pipeline::core_2d::Camera2d>,) -> Val<::bevy_core_pipeline::core_2d::Camera2d> {
        let output: Val<::bevy_core_pipeline::core_2d::Camera2d> =<::bevy_core_pipeline::core_2d::Camera2d as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "camera_3_d_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::core_3d::Camera3d {


    
    fn clone (_self:Ref<::bevy_core_pipeline::core_3d::Camera3d>,) -> Val<::bevy_core_pipeline::core_3d::Camera3d> {
        let output: Val<::bevy_core_pipeline::core_3d::Camera3d> =<::bevy_core_pipeline::core_3d::Camera3d as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "deferred_prepass_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::prepass::DeferredPrepass {
     
}

#[script_bindings(
    remote,
    name = "depth_prepass_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::prepass::DepthPrepass {


    
    fn clone (_self:Ref<::bevy_core_pipeline::prepass::DepthPrepass>,) -> Val<::bevy_core_pipeline::prepass::DepthPrepass> {
        let output: Val<::bevy_core_pipeline::prepass::DepthPrepass> =<::bevy_core_pipeline::prepass::DepthPrepass as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "motion_vector_prepass_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::prepass::MotionVectorPrepass {


    
    fn clone (_self:Ref<::bevy_core_pipeline::prepass::MotionVectorPrepass>,) -> Val<::bevy_core_pipeline::prepass::MotionVectorPrepass> {
        let output: Val<::bevy_core_pipeline::prepass::MotionVectorPrepass> =<::bevy_core_pipeline::prepass::MotionVectorPrepass as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "normal_prepass_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::prepass::NormalPrepass {


    
    fn clone (_self:Ref<::bevy_core_pipeline::prepass::NormalPrepass>,) -> Val<::bevy_core_pipeline::prepass::NormalPrepass> {
        let output: Val<::bevy_core_pipeline::prepass::NormalPrepass> =<::bevy_core_pipeline::prepass::NormalPrepass as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "auto_exposure_compensation_curve_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::auto_exposure::AutoExposureCompensationCurve {


    
    fn clone (_self:Ref<::bevy_core_pipeline::auto_exposure::AutoExposureCompensationCurve>,) -> Val<::bevy_core_pipeline::auto_exposure::AutoExposureCompensationCurve> {
        let output: Val<::bevy_core_pipeline::auto_exposure::AutoExposureCompensationCurve> =<::bevy_core_pipeline::auto_exposure::AutoExposureCompensationCurve as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "auto_exposure_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::auto_exposure::AutoExposure {


    
    fn clone (_self:Ref<::bevy_core_pipeline::auto_exposure::AutoExposure>,) -> Val<::bevy_core_pipeline::auto_exposure::AutoExposure> {
        let output: Val<::bevy_core_pipeline::auto_exposure::AutoExposure> =<::bevy_core_pipeline::auto_exposure::AutoExposure as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "tonemapping_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::tonemapping::Tonemapping {


    
    fn assert_receiver_is_total_eq (_self:Ref<::bevy_core_pipeline::tonemapping::Tonemapping>,) -> () {
        let output: () =<::bevy_core_pipeline::tonemapping::Tonemapping as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_core_pipeline::tonemapping::Tonemapping>,) -> Val<::bevy_core_pipeline::tonemapping::Tonemapping> {
        let output: Val<::bevy_core_pipeline::tonemapping::Tonemapping> =<::bevy_core_pipeline::tonemapping::Tonemapping as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_core_pipeline::tonemapping::Tonemapping>,other:Ref<::bevy_core_pipeline::tonemapping::Tonemapping>,) -> bool {
        let output: bool =<::bevy_core_pipeline::tonemapping::Tonemapping as ::std::cmp::PartialEq::<::bevy_core_pipeline::tonemapping::Tonemapping>>::eq(&_self,&other,).into();
        output
    }


    
    fn is_enabled (_self:Ref<::bevy_core_pipeline::tonemapping::Tonemapping>,) -> bool {
        let output: bool =::bevy_core_pipeline::tonemapping::Tonemapping::is_enabled(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "bloom_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::bloom::Bloom {


    
    fn clone (_self:Ref<::bevy_core_pipeline::bloom::Bloom>,) -> Val<::bevy_core_pipeline::bloom::Bloom> {
        let output: Val<::bevy_core_pipeline::bloom::Bloom> =<::bevy_core_pipeline::bloom::Bloom as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "bloom_composite_mode_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::bloom::BloomCompositeMode {


    
    fn assert_receiver_is_total_eq (_self:Ref<::bevy_core_pipeline::bloom::BloomCompositeMode>,) -> () {
        let output: () =<::bevy_core_pipeline::bloom::BloomCompositeMode as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_core_pipeline::bloom::BloomCompositeMode>,) -> Val<::bevy_core_pipeline::bloom::BloomCompositeMode> {
        let output: Val<::bevy_core_pipeline::bloom::BloomCompositeMode> =<::bevy_core_pipeline::bloom::BloomCompositeMode as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_core_pipeline::bloom::BloomCompositeMode>,other:Ref<::bevy_core_pipeline::bloom::BloomCompositeMode>,) -> bool {
        let output: bool =<::bevy_core_pipeline::bloom::BloomCompositeMode as ::std::cmp::PartialEq::<::bevy_core_pipeline::bloom::BloomCompositeMode>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "bloom_prefilter_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::bloom::BloomPrefilter {


    
    fn clone (_self:Ref<::bevy_core_pipeline::bloom::BloomPrefilter>,) -> Val<::bevy_core_pipeline::bloom::BloomPrefilter> {
        let output: Val<::bevy_core_pipeline::bloom::BloomPrefilter> =<::bevy_core_pipeline::bloom::BloomPrefilter as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "contrast_adaptive_sharpening_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::contrast_adaptive_sharpening::ContrastAdaptiveSharpening {


    
    fn clone (_self:Ref<::bevy_core_pipeline::contrast_adaptive_sharpening::ContrastAdaptiveSharpening>,) -> Val<::bevy_core_pipeline::contrast_adaptive_sharpening::ContrastAdaptiveSharpening> {
        let output: Val<::bevy_core_pipeline::contrast_adaptive_sharpening::ContrastAdaptiveSharpening> =<::bevy_core_pipeline::contrast_adaptive_sharpening::ContrastAdaptiveSharpening as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "denoise_cas_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::contrast_adaptive_sharpening::DenoiseCas {


    
    fn clone (_self:Ref<::bevy_core_pipeline::contrast_adaptive_sharpening::DenoiseCas>,) -> Val<::bevy_core_pipeline::contrast_adaptive_sharpening::DenoiseCas> {
        let output: Val<::bevy_core_pipeline::contrast_adaptive_sharpening::DenoiseCas> =<::bevy_core_pipeline::contrast_adaptive_sharpening::DenoiseCas as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "fxaa_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::fxaa::Fxaa {


    
    fn clone (_self:Ref<::bevy_core_pipeline::fxaa::Fxaa>,) -> Val<::bevy_core_pipeline::fxaa::Fxaa> {
        let output: Val<::bevy_core_pipeline::fxaa::Fxaa> =<::bevy_core_pipeline::fxaa::Fxaa as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "smaa_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::smaa::Smaa {


    
    fn clone (_self:Ref<::bevy_core_pipeline::smaa::Smaa>,) -> Val<::bevy_core_pipeline::smaa::Smaa> {
        let output: Val<::bevy_core_pipeline::smaa::Smaa> =<::bevy_core_pipeline::smaa::Smaa as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "deband_dither_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::tonemapping::DebandDither {


    
    fn assert_receiver_is_total_eq (_self:Ref<::bevy_core_pipeline::tonemapping::DebandDither>,) -> () {
        let output: () =<::bevy_core_pipeline::tonemapping::DebandDither as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_core_pipeline::tonemapping::DebandDither>,) -> Val<::bevy_core_pipeline::tonemapping::DebandDither> {
        let output: Val<::bevy_core_pipeline::tonemapping::DebandDither> =<::bevy_core_pipeline::tonemapping::DebandDither as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_core_pipeline::tonemapping::DebandDither>,other:Ref<::bevy_core_pipeline::tonemapping::DebandDither>,) -> bool {
        let output: bool =<::bevy_core_pipeline::tonemapping::DebandDither as ::std::cmp::PartialEq::<::bevy_core_pipeline::tonemapping::DebandDither>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "motion_blur_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::motion_blur::MotionBlur {


    
    fn clone (_self:Ref<::bevy_core_pipeline::motion_blur::MotionBlur>,) -> Val<::bevy_core_pipeline::motion_blur::MotionBlur> {
        let output: Val<::bevy_core_pipeline::motion_blur::MotionBlur> =<::bevy_core_pipeline::motion_blur::MotionBlur as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "depth_of_field_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::dof::DepthOfField {


    
    fn clone (_self:Ref<::bevy_core_pipeline::dof::DepthOfField>,) -> Val<::bevy_core_pipeline::dof::DepthOfField> {
        let output: Val<::bevy_core_pipeline::dof::DepthOfField> =<::bevy_core_pipeline::dof::DepthOfField as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "screen_space_transmission_quality_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::core_3d::ScreenSpaceTransmissionQuality {


    
    fn clone (_self:Ref<::bevy_core_pipeline::core_3d::ScreenSpaceTransmissionQuality>,) -> Val<::bevy_core_pipeline::core_3d::ScreenSpaceTransmissionQuality> {
        let output: Val<::bevy_core_pipeline::core_3d::ScreenSpaceTransmissionQuality> =<::bevy_core_pipeline::core_3d::ScreenSpaceTransmissionQuality as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_core_pipeline::core_3d::ScreenSpaceTransmissionQuality>,other:Ref<::bevy_core_pipeline::core_3d::ScreenSpaceTransmissionQuality>,) -> bool {
        let output: bool =<::bevy_core_pipeline::core_3d::ScreenSpaceTransmissionQuality as ::std::cmp::PartialEq::<::bevy_core_pipeline::core_3d::ScreenSpaceTransmissionQuality>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "camera_3_d_depth_load_op_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::core_3d::Camera3dDepthLoadOp {


    
    fn clone (_self:Ref<::bevy_core_pipeline::core_3d::Camera3dDepthLoadOp>,) -> Val<::bevy_core_pipeline::core_3d::Camera3dDepthLoadOp> {
        let output: Val<::bevy_core_pipeline::core_3d::Camera3dDepthLoadOp> =<::bevy_core_pipeline::core_3d::Camera3dDepthLoadOp as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "camera_3_d_depth_texture_usage_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::core_3d::Camera3dDepthTextureUsage {


    
    fn clone (_self:Ref<::bevy_core_pipeline::core_3d::Camera3dDepthTextureUsage>,) -> Val<::bevy_core_pipeline::core_3d::Camera3dDepthTextureUsage> {
        let output: Val<::bevy_core_pipeline::core_3d::Camera3dDepthTextureUsage> =<::bevy_core_pipeline::core_3d::Camera3dDepthTextureUsage as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "depth_of_field_mode_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::dof::DepthOfFieldMode {


    
    fn clone (_self:Ref<::bevy_core_pipeline::dof::DepthOfFieldMode>,) -> Val<::bevy_core_pipeline::dof::DepthOfFieldMode> {
        let output: Val<::bevy_core_pipeline::dof::DepthOfFieldMode> =<::bevy_core_pipeline::dof::DepthOfFieldMode as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_core_pipeline::dof::DepthOfFieldMode>,other:Ref<::bevy_core_pipeline::dof::DepthOfFieldMode>,) -> bool {
        let output: bool =<::bevy_core_pipeline::dof::DepthOfFieldMode as ::std::cmp::PartialEq::<::bevy_core_pipeline::dof::DepthOfFieldMode>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "temporal_anti_aliasing_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::experimental::taa::TemporalAntiAliasing {


    
    fn clone (_self:Ref<::bevy_core_pipeline::experimental::taa::TemporalAntiAliasing>,) -> Val<::bevy_core_pipeline::experimental::taa::TemporalAntiAliasing> {
        let output: Val<::bevy_core_pipeline::experimental::taa::TemporalAntiAliasing> =<::bevy_core_pipeline::experimental::taa::TemporalAntiAliasing as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "sensitivity_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::fxaa::Sensitivity {


    
    fn assert_receiver_is_total_eq (_self:Ref<::bevy_core_pipeline::fxaa::Sensitivity>,) -> () {
        let output: () =<::bevy_core_pipeline::fxaa::Sensitivity as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_core_pipeline::fxaa::Sensitivity>,) -> Val<::bevy_core_pipeline::fxaa::Sensitivity> {
        let output: Val<::bevy_core_pipeline::fxaa::Sensitivity> =<::bevy_core_pipeline::fxaa::Sensitivity as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_core_pipeline::fxaa::Sensitivity>,other:Ref<::bevy_core_pipeline::fxaa::Sensitivity>,) -> bool {
        let output: bool =<::bevy_core_pipeline::fxaa::Sensitivity as ::std::cmp::PartialEq::<::bevy_core_pipeline::fxaa::Sensitivity>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "order_independent_transparency_settings_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::oit::OrderIndependentTransparencySettings {


    
    fn clone (_self:Ref<::bevy_core_pipeline::oit::OrderIndependentTransparencySettings>,) -> Val<::bevy_core_pipeline::oit::OrderIndependentTransparencySettings> {
        let output: Val<::bevy_core_pipeline::oit::OrderIndependentTransparencySettings> =<::bevy_core_pipeline::oit::OrderIndependentTransparencySettings as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "chromatic_aberration_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::post_process::ChromaticAberration {


    
    fn clone (_self:Ref<::bevy_core_pipeline::post_process::ChromaticAberration>,) -> Val<::bevy_core_pipeline::post_process::ChromaticAberration> {
        let output: Val<::bevy_core_pipeline::post_process::ChromaticAberration> =<::bevy_core_pipeline::post_process::ChromaticAberration as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "smaa_preset_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_core_pipeline::smaa::SmaaPreset {


    
    fn assert_receiver_is_total_eq (_self:Ref<::bevy_core_pipeline::smaa::SmaaPreset>,) -> () {
        let output: () =<::bevy_core_pipeline::smaa::SmaaPreset as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_core_pipeline::smaa::SmaaPreset>,) -> Val<::bevy_core_pipeline::smaa::SmaaPreset> {
        let output: Val<::bevy_core_pipeline::smaa::SmaaPreset> =<::bevy_core_pipeline::smaa::SmaaPreset as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_core_pipeline::smaa::SmaaPreset>,other:Ref<::bevy_core_pipeline::smaa::SmaaPreset>,) -> bool {
        let output: bool =<::bevy_core_pipeline::smaa::SmaaPreset as ::std::cmp::PartialEq::<::bevy_core_pipeline::smaa::SmaaPreset>>::eq(&_self,&other,).into();
        output
    }
     
}


impl Plugin for BevyCorePipelineScriptingPlugin {
    fn build(&self, app: &mut App) {
        let mut world = app.world_mut();

        
            register_skybox_functions(&mut world);
        
            register_camera_2_d_functions(&mut world);
        
            register_camera_3_d_functions(&mut world);
        
            register_deferred_prepass_functions(&mut world);
        
            register_depth_prepass_functions(&mut world);
        
            register_motion_vector_prepass_functions(&mut world);
        
            register_normal_prepass_functions(&mut world);
        
            register_auto_exposure_compensation_curve_functions(&mut world);
        
            register_auto_exposure_functions(&mut world);
        
            register_tonemapping_functions(&mut world);
        
            register_bloom_functions(&mut world);
        
            register_bloom_composite_mode_functions(&mut world);
        
            register_bloom_prefilter_functions(&mut world);
        
            register_contrast_adaptive_sharpening_functions(&mut world);
        
            register_denoise_cas_functions(&mut world);
        
            register_fxaa_functions(&mut world);
        
            register_smaa_functions(&mut world);
        
            register_deband_dither_functions(&mut world);
        
            register_motion_blur_functions(&mut world);
        
            register_depth_of_field_functions(&mut world);
        
            register_screen_space_transmission_quality_functions(&mut world);
        
            register_camera_3_d_depth_load_op_functions(&mut world);
        
            register_camera_3_d_depth_texture_usage_functions(&mut world);
        
            register_depth_of_field_mode_functions(&mut world);
        
            register_temporal_anti_aliasing_functions(&mut world);
        
            register_sensitivity_functions(&mut world);
        
            register_order_independent_transparency_settings_functions(&mut world);
        
            register_chromatic_aberration_functions(&mut world);
        
            register_smaa_preset_functions(&mut world);
        
    }
}
