// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use bevy_mod_scripting_core::{
    bindings::{
        ReflectReference, 
        function::{from::{Ref, Mut, Val}, namespace::{NamespaceBuilder}}
    }
};

use bevy_mod_scripting_derive::script_bindings;


use crate::*;







pub struct BevyPickingScriptingPlugin;


#[script_bindings(
    remote,
    name = "ray_cast_backfaces_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::mesh_picking::ray_cast::RayCastBackfaces {


    
    fn clone (_self:Ref<bevy::picking::mesh_picking::ray_cast::RayCastBackfaces>,) -> Val<bevy::picking::mesh_picking::ray_cast::RayCastBackfaces> {
        let output: Val<bevy::picking::mesh_picking::ray_cast::RayCastBackfaces> =<bevy::picking::mesh_picking::ray_cast::RayCastBackfaces as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "ray_cast_visibility_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::mesh_picking::ray_cast::RayCastVisibility {


    
    fn clone (_self:Ref<bevy::picking::mesh_picking::ray_cast::RayCastVisibility>,) -> Val<bevy::picking::mesh_picking::ray_cast::RayCastVisibility> {
        let output: Val<bevy::picking::mesh_picking::ray_cast::RayCastVisibility> =<bevy::picking::mesh_picking::ray_cast::RayCastVisibility as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "mesh_picking_camera_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::mesh_picking::MeshPickingCamera {


    
    fn clone (_self:Ref<bevy::picking::mesh_picking::MeshPickingCamera>,) -> Val<bevy::picking::mesh_picking::MeshPickingCamera> {
        let output: Val<bevy::picking::mesh_picking::MeshPickingCamera> =<bevy::picking::mesh_picking::MeshPickingCamera as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "mesh_picking_settings_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::mesh_picking::MeshPickingSettings {
     
}

#[script_bindings(
    remote,
    name = "pointer_input_plugin_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::input::prelude::PointerInputPlugin {


    
    fn clone (_self:Ref<bevy::picking::input::prelude::PointerInputPlugin>,) -> Val<bevy::picking::input::prelude::PointerInputPlugin> {
        let output: Val<bevy::picking::input::prelude::PointerInputPlugin> =<bevy::picking::input::prelude::PointerInputPlugin as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "pointer_button_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::pointer::PointerButton {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::picking::pointer::PointerButton>,) -> () {
        let output: () =<bevy::picking::pointer::PointerButton as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::picking::pointer::PointerButton>,) -> Val<bevy::picking::pointer::PointerButton> {
        let output: Val<bevy::picking::pointer::PointerButton> =<bevy::picking::pointer::PointerButton as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::pointer::PointerButton>,other:Ref<bevy::picking::pointer::PointerButton>,) -> bool {
        let output: bool =<bevy::picking::pointer::PointerButton as ::std::cmp::PartialEq::<bevy::picking::pointer::PointerButton>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "pickable_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::backend::prelude::Pickable {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::picking::backend::prelude::Pickable>,) -> () {
        let output: () =<bevy::picking::backend::prelude::Pickable as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::picking::backend::prelude::Pickable>,) -> Val<bevy::picking::backend::prelude::Pickable> {
        let output: Val<bevy::picking::backend::prelude::Pickable> =<bevy::picking::backend::prelude::Pickable as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::backend::prelude::Pickable>,other:Ref<bevy::picking::backend::prelude::Pickable>,) -> bool {
        let output: bool =<bevy::picking::backend::prelude::Pickable as ::std::cmp::PartialEq::<bevy::picking::backend::prelude::Pickable>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "picking_plugin_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::prelude::PickingPlugin {


    
    fn clone (_self:Ref<bevy::picking::prelude::PickingPlugin>,) -> Val<bevy::picking::prelude::PickingPlugin> {
        let output: Val<bevy::picking::prelude::PickingPlugin> =<bevy::picking::prelude::PickingPlugin as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "pointer_input_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::pointer::PointerInput {


    
    ///  Returns true if the `target_button` of this pointer was just pressed.
    
    fn button_just_pressed (_self:Ref<bevy::picking::pointer::PointerInput>,target_button:Val<bevy::picking::pointer::PointerButton>,) -> bool {
        let output: bool =bevy::picking::pointer::PointerInput::button_just_pressed(&_self,target_button.into_inner(),).into();
        output
    }


    
    ///  Returns true if the `target_button` of this pointer was just released.
    
    fn button_just_released (_self:Ref<bevy::picking::pointer::PointerInput>,target_button:Val<bevy::picking::pointer::PointerButton>,) -> bool {
        let output: bool =bevy::picking::pointer::PointerInput::button_just_released(&_self,target_button.into_inner(),).into();
        output
    }


    
    fn clone (_self:Ref<bevy::picking::pointer::PointerInput>,) -> Val<bevy::picking::pointer::PointerInput> {
        let output: Val<bevy::picking::pointer::PointerInput> =<bevy::picking::pointer::PointerInput as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new pointer input event.
    
    ///  Note that `location` refers to the position of the pointer *after* the event occurred.
    
    fn new (pointer_id:Val<bevy::picking::backend::prelude::PointerId>,location:Val<bevy::picking::pointer::Location>,action:Val<bevy::picking::pointer::PointerAction>,) -> Val<bevy::picking::pointer::PointerInput> {
        let output: Val<bevy::picking::pointer::PointerInput> =bevy::picking::pointer::PointerInput::new(pointer_id.into_inner(),location.into_inner(),action.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "pointer_hits_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::backend::prelude::PointerHits {


    
    fn clone (_self:Ref<bevy::picking::backend::prelude::PointerHits>,) -> Val<bevy::picking::backend::prelude::PointerHits> {
        let output: Val<bevy::picking::backend::prelude::PointerHits> =<bevy::picking::backend::prelude::PointerHits as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "picking_interaction_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::hover::PickingInteraction {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::picking::hover::PickingInteraction>,) -> () {
        let output: () =<bevy::picking::hover::PickingInteraction as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::picking::hover::PickingInteraction>,) -> Val<bevy::picking::hover::PickingInteraction> {
        let output: Val<bevy::picking::hover::PickingInteraction> =<bevy::picking::hover::PickingInteraction as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::hover::PickingInteraction>,other:Ref<bevy::picking::hover::PickingInteraction>,) -> bool {
        let output: bool =<bevy::picking::hover::PickingInteraction as ::std::cmp::PartialEq::<bevy::picking::hover::PickingInteraction>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "pointer_id_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::backend::prelude::PointerId {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::picking::backend::prelude::PointerId>,) -> () {
        let output: () =<bevy::picking::backend::prelude::PointerId as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::picking::backend::prelude::PointerId>,) -> Val<bevy::picking::backend::prelude::PointerId> {
        let output: Val<bevy::picking::backend::prelude::PointerId> =<bevy::picking::backend::prelude::PointerId as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::backend::prelude::PointerId>,other:Ref<bevy::picking::backend::prelude::PointerId>,) -> bool {
        let output: bool =<bevy::picking::backend::prelude::PointerId as ::std::cmp::PartialEq::<bevy::picking::backend::prelude::PointerId>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Returns the touch id if the pointer is a touch input.
    
    fn get_touch_id (_self:Ref<bevy::picking::backend::prelude::PointerId>,) -> ::std::option::Option<u64> {
        let output: ::std::option::Option<u64> =bevy::picking::backend::prelude::PointerId::get_touch_id(&_self,).into();
        output
    }


    
    ///  Returns true if the pointer is a custom input.
    
    fn is_custom (_self:Ref<bevy::picking::backend::prelude::PointerId>,) -> bool {
        let output: bool =bevy::picking::backend::prelude::PointerId::is_custom(&_self,).into();
        output
    }


    
    ///  Returns true if the pointer is the mouse.
    
    fn is_mouse (_self:Ref<bevy::picking::backend::prelude::PointerId>,) -> bool {
        let output: bool =bevy::picking::backend::prelude::PointerId::is_mouse(&_self,).into();
        output
    }


    
    ///  Returns true if the pointer is a touch input.
    
    fn is_touch (_self:Ref<bevy::picking::backend::prelude::PointerId>,) -> bool {
        let output: bool =bevy::picking::backend::prelude::PointerId::is_touch(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "pointer_location_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::backend::prelude::PointerLocation {


    
    fn clone (_self:Ref<bevy::picking::backend::prelude::PointerLocation>,) -> Val<bevy::picking::backend::prelude::PointerLocation> {
        let output: Val<bevy::picking::backend::prelude::PointerLocation> =<bevy::picking::backend::prelude::PointerLocation as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::backend::prelude::PointerLocation>,other:Ref<bevy::picking::backend::prelude::PointerLocation>,) -> bool {
        let output: bool =<bevy::picking::backend::prelude::PointerLocation as ::std::cmp::PartialEq::<bevy::picking::backend::prelude::PointerLocation>>::eq(&_self,&other,).into();
        output
    }


    
    /// Returns a [`PointerLocation`] associated with the given location
    
    fn new (location:Val<bevy::picking::pointer::Location>,) -> Val<bevy::picking::backend::prelude::PointerLocation> {
        let output: Val<bevy::picking::backend::prelude::PointerLocation> =bevy::picking::backend::prelude::PointerLocation::new(location.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "pointer_press_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::pointer::PointerPress {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::picking::pointer::PointerPress>,) -> () {
        let output: () =<bevy::picking::pointer::PointerPress as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::picking::pointer::PointerPress>,) -> Val<bevy::picking::pointer::PointerPress> {
        let output: Val<bevy::picking::pointer::PointerPress> =<bevy::picking::pointer::PointerPress as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::pointer::PointerPress>,other:Ref<bevy::picking::pointer::PointerPress>,) -> bool {
        let output: bool =<bevy::picking::pointer::PointerPress as ::std::cmp::PartialEq::<bevy::picking::pointer::PointerPress>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Returns true if any pointer button is pressed.
    
    fn is_any_pressed (_self:Ref<bevy::picking::pointer::PointerPress>,) -> bool {
        let output: bool =bevy::picking::pointer::PointerPress::is_any_pressed(&_self,).into();
        output
    }


    
    ///  Returns true if the middle (tertiary) pointer button is pressed.
    
    fn is_middle_pressed (_self:Ref<bevy::picking::pointer::PointerPress>,) -> bool {
        let output: bool =bevy::picking::pointer::PointerPress::is_middle_pressed(&_self,).into();
        output
    }


    
    ///  Returns true if the primary pointer button is pressed.
    
    fn is_primary_pressed (_self:Ref<bevy::picking::pointer::PointerPress>,) -> bool {
        let output: bool =bevy::picking::pointer::PointerPress::is_primary_pressed(&_self,).into();
        output
    }


    
    ///  Returns true if the secondary pointer button is pressed.
    
    fn is_secondary_pressed (_self:Ref<bevy::picking::pointer::PointerPress>,) -> bool {
        let output: bool =bevy::picking::pointer::PointerPress::is_secondary_pressed(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "pointer_interaction_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::pointer::PointerInteraction {


    
    fn clone (_self:Ref<bevy::picking::pointer::PointerInteraction>,) -> Val<bevy::picking::pointer::PointerInteraction> {
        let output: Val<bevy::picking::pointer::PointerInteraction> =<bevy::picking::pointer::PointerInteraction as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "ray_id_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::backend::ray::RayId {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::picking::backend::ray::RayId>,) -> () {
        let output: () =<bevy::picking::backend::ray::RayId as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::picking::backend::ray::RayId>,) -> Val<bevy::picking::backend::ray::RayId> {
        let output: Val<bevy::picking::backend::ray::RayId> =<bevy::picking::backend::ray::RayId as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::backend::ray::RayId>,other:Ref<bevy::picking::backend::ray::RayId>,) -> bool {
        let output: bool =<bevy::picking::backend::ray::RayId as ::std::cmp::PartialEq::<bevy::picking::backend::ray::RayId>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Construct a [`RayId`].
    
    fn new (camera:Val<bevy::ecs::entity::Entity>,pointer:Val<bevy::picking::backend::prelude::PointerId>,) -> Val<bevy::picking::backend::ray::RayId> {
        let output: Val<bevy::picking::backend::ray::RayId> =bevy::picking::backend::ray::RayId::new(camera.into_inner(),pointer.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cancel_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::events::Cancel {


    
    fn clone (_self:Ref<bevy::picking::events::Cancel>,) -> Val<bevy::picking::events::Cancel> {
        let output: Val<bevy::picking::events::Cancel> =<bevy::picking::events::Cancel as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::events::Cancel>,other:Ref<bevy::picking::events::Cancel>,) -> bool {
        let output: bool =<bevy::picking::events::Cancel as ::std::cmp::PartialEq::<bevy::picking::events::Cancel>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "click_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::events::Click {


    
    fn clone (_self:Ref<bevy::picking::events::Click>,) -> Val<bevy::picking::events::Click> {
        let output: Val<bevy::picking::events::Click> =<bevy::picking::events::Click as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::events::Click>,other:Ref<bevy::picking::events::Click>,) -> bool {
        let output: bool =<bevy::picking::events::Click as ::std::cmp::PartialEq::<bevy::picking::events::Click>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "pressed_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::events::Pressed {


    
    fn clone (_self:Ref<bevy::picking::events::Pressed>,) -> Val<bevy::picking::events::Pressed> {
        let output: Val<bevy::picking::events::Pressed> =<bevy::picking::events::Pressed as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::events::Pressed>,other:Ref<bevy::picking::events::Pressed>,) -> bool {
        let output: bool =<bevy::picking::events::Pressed as ::std::cmp::PartialEq::<bevy::picking::events::Pressed>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "drag_drop_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::events::DragDrop {


    
    fn clone (_self:Ref<bevy::picking::events::DragDrop>,) -> Val<bevy::picking::events::DragDrop> {
        let output: Val<bevy::picking::events::DragDrop> =<bevy::picking::events::DragDrop as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::events::DragDrop>,other:Ref<bevy::picking::events::DragDrop>,) -> bool {
        let output: bool =<bevy::picking::events::DragDrop as ::std::cmp::PartialEq::<bevy::picking::events::DragDrop>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "drag_end_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::events::DragEnd {


    
    fn clone (_self:Ref<bevy::picking::events::DragEnd>,) -> Val<bevy::picking::events::DragEnd> {
        let output: Val<bevy::picking::events::DragEnd> =<bevy::picking::events::DragEnd as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::events::DragEnd>,other:Ref<bevy::picking::events::DragEnd>,) -> bool {
        let output: bool =<bevy::picking::events::DragEnd as ::std::cmp::PartialEq::<bevy::picking::events::DragEnd>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "drag_enter_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::events::DragEnter {


    
    fn clone (_self:Ref<bevy::picking::events::DragEnter>,) -> Val<bevy::picking::events::DragEnter> {
        let output: Val<bevy::picking::events::DragEnter> =<bevy::picking::events::DragEnter as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::events::DragEnter>,other:Ref<bevy::picking::events::DragEnter>,) -> bool {
        let output: bool =<bevy::picking::events::DragEnter as ::std::cmp::PartialEq::<bevy::picking::events::DragEnter>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "drag_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::events::Drag {


    
    fn clone (_self:Ref<bevy::picking::events::Drag>,) -> Val<bevy::picking::events::Drag> {
        let output: Val<bevy::picking::events::Drag> =<bevy::picking::events::Drag as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::events::Drag>,other:Ref<bevy::picking::events::Drag>,) -> bool {
        let output: bool =<bevy::picking::events::Drag as ::std::cmp::PartialEq::<bevy::picking::events::Drag>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "drag_leave_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::events::DragLeave {


    
    fn clone (_self:Ref<bevy::picking::events::DragLeave>,) -> Val<bevy::picking::events::DragLeave> {
        let output: Val<bevy::picking::events::DragLeave> =<bevy::picking::events::DragLeave as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::events::DragLeave>,other:Ref<bevy::picking::events::DragLeave>,) -> bool {
        let output: bool =<bevy::picking::events::DragLeave as ::std::cmp::PartialEq::<bevy::picking::events::DragLeave>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "drag_over_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::events::DragOver {


    
    fn clone (_self:Ref<bevy::picking::events::DragOver>,) -> Val<bevy::picking::events::DragOver> {
        let output: Val<bevy::picking::events::DragOver> =<bevy::picking::events::DragOver as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::events::DragOver>,other:Ref<bevy::picking::events::DragOver>,) -> bool {
        let output: bool =<bevy::picking::events::DragOver as ::std::cmp::PartialEq::<bevy::picking::events::DragOver>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "drag_start_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::events::DragStart {


    
    fn clone (_self:Ref<bevy::picking::events::DragStart>,) -> Val<bevy::picking::events::DragStart> {
        let output: Val<bevy::picking::events::DragStart> =<bevy::picking::events::DragStart as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::events::DragStart>,other:Ref<bevy::picking::events::DragStart>,) -> bool {
        let output: bool =<bevy::picking::events::DragStart as ::std::cmp::PartialEq::<bevy::picking::events::DragStart>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "move_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::events::Move {


    
    fn clone (_self:Ref<bevy::picking::events::Move>,) -> Val<bevy::picking::events::Move> {
        let output: Val<bevy::picking::events::Move> =<bevy::picking::events::Move as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::events::Move>,other:Ref<bevy::picking::events::Move>,) -> bool {
        let output: bool =<bevy::picking::events::Move as ::std::cmp::PartialEq::<bevy::picking::events::Move>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "out_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::events::Out {


    
    fn clone (_self:Ref<bevy::picking::events::Out>,) -> Val<bevy::picking::events::Out> {
        let output: Val<bevy::picking::events::Out> =<bevy::picking::events::Out as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::events::Out>,other:Ref<bevy::picking::events::Out>,) -> bool {
        let output: bool =<bevy::picking::events::Out as ::std::cmp::PartialEq::<bevy::picking::events::Out>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "over_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::events::Over {


    
    fn clone (_self:Ref<bevy::picking::events::Over>,) -> Val<bevy::picking::events::Over> {
        let output: Val<bevy::picking::events::Over> =<bevy::picking::events::Over as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::events::Over>,other:Ref<bevy::picking::events::Over>,) -> bool {
        let output: bool =<bevy::picking::events::Over as ::std::cmp::PartialEq::<bevy::picking::events::Over>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "released_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::events::Released {


    
    fn clone (_self:Ref<bevy::picking::events::Released>,) -> Val<bevy::picking::events::Released> {
        let output: Val<bevy::picking::events::Released> =<bevy::picking::events::Released as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::events::Released>,other:Ref<bevy::picking::events::Released>,) -> bool {
        let output: bool =<bevy::picking::events::Released as ::std::cmp::PartialEq::<bevy::picking::events::Released>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "scroll_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::events::Scroll {


    
    fn clone (_self:Ref<bevy::picking::events::Scroll>,) -> Val<bevy::picking::events::Scroll> {
        let output: Val<bevy::picking::events::Scroll> =<bevy::picking::events::Scroll as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::events::Scroll>,other:Ref<bevy::picking::events::Scroll>,) -> bool {
        let output: bool =<bevy::picking::events::Scroll as ::std::cmp::PartialEq::<bevy::picking::events::Scroll>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "hit_data_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::backend::prelude::HitData {


    
    fn clone (_self:Ref<bevy::picking::backend::prelude::HitData>,) -> Val<bevy::picking::backend::prelude::HitData> {
        let output: Val<bevy::picking::backend::prelude::HitData> =<bevy::picking::backend::prelude::HitData as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::backend::prelude::HitData>,other:Ref<bevy::picking::backend::prelude::HitData>,) -> bool {
        let output: bool =<bevy::picking::backend::prelude::HitData as ::std::cmp::PartialEq::<bevy::picking::backend::prelude::HitData>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "location_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::pointer::Location {


    
    fn clone (_self:Ref<bevy::picking::pointer::Location>,) -> Val<bevy::picking::pointer::Location> {
        let output: Val<bevy::picking::pointer::Location> =<bevy::picking::pointer::Location as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::pointer::Location>,other:Ref<bevy::picking::pointer::Location>,) -> bool {
        let output: bool =<bevy::picking::pointer::Location as ::std::cmp::PartialEq::<bevy::picking::pointer::Location>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "pointer_action_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::pointer::PointerAction {


    
    fn clone (_self:Ref<bevy::picking::pointer::PointerAction>,) -> Val<bevy::picking::pointer::PointerAction> {
        let output: Val<bevy::picking::pointer::PointerAction> =<bevy::picking::pointer::PointerAction as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "drag_entry_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::events::DragEntry {


    
    fn clone (_self:Ref<bevy::picking::events::DragEntry>,) -> Val<bevy::picking::events::DragEntry> {
        let output: Val<bevy::picking::events::DragEntry> =<bevy::picking::events::DragEntry as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::events::DragEntry>,other:Ref<bevy::picking::events::DragEntry>,) -> bool {
        let output: bool =<bevy::picking::events::DragEntry as ::std::cmp::PartialEq::<bevy::picking::events::DragEntry>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "simplified_mesh_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::mesh_picking::ray_cast::SimplifiedMesh {


    
    fn clone (_self:Ref<bevy::picking::mesh_picking::ray_cast::SimplifiedMesh>,) -> Val<bevy::picking::mesh_picking::ray_cast::SimplifiedMesh> {
        let output: Val<bevy::picking::mesh_picking::ray_cast::SimplifiedMesh> =<bevy::picking::mesh_picking::ray_cast::SimplifiedMesh as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "ray_mesh_hit_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::mesh_picking::ray_cast::RayMeshHit {


    
    fn clone (_self:Ref<bevy::picking::mesh_picking::ray_cast::RayMeshHit>,) -> Val<bevy::picking::mesh_picking::ray_cast::RayMeshHit> {
        let output: Val<bevy::picking::mesh_picking::ray_cast::RayMeshHit> =<bevy::picking::mesh_picking::ray_cast::RayMeshHit as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "backfaces_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::mesh_picking::ray_cast::Backfaces {


    
    fn clone (_self:Ref<bevy::picking::mesh_picking::ray_cast::Backfaces>,) -> Val<bevy::picking::mesh_picking::ray_cast::Backfaces> {
        let output: Val<bevy::picking::mesh_picking::ray_cast::Backfaces> =<bevy::picking::mesh_picking::ray_cast::Backfaces as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "press_direction_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::picking::pointer::PressDirection {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::picking::pointer::PressDirection>,) -> () {
        let output: () =<bevy::picking::pointer::PressDirection as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::picking::pointer::PressDirection>,) -> Val<bevy::picking::pointer::PressDirection> {
        let output: Val<bevy::picking::pointer::PressDirection> =<bevy::picking::pointer::PressDirection as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::picking::pointer::PressDirection>,other:Ref<bevy::picking::pointer::PressDirection>,) -> bool {
        let output: bool =<bevy::picking::pointer::PressDirection as ::std::cmp::PartialEq::<bevy::picking::pointer::PressDirection>>::eq(&_self,&other,).into();
        output
    }
     
}


impl ::bevy::app::Plugin for BevyPickingScriptingPlugin {
    fn build(&self, app: &mut ::bevy::prelude::App) {
        let mut world = app.world_mut();

        
            register_ray_cast_backfaces_functions(&mut world);
        
            register_ray_cast_visibility_functions(&mut world);
        
            register_mesh_picking_camera_functions(&mut world);
        
            register_mesh_picking_settings_functions(&mut world);
        
            register_pointer_input_plugin_functions(&mut world);
        
            register_pointer_button_functions(&mut world);
        
            register_pickable_functions(&mut world);
        
            register_picking_plugin_functions(&mut world);
        
            register_pointer_input_functions(&mut world);
        
            register_pointer_hits_functions(&mut world);
        
            register_picking_interaction_functions(&mut world);
        
            register_pointer_id_functions(&mut world);
        
            register_pointer_location_functions(&mut world);
        
            register_pointer_press_functions(&mut world);
        
            register_pointer_interaction_functions(&mut world);
        
            register_ray_id_functions(&mut world);
        
            register_cancel_functions(&mut world);
        
            register_click_functions(&mut world);
        
            register_pressed_functions(&mut world);
        
            register_drag_drop_functions(&mut world);
        
            register_drag_end_functions(&mut world);
        
            register_drag_enter_functions(&mut world);
        
            register_drag_functions(&mut world);
        
            register_drag_leave_functions(&mut world);
        
            register_drag_over_functions(&mut world);
        
            register_drag_start_functions(&mut world);
        
            register_move_functions(&mut world);
        
            register_out_functions(&mut world);
        
            register_over_functions(&mut world);
        
            register_released_functions(&mut world);
        
            register_scroll_functions(&mut world);
        
            register_hit_data_functions(&mut world);
        
            register_location_functions(&mut world);
        
            register_pointer_action_functions(&mut world);
        
            register_drag_entry_functions(&mut world);
        
            register_simplified_mesh_functions(&mut world);
        
            register_ray_mesh_hit_functions(&mut world);
        
            register_backfaces_functions(&mut world);
        
            register_press_direction_functions(&mut world);
        
    }
}
