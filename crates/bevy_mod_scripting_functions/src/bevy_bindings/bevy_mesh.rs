// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use bevy_mod_scripting_core::{
    bindings::{
        ReflectReference, 
        function::{from::{Ref, Mut, Val}, namespace::{NamespaceBuilder}}
    }
};
use bevy_ecs::{prelude::*};


use bevy_mod_scripting_derive::script_bindings;


use crate::*;







pub struct BevyMeshScriptingPlugin;


#[script_bindings(
    remote,
    name = "indices_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::Indices {


    
    fn clone (_self:Ref<::bevy_mesh::Indices>,) -> Val<::bevy_mesh::Indices> {
        let output: Val<::bevy_mesh::Indices> =<::bevy_mesh::Indices as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Returns `true` if there are no indices.
    
    fn is_empty (_self:Ref<::bevy_mesh::Indices>,) -> bool {
        let output: bool =::bevy_mesh::Indices::is_empty(&_self,).into();
        output
    }


    
    ///  Returns the number of indices.
    
    fn len (_self:Ref<::bevy_mesh::Indices>,) -> usize {
        let output: usize =::bevy_mesh::Indices::len(&_self,).into();
        output
    }


    
    ///  Add an index. If the index is greater than `u16::MAX`,
    
    ///  the storage will be converted to `u32`.
    
    fn push (mut _self:Mut<::bevy_mesh::Indices>,index:u32,) -> () {
        let output: () =::bevy_mesh::Indices::push(&mut _self,index,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "mesh_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::Mesh {


    
    fn clone (_self:Ref<::bevy_mesh::Mesh>,) -> Val<::bevy_mesh::Mesh> {
        let output: Val<::bevy_mesh::Mesh> =<::bevy_mesh::Mesh as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Calculates the [`Mesh::ATTRIBUTE_NORMAL`] of a mesh.
    
    ///  # Panics
    
    ///  Panics if [`Indices`] are set or [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
    
    ///  Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
    
    ///  Consider calling [`Mesh::duplicate_vertices`] or exporting your mesh with normal
    
    ///  attributes.
    
    ///  FIXME: This should handle more cases since this is called as a part of gltf
    
    ///  mesh loading where we can't really blame users for loading meshes that might
    
    ///  not conform to the limitations here!
    
    fn compute_flat_normals (mut _self:Mut<::bevy_mesh::Mesh>,) -> () {
        let output: () =::bevy_mesh::Mesh::compute_flat_normals(&mut _self,).into();
        output
    }


    
    ///  Calculates the [`Mesh::ATTRIBUTE_NORMAL`] of a mesh.
    
    ///  If the mesh is indexed, this defaults to smooth normals. Otherwise, it defaults to flat
    
    ///  normals.
    
    ///  # Panics
    
    ///  Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
    
    ///  Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
    
    ///  FIXME: This should handle more cases since this is called as a part of gltf
    
    ///  mesh loading where we can't really blame users for loading meshes that might
    
    ///  not conform to the limitations here!
    
    fn compute_normals (mut _self:Mut<::bevy_mesh::Mesh>,) -> () {
        let output: () =::bevy_mesh::Mesh::compute_normals(&mut _self,).into();
        output
    }


    
    ///  Calculates the [`Mesh::ATTRIBUTE_NORMAL`] of an indexed mesh, smoothing normals for shared
    
    ///  vertices.
    
    ///  # Panics
    
    ///  Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
    
    ///  Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
    
    ///  Panics if the mesh does not have indices defined.
    
    ///  FIXME: This should handle more cases since this is called as a part of gltf
    
    ///  mesh loading where we can't really blame users for loading meshes that might
    
    ///  not conform to the limitations here!
    
    fn compute_smooth_normals (mut _self:Mut<::bevy_mesh::Mesh>,) -> () {
        let output: () =::bevy_mesh::Mesh::compute_smooth_normals(&mut _self,).into();
        output
    }


    
    ///  Counts all vertices of the mesh.
    
    ///  If the attributes have different vertex counts, the smallest is returned.
    
    fn count_vertices (_self:Ref<::bevy_mesh::Mesh>,) -> usize {
        let output: usize =::bevy_mesh::Mesh::count_vertices(&_self,).into();
        output
    }


    
    ///  Computes and returns the vertex data of the mesh as bytes.
    
    ///  Therefore the attributes are located in the order of their [`MeshVertexAttribute::id`].
    
    ///  This is used to transform the vertex data into a GPU friendly format.
    
    ///  If the vertex attributes have different lengths, they are all truncated to
    
    ///  the length of the smallest.
    
    ///  This is a convenience method which allocates a Vec.
    
    ///  Prefer pre-allocating and using [`Mesh::write_packed_vertex_buffer_data`] when possible.
    
    fn create_packed_vertex_buffer_data (_self:Ref<::bevy_mesh::Mesh>,) -> ::std::vec::Vec<u8, ::std::alloc::Global> {
        let output: ::std::vec::Vec<u8, ::std::alloc::Global> =::bevy_mesh::Mesh::create_packed_vertex_buffer_data(&_self,).into();
        output
    }


    
    ///  Duplicates the vertex attributes so that no vertices are shared.
    
    ///  This can dramatically increase the vertex count, so make sure this is what you want.
    
    ///  Does nothing if no [Indices] are set.
    
    fn duplicate_vertices (mut _self:Mut<::bevy_mesh::Mesh>,) -> () {
        let output: () =::bevy_mesh::Mesh::duplicate_vertices(&mut _self,).into();
        output
    }


    
    ///  Returns the size required for the vertex buffer in bytes.
    
    fn get_vertex_buffer_size (_self:Ref<::bevy_mesh::Mesh>,) -> usize {
        let output: usize =::bevy_mesh::Mesh::get_vertex_buffer_size(&_self,).into();
        output
    }


    
    ///  Returns the size of a vertex in bytes.
    
    fn get_vertex_size (_self:Ref<::bevy_mesh::Mesh>,) -> u64 {
        let output: u64 =::bevy_mesh::Mesh::get_vertex_size(&_self,).into();
        output
    }


    
    ///  Whether this mesh has morph targets.
    
    fn has_morph_targets (_self:Ref<::bevy_mesh::Mesh>,) -> bool {
        let output: bool =::bevy_mesh::Mesh::has_morph_targets(&_self,).into();
        output
    }


    
    ///  Sets the vertex indices of the mesh. They describe how triangles are constructed out of the
    
    ///  vertex attributes and are therefore only useful for the [`PrimitiveTopology`] variants
    
    ///  that use triangles.
    
    fn insert_indices (mut _self:Mut<::bevy_mesh::Mesh>,indices:Val<::bevy_mesh::Indices>,) -> () {
        let output: () =::bevy_mesh::Mesh::insert_indices(&mut _self,indices.into_inner(),).into();
        output
    }


    
    ///  Normalize joint weights so they sum to 1.
    
    fn normalize_joint_weights (mut _self:Mut<::bevy_mesh::Mesh>,) -> () {
        let output: () =::bevy_mesh::Mesh::normalize_joint_weights(&mut _self,).into();
        output
    }


    
    ///  Rotates the vertex positions, normals, and tangents of the mesh in place by the given [`Quat`].
    
    ///  `Aabb` of entities with modified mesh are not updated automatically.
    
    fn rotate_by (mut _self:Mut<::bevy_mesh::Mesh>,rotation:Val<::bevy_math::Quat>,) -> () {
        let output: () =::bevy_mesh::Mesh::rotate_by(&mut _self,rotation.into_inner(),).into();
        output
    }


    
    ///  Rotates the vertex positions, normals, and tangents of the mesh by the given [`Quat`].
    
    ///  `Aabb` of entities with modified mesh are not updated automatically.
    
    fn rotated_by (_self:Val<::bevy_mesh::Mesh>,rotation:Val<::bevy_math::Quat>,) -> Val<::bevy_mesh::Mesh> {
        let output: Val<::bevy_mesh::Mesh> =::bevy_mesh::Mesh::rotated_by(_self.into_inner(),rotation.into_inner(),).into();
        output
    }


    
    ///  Scales the vertex positions, normals, and tangents of the mesh in place by the given [`Vec3`].
    
    ///  `Aabb` of entities with modified mesh are not updated automatically.
    
    fn scale_by (mut _self:Mut<::bevy_mesh::Mesh>,scale:Val<::bevy_math::Vec3>,) -> () {
        let output: () =::bevy_mesh::Mesh::scale_by(&mut _self,scale.into_inner(),).into();
        output
    }


    
    ///  Scales the vertex positions, normals, and tangents of the mesh by the given [`Vec3`].
    
    ///  `Aabb` of entities with modified mesh are not updated automatically.
    
    fn scaled_by (_self:Val<::bevy_mesh::Mesh>,scale:Val<::bevy_math::Vec3>,) -> Val<::bevy_mesh::Mesh> {
        let output: Val<::bevy_mesh::Mesh> =::bevy_mesh::Mesh::scaled_by(_self.into_inner(),scale.into_inner(),).into();
        output
    }


    
    ///  Sets the names of each morph target. This should correspond to the order of the morph targets in `set_morph_targets`.
    
    fn set_morph_target_names (mut _self:Mut<::bevy_mesh::Mesh>,names:::std::vec::Vec<::std::string::String, ::std::alloc::Global>,) -> () {
        let output: () =::bevy_mesh::Mesh::set_morph_target_names(&mut _self,names,).into();
        output
    }


    
    ///  Transforms the vertex positions, normals, and tangents of the mesh in place by the given [`Transform`].
    
    ///  `Aabb` of entities with modified mesh are not updated automatically.
    
    fn transform_by (mut _self:Mut<::bevy_mesh::Mesh>,transform:Val<::bevy_transform::components::Transform>,) -> () {
        let output: () =::bevy_mesh::Mesh::transform_by(&mut _self,transform.into_inner(),).into();
        output
    }


    
    ///  Transforms the vertex positions, normals, and tangents of the mesh by the given [`Transform`].
    
    ///  `Aabb` of entities with modified mesh are not updated automatically.
    
    fn transformed_by (_self:Val<::bevy_mesh::Mesh>,transform:Val<::bevy_transform::components::Transform>,) -> Val<::bevy_mesh::Mesh> {
        let output: Val<::bevy_mesh::Mesh> =::bevy_mesh::Mesh::transformed_by(_self.into_inner(),transform.into_inner(),).into();
        output
    }


    
    ///  Translates the vertex positions of the mesh in place by the given [`Vec3`].
    
    ///  `Aabb` of entities with modified mesh are not updated automatically.
    
    fn translate_by (mut _self:Mut<::bevy_mesh::Mesh>,translation:Val<::bevy_math::Vec3>,) -> () {
        let output: () =::bevy_mesh::Mesh::translate_by(&mut _self,translation.into_inner(),).into();
        output
    }


    
    ///  Translates the vertex positions of the mesh by the given [`Vec3`].
    
    ///  `Aabb` of entities with modified mesh are not updated automatically.
    
    fn translated_by (_self:Val<::bevy_mesh::Mesh>,translation:Val<::bevy_math::Vec3>,) -> Val<::bevy_mesh::Mesh> {
        let output: Val<::bevy_mesh::Mesh> =::bevy_mesh::Mesh::translated_by(_self.into_inner(),translation.into_inner(),).into();
        output
    }


    
    ///  Consumes the mesh and returns a mesh with calculated [`Mesh::ATTRIBUTE_NORMAL`].
    
    ///  (Alternatively, you can use [`Mesh::compute_flat_normals`] to mutate an existing mesh in-place)
    
    ///  # Panics
    
    ///  Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
    
    ///  Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
    
    ///  Panics if the mesh has indices defined
    
    fn with_computed_flat_normals (_self:Val<::bevy_mesh::Mesh>,) -> Val<::bevy_mesh::Mesh> {
        let output: Val<::bevy_mesh::Mesh> =::bevy_mesh::Mesh::with_computed_flat_normals(_self.into_inner(),).into();
        output
    }


    
    ///  Consumes the mesh and returns a mesh with calculated [`Mesh::ATTRIBUTE_NORMAL`].
    
    ///  If the mesh is indexed, this defaults to smooth normals. Otherwise, it defaults to flat
    
    ///  normals.
    
    ///  (Alternatively, you can use [`Mesh::compute_normals`] to mutate an existing mesh in-place)
    
    ///  # Panics
    
    ///  Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
    
    ///  Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
    
    fn with_computed_normals (_self:Val<::bevy_mesh::Mesh>,) -> Val<::bevy_mesh::Mesh> {
        let output: Val<::bevy_mesh::Mesh> =::bevy_mesh::Mesh::with_computed_normals(_self.into_inner(),).into();
        output
    }


    
    ///  Consumes the mesh and returns a mesh with calculated [`Mesh::ATTRIBUTE_NORMAL`].
    
    ///  (Alternatively, you can use [`Mesh::compute_smooth_normals`] to mutate an existing mesh in-place)
    
    ///  # Panics
    
    ///  Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
    
    ///  Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
    
    ///  Panics if the mesh does not have indices defined.
    
    fn with_computed_smooth_normals (_self:Val<::bevy_mesh::Mesh>,) -> Val<::bevy_mesh::Mesh> {
        let output: Val<::bevy_mesh::Mesh> =::bevy_mesh::Mesh::with_computed_smooth_normals(_self.into_inner(),).into();
        output
    }


    
    ///  Consumes the mesh and returns a mesh with no shared vertices.
    
    ///  This can dramatically increase the vertex count, so make sure this is what you want.
    
    ///  Does nothing if no [`Indices`] are set.
    
    ///  (Alternatively, you can use [`Mesh::duplicate_vertices`] to mutate an existing mesh in-place)
    
    fn with_duplicated_vertices (_self:Val<::bevy_mesh::Mesh>,) -> Val<::bevy_mesh::Mesh> {
        let output: Val<::bevy_mesh::Mesh> =::bevy_mesh::Mesh::with_duplicated_vertices(_self.into_inner(),).into();
        output
    }


    
    ///  Consumes the mesh and returns a mesh with the given vertex indices. They describe how triangles
    
    ///  are constructed out of the vertex attributes and are therefore only useful for the
    
    ///  [`PrimitiveTopology`] variants that use triangles.
    
    ///  (Alternatively, you can use [`Mesh::insert_indices`] to mutate an existing mesh in-place)
    
    fn with_inserted_indices (_self:Val<::bevy_mesh::Mesh>,indices:Val<::bevy_mesh::Indices>,) -> Val<::bevy_mesh::Mesh> {
        let output: Val<::bevy_mesh::Mesh> =::bevy_mesh::Mesh::with_inserted_indices(_self.into_inner(),indices.into_inner(),).into();
        output
    }


    
    ///  Consumes the mesh and returns a mesh with morph target names.
    
    ///  Names should correspond to the order of the morph targets in `set_morph_targets`.
    
    ///  (Alternatively, you can use [`Mesh::set_morph_target_names`] to mutate an existing mesh in-place)
    
    fn with_morph_target_names (_self:Val<::bevy_mesh::Mesh>,names:::std::vec::Vec<::std::string::String, ::std::alloc::Global>,) -> Val<::bevy_mesh::Mesh> {
        let output: Val<::bevy_mesh::Mesh> =::bevy_mesh::Mesh::with_morph_target_names(_self.into_inner(),names,).into();
        output
    }


    
    ///  Consumes the mesh and returns a mesh without the vertex `indices` of the mesh.
    
    ///  (Alternatively, you can use [`Mesh::remove_indices`] to mutate an existing mesh in-place)
    
    fn with_removed_indices (_self:Val<::bevy_mesh::Mesh>,) -> Val<::bevy_mesh::Mesh> {
        let output: Val<::bevy_mesh::Mesh> =::bevy_mesh::Mesh::with_removed_indices(_self.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "morph_weights_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::morph::MorphWeights {


    
    fn clone (_self:Ref<::bevy_mesh::morph::MorphWeights>,) -> Val<::bevy_mesh::morph::MorphWeights> {
        let output: Val<::bevy_mesh::morph::MorphWeights> =<::bevy_mesh::morph::MorphWeights as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "mesh_morph_weights_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::morph::MeshMorphWeights {


    
    fn clear_weights (mut _self:Mut<::bevy_mesh::morph::MeshMorphWeights>,) -> () {
        let output: () =::bevy_mesh::morph::MeshMorphWeights::clear_weights(&mut _self,).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_mesh::morph::MeshMorphWeights>,) -> Val<::bevy_mesh::morph::MeshMorphWeights> {
        let output: Val<::bevy_mesh::morph::MeshMorphWeights> =<::bevy_mesh::morph::MeshMorphWeights as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "circle_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::CircleMeshBuilder {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::CircleMeshBuilder>,) -> Val<::bevy_mesh::primitives::CircleMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::CircleMeshBuilder> =<::bevy_mesh::primitives::CircleMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new [`CircleMeshBuilder`] from a given radius and vertex count.
    
    fn new (radius:f32,resolution:u32,) -> Val<::bevy_mesh::primitives::CircleMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::CircleMeshBuilder> =::bevy_mesh::primitives::CircleMeshBuilder::new(radius,resolution,).into();
        output
    }


    
    ///  Sets the number of vertices used for the circle mesh.
    
    fn resolution (_self:Val<::bevy_mesh::primitives::CircleMeshBuilder>,resolution:u32,) -> Val<::bevy_mesh::primitives::CircleMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::CircleMeshBuilder> =::bevy_mesh::primitives::CircleMeshBuilder::resolution(_self.into_inner(),resolution,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "circular_mesh_uv_mode_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::CircularMeshUvMode {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::CircularMeshUvMode>,) -> Val<::bevy_mesh::primitives::CircularMeshUvMode> {
        let output: Val<::bevy_mesh::primitives::CircularMeshUvMode> =<::bevy_mesh::primitives::CircularMeshUvMode as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<::bevy_mesh::primitives::CircularMeshUvMode>,other:Ref<::bevy_mesh::primitives::CircularMeshUvMode>,) -> bool {
        let output: bool =<::bevy_mesh::primitives::CircularMeshUvMode as ::std::cmp::PartialEq::<::bevy_mesh::primitives::CircularMeshUvMode>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "circular_sector_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::CircularSectorMeshBuilder {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::CircularSectorMeshBuilder>,) -> Val<::bevy_mesh::primitives::CircularSectorMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::CircularSectorMeshBuilder> =<::bevy_mesh::primitives::CircularSectorMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new [`CircularSectorMeshBuilder`] from a given sector
    
    fn new (sector:Val<::bevy_math::primitives::CircularSector>,) -> Val<::bevy_mesh::primitives::CircularSectorMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::CircularSectorMeshBuilder> =::bevy_mesh::primitives::CircularSectorMeshBuilder::new(sector.into_inner(),).into();
        output
    }


    
    ///  Sets the number of vertices used for the sector mesh.
    
    fn resolution (_self:Val<::bevy_mesh::primitives::CircularSectorMeshBuilder>,resolution:u32,) -> Val<::bevy_mesh::primitives::CircularSectorMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::CircularSectorMeshBuilder> =::bevy_mesh::primitives::CircularSectorMeshBuilder::resolution(_self.into_inner(),resolution,).into();
        output
    }


    
    ///  Sets the uv mode used for the sector mesh
    
    fn uv_mode (_self:Val<::bevy_mesh::primitives::CircularSectorMeshBuilder>,uv_mode:Val<::bevy_mesh::primitives::CircularMeshUvMode>,) -> Val<::bevy_mesh::primitives::CircularSectorMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::CircularSectorMeshBuilder> =::bevy_mesh::primitives::CircularSectorMeshBuilder::uv_mode(_self.into_inner(),uv_mode.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "circular_segment_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::CircularSegmentMeshBuilder {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::CircularSegmentMeshBuilder>,) -> Val<::bevy_mesh::primitives::CircularSegmentMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::CircularSegmentMeshBuilder> =<::bevy_mesh::primitives::CircularSegmentMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new [`CircularSegmentMeshBuilder`] from a given segment
    
    fn new (segment:Val<::bevy_math::primitives::CircularSegment>,) -> Val<::bevy_mesh::primitives::CircularSegmentMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::CircularSegmentMeshBuilder> =::bevy_mesh::primitives::CircularSegmentMeshBuilder::new(segment.into_inner(),).into();
        output
    }


    
    ///  Sets the number of vertices used for the segment mesh.
    
    fn resolution (_self:Val<::bevy_mesh::primitives::CircularSegmentMeshBuilder>,resolution:u32,) -> Val<::bevy_mesh::primitives::CircularSegmentMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::CircularSegmentMeshBuilder> =::bevy_mesh::primitives::CircularSegmentMeshBuilder::resolution(_self.into_inner(),resolution,).into();
        output
    }


    
    ///  Sets the uv mode used for the segment mesh
    
    fn uv_mode (_self:Val<::bevy_mesh::primitives::CircularSegmentMeshBuilder>,uv_mode:Val<::bevy_mesh::primitives::CircularMeshUvMode>,) -> Val<::bevy_mesh::primitives::CircularSegmentMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::CircularSegmentMeshBuilder> =::bevy_mesh::primitives::CircularSegmentMeshBuilder::uv_mode(_self.into_inner(),uv_mode.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "regular_polygon_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::RegularPolygonMeshBuilder {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::RegularPolygonMeshBuilder>,) -> Val<::bevy_mesh::primitives::RegularPolygonMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::RegularPolygonMeshBuilder> =<::bevy_mesh::primitives::RegularPolygonMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new [`RegularPolygonMeshBuilder`] from the radius of a circumcircle and a number
    
    ///  of sides.
    
    ///  # Panics
    
    ///  Panics in debug mode if `circumradius` is negative, or if `sides` is less than 3.
    
    fn new (circumradius:f32,sides:u32,) -> Val<::bevy_mesh::primitives::RegularPolygonMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::RegularPolygonMeshBuilder> =::bevy_mesh::primitives::RegularPolygonMeshBuilder::new(circumradius,sides,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "ellipse_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::EllipseMeshBuilder {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::EllipseMeshBuilder>,) -> Val<::bevy_mesh::primitives::EllipseMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::EllipseMeshBuilder> =<::bevy_mesh::primitives::EllipseMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new [`EllipseMeshBuilder`] from a given half width and half height and a vertex count.
    
    fn new (half_width:f32,half_height:f32,resolution:u32,) -> Val<::bevy_mesh::primitives::EllipseMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::EllipseMeshBuilder> =::bevy_mesh::primitives::EllipseMeshBuilder::new(half_width,half_height,resolution,).into();
        output
    }


    
    ///  Sets the number of vertices used for the ellipse mesh.
    
    fn resolution (_self:Val<::bevy_mesh::primitives::EllipseMeshBuilder>,resolution:u32,) -> Val<::bevy_mesh::primitives::EllipseMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::EllipseMeshBuilder> =::bevy_mesh::primitives::EllipseMeshBuilder::resolution(_self.into_inner(),resolution,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "annulus_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::AnnulusMeshBuilder {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::AnnulusMeshBuilder>,) -> Val<::bevy_mesh::primitives::AnnulusMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::AnnulusMeshBuilder> =<::bevy_mesh::primitives::AnnulusMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Create an [`AnnulusMeshBuilder`] with the given inner radius, outer radius, and angular vertex count.
    
    fn new (inner_radius:f32,outer_radius:f32,resolution:u32,) -> Val<::bevy_mesh::primitives::AnnulusMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::AnnulusMeshBuilder> =::bevy_mesh::primitives::AnnulusMeshBuilder::new(inner_radius,outer_radius,resolution,).into();
        output
    }


    
    ///  Sets the number of vertices used in constructing the concentric circles of the annulus mesh.
    
    fn resolution (_self:Val<::bevy_mesh::primitives::AnnulusMeshBuilder>,resolution:u32,) -> Val<::bevy_mesh::primitives::AnnulusMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::AnnulusMeshBuilder> =::bevy_mesh::primitives::AnnulusMeshBuilder::resolution(_self.into_inner(),resolution,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "rhombus_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::RhombusMeshBuilder {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::RhombusMeshBuilder>,) -> Val<::bevy_mesh::primitives::RhombusMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::RhombusMeshBuilder> =<::bevy_mesh::primitives::RhombusMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new [`RhombusMeshBuilder`] from a horizontal and vertical diagonal size.
    
    ///  # Panics
    
    ///  Panics in debug mode if `horizontal_diagonal` or `vertical_diagonal` is negative.
    
    fn new (horizontal_diagonal:f32,vertical_diagonal:f32,) -> Val<::bevy_mesh::primitives::RhombusMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::RhombusMeshBuilder> =::bevy_mesh::primitives::RhombusMeshBuilder::new(horizontal_diagonal,vertical_diagonal,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "triangle_2_d_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::Triangle2dMeshBuilder {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::Triangle2dMeshBuilder>,) -> Val<::bevy_mesh::primitives::Triangle2dMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::Triangle2dMeshBuilder> =<::bevy_mesh::primitives::Triangle2dMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new [`Triangle2dMeshBuilder`] from the points `a`, `b`, and `c`.
    
    fn new (a:Val<::bevy_math::Vec2>,b:Val<::bevy_math::Vec2>,c:Val<::bevy_math::Vec2>,) -> Val<::bevy_mesh::primitives::Triangle2dMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::Triangle2dMeshBuilder> =::bevy_mesh::primitives::Triangle2dMeshBuilder::new(a.into_inner(),b.into_inner(),c.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "rectangle_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::RectangleMeshBuilder {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::RectangleMeshBuilder>,) -> Val<::bevy_mesh::primitives::RectangleMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::RectangleMeshBuilder> =<::bevy_mesh::primitives::RectangleMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new [`RectangleMeshBuilder`] from a full width and height.
    
    ///  # Panics
    
    ///  Panics in debug mode if `width` or `height` is negative.
    
    fn new (width:f32,height:f32,) -> Val<::bevy_mesh::primitives::RectangleMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::RectangleMeshBuilder> =::bevy_mesh::primitives::RectangleMeshBuilder::new(width,height,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "capsule_2_d_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::Capsule2dMeshBuilder {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::Capsule2dMeshBuilder>,) -> Val<::bevy_mesh::primitives::Capsule2dMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::Capsule2dMeshBuilder> =<::bevy_mesh::primitives::Capsule2dMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new [`Capsule2dMeshBuilder`] from a given radius, length, and the number of vertices
    
    ///  used for one hemicircle. The total number of vertices for the capsule mesh will be two times the resolution.
    
    fn new (radius:f32,length:f32,resolution:u32,) -> Val<::bevy_mesh::primitives::Capsule2dMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::Capsule2dMeshBuilder> =::bevy_mesh::primitives::Capsule2dMeshBuilder::new(radius,length,resolution,).into();
        output
    }


    
    ///  Sets the number of vertices used for one hemicircle.
    
    ///  The total number of vertices for the capsule mesh will be two times the resolution.
    
    fn resolution (_self:Val<::bevy_mesh::primitives::Capsule2dMeshBuilder>,resolution:u32,) -> Val<::bevy_mesh::primitives::Capsule2dMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::Capsule2dMeshBuilder> =::bevy_mesh::primitives::Capsule2dMeshBuilder::resolution(_self.into_inner(),resolution,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "capsule_uv_profile_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::CapsuleUvProfile {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::CapsuleUvProfile>,) -> Val<::bevy_mesh::primitives::CapsuleUvProfile> {
        let output: Val<::bevy_mesh::primitives::CapsuleUvProfile> =<::bevy_mesh::primitives::CapsuleUvProfile as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "capsule_3_d_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::Capsule3dMeshBuilder {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::Capsule3dMeshBuilder>,) -> Val<::bevy_mesh::primitives::Capsule3dMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::Capsule3dMeshBuilder> =<::bevy_mesh::primitives::Capsule3dMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Sets the number of horizontal lines subdividing the hemispheres of the capsule.
    
    fn latitudes (_self:Val<::bevy_mesh::primitives::Capsule3dMeshBuilder>,latitudes:u32,) -> Val<::bevy_mesh::primitives::Capsule3dMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::Capsule3dMeshBuilder> =::bevy_mesh::primitives::Capsule3dMeshBuilder::latitudes(_self.into_inner(),latitudes,).into();
        output
    }


    
    ///  Sets the number of vertical lines subdividing the hemispheres of the capsule.
    
    fn longitudes (_self:Val<::bevy_mesh::primitives::Capsule3dMeshBuilder>,longitudes:u32,) -> Val<::bevy_mesh::primitives::Capsule3dMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::Capsule3dMeshBuilder> =::bevy_mesh::primitives::Capsule3dMeshBuilder::longitudes(_self.into_inner(),longitudes,).into();
        output
    }


    
    ///  Creates a new [`Capsule3dMeshBuilder`] from a given radius, height, longitudes, and latitudes.
    
    ///  Note that `height` is the distance between the centers of the hemispheres.
    
    ///  `radius` will be added to both ends to get the real height of the mesh.
    
    fn new (radius:f32,height:f32,longitudes:u32,latitudes:u32,) -> Val<::bevy_mesh::primitives::Capsule3dMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::Capsule3dMeshBuilder> =::bevy_mesh::primitives::Capsule3dMeshBuilder::new(radius,height,longitudes,latitudes,).into();
        output
    }


    
    ///  Sets the number of horizontal lines subdividing the cylindrical part of the capsule.
    
    fn rings (_self:Val<::bevy_mesh::primitives::Capsule3dMeshBuilder>,rings:u32,) -> Val<::bevy_mesh::primitives::Capsule3dMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::Capsule3dMeshBuilder> =::bevy_mesh::primitives::Capsule3dMeshBuilder::rings(_self.into_inner(),rings,).into();
        output
    }


    
    ///  Sets the manner in which UV coordinates are distributed vertically.
    
    fn uv_profile (_self:Val<::bevy_mesh::primitives::Capsule3dMeshBuilder>,uv_profile:Val<::bevy_mesh::primitives::CapsuleUvProfile>,) -> Val<::bevy_mesh::primitives::Capsule3dMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::Capsule3dMeshBuilder> =::bevy_mesh::primitives::Capsule3dMeshBuilder::uv_profile(_self.into_inner(),uv_profile.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cone_anchor_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::ConeAnchor {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::ConeAnchor>,) -> Val<::bevy_mesh::primitives::ConeAnchor> {
        let output: Val<::bevy_mesh::primitives::ConeAnchor> =<::bevy_mesh::primitives::ConeAnchor as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cone_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::ConeMeshBuilder {


    
    ///  Sets a custom anchor point for the mesh
    
    fn anchor (_self:Val<::bevy_mesh::primitives::ConeMeshBuilder>,anchor:Val<::bevy_mesh::primitives::ConeAnchor>,) -> Val<::bevy_mesh::primitives::ConeMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::ConeMeshBuilder> =::bevy_mesh::primitives::ConeMeshBuilder::anchor(_self.into_inner(),anchor.into_inner(),).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_mesh::primitives::ConeMeshBuilder>,) -> Val<::bevy_mesh::primitives::ConeMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::ConeMeshBuilder> =<::bevy_mesh::primitives::ConeMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new [`ConeMeshBuilder`] from a given radius, height,
    
    ///  and number of vertices used for the base of the cone.
    
    fn new (radius:f32,height:f32,resolution:u32,) -> Val<::bevy_mesh::primitives::ConeMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::ConeMeshBuilder> =::bevy_mesh::primitives::ConeMeshBuilder::new(radius,height,resolution,).into();
        output
    }


    
    ///  Sets the number of vertices used for the base of the cone.
    
    fn resolution (_self:Val<::bevy_mesh::primitives::ConeMeshBuilder>,resolution:u32,) -> Val<::bevy_mesh::primitives::ConeMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::ConeMeshBuilder> =::bevy_mesh::primitives::ConeMeshBuilder::resolution(_self.into_inner(),resolution,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "conical_frustum_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::ConicalFrustumMeshBuilder {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::ConicalFrustumMeshBuilder>,) -> Val<::bevy_mesh::primitives::ConicalFrustumMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::ConicalFrustumMeshBuilder> =<::bevy_mesh::primitives::ConicalFrustumMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new [`ConicalFrustumMeshBuilder`] from the given top and bottom radii, a height,
    
    ///  and a resolution used for the top and bottom.
    
    fn new (radius_top:f32,radius_bottom:f32,height:f32,resolution:u32,) -> Val<::bevy_mesh::primitives::ConicalFrustumMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::ConicalFrustumMeshBuilder> =::bevy_mesh::primitives::ConicalFrustumMeshBuilder::new(radius_top,radius_bottom,height,resolution,).into();
        output
    }


    
    ///  Sets the number of vertices used for the top and bottom of the conical frustum.
    
    fn resolution (_self:Val<::bevy_mesh::primitives::ConicalFrustumMeshBuilder>,resolution:u32,) -> Val<::bevy_mesh::primitives::ConicalFrustumMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::ConicalFrustumMeshBuilder> =::bevy_mesh::primitives::ConicalFrustumMeshBuilder::resolution(_self.into_inner(),resolution,).into();
        output
    }


    
    ///  Sets the number of horizontal lines subdividing the lateral surface of the conical frustum.
    
    fn segments (_self:Val<::bevy_mesh::primitives::ConicalFrustumMeshBuilder>,segments:u32,) -> Val<::bevy_mesh::primitives::ConicalFrustumMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::ConicalFrustumMeshBuilder> =::bevy_mesh::primitives::ConicalFrustumMeshBuilder::segments(_self.into_inner(),segments,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cuboid_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::CuboidMeshBuilder {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::CuboidMeshBuilder>,) -> Val<::bevy_mesh::primitives::CuboidMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::CuboidMeshBuilder> =<::bevy_mesh::primitives::CuboidMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cylinder_anchor_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::CylinderAnchor {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::CylinderAnchor>,) -> Val<::bevy_mesh::primitives::CylinderAnchor> {
        let output: Val<::bevy_mesh::primitives::CylinderAnchor> =<::bevy_mesh::primitives::CylinderAnchor as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cylinder_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::CylinderMeshBuilder {


    
    ///  Sets a custom anchor point for the mesh
    
    fn anchor (_self:Val<::bevy_mesh::primitives::CylinderMeshBuilder>,anchor:Val<::bevy_mesh::primitives::CylinderAnchor>,) -> Val<::bevy_mesh::primitives::CylinderMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::CylinderMeshBuilder> =::bevy_mesh::primitives::CylinderMeshBuilder::anchor(_self.into_inner(),anchor.into_inner(),).into();
        output
    }


    
    fn clone (_self:Ref<::bevy_mesh::primitives::CylinderMeshBuilder>,) -> Val<::bevy_mesh::primitives::CylinderMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::CylinderMeshBuilder> =<::bevy_mesh::primitives::CylinderMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new [`CylinderMeshBuilder`] from the given radius, a height,
    
    ///  and a resolution used for the top and bottom.
    
    fn new (radius:f32,height:f32,resolution:u32,) -> Val<::bevy_mesh::primitives::CylinderMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::CylinderMeshBuilder> =::bevy_mesh::primitives::CylinderMeshBuilder::new(radius,height,resolution,).into();
        output
    }


    
    ///  Sets the number of vertices used for the top and bottom of the cylinder.
    
    fn resolution (_self:Val<::bevy_mesh::primitives::CylinderMeshBuilder>,resolution:u32,) -> Val<::bevy_mesh::primitives::CylinderMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::CylinderMeshBuilder> =::bevy_mesh::primitives::CylinderMeshBuilder::resolution(_self.into_inner(),resolution,).into();
        output
    }


    
    ///  Sets the number of segments along the height of the cylinder.
    
    ///  Must be greater than `0` for geometry to be generated.
    
    fn segments (_self:Val<::bevy_mesh::primitives::CylinderMeshBuilder>,segments:u32,) -> Val<::bevy_mesh::primitives::CylinderMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::CylinderMeshBuilder> =::bevy_mesh::primitives::CylinderMeshBuilder::segments(_self.into_inner(),segments,).into();
        output
    }


    
    ///  Ignore the cylinder caps, making the mesh a shallow tube instead
    
    fn without_caps (_self:Val<::bevy_mesh::primitives::CylinderMeshBuilder>,) -> Val<::bevy_mesh::primitives::CylinderMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::CylinderMeshBuilder> =::bevy_mesh::primitives::CylinderMeshBuilder::without_caps(_self.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "plane_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::PlaneMeshBuilder {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::PlaneMeshBuilder>,) -> Val<::bevy_mesh::primitives::PlaneMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::PlaneMeshBuilder> =<::bevy_mesh::primitives::PlaneMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new [`PlaneMeshBuilder`] from the given length, with the normal pointing upwards,
    
    ///  and the resulting [`PlaneMeshBuilder`] being a square.
    
    fn from_length (length:f32,) -> Val<::bevy_mesh::primitives::PlaneMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::PlaneMeshBuilder> =::bevy_mesh::primitives::PlaneMeshBuilder::from_length(length,).into();
        output
    }


    
    ///  Creates a new [`PlaneMeshBuilder`] from the given size, with the normal pointing upwards.
    
    fn from_size (size:Val<::bevy_math::Vec2>,) -> Val<::bevy_mesh::primitives::PlaneMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::PlaneMeshBuilder> =::bevy_mesh::primitives::PlaneMeshBuilder::from_size(size.into_inner(),).into();
        output
    }


    
    ///  Creates a new [`PlaneMeshBuilder`] from a given normal and size.
    
    fn new (normal:Val<::bevy_math::Dir3>,size:Val<::bevy_math::Vec2>,) -> Val<::bevy_mesh::primitives::PlaneMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::PlaneMeshBuilder> =::bevy_mesh::primitives::PlaneMeshBuilder::new(normal.into_inner(),size.into_inner(),).into();
        output
    }


    
    ///  Sets the normal of the plane, aka the direction the plane is facing.
    
    fn normal (_self:Val<::bevy_mesh::primitives::PlaneMeshBuilder>,normal:Val<::bevy_math::Dir3>,) -> Val<::bevy_mesh::primitives::PlaneMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::PlaneMeshBuilder> =::bevy_mesh::primitives::PlaneMeshBuilder::normal(_self.into_inner(),normal.into_inner(),).into();
        output
    }


    
    ///  Sets the size of the plane mesh.
    
    fn size (_self:Val<::bevy_mesh::primitives::PlaneMeshBuilder>,width:f32,height:f32,) -> Val<::bevy_mesh::primitives::PlaneMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::PlaneMeshBuilder> =::bevy_mesh::primitives::PlaneMeshBuilder::size(_self.into_inner(),width,height,).into();
        output
    }


    
    ///  Sets the subdivisions of the plane mesh.
    
    ///  0 - is the original plane geometry, the 4 points in the XZ plane.
    
    ///  1 - is split by 1 line in the middle of the plane on both the X axis and the Z axis,
    
    ///      resulting in a plane with 4 quads / 8 triangles.
    
    ///  2 - is a plane split by 2 lines on both the X and Z axes, subdividing the plane into 3
    
    ///      equal sections along each axis, resulting in a plane with 9 quads / 18 triangles.
    
    fn subdivisions (_self:Val<::bevy_mesh::primitives::PlaneMeshBuilder>,subdivisions:u32,) -> Val<::bevy_mesh::primitives::PlaneMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::PlaneMeshBuilder> =::bevy_mesh::primitives::PlaneMeshBuilder::subdivisions(_self.into_inner(),subdivisions,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "sphere_kind_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::SphereKind {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::SphereKind>,) -> Val<::bevy_mesh::primitives::SphereKind> {
        let output: Val<::bevy_mesh::primitives::SphereKind> =<::bevy_mesh::primitives::SphereKind as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "sphere_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::SphereMeshBuilder {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::SphereMeshBuilder>,) -> Val<::bevy_mesh::primitives::SphereMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::SphereMeshBuilder> =<::bevy_mesh::primitives::SphereMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Sets the [`SphereKind`] that will be used for building the mesh.
    
    fn kind (_self:Val<::bevy_mesh::primitives::SphereMeshBuilder>,kind:Val<::bevy_mesh::primitives::SphereKind>,) -> Val<::bevy_mesh::primitives::SphereMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::SphereMeshBuilder> =::bevy_mesh::primitives::SphereMeshBuilder::kind(_self.into_inner(),kind.into_inner(),).into();
        output
    }


    
    ///  Creates a new [`SphereMeshBuilder`] from a radius and [`SphereKind`].
    
    fn new (radius:f32,kind:Val<::bevy_mesh::primitives::SphereKind>,) -> Val<::bevy_mesh::primitives::SphereMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::SphereMeshBuilder> =::bevy_mesh::primitives::SphereMeshBuilder::new(radius,kind.into_inner(),).into();
        output
    }


    
    ///  Creates a UV sphere [`Mesh`] with the given number of
    
    ///  longitudinal sectors and latitudinal stacks, aka horizontal and vertical resolution.
    
    ///  A good default is `32` sectors and `18` stacks.
    
    fn uv (_self:Ref<::bevy_mesh::primitives::SphereMeshBuilder>,sectors:u32,stacks:u32,) -> Val<::bevy_mesh::Mesh> {
        let output: Val<::bevy_mesh::Mesh> =::bevy_mesh::primitives::SphereMeshBuilder::uv(&_self,sectors,stacks,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "tetrahedron_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::TetrahedronMeshBuilder {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::TetrahedronMeshBuilder>,) -> Val<::bevy_mesh::primitives::TetrahedronMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::TetrahedronMeshBuilder> =<::bevy_mesh::primitives::TetrahedronMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "torus_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::TorusMeshBuilder {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::TorusMeshBuilder>,) -> Val<::bevy_mesh::primitives::TorusMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::TorusMeshBuilder> =<::bevy_mesh::primitives::TorusMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Sets the number of segments used for the main ring of the torus.
    
    ///  A resolution of `4` would make the torus appear rectangular,
    
    ///  while a resolution of `32` resembles a circular ring.
    
    fn major_resolution (_self:Val<::bevy_mesh::primitives::TorusMeshBuilder>,resolution:usize,) -> Val<::bevy_mesh::primitives::TorusMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::TorusMeshBuilder> =::bevy_mesh::primitives::TorusMeshBuilder::major_resolution(_self.into_inner(),resolution,).into();
        output
    }


    
    ///  Sets the number of vertices used for each circular segment
    
    ///  in the ring or tube of the torus.
    
    fn minor_resolution (_self:Val<::bevy_mesh::primitives::TorusMeshBuilder>,resolution:usize,) -> Val<::bevy_mesh::primitives::TorusMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::TorusMeshBuilder> =::bevy_mesh::primitives::TorusMeshBuilder::minor_resolution(_self.into_inner(),resolution,).into();
        output
    }


    
    ///  Creates a new [`TorusMeshBuilder`] from an inner and outer radius.
    
    ///  The inner radius is the radius of the hole, and the outer radius
    
    ///  is the radius of the entire object.
    
    fn new (inner_radius:f32,outer_radius:f32,) -> Val<::bevy_mesh::primitives::TorusMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::TorusMeshBuilder> =::bevy_mesh::primitives::TorusMeshBuilder::new(inner_radius,outer_radius,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "triangle_3_d_mesh_builder_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::primitives::Triangle3dMeshBuilder {


    
    fn clone (_self:Ref<::bevy_mesh::primitives::Triangle3dMeshBuilder>,) -> Val<::bevy_mesh::primitives::Triangle3dMeshBuilder> {
        let output: Val<::bevy_mesh::primitives::Triangle3dMeshBuilder> =<::bevy_mesh::primitives::Triangle3dMeshBuilder as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "skinned_mesh_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_mesh::skinning::SkinnedMesh {


    
    fn clone (_self:Ref<::bevy_mesh::skinning::SkinnedMesh>,) -> Val<::bevy_mesh::skinning::SkinnedMesh> {
        let output: Val<::bevy_mesh::skinning::SkinnedMesh> =<::bevy_mesh::skinning::SkinnedMesh as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}


impl Plugin for BevyMeshScriptingPlugin {
    fn build(&self, app: &mut App) {
        let mut world = app.world_mut();

        
            register_indices_functions(&mut world);
        
            register_mesh_functions(&mut world);
        
            register_morph_weights_functions(&mut world);
        
            register_mesh_morph_weights_functions(&mut world);
        
            register_circle_mesh_builder_functions(&mut world);
        
            register_circular_mesh_uv_mode_functions(&mut world);
        
            register_circular_sector_mesh_builder_functions(&mut world);
        
            register_circular_segment_mesh_builder_functions(&mut world);
        
            register_regular_polygon_mesh_builder_functions(&mut world);
        
            register_ellipse_mesh_builder_functions(&mut world);
        
            register_annulus_mesh_builder_functions(&mut world);
        
            register_rhombus_mesh_builder_functions(&mut world);
        
            register_triangle_2_d_mesh_builder_functions(&mut world);
        
            register_rectangle_mesh_builder_functions(&mut world);
        
            register_capsule_2_d_mesh_builder_functions(&mut world);
        
            register_capsule_uv_profile_functions(&mut world);
        
            register_capsule_3_d_mesh_builder_functions(&mut world);
        
            register_cone_anchor_functions(&mut world);
        
            register_cone_mesh_builder_functions(&mut world);
        
            register_conical_frustum_mesh_builder_functions(&mut world);
        
            register_cuboid_mesh_builder_functions(&mut world);
        
            register_cylinder_anchor_functions(&mut world);
        
            register_cylinder_mesh_builder_functions(&mut world);
        
            register_plane_mesh_builder_functions(&mut world);
        
            register_sphere_kind_functions(&mut world);
        
            register_sphere_mesh_builder_functions(&mut world);
        
            register_tetrahedron_mesh_builder_functions(&mut world);
        
            register_torus_mesh_builder_functions(&mut world);
        
            register_triangle_3_d_mesh_builder_functions(&mut world);
        
            register_skinned_mesh_functions(&mut world);
        
    }
}
