// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use bevy_mod_scripting_core::{
    bindings::{
        ReflectReference, 
        function::{from::{Ref, Mut, Val}, namespace::{NamespaceBuilder}}
    }
};

use bevy_mod_scripting_derive::script_bindings;


use crate::*;







pub struct BevyWindowScriptingPlugin;


#[script_bindings(
    remote,
    name = "cursor_entered_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::prelude::CursorEntered {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::prelude::CursorEntered>,) -> () {
        let output: () =<bevy::window::prelude::CursorEntered as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::prelude::CursorEntered>,) -> Val<bevy::window::prelude::CursorEntered> {
        let output: Val<bevy::window::prelude::CursorEntered> =<bevy::window::prelude::CursorEntered as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::prelude::CursorEntered>,other:Ref<bevy::window::prelude::CursorEntered>,) -> bool {
        let output: bool =<bevy::window::prelude::CursorEntered as ::core::cmp::PartialEq::<bevy::window::prelude::CursorEntered>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cursor_left_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::prelude::CursorLeft {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::prelude::CursorLeft>,) -> () {
        let output: () =<bevy::window::prelude::CursorLeft as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::prelude::CursorLeft>,) -> Val<bevy::window::prelude::CursorLeft> {
        let output: Val<bevy::window::prelude::CursorLeft> =<bevy::window::prelude::CursorLeft as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::prelude::CursorLeft>,other:Ref<bevy::window::prelude::CursorLeft>,) -> bool {
        let output: bool =<bevy::window::prelude::CursorLeft as ::core::cmp::PartialEq::<bevy::window::prelude::CursorLeft>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cursor_moved_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::prelude::CursorMoved {


    
    fn clone (_self:Ref<bevy::window::prelude::CursorMoved>,) -> Val<bevy::window::prelude::CursorMoved> {
        let output: Val<bevy::window::prelude::CursorMoved> =<bevy::window::prelude::CursorMoved as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::prelude::CursorMoved>,other:Ref<bevy::window::prelude::CursorMoved>,) -> bool {
        let output: bool =<bevy::window::prelude::CursorMoved as ::core::cmp::PartialEq::<bevy::window::prelude::CursorMoved>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "file_drag_and_drop_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::prelude::FileDragAndDrop {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::prelude::FileDragAndDrop>,) -> () {
        let output: () =<bevy::window::prelude::FileDragAndDrop as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::prelude::FileDragAndDrop>,) -> Val<bevy::window::prelude::FileDragAndDrop> {
        let output: Val<bevy::window::prelude::FileDragAndDrop> =<bevy::window::prelude::FileDragAndDrop as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::prelude::FileDragAndDrop>,other:Ref<bevy::window::prelude::FileDragAndDrop>,) -> bool {
        let output: bool =<bevy::window::prelude::FileDragAndDrop as ::core::cmp::PartialEq::<bevy::window::prelude::FileDragAndDrop>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "ime_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::prelude::Ime {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::prelude::Ime>,) -> () {
        let output: () =<bevy::window::prelude::Ime as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::prelude::Ime>,) -> Val<bevy::window::prelude::Ime> {
        let output: Val<bevy::window::prelude::Ime> =<bevy::window::prelude::Ime as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::prelude::Ime>,other:Ref<bevy::window::prelude::Ime>,) -> bool {
        let output: bool =<bevy::window::prelude::Ime as ::core::cmp::PartialEq::<bevy::window::prelude::Ime>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "monitor_selection_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::prelude::MonitorSelection {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::prelude::MonitorSelection>,) -> () {
        let output: () =<bevy::window::prelude::MonitorSelection as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::prelude::MonitorSelection>,) -> Val<bevy::window::prelude::MonitorSelection> {
        let output: Val<bevy::window::prelude::MonitorSelection> =<bevy::window::prelude::MonitorSelection as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::prelude::MonitorSelection>,other:Ref<bevy::window::prelude::MonitorSelection>,) -> bool {
        let output: bool =<bevy::window::prelude::MonitorSelection as ::core::cmp::PartialEq::<bevy::window::prelude::MonitorSelection>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "video_mode_selection_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::prelude::VideoModeSelection {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::prelude::VideoModeSelection>,) -> () {
        let output: () =<bevy::window::prelude::VideoModeSelection as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::prelude::VideoModeSelection>,) -> Val<bevy::window::prelude::VideoModeSelection> {
        let output: Val<bevy::window::prelude::VideoModeSelection> =<bevy::window::prelude::VideoModeSelection as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::prelude::VideoModeSelection>,other:Ref<bevy::window::prelude::VideoModeSelection>,) -> bool {
        let output: bool =<bevy::window::prelude::VideoModeSelection as ::core::cmp::PartialEq::<bevy::window::prelude::VideoModeSelection>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::prelude::Window {


    
    fn clone (_self:Ref<bevy::window::prelude::Window>,) -> Val<bevy::window::prelude::Window> {
        let output: Val<bevy::window::prelude::Window> =<bevy::window::prelude::Window as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  The window's client area height in logical pixels.
    
    ///  See [`WindowResolution`] for an explanation about logical/physical sizes.
    
    fn height (_self:Ref<bevy::window::prelude::Window>,) -> f32 {
        let output: f32 =bevy::window::prelude::Window::height(&_self,).into();
        output
    }


    
    ///  The window's client area height in physical pixels.
    
    ///  See [`WindowResolution`] for an explanation about logical/physical sizes.
    
    fn physical_height (_self:Ref<bevy::window::prelude::Window>,) -> u32 {
        let output: u32 =bevy::window::prelude::Window::physical_height(&_self,).into();
        output
    }


    
    ///  The window's client size in physical pixels
    
    ///  See [`WindowResolution`] for an explanation about logical/physical sizes.
    
    fn physical_size (_self:Ref<bevy::window::prelude::Window>,) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> =bevy::window::prelude::Window::physical_size(&_self,).into();
        output
    }


    
    ///  The window's client area width in physical pixels.
    
    ///  See [`WindowResolution`] for an explanation about logical/physical sizes.
    
    fn physical_width (_self:Ref<bevy::window::prelude::Window>,) -> u32 {
        let output: u32 =bevy::window::prelude::Window::physical_width(&_self,).into();
        output
    }


    
    ///  The window's scale factor.
    
    ///  Ratio of physical size to logical size, see [`WindowResolution`].
    
    fn scale_factor (_self:Ref<bevy::window::prelude::Window>,) -> f32 {
        let output: f32 =bevy::window::prelude::Window::scale_factor(&_self,).into();
        output
    }


    
    ///  Setting to true will attempt to maximize the window.
    
    ///  Setting to false will attempt to un-maximize the window.
    
    fn set_maximized (mut _self:Mut<bevy::window::prelude::Window>,maximized:bool,) -> () {
        let output: () =bevy::window::prelude::Window::set_maximized(&mut _self,maximized,).into();
        output
    }


    
    ///  Setting to true will attempt to minimize the window.
    
    ///  Setting to false will attempt to un-minimize the window.
    
    fn set_minimized (mut _self:Mut<bevy::window::prelude::Window>,minimized:bool,) -> () {
        let output: () =bevy::window::prelude::Window::set_minimized(&mut _self,minimized,).into();
        output
    }


    
    ///  The window's client size in logical pixels
    
    ///  See [`WindowResolution`] for an explanation about logical/physical sizes.
    
    fn size (_self:Ref<bevy::window::prelude::Window>,) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> =bevy::window::prelude::Window::size(&_self,).into();
        output
    }


    
    ///  Calling this will attempt to start a drag-move of the window.
    
    ///  There is no guarantee that this will work unless the left mouse button was
    
    ///  pressed immediately before this function was called.
    
    fn start_drag_move (mut _self:Mut<bevy::window::prelude::Window>,) -> () {
        let output: () =bevy::window::prelude::Window::start_drag_move(&mut _self,).into();
        output
    }


    
    ///  Calling this will attempt to start a drag-resize of the window.
    
    ///  There is no guarantee that this will work unless the left mouse button was
    
    ///  pressed immediately before this function was called.
    
    fn start_drag_resize (mut _self:Mut<bevy::window::prelude::Window>,direction:Val<bevy::math::CompassOctant>,) -> () {
        let output: () =bevy::window::prelude::Window::start_drag_resize(&mut _self,direction.into_inner(),).into();
        output
    }


    
    ///  The window's client area width in logical pixels.
    
    ///  See [`WindowResolution`] for an explanation about logical/physical sizes.
    
    fn width (_self:Ref<bevy::window::prelude::Window>,) -> f32 {
        let output: f32 =bevy::window::prelude::Window::width(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_moved_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::prelude::WindowMoved {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::prelude::WindowMoved>,) -> () {
        let output: () =<bevy::window::prelude::WindowMoved as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::prelude::WindowMoved>,) -> Val<bevy::window::prelude::WindowMoved> {
        let output: Val<bevy::window::prelude::WindowMoved> =<bevy::window::prelude::WindowMoved as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::prelude::WindowMoved>,other:Ref<bevy::window::prelude::WindowMoved>,) -> bool {
        let output: bool =<bevy::window::prelude::WindowMoved as ::core::cmp::PartialEq::<bevy::window::prelude::WindowMoved>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_position_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::prelude::WindowPosition {


    
    ///  Set the window to a specific monitor.
    
    fn center (mut _self:Mut<bevy::window::prelude::WindowPosition>,monitor:Val<bevy::window::prelude::MonitorSelection>,) -> () {
        let output: () =bevy::window::prelude::WindowPosition::center(&mut _self,monitor.into_inner(),).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::prelude::WindowPosition>,) -> Val<bevy::window::prelude::WindowPosition> {
        let output: Val<bevy::window::prelude::WindowPosition> =<bevy::window::prelude::WindowPosition as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::prelude::WindowPosition>,other:Ref<bevy::window::prelude::WindowPosition>,) -> bool {
        let output: bool =<bevy::window::prelude::WindowPosition as ::core::cmp::PartialEq::<bevy::window::prelude::WindowPosition>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Creates a new [`WindowPosition`] at a position.
    
    fn new (position:Val<bevy::math::IVec2>,) -> Val<bevy::window::prelude::WindowPosition> {
        let output: Val<bevy::window::prelude::WindowPosition> =bevy::window::prelude::WindowPosition::new(position.into_inner(),).into();
        output
    }


    
    ///  Set the position to a specific point.
    
    fn set (mut _self:Mut<bevy::window::prelude::WindowPosition>,position:Val<bevy::math::IVec2>,) -> () {
        let output: () =bevy::window::prelude::WindowPosition::set(&mut _self,position.into_inner(),).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_resize_constraints_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::prelude::WindowResizeConstraints {


    
    ///  Checks if the constraints are valid.
    
    ///  Will output warnings if it isn't.
    
    fn check_constraints (_self:Ref<bevy::window::prelude::WindowResizeConstraints>,) -> Val<bevy::window::prelude::WindowResizeConstraints> {
        let output: Val<bevy::window::prelude::WindowResizeConstraints> =bevy::window::prelude::WindowResizeConstraints::check_constraints(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::prelude::WindowResizeConstraints>,) -> Val<bevy::window::prelude::WindowResizeConstraints> {
        let output: Val<bevy::window::prelude::WindowResizeConstraints> =<bevy::window::prelude::WindowResizeConstraints as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::prelude::WindowResizeConstraints>,other:Ref<bevy::window::prelude::WindowResizeConstraints>,) -> bool {
        let output: bool =<bevy::window::prelude::WindowResizeConstraints as ::core::cmp::PartialEq::<bevy::window::prelude::WindowResizeConstraints>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_event_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::WindowEvent {


    
    fn clone (_self:Ref<bevy::window::WindowEvent>,) -> Val<bevy::window::WindowEvent> {
        let output: Val<bevy::window::WindowEvent> =<bevy::window::WindowEvent as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::WindowEvent>,other:Ref<bevy::window::WindowEvent>,) -> bool {
        let output: bool =<bevy::window::WindowEvent as ::core::cmp::PartialEq::<bevy::window::WindowEvent>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_resized_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::WindowResized {


    
    fn clone (_self:Ref<bevy::window::WindowResized>,) -> Val<bevy::window::WindowResized> {
        let output: Val<bevy::window::WindowResized> =<bevy::window::WindowResized as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::WindowResized>,other:Ref<bevy::window::WindowResized>,) -> bool {
        let output: bool =<bevy::window::WindowResized as ::core::cmp::PartialEq::<bevy::window::WindowResized>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_created_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::WindowCreated {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::WindowCreated>,) -> () {
        let output: () =<bevy::window::WindowCreated as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::WindowCreated>,) -> Val<bevy::window::WindowCreated> {
        let output: Val<bevy::window::WindowCreated> =<bevy::window::WindowCreated as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::WindowCreated>,other:Ref<bevy::window::WindowCreated>,) -> bool {
        let output: bool =<bevy::window::WindowCreated as ::core::cmp::PartialEq::<bevy::window::WindowCreated>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_closing_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::WindowClosing {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::WindowClosing>,) -> () {
        let output: () =<bevy::window::WindowClosing as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::WindowClosing>,) -> Val<bevy::window::WindowClosing> {
        let output: Val<bevy::window::WindowClosing> =<bevy::window::WindowClosing as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::WindowClosing>,other:Ref<bevy::window::WindowClosing>,) -> bool {
        let output: bool =<bevy::window::WindowClosing as ::core::cmp::PartialEq::<bevy::window::WindowClosing>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_closed_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::WindowClosed {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::WindowClosed>,) -> () {
        let output: () =<bevy::window::WindowClosed as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::WindowClosed>,) -> Val<bevy::window::WindowClosed> {
        let output: Val<bevy::window::WindowClosed> =<bevy::window::WindowClosed as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::WindowClosed>,other:Ref<bevy::window::WindowClosed>,) -> bool {
        let output: bool =<bevy::window::WindowClosed as ::core::cmp::PartialEq::<bevy::window::WindowClosed>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_close_requested_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::WindowCloseRequested {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::WindowCloseRequested>,) -> () {
        let output: () =<bevy::window::WindowCloseRequested as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::WindowCloseRequested>,) -> Val<bevy::window::WindowCloseRequested> {
        let output: Val<bevy::window::WindowCloseRequested> =<bevy::window::WindowCloseRequested as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::WindowCloseRequested>,other:Ref<bevy::window::WindowCloseRequested>,) -> bool {
        let output: bool =<bevy::window::WindowCloseRequested as ::core::cmp::PartialEq::<bevy::window::WindowCloseRequested>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_destroyed_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::WindowDestroyed {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::WindowDestroyed>,) -> () {
        let output: () =<bevy::window::WindowDestroyed as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::WindowDestroyed>,) -> Val<bevy::window::WindowDestroyed> {
        let output: Val<bevy::window::WindowDestroyed> =<bevy::window::WindowDestroyed as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::WindowDestroyed>,other:Ref<bevy::window::WindowDestroyed>,) -> bool {
        let output: bool =<bevy::window::WindowDestroyed as ::core::cmp::PartialEq::<bevy::window::WindowDestroyed>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "request_redraw_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::RequestRedraw {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::RequestRedraw>,) -> () {
        let output: () =<bevy::window::RequestRedraw as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::RequestRedraw>,) -> Val<bevy::window::RequestRedraw> {
        let output: Val<bevy::window::RequestRedraw> =<bevy::window::RequestRedraw as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::RequestRedraw>,other:Ref<bevy::window::RequestRedraw>,) -> bool {
        let output: bool =<bevy::window::RequestRedraw as ::core::cmp::PartialEq::<bevy::window::RequestRedraw>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_focused_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::WindowFocused {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::WindowFocused>,) -> () {
        let output: () =<bevy::window::WindowFocused as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::WindowFocused>,) -> Val<bevy::window::WindowFocused> {
        let output: Val<bevy::window::WindowFocused> =<bevy::window::WindowFocused as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::WindowFocused>,other:Ref<bevy::window::WindowFocused>,) -> bool {
        let output: bool =<bevy::window::WindowFocused as ::core::cmp::PartialEq::<bevy::window::WindowFocused>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_occluded_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::WindowOccluded {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::WindowOccluded>,) -> () {
        let output: () =<bevy::window::WindowOccluded as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::WindowOccluded>,) -> Val<bevy::window::WindowOccluded> {
        let output: Val<bevy::window::WindowOccluded> =<bevy::window::WindowOccluded as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::WindowOccluded>,other:Ref<bevy::window::WindowOccluded>,) -> bool {
        let output: bool =<bevy::window::WindowOccluded as ::core::cmp::PartialEq::<bevy::window::WindowOccluded>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_scale_factor_changed_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::WindowScaleFactorChanged {


    
    fn clone (_self:Ref<bevy::window::WindowScaleFactorChanged>,) -> Val<bevy::window::WindowScaleFactorChanged> {
        let output: Val<bevy::window::WindowScaleFactorChanged> =<bevy::window::WindowScaleFactorChanged as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::WindowScaleFactorChanged>,other:Ref<bevy::window::WindowScaleFactorChanged>,) -> bool {
        let output: bool =<bevy::window::WindowScaleFactorChanged as ::core::cmp::PartialEq::<bevy::window::WindowScaleFactorChanged>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_backend_scale_factor_changed_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::WindowBackendScaleFactorChanged {


    
    fn clone (_self:Ref<bevy::window::WindowBackendScaleFactorChanged>,) -> Val<bevy::window::WindowBackendScaleFactorChanged> {
        let output: Val<bevy::window::WindowBackendScaleFactorChanged> =<bevy::window::WindowBackendScaleFactorChanged as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::WindowBackendScaleFactorChanged>,other:Ref<bevy::window::WindowBackendScaleFactorChanged>,) -> bool {
        let output: bool =<bevy::window::WindowBackendScaleFactorChanged as ::core::cmp::PartialEq::<bevy::window::WindowBackendScaleFactorChanged>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_theme_changed_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::WindowThemeChanged {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::WindowThemeChanged>,) -> () {
        let output: () =<bevy::window::WindowThemeChanged as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::WindowThemeChanged>,) -> Val<bevy::window::WindowThemeChanged> {
        let output: Val<bevy::window::WindowThemeChanged> =<bevy::window::WindowThemeChanged as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::WindowThemeChanged>,other:Ref<bevy::window::WindowThemeChanged>,) -> bool {
        let output: bool =<bevy::window::WindowThemeChanged as ::core::cmp::PartialEq::<bevy::window::WindowThemeChanged>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "app_lifecycle_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::AppLifecycle {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::AppLifecycle>,) -> () {
        let output: () =<bevy::window::AppLifecycle as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::AppLifecycle>,) -> Val<bevy::window::AppLifecycle> {
        let output: Val<bevy::window::AppLifecycle> =<bevy::window::AppLifecycle as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::AppLifecycle>,other:Ref<bevy::window::AppLifecycle>,) -> bool {
        let output: bool =<bevy::window::AppLifecycle as ::core::cmp::PartialEq::<bevy::window::AppLifecycle>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Return `true` if the app can be updated.
    
    fn is_active (_self:Ref<bevy::window::AppLifecycle>,) -> bool {
        let output: bool =bevy::window::AppLifecycle::is_active(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "primary_window_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::PrimaryWindow {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::PrimaryWindow>,) -> () {
        let output: () =<bevy::window::PrimaryWindow as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::PrimaryWindow>,) -> Val<bevy::window::PrimaryWindow> {
        let output: Val<bevy::window::PrimaryWindow> =<bevy::window::PrimaryWindow as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::PrimaryWindow>,other:Ref<bevy::window::PrimaryWindow>,) -> bool {
        let output: bool =<bevy::window::PrimaryWindow as ::core::cmp::PartialEq::<bevy::window::PrimaryWindow>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "monitor_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::Monitor {


    
    fn clone (_self:Ref<bevy::window::Monitor>,) -> Val<bevy::window::Monitor> {
        let output: Val<bevy::window::Monitor> =<bevy::window::Monitor as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Returns the physical size of the monitor in pixels
    
    fn physical_size (_self:Ref<bevy::window::Monitor>,) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> =bevy::window::Monitor::physical_size(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_theme_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::WindowTheme {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::WindowTheme>,) -> () {
        let output: () =<bevy::window::WindowTheme as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::WindowTheme>,) -> Val<bevy::window::WindowTheme> {
        let output: Val<bevy::window::WindowTheme> =<bevy::window::WindowTheme as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::WindowTheme>,other:Ref<bevy::window::WindowTheme>,) -> bool {
        let output: bool =<bevy::window::WindowTheme as ::core::cmp::PartialEq::<bevy::window::WindowTheme>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "video_mode_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::VideoMode {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::VideoMode>,) -> () {
        let output: () =<bevy::window::VideoMode as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::VideoMode>,) -> Val<bevy::window::VideoMode> {
        let output: Val<bevy::window::VideoMode> =<bevy::window::VideoMode as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::VideoMode>,other:Ref<bevy::window::VideoMode>,) -> bool {
        let output: bool =<bevy::window::VideoMode as ::core::cmp::PartialEq::<bevy::window::VideoMode>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "primary_monitor_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::PrimaryMonitor {


    
    fn clone (_self:Ref<bevy::window::PrimaryMonitor>,) -> Val<bevy::window::PrimaryMonitor> {
        let output: Val<bevy::window::PrimaryMonitor> =<bevy::window::PrimaryMonitor as ::core::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "system_cursor_icon_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::SystemCursorIcon {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::SystemCursorIcon>,) -> () {
        let output: () =<bevy::window::SystemCursorIcon as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::SystemCursorIcon>,) -> Val<bevy::window::SystemCursorIcon> {
        let output: Val<bevy::window::SystemCursorIcon> =<bevy::window::SystemCursorIcon as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::SystemCursorIcon>,other:Ref<bevy::window::SystemCursorIcon>,) -> bool {
        let output: bool =<bevy::window::SystemCursorIcon as ::core::cmp::PartialEq::<bevy::window::SystemCursorIcon>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_ref_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::WindowRef {


    
    fn clone (_self:Ref<bevy::window::WindowRef>,) -> Val<bevy::window::WindowRef> {
        let output: Val<bevy::window::WindowRef> =<bevy::window::WindowRef as ::core::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "normalized_window_ref_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::NormalizedWindowRef {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::NormalizedWindowRef>,) -> () {
        let output: () =<bevy::window::NormalizedWindowRef as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::NormalizedWindowRef>,) -> Val<bevy::window::NormalizedWindowRef> {
        let output: Val<bevy::window::NormalizedWindowRef> =<bevy::window::NormalizedWindowRef as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::NormalizedWindowRef>,other:Ref<bevy::window::NormalizedWindowRef>,) -> bool {
        let output: bool =<bevy::window::NormalizedWindowRef as ::core::cmp::PartialEq::<bevy::window::NormalizedWindowRef>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cursor_options_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::CursorOptions {


    
    fn clone (_self:Ref<bevy::window::CursorOptions>,) -> Val<bevy::window::CursorOptions> {
        let output: Val<bevy::window::CursorOptions> =<bevy::window::CursorOptions as ::core::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "present_mode_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::PresentMode {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::PresentMode>,) -> () {
        let output: () =<bevy::window::PresentMode as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::PresentMode>,) -> Val<bevy::window::PresentMode> {
        let output: Val<bevy::window::PresentMode> =<bevy::window::PresentMode as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::PresentMode>,other:Ref<bevy::window::PresentMode>,) -> bool {
        let output: bool =<bevy::window::PresentMode as ::core::cmp::PartialEq::<bevy::window::PresentMode>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_mode_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::WindowMode {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::WindowMode>,) -> () {
        let output: () =<bevy::window::WindowMode as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::WindowMode>,) -> Val<bevy::window::WindowMode> {
        let output: Val<bevy::window::WindowMode> =<bevy::window::WindowMode as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::WindowMode>,other:Ref<bevy::window::WindowMode>,) -> bool {
        let output: bool =<bevy::window::WindowMode as ::core::cmp::PartialEq::<bevy::window::WindowMode>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_resolution_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::WindowResolution {


    
    ///  The window scale factor as reported by the window backend.
    
    ///  This value is unaffected by [`WindowResolution::scale_factor_override`].
    
    fn base_scale_factor (_self:Ref<bevy::window::WindowResolution>,) -> f32 {
        let output: f32 =bevy::window::WindowResolution::base_scale_factor(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::WindowResolution>,) -> Val<bevy::window::WindowResolution> {
        let output: Val<bevy::window::WindowResolution> =<bevy::window::WindowResolution as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::WindowResolution>,other:Ref<bevy::window::WindowResolution>,) -> bool {
        let output: bool =<bevy::window::WindowResolution as ::core::cmp::PartialEq::<bevy::window::WindowResolution>>::eq(&_self,&other,).into();
        output
    }


    
    ///  The window's client area height in logical pixels.
    
    fn height (_self:Ref<bevy::window::WindowResolution>,) -> f32 {
        let output: f32 =bevy::window::WindowResolution::height(&_self,).into();
        output
    }


    
    ///  Creates a new [`WindowResolution`].
    
    fn new (physical_width:f32,physical_height:f32,) -> Val<bevy::window::WindowResolution> {
        let output: Val<bevy::window::WindowResolution> =bevy::window::WindowResolution::new(physical_width,physical_height,).into();
        output
    }


    
    ///  The window's client area height in physical pixels.
    
    fn physical_height (_self:Ref<bevy::window::WindowResolution>,) -> u32 {
        let output: u32 =bevy::window::WindowResolution::physical_height(&_self,).into();
        output
    }


    
    ///  The window's client size in physical pixels
    
    fn physical_size (_self:Ref<bevy::window::WindowResolution>,) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> =bevy::window::WindowResolution::physical_size(&_self,).into();
        output
    }


    
    ///  The window's client area width in physical pixels.
    
    fn physical_width (_self:Ref<bevy::window::WindowResolution>,) -> u32 {
        let output: u32 =bevy::window::WindowResolution::physical_width(&_self,).into();
        output
    }


    
    ///  The ratio of physical pixels to logical pixels.
    
    ///  `physical_pixels = logical_pixels * scale_factor`
    
    fn scale_factor (_self:Ref<bevy::window::WindowResolution>,) -> f32 {
        let output: f32 =bevy::window::WindowResolution::scale_factor(&_self,).into();
        output
    }


    
    ///  The scale factor set with [`WindowResolution::set_scale_factor_override`].
    
    ///  This value may be different from the scale factor reported by the window backend.
    
    fn scale_factor_override (_self:Ref<bevy::window::WindowResolution>,) -> ::core::option::Option<f32> {
        let output: ::core::option::Option<f32> =bevy::window::WindowResolution::scale_factor_override(&_self,).into();
        output
    }


    
    ///  Set the window's logical resolution.
    
    fn set (mut _self:Mut<bevy::window::WindowResolution>,width:f32,height:f32,) -> () {
        let output: () =bevy::window::WindowResolution::set(&mut _self,width,height,).into();
        output
    }


    
    ///  Set the window's physical resolution.
    
    ///  This will ignore the scale factor setting, so most of the time you should
    
    ///  prefer to use [`WindowResolution::set`].
    
    fn set_physical_resolution (mut _self:Mut<bevy::window::WindowResolution>,width:u32,height:u32,) -> () {
        let output: () =bevy::window::WindowResolution::set_physical_resolution(&mut _self,width,height,).into();
        output
    }


    
    ///  Set the window's scale factor, this may get overridden by the backend.
    
    fn set_scale_factor (mut _self:Mut<bevy::window::WindowResolution>,scale_factor:f32,) -> () {
        let output: () =bevy::window::WindowResolution::set_scale_factor(&mut _self,scale_factor,).into();
        output
    }


    
    ///  Set the window's scale factor, and apply it to the currently known physical size.
    
    ///  This may get overridden by the backend. This is mostly useful on window creation,
    
    ///  so that the window is created with the expected size instead of waiting for a resize
    
    ///  event after its creation.
    
    fn set_scale_factor_and_apply_to_physical_size (mut _self:Mut<bevy::window::WindowResolution>,scale_factor:f32,) -> () {
        let output: () =bevy::window::WindowResolution::set_scale_factor_and_apply_to_physical_size(&mut _self,scale_factor,).into();
        output
    }


    
    ///  Set the window's scale factor, this will be used over what the backend decides.
    
    ///  This can change the logical and physical sizes if the resulting physical
    
    ///  size is not within the limits.
    
    fn set_scale_factor_override (mut _self:Mut<bevy::window::WindowResolution>,scale_factor_override:::core::option::Option<f32>,) -> () {
        let output: () =bevy::window::WindowResolution::set_scale_factor_override(&mut _self,scale_factor_override,).into();
        output
    }


    
    ///  The window's client size in logical pixels
    
    fn size (_self:Ref<bevy::window::WindowResolution>,) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> =bevy::window::WindowResolution::size(&_self,).into();
        output
    }


    
    ///  The window's client area width in logical pixels.
    
    fn width (_self:Ref<bevy::window::WindowResolution>,) -> f32 {
        let output: f32 =bevy::window::WindowResolution::width(&_self,).into();
        output
    }


    
    ///  Builder method for adding a scale factor override to the resolution.
    
    fn with_scale_factor_override (_self:Val<bevy::window::WindowResolution>,scale_factor_override:f32,) -> Val<bevy::window::WindowResolution> {
        let output: Val<bevy::window::WindowResolution> =bevy::window::WindowResolution::with_scale_factor_override(_self.into_inner(),scale_factor_override,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "composite_alpha_mode_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::CompositeAlphaMode {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::CompositeAlphaMode>,) -> () {
        let output: () =<bevy::window::CompositeAlphaMode as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::CompositeAlphaMode>,) -> Val<bevy::window::CompositeAlphaMode> {
        let output: Val<bevy::window::CompositeAlphaMode> =<bevy::window::CompositeAlphaMode as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::CompositeAlphaMode>,other:Ref<bevy::window::CompositeAlphaMode>,) -> bool {
        let output: bool =<bevy::window::CompositeAlphaMode as ::core::cmp::PartialEq::<bevy::window::CompositeAlphaMode>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "enabled_buttons_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::EnabledButtons {


    
    fn clone (_self:Ref<bevy::window::EnabledButtons>,) -> Val<bevy::window::EnabledButtons> {
        let output: Val<bevy::window::EnabledButtons> =<bevy::window::EnabledButtons as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::EnabledButtons>,other:Ref<bevy::window::EnabledButtons>,) -> bool {
        let output: bool =<bevy::window::EnabledButtons as ::core::cmp::PartialEq::<bevy::window::EnabledButtons>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "window_level_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::WindowLevel {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::WindowLevel>,) -> () {
        let output: () =<bevy::window::WindowLevel as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::WindowLevel>,) -> Val<bevy::window::WindowLevel> {
        let output: Val<bevy::window::WindowLevel> =<bevy::window::WindowLevel as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::WindowLevel>,other:Ref<bevy::window::WindowLevel>,) -> bool {
        let output: bool =<bevy::window::WindowLevel as ::core::cmp::PartialEq::<bevy::window::WindowLevel>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "internal_window_state_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::InternalWindowState {


    
    fn clone (_self:Ref<bevy::window::InternalWindowState>,) -> Val<bevy::window::InternalWindowState> {
        let output: Val<bevy::window::InternalWindowState> =<bevy::window::InternalWindowState as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::InternalWindowState>,other:Ref<bevy::window::InternalWindowState>,) -> bool {
        let output: bool =<bevy::window::InternalWindowState as ::core::cmp::PartialEq::<bevy::window::InternalWindowState>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Consumes the current maximize request, if it exists. This should only be called by window backends.
    
    fn take_maximize_request (mut _self:Mut<bevy::window::InternalWindowState>,) -> ::core::option::Option<bool> {
        let output: ::core::option::Option<bool> =bevy::window::InternalWindowState::take_maximize_request(&mut _self,).into();
        output
    }


    
    ///  Consumes the current minimize request, if it exists. This should only be called by window backends.
    
    fn take_minimize_request (mut _self:Mut<bevy::window::InternalWindowState>,) -> ::core::option::Option<bool> {
        let output: ::core::option::Option<bool> =bevy::window::InternalWindowState::take_minimize_request(&mut _self,).into();
        output
    }


    
    ///  Consumes the current move request, if it exists. This should only be called by window backends.
    
    fn take_move_request (mut _self:Mut<bevy::window::InternalWindowState>,) -> bool {
        let output: bool =bevy::window::InternalWindowState::take_move_request(&mut _self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cursor_grab_mode_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::window::CursorGrabMode {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::window::CursorGrabMode>,) -> () {
        let output: () =<bevy::window::CursorGrabMode as ::core::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::window::CursorGrabMode>,) -> Val<bevy::window::CursorGrabMode> {
        let output: Val<bevy::window::CursorGrabMode> =<bevy::window::CursorGrabMode as ::core::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::window::CursorGrabMode>,other:Ref<bevy::window::CursorGrabMode>,) -> bool {
        let output: bool =<bevy::window::CursorGrabMode as ::core::cmp::PartialEq::<bevy::window::CursorGrabMode>>::eq(&_self,&other,).into();
        output
    }
     
}


impl ::bevy::app::Plugin for BevyWindowScriptingPlugin {
    fn build(&self, app: &mut ::bevy::prelude::App) {
        let mut world = app.world_mut();

        
            register_cursor_entered_functions(&mut world);
        
            register_cursor_left_functions(&mut world);
        
            register_cursor_moved_functions(&mut world);
        
            register_file_drag_and_drop_functions(&mut world);
        
            register_ime_functions(&mut world);
        
            register_monitor_selection_functions(&mut world);
        
            register_video_mode_selection_functions(&mut world);
        
            register_window_functions(&mut world);
        
            register_window_moved_functions(&mut world);
        
            register_window_position_functions(&mut world);
        
            register_window_resize_constraints_functions(&mut world);
        
            register_window_event_functions(&mut world);
        
            register_window_resized_functions(&mut world);
        
            register_window_created_functions(&mut world);
        
            register_window_closing_functions(&mut world);
        
            register_window_closed_functions(&mut world);
        
            register_window_close_requested_functions(&mut world);
        
            register_window_destroyed_functions(&mut world);
        
            register_request_redraw_functions(&mut world);
        
            register_window_focused_functions(&mut world);
        
            register_window_occluded_functions(&mut world);
        
            register_window_scale_factor_changed_functions(&mut world);
        
            register_window_backend_scale_factor_changed_functions(&mut world);
        
            register_window_theme_changed_functions(&mut world);
        
            register_app_lifecycle_functions(&mut world);
        
            register_primary_window_functions(&mut world);
        
            register_monitor_functions(&mut world);
        
            register_window_theme_functions(&mut world);
        
            register_video_mode_functions(&mut world);
        
            register_primary_monitor_functions(&mut world);
        
            register_system_cursor_icon_functions(&mut world);
        
            register_window_ref_functions(&mut world);
        
            register_normalized_window_ref_functions(&mut world);
        
            register_cursor_options_functions(&mut world);
        
            register_present_mode_functions(&mut world);
        
            register_window_mode_functions(&mut world);
        
            register_window_resolution_functions(&mut world);
        
            register_composite_alpha_mode_functions(&mut world);
        
            register_enabled_buttons_functions(&mut world);
        
            register_window_level_functions(&mut world);
        
            register_internal_window_state_functions(&mut world);
        
            register_cursor_grab_mode_functions(&mut world);
        
    }
}
