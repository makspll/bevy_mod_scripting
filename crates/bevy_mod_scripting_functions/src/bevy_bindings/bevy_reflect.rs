// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use bevy_mod_scripting_core::bindings::{
    ReflectReference,
    function::{
        from::{Ref, Mut, Val},
        namespace::NamespaceBuilder,
    },
};
use bevy_mod_scripting_derive::script_bindings;
use crate::*;
pub struct BevyReflectScriptingPlugin;
#[script_bindings(
    remote,
    name = "atomic_bool_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl std::sync::atomic::AtomicBool {
    ///  Consumes the atomic and returns the contained value.
    ///  This is safe because passing `self` by value guarantees that no other threads are
    ///  concurrently accessing the atomic data.
    ///  # Examples
    ///  ```
    ///  use std::sync::atomic::AtomicBool;
    ///  let some_bool = AtomicBool::new(true);
    ///  assert_eq!(some_bool.into_inner(), true);
    ///  ```
    fn into_inner(_self: Val<std::sync::atomic::AtomicBool>) -> bool {
        let output: bool = std::sync::atomic::AtomicBool::into_inner(_self.into_inner())
            .into();
        output
    }
    ///  Creates a new `AtomicBool`.
    ///  # Examples
    ///  ```
    ///  use std::sync::atomic::AtomicBool;
    ///  let atomic_true = AtomicBool::new(true);
    ///  let atomic_false = AtomicBool::new(false);
    ///  ```
    fn new(v: bool) -> Val<std::sync::atomic::AtomicBool> {
        let output: Val<std::sync::atomic::AtomicBool> = std::sync::atomic::AtomicBool::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "atomic_i_16_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl std::sync::atomic::AtomicI16 {
    ///  Consumes the atomic and returns the contained value.
    ///  This is safe because passing `self` by value guarantees that no other threads are
    ///  concurrently accessing the atomic data.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicI16;
    /// let some_var = AtomicI16::new(5);
    ///  assert_eq!(some_var.into_inner(), 5);
    ///  ```
    fn into_inner(_self: Val<std::sync::atomic::AtomicI16>) -> i16 {
        let output: i16 = std::sync::atomic::AtomicI16::into_inner(_self.into_inner())
            .into();
        output
    }
    ///  Creates a new atomic integer.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicI16;
    /// let atomic_forty_two = AtomicI16::new(42);
    ///  ```
    fn new(v: i16) -> Val<std::sync::atomic::AtomicI16> {
        let output: Val<std::sync::atomic::AtomicI16> = std::sync::atomic::AtomicI16::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "atomic_i_32_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl std::sync::atomic::AtomicI32 {
    ///  Consumes the atomic and returns the contained value.
    ///  This is safe because passing `self` by value guarantees that no other threads are
    ///  concurrently accessing the atomic data.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicI32;
    /// let some_var = AtomicI32::new(5);
    ///  assert_eq!(some_var.into_inner(), 5);
    ///  ```
    fn into_inner(_self: Val<std::sync::atomic::AtomicI32>) -> i32 {
        let output: i32 = std::sync::atomic::AtomicI32::into_inner(_self.into_inner())
            .into();
        output
    }
    ///  Creates a new atomic integer.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicI32;
    /// let atomic_forty_two = AtomicI32::new(42);
    ///  ```
    fn new(v: i32) -> Val<std::sync::atomic::AtomicI32> {
        let output: Val<std::sync::atomic::AtomicI32> = std::sync::atomic::AtomicI32::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "atomic_i_64_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl std::sync::atomic::AtomicI64 {
    ///  Consumes the atomic and returns the contained value.
    ///  This is safe because passing `self` by value guarantees that no other threads are
    ///  concurrently accessing the atomic data.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicI64;
    /// let some_var = AtomicI64::new(5);
    ///  assert_eq!(some_var.into_inner(), 5);
    ///  ```
    fn into_inner(_self: Val<std::sync::atomic::AtomicI64>) -> i64 {
        let output: i64 = std::sync::atomic::AtomicI64::into_inner(_self.into_inner())
            .into();
        output
    }
    ///  Creates a new atomic integer.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicI64;
    /// let atomic_forty_two = AtomicI64::new(42);
    ///  ```
    fn new(v: i64) -> Val<std::sync::atomic::AtomicI64> {
        let output: Val<std::sync::atomic::AtomicI64> = std::sync::atomic::AtomicI64::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "atomic_i_8_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl std::sync::atomic::AtomicI8 {
    ///  Consumes the atomic and returns the contained value.
    ///  This is safe because passing `self` by value guarantees that no other threads are
    ///  concurrently accessing the atomic data.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicI8;
    /// let some_var = AtomicI8::new(5);
    ///  assert_eq!(some_var.into_inner(), 5);
    ///  ```
    fn into_inner(_self: Val<std::sync::atomic::AtomicI8>) -> i8 {
        let output: i8 = std::sync::atomic::AtomicI8::into_inner(_self.into_inner())
            .into();
        output
    }
    ///  Creates a new atomic integer.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicI8;
    /// let atomic_forty_two = AtomicI8::new(42);
    ///  ```
    fn new(v: i8) -> Val<std::sync::atomic::AtomicI8> {
        let output: Val<std::sync::atomic::AtomicI8> = std::sync::atomic::AtomicI8::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "atomic_isize_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl std::sync::atomic::AtomicIsize {
    ///  Consumes the atomic and returns the contained value.
    ///  This is safe because passing `self` by value guarantees that no other threads are
    ///  concurrently accessing the atomic data.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicIsize;
    /// let some_var = AtomicIsize::new(5);
    ///  assert_eq!(some_var.into_inner(), 5);
    ///  ```
    fn into_inner(_self: Val<std::sync::atomic::AtomicIsize>) -> isize {
        let output: isize = std::sync::atomic::AtomicIsize::into_inner(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new atomic integer.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicIsize;
    /// let atomic_forty_two = AtomicIsize::new(42);
    ///  ```
    fn new(v: isize) -> Val<std::sync::atomic::AtomicIsize> {
        let output: Val<std::sync::atomic::AtomicIsize> = std::sync::atomic::AtomicIsize::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "atomic_u_16_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl std::sync::atomic::AtomicU16 {
    ///  Consumes the atomic and returns the contained value.
    ///  This is safe because passing `self` by value guarantees that no other threads are
    ///  concurrently accessing the atomic data.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicU16;
    /// let some_var = AtomicU16::new(5);
    ///  assert_eq!(some_var.into_inner(), 5);
    ///  ```
    fn into_inner(_self: Val<std::sync::atomic::AtomicU16>) -> u16 {
        let output: u16 = std::sync::atomic::AtomicU16::into_inner(_self.into_inner())
            .into();
        output
    }
    ///  Creates a new atomic integer.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicU16;
    /// let atomic_forty_two = AtomicU16::new(42);
    ///  ```
    fn new(v: u16) -> Val<std::sync::atomic::AtomicU16> {
        let output: Val<std::sync::atomic::AtomicU16> = std::sync::atomic::AtomicU16::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "atomic_u_32_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl std::sync::atomic::AtomicU32 {
    ///  Consumes the atomic and returns the contained value.
    ///  This is safe because passing `self` by value guarantees that no other threads are
    ///  concurrently accessing the atomic data.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicU32;
    /// let some_var = AtomicU32::new(5);
    ///  assert_eq!(some_var.into_inner(), 5);
    ///  ```
    fn into_inner(_self: Val<std::sync::atomic::AtomicU32>) -> u32 {
        let output: u32 = std::sync::atomic::AtomicU32::into_inner(_self.into_inner())
            .into();
        output
    }
    ///  Creates a new atomic integer.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicU32;
    /// let atomic_forty_two = AtomicU32::new(42);
    ///  ```
    fn new(v: u32) -> Val<std::sync::atomic::AtomicU32> {
        let output: Val<std::sync::atomic::AtomicU32> = std::sync::atomic::AtomicU32::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "atomic_u_64_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl std::sync::atomic::AtomicU64 {
    ///  Consumes the atomic and returns the contained value.
    ///  This is safe because passing `self` by value guarantees that no other threads are
    ///  concurrently accessing the atomic data.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicU64;
    /// let some_var = AtomicU64::new(5);
    ///  assert_eq!(some_var.into_inner(), 5);
    ///  ```
    fn into_inner(_self: Val<std::sync::atomic::AtomicU64>) -> u64 {
        let output: u64 = std::sync::atomic::AtomicU64::into_inner(_self.into_inner())
            .into();
        output
    }
    ///  Creates a new atomic integer.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicU64;
    /// let atomic_forty_two = AtomicU64::new(42);
    ///  ```
    fn new(v: u64) -> Val<std::sync::atomic::AtomicU64> {
        let output: Val<std::sync::atomic::AtomicU64> = std::sync::atomic::AtomicU64::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "atomic_u_8_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl std::sync::atomic::AtomicU8 {
    ///  Consumes the atomic and returns the contained value.
    ///  This is safe because passing `self` by value guarantees that no other threads are
    ///  concurrently accessing the atomic data.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicU8;
    /// let some_var = AtomicU8::new(5);
    ///  assert_eq!(some_var.into_inner(), 5);
    ///  ```
    fn into_inner(_self: Val<std::sync::atomic::AtomicU8>) -> u8 {
        let output: u8 = std::sync::atomic::AtomicU8::into_inner(_self.into_inner())
            .into();
        output
    }
    ///  Creates a new atomic integer.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicU8;
    /// let atomic_forty_two = AtomicU8::new(42);
    ///  ```
    fn new(v: u8) -> Val<std::sync::atomic::AtomicU8> {
        let output: Val<std::sync::atomic::AtomicU8> = std::sync::atomic::AtomicU8::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "atomic_usize_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl std::sync::atomic::AtomicUsize {
    ///  Consumes the atomic and returns the contained value.
    ///  This is safe because passing `self` by value guarantees that no other threads are
    ///  concurrently accessing the atomic data.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicUsize;
    /// let some_var = AtomicUsize::new(5);
    ///  assert_eq!(some_var.into_inner(), 5);
    ///  ```
    fn into_inner(_self: Val<std::sync::atomic::AtomicUsize>) -> usize {
        let output: usize = std::sync::atomic::AtomicUsize::into_inner(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new atomic integer.
    ///  # Examples
    ///  ```
    /// use std::sync::atomic::AtomicUsize;
    /// let atomic_forty_two = AtomicUsize::new(42);
    ///  ```
    fn new(v: usize) -> Val<std::sync::atomic::AtomicUsize> {
        let output: Val<std::sync::atomic::AtomicUsize> = std::sync::atomic::AtomicUsize::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "duration_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl std::time::Duration {
    ///  Computes the absolute difference between `self` and `other`.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  assert_eq!(Duration::new(100, 0).abs_diff(Duration::new(80, 0)), Duration::new(20, 0));
    ///  assert_eq!(Duration::new(100, 400_000_000).abs_diff(Duration::new(110, 0)), Duration::new(9, 600_000_000));
    ///  ```
    fn abs_diff(
        _self: Val<std::time::Duration>,
        other: Val<std::time::Duration>,
    ) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = std::time::Duration::abs_diff(
                _self.into_inner(),
                other.into_inner(),
            )
            .into();
        output
    }
    fn add(
        _self: Val<std::time::Duration>,
        rhs: Val<std::time::Duration>,
    ) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = <std::time::Duration as std::ops::Add<
            std::time::Duration,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns the total number of whole microseconds contained by this `Duration`.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let duration = Duration::new(5, 730_023_852);
    ///  assert_eq!(duration.as_micros(), 5_730_023);
    ///  ```
    fn as_micros(_self: Ref<std::time::Duration>) -> u128 {
        let output: u128 = std::time::Duration::as_micros(&_self).into();
        output
    }
    ///  Returns the total number of whole milliseconds contained by this `Duration`.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let duration = Duration::new(5, 730_023_852);
    ///  assert_eq!(duration.as_millis(), 5_730);
    ///  ```
    fn as_millis(_self: Ref<std::time::Duration>) -> u128 {
        let output: u128 = std::time::Duration::as_millis(&_self).into();
        output
    }
    ///  Returns the total number of nanoseconds contained by this `Duration`.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let duration = Duration::new(5, 730_023_852);
    ///  assert_eq!(duration.as_nanos(), 5_730_023_852);
    ///  ```
    fn as_nanos(_self: Ref<std::time::Duration>) -> u128 {
        let output: u128 = std::time::Duration::as_nanos(&_self).into();
        output
    }
    ///  Returns the number of _whole_ seconds contained by this `Duration`.
    ///  The returned value does not include the fractional (nanosecond) part of the
    ///  duration, which can be obtained using [`subsec_nanos`].
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let duration = Duration::new(5, 730_023_852);
    ///  assert_eq!(duration.as_secs(), 5);
    ///  ```
    ///  To determine the total number of seconds represented by the `Duration`
    ///  including the fractional part, use [`as_secs_f64`] or [`as_secs_f32`]
    ///  [`as_secs_f64`]: Duration::as_secs_f64
    ///  [`as_secs_f32`]: Duration::as_secs_f32
    ///  [`subsec_nanos`]: Duration::subsec_nanos
    fn as_secs(_self: Ref<std::time::Duration>) -> u64 {
        let output: u64 = std::time::Duration::as_secs(&_self).into();
        output
    }
    ///  Returns the number of seconds contained by this `Duration` as `f32`.
    ///  The returned value includes the fractional (nanosecond) part of the duration.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let dur = Duration::new(2, 700_000_000);
    ///  assert_eq!(dur.as_secs_f32(), 2.7);
    ///  ```
    fn as_secs_f32(_self: Ref<std::time::Duration>) -> f32 {
        let output: f32 = std::time::Duration::as_secs_f32(&_self).into();
        output
    }
    ///  Returns the number of seconds contained by this `Duration` as `f64`.
    ///  The returned value includes the fractional (nanosecond) part of the duration.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let dur = Duration::new(2, 700_000_000);
    ///  assert_eq!(dur.as_secs_f64(), 2.7);
    ///  ```
    fn as_secs_f64(_self: Ref<std::time::Duration>) -> f64 {
        let output: f64 = std::time::Duration::as_secs_f64(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<std::time::Duration>) -> () {
        let output: () = <std::time::Duration as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(_self: Ref<std::time::Duration>) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = <std::time::Duration as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn div(_self: Val<std::time::Duration>, rhs: u32) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = <std::time::Duration as std::ops::Div<
            u32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Divides `Duration` by `Duration` and returns `f32`.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let dur1 = Duration::new(2, 700_000_000);
    ///  let dur2 = Duration::new(5, 400_000_000);
    ///  assert_eq!(dur1.div_duration_f32(dur2), 0.5);
    ///  ```
    fn div_duration_f32(
        _self: Val<std::time::Duration>,
        rhs: Val<std::time::Duration>,
    ) -> f32 {
        let output: f32 = std::time::Duration::div_duration_f32(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Divides `Duration` by `Duration` and returns `f64`.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let dur1 = Duration::new(2, 700_000_000);
    ///  let dur2 = Duration::new(5, 400_000_000);
    ///  assert_eq!(dur1.div_duration_f64(dur2), 0.5);
    ///  ```
    fn div_duration_f64(
        _self: Val<std::time::Duration>,
        rhs: Val<std::time::Duration>,
    ) -> f64 {
        let output: f64 = std::time::Duration::div_duration_f64(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Divides `Duration` by `f32`.
    ///  # Panics
    ///  This method will panic if result is negative, overflows `Duration` or not finite.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let dur = Duration::new(2, 700_000_000);
    ///  // note that due to rounding errors result is slightly
    ///  // different from 0.859_872_611
    ///  assert_eq!(dur.div_f32(3.14), Duration::new(0, 859_872_580));
    ///  assert_eq!(dur.div_f32(3.14e5), Duration::new(0, 8_599));
    ///  ```
    fn div_f32(
        _self: Val<std::time::Duration>,
        rhs: f32,
    ) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = std::time::Duration::div_f32(
                _self.into_inner(),
                rhs,
            )
            .into();
        output
    }
    ///  Divides `Duration` by `f64`.
    ///  # Panics
    ///  This method will panic if result is negative, overflows `Duration` or not finite.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let dur = Duration::new(2, 700_000_000);
    ///  assert_eq!(dur.div_f64(3.14), Duration::new(0, 859_872_611));
    ///  assert_eq!(dur.div_f64(3.14e5), Duration::new(0, 8_599));
    ///  ```
    fn div_f64(
        _self: Val<std::time::Duration>,
        rhs: f64,
    ) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = std::time::Duration::div_f64(
                _self.into_inner(),
                rhs,
            )
            .into();
        output
    }
    fn eq(_self: Ref<std::time::Duration>, other: Ref<std::time::Duration>) -> bool {
        let output: bool = <std::time::Duration as std::cmp::PartialEq<
            std::time::Duration,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a new `Duration` from the specified number of microseconds.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let duration = Duration::from_micros(1_000_002);
    ///  assert_eq!(1, duration.as_secs());
    ///  assert_eq!(2_000, duration.subsec_nanos());
    ///  ```
    fn from_micros(micros: u64) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = std::time::Duration::from_micros(
                micros,
            )
            .into();
        output
    }
    ///  Creates a new `Duration` from the specified number of milliseconds.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let duration = Duration::from_millis(2_569);
    ///  assert_eq!(2, duration.as_secs());
    ///  assert_eq!(569_000_000, duration.subsec_nanos());
    ///  ```
    fn from_millis(millis: u64) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = std::time::Duration::from_millis(
                millis,
            )
            .into();
        output
    }
    ///  Creates a new `Duration` from the specified number of nanoseconds.
    ///  Note: Using this on the return value of `as_nanos()` might cause unexpected behavior:
    ///  `as_nanos()` returns a u128, and can return values that do not fit in u64, e.g. 585 years.
    ///  Instead, consider using the pattern `Duration::new(d.as_secs(), d.subsec_nanos())`
    ///  if you cannot copy/clone the Duration directly.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let duration = Duration::from_nanos(1_000_000_123);
    ///  assert_eq!(1, duration.as_secs());
    ///  assert_eq!(123, duration.subsec_nanos());
    ///  ```
    fn from_nanos(nanos: u64) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = std::time::Duration::from_nanos(nanos)
            .into();
        output
    }
    ///  Creates a new `Duration` from the specified number of whole seconds.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let duration = Duration::from_secs(5);
    ///  assert_eq!(5, duration.as_secs());
    ///  assert_eq!(0, duration.subsec_nanos());
    ///  ```
    fn from_secs(secs: u64) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = std::time::Duration::from_secs(secs)
            .into();
        output
    }
    ///  Creates a new `Duration` from the specified number of seconds represented
    ///  as `f32`.
    ///  # Panics
    ///  This constructor will panic if `secs` is negative, overflows `Duration` or not finite.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let res = Duration::from_secs_f32(0.0);
    ///  assert_eq!(res, Duration::new(0, 0));
    ///  let res = Duration::from_secs_f32(1e-20);
    ///  assert_eq!(res, Duration::new(0, 0));
    ///  let res = Duration::from_secs_f32(4.2e-7);
    ///  assert_eq!(res, Duration::new(0, 420));
    ///  let res = Duration::from_secs_f32(2.7);
    ///  assert_eq!(res, Duration::new(2, 700_000_048));
    ///  let res = Duration::from_secs_f32(3e10);
    ///  assert_eq!(res, Duration::new(30_000_001_024, 0));
    ///  // subnormal float
    ///  let res = Duration::from_secs_f32(f32::from_bits(1));
    ///  assert_eq!(res, Duration::new(0, 0));
    ///  // conversion uses rounding
    ///  let res = Duration::from_secs_f32(0.999e-9);
    ///  assert_eq!(res, Duration::new(0, 1));
    ///  ```
    fn from_secs_f32(secs: f32) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = std::time::Duration::from_secs_f32(
                secs,
            )
            .into();
        output
    }
    ///  Creates a new `Duration` from the specified number of seconds represented
    ///  as `f64`.
    ///  # Panics
    ///  This constructor will panic if `secs` is negative, overflows `Duration` or not finite.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let res = Duration::from_secs_f64(0.0);
    ///  assert_eq!(res, Duration::new(0, 0));
    ///  let res = Duration::from_secs_f64(1e-20);
    ///  assert_eq!(res, Duration::new(0, 0));
    ///  let res = Duration::from_secs_f64(4.2e-7);
    ///  assert_eq!(res, Duration::new(0, 420));
    ///  let res = Duration::from_secs_f64(2.7);
    ///  assert_eq!(res, Duration::new(2, 700_000_000));
    ///  let res = Duration::from_secs_f64(3e10);
    ///  assert_eq!(res, Duration::new(30_000_000_000, 0));
    ///  // subnormal float
    ///  let res = Duration::from_secs_f64(f64::from_bits(1));
    ///  assert_eq!(res, Duration::new(0, 0));
    ///  // conversion uses rounding
    ///  let res = Duration::from_secs_f64(0.999e-9);
    ///  assert_eq!(res, Duration::new(0, 1));
    ///  ```
    fn from_secs_f64(secs: f64) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = std::time::Duration::from_secs_f64(
                secs,
            )
            .into();
        output
    }
    ///  Returns true if this `Duration` spans no time.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  assert!(Duration::ZERO.is_zero());
    ///  assert!(Duration::new(0, 0).is_zero());
    ///  assert!(Duration::from_nanos(0).is_zero());
    ///  assert!(Duration::from_secs(0).is_zero());
    ///  assert!(!Duration::new(1, 1).is_zero());
    ///  assert!(!Duration::from_nanos(1).is_zero());
    ///  assert!(!Duration::from_secs(1).is_zero());
    ///  ```
    fn is_zero(_self: Ref<std::time::Duration>) -> bool {
        let output: bool = std::time::Duration::is_zero(&_self).into();
        output
    }
    fn mul(_self: Val<std::time::Duration>, rhs: u32) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = <std::time::Duration as std::ops::Mul<
            u32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Multiplies `Duration` by `f32`.
    ///  # Panics
    ///  This method will panic if result is negative, overflows `Duration` or not finite.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let dur = Duration::new(2, 700_000_000);
    ///  assert_eq!(dur.mul_f32(3.14), Duration::new(8, 478_000_641));
    ///  assert_eq!(dur.mul_f32(3.14e5), Duration::new(847_800, 0));
    ///  ```
    fn mul_f32(
        _self: Val<std::time::Duration>,
        rhs: f32,
    ) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = std::time::Duration::mul_f32(
                _self.into_inner(),
                rhs,
            )
            .into();
        output
    }
    ///  Multiplies `Duration` by `f64`.
    ///  # Panics
    ///  This method will panic if result is negative, overflows `Duration` or not finite.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let dur = Duration::new(2, 700_000_000);
    ///  assert_eq!(dur.mul_f64(3.14), Duration::new(8, 478_000_000));
    ///  assert_eq!(dur.mul_f64(3.14e5), Duration::new(847_800, 0));
    ///  ```
    fn mul_f64(
        _self: Val<std::time::Duration>,
        rhs: f64,
    ) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = std::time::Duration::mul_f64(
                _self.into_inner(),
                rhs,
            )
            .into();
        output
    }
    ///  Creates a new `Duration` from the specified number of whole seconds and
    ///  additional nanoseconds.
    ///  If the number of nanoseconds is greater than 1 billion (the number of
    ///  nanoseconds in a second), then it will carry over into the seconds provided.
    ///  # Panics
    ///  This constructor will panic if the carry from the nanoseconds overflows
    ///  the seconds counter.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let five_seconds = Duration::new(5, 0);
    ///  ```
    fn new(secs: u64, nanos: u32) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = std::time::Duration::new(secs, nanos)
            .into();
        output
    }
    ///  Saturating `Duration` addition. Computes `self + other`, returning [`Duration::MAX`]
    ///  if overflow occurred.
    ///  # Examples
    ///  ```
    ///  #![feature(duration_constants)]
    ///  use std::time::Duration;
    ///  assert_eq!(Duration::new(0, 0).saturating_add(Duration::new(0, 1)), Duration::new(0, 1));
    ///  assert_eq!(Duration::new(1, 0).saturating_add(Duration::new(u64::MAX, 0)), Duration::MAX);
    ///  ```
    fn saturating_add(
        _self: Val<std::time::Duration>,
        rhs: Val<std::time::Duration>,
    ) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = std::time::Duration::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Saturating `Duration` multiplication. Computes `self * other`, returning
    ///  [`Duration::MAX`] if overflow occurred.
    ///  # Examples
    ///  ```
    ///  #![feature(duration_constants)]
    ///  use std::time::Duration;
    ///  assert_eq!(Duration::new(0, 500_000_001).saturating_mul(2), Duration::new(1, 2));
    ///  assert_eq!(Duration::new(u64::MAX - 1, 0).saturating_mul(2), Duration::MAX);
    ///  ```
    fn saturating_mul(
        _self: Val<std::time::Duration>,
        rhs: u32,
    ) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = std::time::Duration::saturating_mul(
                _self.into_inner(),
                rhs,
            )
            .into();
        output
    }
    ///  Saturating `Duration` subtraction. Computes `self - other`, returning [`Duration::ZERO`]
    ///  if the result would be negative or if overflow occurred.
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  assert_eq!(Duration::new(0, 1).saturating_sub(Duration::new(0, 0)), Duration::new(0, 1));
    ///  assert_eq!(Duration::new(0, 0).saturating_sub(Duration::new(0, 1)), Duration::ZERO);
    ///  ```
    fn saturating_sub(
        _self: Val<std::time::Duration>,
        rhs: Val<std::time::Duration>,
    ) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = std::time::Duration::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn sub(
        _self: Val<std::time::Duration>,
        rhs: Val<std::time::Duration>,
    ) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = <std::time::Duration as std::ops::Sub<
            std::time::Duration,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns the fractional part of this `Duration`, in whole microseconds.
    ///  This method does **not** return the length of the duration when
    ///  represented by microseconds. The returned number always represents a
    ///  fractional portion of a second (i.e., it is less than one million).
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let duration = Duration::from_micros(1_234_567);
    ///  assert_eq!(duration.as_secs(), 1);
    ///  assert_eq!(duration.subsec_micros(), 234_567);
    ///  ```
    fn subsec_micros(_self: Ref<std::time::Duration>) -> u32 {
        let output: u32 = std::time::Duration::subsec_micros(&_self).into();
        output
    }
    ///  Returns the fractional part of this `Duration`, in whole milliseconds.
    ///  This method does **not** return the length of the duration when
    ///  represented by milliseconds. The returned number always represents a
    ///  fractional portion of a second (i.e., it is less than one thousand).
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let duration = Duration::from_millis(5_432);
    ///  assert_eq!(duration.as_secs(), 5);
    ///  assert_eq!(duration.subsec_millis(), 432);
    ///  ```
    fn subsec_millis(_self: Ref<std::time::Duration>) -> u32 {
        let output: u32 = std::time::Duration::subsec_millis(&_self).into();
        output
    }
    ///  Returns the fractional part of this `Duration`, in nanoseconds.
    ///  This method does **not** return the length of the duration when
    ///  represented by nanoseconds. The returned number always represents a
    ///  fractional portion of a second (i.e., it is less than one billion).
    ///  # Examples
    ///  ```
    ///  use std::time::Duration;
    ///  let duration = Duration::from_millis(5_010);
    ///  assert_eq!(duration.as_secs(), 5);
    ///  assert_eq!(duration.subsec_nanos(), 10_000_000);
    ///  ```
    fn subsec_nanos(_self: Ref<std::time::Duration>) -> u32 {
        let output: u32 = std::time::Duration::subsec_nanos(&_self).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "instant_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::platform::time::Instant {
    ///  # Panics
    ///  This function may panic if the resulting point in time cannot be represented by the
    ///  underlying data structure. See [`Instant::checked_add`] for a version without panic.
    fn add(
        _self: Val<bevy::platform::time::Instant>,
        other: Val<std::time::Duration>,
    ) -> Val<bevy::platform::time::Instant> {
        let output: Val<bevy::platform::time::Instant> = <bevy::platform::time::Instant as std::ops::Add<
            std::time::Duration,
        >>::add(_self.into_inner(), other.into_inner())
            .into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::platform::time::Instant>) -> () {
        let output: () = <bevy::platform::time::Instant as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::platform::time::Instant>) -> Val<bevy::platform::time::Instant> {
        let output: Val<bevy::platform::time::Instant> = <bevy::platform::time::Instant as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the amount of time elapsed from another instant to this one,
    ///  or zero duration if that instant is later than this one.
    ///  # Panics
    ///  Previous Rust versions panicked when `earlier` was later than `self`. Currently this
    ///  method saturates. Future versions may reintroduce the panic in some circumstances.
    ///  See [Monotonicity].
    ///  [Monotonicity]: Instant#monotonicity
    ///  # Examples
    ///  ```no_run
    ///  use std::time::{Duration, Instant};
    ///  use std::thread::sleep;
    ///  let now = Instant::now();
    ///  sleep(Duration::new(1, 0));
    ///  let new_now = Instant::now();
    ///  println!("{:?}", new_now.duration_since(now));
    ///  println!("{:?}", now.duration_since(new_now)); // 0ns
    ///  ```
    fn duration_since(
        _self: Ref<bevy::platform::time::Instant>,
        earlier: Val<bevy::platform::time::Instant>,
    ) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = bevy::platform::time::Instant::duration_since(
                &_self,
                earlier.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the amount of time elapsed since this instant.
    ///  # Panics
    ///  Previous Rust versions panicked when the current time was earlier than self. Currently this
    ///  method returns a Duration of zero in that case. Future versions may reintroduce the panic.
    ///  See [Monotonicity].
    ///  [Monotonicity]: Instant#monotonicity
    ///  # Examples
    ///  ```no_run
    ///  use std::thread::sleep;
    ///  use std::time::{Duration, Instant};
    ///  let instant = Instant::now();
    ///  let three_secs = Duration::from_secs(3);
    ///  sleep(three_secs);
    ///  assert!(instant.elapsed() >= three_secs);
    ///  ```
    fn elapsed(_self: Ref<bevy::platform::time::Instant>) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = bevy::platform::time::Instant::elapsed(&_self)
            .into();
        output
    }
    fn eq(_self: Ref<bevy::platform::time::Instant>, other: Ref<bevy::platform::time::Instant>) -> bool {
        let output: bool = <bevy::platform::time::Instant as std::cmp::PartialEq<
            bevy::platform::time::Instant,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Returns an instant corresponding to "now".
    ///  # Examples
    ///  ```
    ///  use std::time::Instant;
    ///  let now = Instant::now();
    ///  ```
    fn now() -> Val<bevy::platform::time::Instant> {
        let output: Val<bevy::platform::time::Instant> = bevy::platform::time::Instant::now().into();
        output
    }
    ///  Returns the amount of time elapsed from another instant to this one,
    ///  or zero duration if that instant is later than this one.
    ///  # Examples
    ///  ```no_run
    ///  use std::time::{Duration, Instant};
    ///  use std::thread::sleep;
    ///  let now = Instant::now();
    ///  sleep(Duration::new(1, 0));
    ///  let new_now = Instant::now();
    ///  println!("{:?}", new_now.saturating_duration_since(now));
    ///  println!("{:?}", now.saturating_duration_since(new_now)); // 0ns
    ///  ```
    fn saturating_duration_since(
        _self: Ref<bevy::platform::time::Instant>,
        earlier: Val<bevy::platform::time::Instant>,
    ) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = bevy::platform::time::Instant::saturating_duration_since(
                &_self,
                earlier.into_inner(),
            )
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::platform::time::Instant>,
        other: Val<std::time::Duration>,
    ) -> Val<bevy::platform::time::Instant> {
        let output: Val<bevy::platform::time::Instant> = <bevy::platform::time::Instant as std::ops::Sub<
            std::time::Duration,
        >>::sub(_self.into_inner(), other.into_inner())
            .into();
        output
    }
    ///  Returns the amount of time elapsed from another instant to this one,
    ///  or zero duration if that instant is later than this one.
    ///  # Panics
    ///  Previous Rust versions panicked when `other` was later than `self`. Currently this
    ///  method saturates. Future versions may reintroduce the panic in some circumstances.
    ///  See [Monotonicity].
    ///  [Monotonicity]: Instant#monotonicity
    fn sub(
        _self: Val<bevy::platform::time::Instant>,
        other: Val<bevy::platform::time::Instant>,
    ) -> Val<std::time::Duration> {
        let output: Val<std::time::Duration> = <bevy::platform::time::Instant as std::ops::Sub<
            bevy::platform::time::Instant,
        >>::sub(_self.into_inner(), other.into_inner())
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "range_full_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl std::ops::RangeFull {
    fn assert_receiver_is_total_eq(_self: Ref<std::ops::RangeFull>) -> () {
        let output: () = <std::ops::RangeFull as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(_self: Ref<std::ops::RangeFull>) -> Val<std::ops::RangeFull> {
        let output: Val<std::ops::RangeFull> = <std::ops::RangeFull as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<std::ops::RangeFull>, other: Ref<std::ops::RangeFull>) -> bool {
        let output: bool = <std::ops::RangeFull as std::cmp::PartialEq<
            std::ops::RangeFull,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "quat_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::Quat {
    ///  Returns true if the absolute difference of all elements between `self` and `rhs`
    ///  is less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two quaternions contain similar elements. It works
    ///  best when comparing with a known value. The `max_abs_diff` that should be used used
    ///  depends on the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Val<bevy::math::Quat>,
        rhs: Val<bevy::math::Quat>,
        max_abs_diff: f32,
    ) -> bool {
        let output: bool = bevy::math::Quat::abs_diff_eq(
                _self.into_inner(),
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    ///  Adds two quaternions.
    ///  The sum is not guaranteed to be normalized.
    ///  Note that addition is not the same as combining the rotations represented by the
    ///  two quaternions! That corresponds to multiplication.
    fn add(
        _self: Val<bevy::math::Quat>,
        rhs: Val<bevy::math::Quat>,
    ) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = <bevy::math::Quat as std::ops::Add<
            bevy::math::Quat,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns the angle (in radians) for the minimal rotation
    ///  for transforming this quaternion into another.
    ///  Both quaternions must be normalized.
    ///  # Panics
    ///  Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
    fn angle_between(_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>) -> f32 {
        let output: f32 = bevy::math::Quat::angle_between(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn as_dquat(_self: Val<bevy::math::Quat>) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::Quat::as_dquat(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::Quat>) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = <bevy::math::Quat as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the quaternion conjugate of `self`. For a unit quaternion the
    ///  conjugate is also the inverse.
    fn conjugate(_self: Val<bevy::math::Quat>) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::conjugate(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Divides a quaternion by a scalar value.
    ///  The quotient is not guaranteed to be normalized.
    fn div(_self: Val<bevy::math::Quat>, rhs: f32) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = <bevy::math::Quat as std::ops::Div<
            f32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`. The dot product is
    ///  equal to the cosine of the angle between two quaternion rotations.
    fn dot(_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>) -> f32 {
        let output: f32 = bevy::math::Quat::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::Quat>, rhs: Ref<bevy::math::Quat>) -> bool {
        let output: bool = <bevy::math::Quat as std::cmp::PartialEq<
            bevy::math::Quat,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    ///  Creates a quaternion from a 3x3 rotation matrix inside a 3D affine transform.
    ///  Note if the input affine matrix contain scales, shears, or other non-rotation
    ///  transformations then the resulting quaternion will be ill-defined.
    ///  # Panics
    ///  Will panic if any input affine matrix column is not normalized when `glam_assert` is
    ///  enabled.
    fn from_affine3(a: Ref<bevy::math::Affine3A>) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_affine3(&a).into();
        output
    }
    ///  Creates a rotation quaternion from an array.
    ///  # Preconditions
    ///  This function does not check if the input is normalized, it is up to the user to
    ///  provide normalized input or to normalized the resulting quaternion.
    fn from_array(a: [f32; 4]) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_array(a).into();
        output
    }
    ///  Create a quaternion for a normalized rotation `axis` and `angle` (in radians).
    ///  The axis must be a unit vector.
    ///  # Panics
    ///  Will panic if `axis` is not normalized when `glam_assert` is enabled.
    fn from_axis_angle(
        axis: Val<bevy::math::Vec3>,
        angle: f32,
    ) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_axis_angle(
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    ///  Creates a quaternion from the given Euler rotation sequence and the angles (in radians).
    fn from_euler(
        euler: Val<bevy::math::EulerRot>,
        a: f32,
        b: f32,
        c: f32,
    ) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_euler(
                euler.into_inner(),
                a,
                b,
                c,
            )
            .into();
        output
    }
    ///  Creates a quaternion from a 3x3 rotation matrix.
    ///  Note if the input matrix contain scales, shears, or other non-rotation transformations then
    ///  the resulting quaternion will be ill-defined.
    ///  # Panics
    ///  Will panic if any input matrix column is not normalized when `glam_assert` is enabled.
    fn from_mat3(mat: Ref<bevy::math::Mat3>) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_mat3(&mat).into();
        output
    }
    ///  Creates a quaternion from a 3x3 SIMD aligned rotation matrix.
    ///  Note if the input matrix contain scales, shears, or other non-rotation transformations then
    ///  the resulting quaternion will be ill-defined.
    ///  # Panics
    ///  Will panic if any input matrix column is not normalized when `glam_assert` is enabled.
    fn from_mat3a(mat: Ref<bevy::math::Mat3A>) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_mat3a(&mat).into();
        output
    }
    ///  Creates a quaternion from the upper 3x3 rotation matrix inside a homogeneous 4x4 matrix.
    ///  Note if the upper 3x3 matrix contain scales, shears, or other non-rotation transformations
    ///  then the resulting quaternion will be ill-defined.
    ///  # Panics
    ///  Will panic if any column of the upper 3x3 rotation matrix is not normalized when
    ///  `glam_assert` is enabled.
    fn from_mat4(mat: Ref<bevy::math::Mat4>) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_mat4(&mat).into();
        output
    }
    ///  Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the
    ///  plane spanned by the two vectors.  Will rotate at most 180 degrees.
    ///  The inputs must be unit vectors.
    ///  `from_rotation_arc(from, to) * from ≈ to`.
    ///  For near-singular cases (from≈to and from≈-to) the current implementation
    ///  is only accurate to about 0.001 (for `f32`).
    ///  # Panics
    ///  Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
    fn from_rotation_arc(
        from: Val<bevy::math::Vec3>,
        to: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_arc(
                from.into_inner(),
                to.into_inner(),
            )
            .into();
        output
    }
    ///  Gets the minimal rotation for transforming `from` to `to`.  The resulting rotation is
    ///  around the z axis. Will rotate at most 180 degrees.
    ///  The inputs must be unit vectors.
    ///  `from_rotation_arc_2d(from, to) * from ≈ to`.
    ///  For near-singular cases (from≈to and from≈-to) the current implementation
    ///  is only accurate to about 0.001 (for `f32`).
    ///  # Panics
    ///  Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
    fn from_rotation_arc_2d(
        from: Val<bevy::math::Vec2>,
        to: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_arc_2d(
                from.into_inner(),
                to.into_inner(),
            )
            .into();
        output
    }
    ///  Gets the minimal rotation for transforming `from` to either `to` or `-to`.  This means
    ///  that the resulting quaternion will rotate `from` so that it is colinear with `to`.
    ///  The rotation is in the plane spanned by the two vectors.  Will rotate at most 90
    ///  degrees.
    ///  The inputs must be unit vectors.
    ///  `to.dot(from_rotation_arc_colinear(from, to) * from).abs() ≈ 1`.
    ///  # Panics
    ///  Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
    fn from_rotation_arc_colinear(
        from: Val<bevy::math::Vec3>,
        to: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_arc_colinear(
                from.into_inner(),
                to.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a quaternion from the `angle` (in radians) around the x axis.
    fn from_rotation_x(angle: f32) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_x(angle)
            .into();
        output
    }
    ///  Creates a quaternion from the `angle` (in radians) around the y axis.
    fn from_rotation_y(angle: f32) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_y(angle)
            .into();
        output
    }
    ///  Creates a quaternion from the `angle` (in radians) around the z axis.
    fn from_rotation_z(angle: f32) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_z(angle)
            .into();
        output
    }
    ///  Create a quaternion that rotates `v.length()` radians around `v.normalize()`.
    ///  `from_scaled_axis(Vec3::ZERO)` results in the identity quaternion.
    fn from_scaled_axis(v: Val<bevy::math::Vec3>) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_scaled_axis(
                v.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new rotation quaternion from a 4D vector.
    ///  # Preconditions
    ///  This function does not check if the input is normalized, it is up to the user to
    ///  provide normalized input or to normalized the resulting quaternion.
    fn from_vec4(v: Val<bevy::math::Vec4>) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_vec4(v.into_inner())
            .into();
        output
    }
    ///  Creates a new rotation quaternion.
    ///  This should generally not be called manually unless you know what you are doing.
    ///  Use one of the other constructors instead such as `identity` or `from_axis_angle`.
    ///  `from_xyzw` is mostly used by unit tests and `serde` deserialization.
    ///  # Preconditions
    ///  This function does not check if the input is normalized, it is up to the user to
    ///  provide normalized input or to normalized the resulting quaternion.
    fn from_xyzw(x: f32, y: f32, z: f32, w: f32) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_xyzw(x, y, z, w)
            .into();
        output
    }
    ///  Returns the inverse of a normalized quaternion.
    ///  Typically quaternion inverse returns the conjugate of a normalized quaternion.
    ///  Because `self` is assumed to already be unit length this method *does not* normalize
    ///  before returning the conjugate.
    ///  # Panics
    ///  Will panic if `self` is not normalized when `glam_assert` is enabled.
    fn inverse(_self: Val<bevy::math::Quat>) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::inverse(_self.into_inner())
            .into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.
    ///  If any element is either `NaN`, positive or negative infinity, this will return `false`.
    fn is_finite(_self: Val<bevy::math::Quat>) -> bool {
        let output: bool = bevy::math::Quat::is_finite(_self.into_inner()).into();
        output
    }
    ///  Returns `true` if any elements are `NAN`.
    fn is_nan(_self: Val<bevy::math::Quat>) -> bool {
        let output: bool = bevy::math::Quat::is_nan(_self.into_inner()).into();
        output
    }
    fn is_near_identity(_self: Val<bevy::math::Quat>) -> bool {
        let output: bool = bevy::math::Quat::is_near_identity(_self.into_inner()).into();
        output
    }
    ///  Returns whether `self` of length `1.0` or not.
    ///  Uses a precision threshold of `1e-6`.
    fn is_normalized(_self: Val<bevy::math::Quat>) -> bool {
        let output: bool = bevy::math::Quat::is_normalized(_self.into_inner()).into();
        output
    }
    ///  Computes the length of `self`.
    fn length(_self: Val<bevy::math::Quat>) -> f32 {
        let output: f32 = bevy::math::Quat::length(_self.into_inner()).into();
        output
    }
    ///  Computes `1.0 / length()`.
    ///  For valid results, `self` must _not_ be of length zero.
    fn length_recip(_self: Val<bevy::math::Quat>) -> f32 {
        let output: f32 = bevy::math::Quat::length_recip(_self.into_inner()).into();
        output
    }
    ///  Computes the squared length of `self`.
    ///  This is generally faster than `length()` as it avoids a square
    ///  root operation.
    fn length_squared(_self: Val<bevy::math::Quat>) -> f32 {
        let output: f32 = bevy::math::Quat::length_squared(_self.into_inner()).into();
        output
    }
    ///  Performs a linear interpolation between `self` and `rhs` based on
    ///  the value `s`.
    ///  When `s` is `0.0`, the result will be equal to `self`.  When `s`
    ///  is `1.0`, the result will be equal to `rhs`.
    ///  # Panics
    ///  Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
    fn lerp(
        _self: Val<bevy::math::Quat>,
        end: Val<bevy::math::Quat>,
        s: f32,
    ) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::lerp(
                _self.into_inner(),
                end.into_inner(),
                s,
            )
            .into();
        output
    }
    ///  Multiplies two quaternions. If they each represent a rotation, the result will
    ///  represent the combined rotation.
    ///  Note that due to floating point rounding the result may not be perfectly
    ///  normalized.
    ///  # Panics
    ///  Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
    fn mul(
        _self: Val<bevy::math::Quat>,
        rhs: Val<bevy::math::Quat>,
    ) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = <bevy::math::Quat as std::ops::Mul<
            bevy::math::Quat,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Multiplies a quaternion and a 3D vector, returning the rotated vector.
    ///  # Panics
    ///  Will panic if `self` is not normalized when `glam_assert` is enabled.
    fn mul(
        _self: Val<bevy::math::Quat>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Quat as std::ops::Mul<
            bevy::math::Vec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Quat>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Quat as std::ops::Mul<
            bevy::math::Vec3A,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Multiplies a quaternion by a scalar value.
    ///  The product is not guaranteed to be normalized.
    fn mul(_self: Val<bevy::math::Quat>, rhs: f32) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = <bevy::math::Quat as std::ops::Mul<
            f32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Multiplies two quaternions. If they each represent a rotation, the result will
    ///  represent the combined rotation.
    ///  Note that due to floating point rounding the result may not be perfectly normalized.
    ///  # Panics
    ///  Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
    fn mul_quat(
        _self: Val<bevy::math::Quat>,
        rhs: Val<bevy::math::Quat>,
    ) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::mul_quat(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Multiplies a quaternion and a 3D vector, returning the rotated vector.
    ///  # Panics
    ///  Will panic if `self` is not normalized when `glam_assert` is enabled.
    fn mul_vec3(
        _self: Val<bevy::math::Quat>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Quat::mul_vec3(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Multiplies a quaternion and a 3D vector, returning the rotated vector.
    fn mul_vec3a(
        _self: Val<bevy::math::Quat>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Quat::mul_vec3a(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::Quat>) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = <bevy::math::Quat as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `self` normalized to length 1.0.
    ///  For valid results, `self` must _not_ be of length zero.
    ///  Panics
    ///  Will panic if `self` is zero length when `glam_assert` is enabled.
    fn normalize(_self: Val<bevy::math::Quat>) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::normalize(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Rotates towards `rhs` up to `max_angle` (in radians).
    ///  When `max_angle` is `0.0`, the result will be equal to `self`. When `max_angle` is equal to
    ///  `self.angle_between(rhs)`, the result will be equal to `rhs`. If `max_angle` is negative,
    ///  rotates towards the exact opposite of `rhs`. Will not go past the target.
    ///  Both quaternions must be normalized.
    ///  # Panics
    ///  Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
    fn rotate_towards(
        _self: Ref<bevy::math::Quat>,
        rhs: Val<bevy::math::Quat>,
        max_angle: f32,
    ) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::rotate_towards(
                &_self,
                rhs.into_inner(),
                max_angle,
            )
            .into();
        output
    }
    ///  Performs a spherical linear interpolation between `self` and `end`
    ///  based on the value `s`.
    ///  When `s` is `0.0`, the result will be equal to `self`.  When `s`
    ///  is `1.0`, the result will be equal to `end`.
    ///  # Panics
    ///  Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
    fn slerp(
        _self: Val<bevy::math::Quat>,
        end: Val<bevy::math::Quat>,
        s: f32,
    ) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::slerp(
                _self.into_inner(),
                end.into_inner(),
                s,
            )
            .into();
        output
    }
    ///  Subtracts the `rhs` quaternion from `self`.
    ///  The difference is not guaranteed to be normalized.
    fn sub(
        _self: Val<bevy::math::Quat>,
        rhs: Val<bevy::math::Quat>,
    ) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = <bevy::math::Quat as std::ops::Sub<
            bevy::math::Quat,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  `[x, y, z, w]`
    fn to_array(_self: Ref<bevy::math::Quat>) -> [f32; 4] {
        let output: [f32; 4] = bevy::math::Quat::to_array(&_self).into();
        output
    }
    ///  Returns the rotation angles for the given euler rotation sequence.
    fn to_euler(
        _self: Val<bevy::math::Quat>,
        order: Val<bevy::math::EulerRot>,
    ) -> (f32, f32, f32) {
        let output: (f32, f32, f32) = bevy::math::Quat::to_euler(
                _self.into_inner(),
                order.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the rotation axis scaled by the rotation in radians.
    fn to_scaled_axis(_self: Val<bevy::math::Quat>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Quat::to_scaled_axis(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the vector part of the quaternion.
    fn xyz(_self: Val<bevy::math::Quat>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Quat::xyz(_self.into_inner())
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "vec_3_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::Vec3 {
    ///  Returns a vector containing the absolute value of each element of `self`.
    fn abs(_self: Val<bevy::math::Vec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::abs(_self.into_inner())
            .into();
        output
    }
    ///  Returns true if the absolute difference of all elements between `self` and `rhs` is
    ///  less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two vectors contain similar elements. It works best when
    ///  comparing with a known value. The `max_abs_diff` that should be used used depends on
    ///  the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
        max_abs_diff: f32,
    ) -> bool {
        let output: bool = bevy::math::Vec3::abs_diff_eq(
                _self.into_inner(),
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::Vec3>,
        rhs: Ref<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Add<
            &bevy::math::Vec3,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Add<
            bevy::math::Vec3,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Vec3>, rhs: f32) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Add<
            f32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the angle (in radians) between two vectors in the range `[0, +π]`.
    ///  The inputs do not need to be unit vectors however they must be non-zero.
    fn angle_between(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) -> f32 {
        let output: f32 = bevy::math::Vec3::angle_between(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns some vector that is orthogonal to the given one.
    ///  The input vector must be finite and non-zero.
    ///  The output vector is not necessarily unit length. For that use
    ///  [`Self::any_orthonormal_vector()`] instead.
    fn any_orthogonal_vector(_self: Ref<bevy::math::Vec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::any_orthogonal_vector(
                &_self,
            )
            .into();
        output
    }
    ///  Returns any unit vector that is orthogonal to the given one.
    ///  The input vector must be unit length.
    ///  # Panics
    ///  Will panic if `self` is not normalized when `glam_assert` is enabled.
    fn any_orthonormal_vector(_self: Ref<bevy::math::Vec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::any_orthonormal_vector(
                &_self,
            )
            .into();
        output
    }
    ///  Casts all elements of `self` to `f64`.
    fn as_dvec3(_self: Ref<bevy::math::Vec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::Vec3::as_dvec3(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `i64`.
    fn as_i64vec3(_self: Ref<bevy::math::Vec3>) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::Vec3::as_i64vec3(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i32`.
    fn as_ivec3(_self: Ref<bevy::math::Vec3>) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::Vec3::as_ivec3(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `u64`.
    fn as_u64vec3(_self: Ref<bevy::math::Vec3>) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::Vec3::as_u64vec3(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u32`.
    fn as_uvec3(_self: Ref<bevy::math::Vec3>) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::Vec3::as_uvec3(&_self).into();
        output
    }
    ///  Returns a vector containing the smallest integer greater than or equal to a number for
    ///  each element of `self`.
    fn ceil(_self: Val<bevy::math::Vec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::ceil(_self.into_inner())
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`f32::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::Vec3>,
        min: Val<bevy::math::Vec3>,
        max: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with a length no less than `min` and no more than `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.
    fn clamp_length(
        _self: Val<bevy::math::Vec3>,
        min: f32,
        max: f32,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::clamp_length(
                _self.into_inner(),
                min,
                max,
            )
            .into();
        output
    }
    ///  Returns a vector with a length no more than `max`.
    ///  # Panics
    ///  Will panic if `max` is negative when `glam_assert` is enabled.
    fn clamp_length_max(
        _self: Val<bevy::math::Vec3>,
        max: f32,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::clamp_length_max(
                _self.into_inner(),
                max,
            )
            .into();
        output
    }
    ///  Returns a vector with a length no less than `min`.
    ///  # Panics
    ///  Will panic if `min` is negative when `glam_assert` is enabled.
    fn clamp_length_min(
        _self: Val<bevy::math::Vec3>,
        min: f32,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::clamp_length_min(
                _self.into_inner(),
                min,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::Vec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with signs of `rhs` and the magnitudes of `self`.
    fn copysign(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::copysign(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the cross product of `self` and `rhs`.
    fn cross(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::cross(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the Euclidean distance between two points in space.
    fn distance(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) -> f32 {
        let output: f32 = bevy::math::Vec3::distance(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Compute the squared euclidean distance between two points in space.
    fn distance_squared(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> f32 {
        let output: f32 = bevy::math::Vec3::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::Vec3>,
        rhs: Ref<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Div<
            &bevy::math::Vec3,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Div<
            bevy::math::Vec3,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::Vec3>, rhs: f32) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Div<
            f32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
    fn div_euclid(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) -> f32 {
        let output: f32 = bevy::math::Vec3::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::Vec3>) -> f32 {
        let output: f32 = bevy::math::Vec3::element_product(_self.into_inner()).into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::Vec3>) -> f32 {
        let output: f32 = bevy::math::Vec3::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::Vec3>, other: Ref<bevy::math::Vec3>) -> bool {
        let output: bool = <bevy::math::Vec3 as std::cmp::PartialEq<
            bevy::math::Vec3,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Returns a vector containing `e^self` (the exponential function) for each element of
    ///  `self`.
    fn exp(_self: Val<bevy::math::Vec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::exp(_self.into_inner())
            .into();
        output
    }
    ///  Creates a 4D vector from `self` and the given `w` value.
    fn extend(_self: Val<bevy::math::Vec3>, w: f32) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec3::extend(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    ///  Returns a vector containing the largest integer less than or equal to a number for each
    ///  element of `self`.
    fn floor(_self: Val<bevy::math::Vec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::floor(_self.into_inner())
            .into();
        output
    }
    ///  Returns a vector containing the fractional part of the vector as `self - self.trunc()`.
    ///  Note that this differs from the GLSL implementation of `fract` which returns
    ///  `self - self.floor()`.
    ///  Note that this is fast but not precise for large numbers.
    fn fract(_self: Val<bevy::math::Vec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::fract(_self.into_inner())
            .into();
        output
    }
    ///  Returns a vector containing the fractional part of the vector as `self - self.floor()`.
    ///  Note that this differs from the Rust implementation of `fract` which returns
    ///  `self - self.trunc()`.
    ///  Note that this is fast but not precise for large numbers.
    fn fract_gl(_self: Val<bevy::math::Vec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::fract_gl(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [f32; 3]) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::from_array(a).into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.  If any element is either
    ///  `NaN`, positive or negative infinity, this will return `false`.
    fn is_finite(_self: Val<bevy::math::Vec3>) -> bool {
        let output: bool = bevy::math::Vec3::is_finite(_self.into_inner()).into();
        output
    }
    ///  Performs `is_finite` on each element of self, returning a vector mask of the results.
    ///  In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.
    fn is_finite_mask(_self: Val<bevy::math::Vec3>) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::Vec3::is_finite_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `true` if any elements are `NaN`.
    fn is_nan(_self: Val<bevy::math::Vec3>) -> bool {
        let output: bool = bevy::math::Vec3::is_nan(_self.into_inner()).into();
        output
    }
    ///  Performs `is_nan` on each element of self, returning a vector mask of the results.
    ///  In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.
    fn is_nan_mask(_self: Val<bevy::math::Vec3>) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::Vec3::is_nan_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.
    ///  A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
    ///  into the first lowest bit, element `y` into the second, etc.
    fn is_negative_bitmask(_self: Val<bevy::math::Vec3>) -> u32 {
        let output: u32 = bevy::math::Vec3::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    ///  Returns whether `self` is length `1.0` or not.
    ///  Uses a precision threshold of approximately `1e-4`.
    fn is_normalized(_self: Val<bevy::math::Vec3>) -> bool {
        let output: bool = bevy::math::Vec3::is_normalized(_self.into_inner()).into();
        output
    }
    ///  Computes the length of `self`.
    fn length(_self: Val<bevy::math::Vec3>) -> f32 {
        let output: f32 = bevy::math::Vec3::length(_self.into_inner()).into();
        output
    }
    ///  Computes `1.0 / length()`.
    ///  For valid results, `self` must _not_ be of length zero.
    fn length_recip(_self: Val<bevy::math::Vec3>) -> f32 {
        let output: f32 = bevy::math::Vec3::length_recip(_self.into_inner()).into();
        output
    }
    ///  Computes the squared length of `self`.
    ///  This is faster than `length()` as it avoids a square root operation.
    fn length_squared(_self: Val<bevy::math::Vec3>) -> f32 {
        let output: f32 = bevy::math::Vec3::length_squared(_self.into_inner()).into();
        output
    }
    ///  Performs a linear interpolation between `self` and `rhs` based on the value `s`.
    ///  When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
    ///  will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
    ///  extrapolated.
    fn lerp(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
        s: f32,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::lerp(
                _self.into_inner(),
                rhs.into_inner(),
                s,
            )
            .into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::Vec3>) -> f32 {
        let output: f32 = bevy::math::Vec3::max_element(_self.into_inner()).into();
        output
    }
    ///  Calculates the midpoint between `self` and `rhs`.
    ///  The midpoint is the average of, or halfway point between, two vectors.
    ///  `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`
    ///  while being slightly cheaper to compute.
    fn midpoint(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::midpoint(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::Vec3>) -> f32 {
        let output: f32 = bevy::math::Vec3::min_element(_self.into_inner()).into();
        output
    }
    ///  Moves towards `rhs` based on the value `d`.
    ///  When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to
    ///  `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.
    fn move_towards(
        _self: Ref<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
        d: f32,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::move_towards(
                &_self,
                rhs.into_inner(),
                d,
            )
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Vec3>,
        rhs: Ref<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Mul<
            &bevy::math::Vec3,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Mul<
            bevy::math::Vec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Vec3>, rhs: f32) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Mul<
            f32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
    ///  error, yielding a more accurate result than an unfused multiply-add.
    ///  Using `mul_add` *may* be more performant than an unfused multiply-add if the target
    ///  architecture has a dedicated fma CPU instruction. However, this is not always true,
    ///  and will be heavily dependant on designing algorithms with specific target hardware in
    ///  mind.
    fn mul_add(
        _self: Val<bevy::math::Vec3>,
        a: Val<bevy::math::Vec3>,
        b: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::mul_add(
                _self.into_inner(),
                a.into_inner(),
                b.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::Vec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: f32, y: f32, z: f32) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::new(x, y, z).into();
        output
    }
    ///  Returns `self` normalized to length 1.0.
    ///  For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.
    ///  See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].
    ///  Panics
    ///  Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.
    fn normalize(_self: Val<bevy::math::Vec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::normalize(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `self` normalized to length 1.0 if possible, else returns a
    ///  fallback value.
    ///  In particular, if the input is zero (or very close to zero), or non-finite,
    ///  the result of this operation will be the fallback value.
    ///  See also [`Self::try_normalize()`].
    fn normalize_or(
        _self: Val<bevy::math::Vec3>,
        fallback: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::normalize_or(
                _self.into_inner(),
                fallback.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `self` normalized to length 1.0 if possible, else returns zero.
    ///  In particular, if the input is zero (or very close to zero), or non-finite,
    ///  the result of this operation will be zero.
    ///  See also [`Self::try_normalize()`].
    fn normalize_or_zero(_self: Val<bevy::math::Vec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::normalize_or_zero(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing each element of `self` raised to the power of `n`.
    fn powf(_self: Val<bevy::math::Vec3>, n: f32) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::powf(_self.into_inner(), n)
            .into();
        output
    }
    ///  Returns the vector projection of `self` onto `rhs`.
    ///  `rhs` must be of non-zero length.
    ///  # Panics
    ///  Will panic if `rhs` is zero length when `glam_assert` is enabled.
    fn project_onto(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::project_onto(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the vector projection of `self` onto `rhs`.
    ///  `rhs` must be normalized.
    ///  # Panics
    ///  Will panic if `rhs` is not normalized when `glam_assert` is enabled.
    fn project_onto_normalized(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::project_onto_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
    fn recip(_self: Val<bevy::math::Vec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::recip(_self.into_inner())
            .into();
        output
    }
    ///  Returns the reflection vector for a given incident vector `self` and surface normal
    ///  `normal`.
    ///  `normal` must be normalized.
    ///  # Panics
    ///  Will panic if `normal` is not normalized when `glam_assert` is enabled.
    fn reflect(
        _self: Val<bevy::math::Vec3>,
        normal: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::reflect(
                _self.into_inner(),
                normal.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the refraction direction for a given incident vector `self`, surface normal
    ///  `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,
    ///  a zero vector will be returned.
    ///  `self` and `normal` must be normalized.
    ///  # Panics
    ///  Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.
    fn refract(
        _self: Val<bevy::math::Vec3>,
        normal: Val<bevy::math::Vec3>,
        eta: f32,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::refract(
                _self.into_inner(),
                normal.into_inner(),
                eta,
            )
            .into();
        output
    }
    ///  Returns the vector rejection of `self` from `rhs`.
    ///  The vector rejection is the vector perpendicular to the projection of `self` onto
    ///  `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
    ///  `rhs` must be of non-zero length.
    ///  # Panics
    ///  Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
    fn reject_from(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::reject_from(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the vector rejection of `self` from `rhs`.
    ///  The vector rejection is the vector perpendicular to the projection of `self` onto
    ///  `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
    ///  `rhs` must be normalized.
    ///  # Panics
    ///  Will panic if `rhs` is not normalized when `glam_assert` is enabled.
    fn reject_from_normalized(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::reject_from_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::Vec3>,
        rhs: Ref<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Rem<
            &bevy::math::Vec3,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Rem<
            bevy::math::Vec3,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::Vec3>, rhs: f32) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Rem<
            f32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
    ///  [Euclidean division]: f32::rem_euclid
    fn rem_euclid(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the nearest integer to a number for each element of `self`.
    ///  Round half-way cases away from 0.0.
    fn round(_self: Val<bevy::math::Vec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::round(_self.into_inner())
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec3>,
        if_true: Val<bevy::math::Vec3>,
        if_false: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with elements representing the sign of `self`.
    ///  - `1.0` if the number is positive, `+0.0` or `INFINITY`
    ///  - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
    ///  - `NAN` if the number is `NAN`
    fn signum(_self: Val<bevy::math::Vec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::signum(_self.into_inner())
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: f32) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::Vec3>,
        rhs: Ref<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Sub<
            &bevy::math::Vec3,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Sub<
            bevy::math::Vec3,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::Vec3>, rhs: f32) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Sub<
            f32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  `[x, y, z]`
    fn to_array(_self: Ref<bevy::math::Vec3>) -> [f32; 3] {
        let output: [f32; 3] = bevy::math::Vec3::to_array(&_self).into();
        output
    }
    ///  Returns a vector containing the integer part each element of `self`. This means numbers are
    ///  always truncated towards zero.
    fn trunc(_self: Val<bevy::math::Vec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::trunc(_self.into_inner())
            .into();
        output
    }
    ///  Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
    ///  Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].
    fn truncate(_self: Val<bevy::math::Vec3>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec3::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::Vec3>, x: f32) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::Vec3>, y: f32) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `z`.
    fn with_z(_self: Val<bevy::math::Vec3>, z: f32) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "i_vec_2_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::IVec2 {
    ///  Returns a vector containing the absolute value of each element of `self`.
    fn abs(_self: Val<bevy::math::IVec2>) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::abs(_self.into_inner())
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::IVec2>,
        rhs: Ref<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Add<
            &bevy::math::IVec2,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Add<
            bevy::math::IVec2,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::IVec2>, rhs: i32) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Add<
            i32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f64`.
    fn as_dvec2(_self: Ref<bevy::math::IVec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::IVec2::as_dvec2(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `i64`.
    fn as_i64vec2(_self: Ref<bevy::math::IVec2>) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::IVec2::as_i64vec2(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u64`.
    fn as_u64vec2(_self: Ref<bevy::math::IVec2>) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::IVec2::as_u64vec2(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u32`.
    fn as_uvec2(_self: Ref<bevy::math::IVec2>) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::IVec2::as_uvec2(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec2(_self: Ref<bevy::math::IVec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::IVec2::as_vec2(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::IVec2>) -> () {
        let output: () = <bevy::math::IVec2 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`i32::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::IVec2>,
        min: Val<bevy::math::IVec2>,
        max: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::IVec2>) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Compute the squared euclidean distance between two points in space.
    fn distance_squared(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> i32 {
        let output: i32 = bevy::math::IVec2::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::IVec2>,
        rhs: Ref<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Div<
            &bevy::math::IVec2,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Div<
            bevy::math::IVec2,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::IVec2>, rhs: i32) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Div<
            i32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
    ///  # Panics
    ///  This function will panic if any `rhs` element is 0 or the division results in overflow.
    fn div_euclid(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) -> i32 {
        let output: i32 = bevy::math::IVec2::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::IVec2>) -> i32 {
        let output: i32 = bevy::math::IVec2::element_product(_self.into_inner()).into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::IVec2>) -> i32 {
        let output: i32 = bevy::math::IVec2::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::IVec2>, other: Ref<bevy::math::IVec2>) -> bool {
        let output: bool = <bevy::math::IVec2 as std::cmp::PartialEq<
            bevy::math::IVec2,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a 3D vector from `self` and the given `z` value.
    fn extend(_self: Val<bevy::math::IVec2>, z: i32) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec2::extend(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [i32; 2]) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::from_array(a).into();
        output
    }
    ///  Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `self`.
    ///  A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
    ///  into the first lowest bit, element `y` into the second, etc.
    fn is_negative_bitmask(_self: Val<bevy::math::IVec2>) -> u32 {
        let output: u32 = bevy::math::IVec2::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    ///  Computes the squared length of `self`.
    fn length_squared(_self: Val<bevy::math::IVec2>) -> i32 {
        let output: i32 = bevy::math::IVec2::length_squared(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::IVec2>) -> i32 {
        let output: i32 = bevy::math::IVec2::max_element(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::IVec2>) -> i32 {
        let output: i32 = bevy::math::IVec2::min_element(_self.into_inner()).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::IVec2>,
        rhs: Ref<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Mul<
            &bevy::math::IVec2,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Mul<
            bevy::math::IVec2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::IVec2>, rhs: i32) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Mul<
            i32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::IVec2>) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: i32, y: i32) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::new(x, y).into();
        output
    }
    ///  Returns a vector that is equal to `self` rotated by 90 degrees.
    fn perp(_self: Val<bevy::math::IVec2>) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::perp(_self.into_inner())
            .into();
        output
    }
    ///  The perpendicular dot product of `self` and `rhs`.
    ///  Also known as the wedge product, 2D cross product, and determinant.
    fn perp_dot(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) -> i32 {
        let output: i32 = bevy::math::IVec2::perp_dot(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::IVec2>,
        rhs: Ref<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Rem<
            &bevy::math::IVec2,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Rem<
            bevy::math::IVec2,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::IVec2>, rhs: i32) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Rem<
            i32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
    ///  # Panics
    ///  This function will panic if any `rhs` element is 0 or the division results in overflow.
    ///  [Euclidean division]: i32::rem_euclid
    fn rem_euclid(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
    ///  then this just rotation. This is what you usually want. Otherwise,
    ///  it will be like a rotation with a multiplication by `self`'s length.
    fn rotate(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::rotate(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.
    fn saturating_add(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.
    fn saturating_add_unsigned(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating division of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.
    fn saturating_div(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.
    fn saturating_mul(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.
    fn saturating_sub(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.
    ///  In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.
    fn saturating_sub_unsigned(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec2>,
        if_true: Val<bevy::math::IVec2>,
        if_false: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with elements representing the sign of `self`.
    ///   - `0` if the number is zero
    ///   - `1` if the number is positive
    ///   - `-1` if the number is negative
    fn signum(_self: Val<bevy::math::IVec2>) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: i32) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::IVec2>,
        rhs: Ref<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Sub<
            &bevy::math::IVec2,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Sub<
            bevy::math::IVec2,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::IVec2>, rhs: i32) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Sub<
            i32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  `[x, y]`
    fn to_array(_self: Ref<bevy::math::IVec2>) -> [i32; 2] {
        let output: [i32; 2] = bevy::math::IVec2::to_array(&_self).into();
        output
    }
    ///  Creates a 2D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::IVec2>, x: i32) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 2D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::IVec2>, y: i32) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.
    fn wrapping_add(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.
    ///  In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.
    fn wrapping_add_unsigned(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping division of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.
    fn wrapping_div(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.
    fn wrapping_mul(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.
    fn wrapping_sub(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.
    ///  In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.
    fn wrapping_sub_unsigned(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "i_vec_3_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::IVec3 {
    ///  Returns a vector containing the absolute value of each element of `self`.
    fn abs(_self: Val<bevy::math::IVec3>) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::abs(_self.into_inner())
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::IVec3>,
        rhs: Ref<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Add<
            &bevy::math::IVec3,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Add<
            bevy::math::IVec3,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::IVec3>, rhs: i32) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Add<
            i32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f64`.
    fn as_dvec3(_self: Ref<bevy::math::IVec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::IVec3::as_dvec3(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `i64`.
    fn as_i64vec3(_self: Ref<bevy::math::IVec3>) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::IVec3::as_i64vec3(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u64`.
    fn as_u64vec3(_self: Ref<bevy::math::IVec3>) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::IVec3::as_u64vec3(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u32`.
    fn as_uvec3(_self: Ref<bevy::math::IVec3>) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::IVec3::as_uvec3(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec3(_self: Ref<bevy::math::IVec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::IVec3::as_vec3(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec3a(_self: Ref<bevy::math::IVec3>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::IVec3::as_vec3a(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::IVec3>) -> () {
        let output: () = <bevy::math::IVec3 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`i32::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::IVec3>,
        min: Val<bevy::math::IVec3>,
        max: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::IVec3>) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the cross product of `self` and `rhs`.
    fn cross(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::cross(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Compute the squared euclidean distance between two points in space.
    fn distance_squared(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> i32 {
        let output: i32 = bevy::math::IVec3::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::IVec3>,
        rhs: Ref<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Div<
            &bevy::math::IVec3,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Div<
            bevy::math::IVec3,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::IVec3>, rhs: i32) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Div<
            i32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
    ///  # Panics
    ///  This function will panic if any `rhs` element is 0 or the division results in overflow.
    fn div_euclid(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) -> i32 {
        let output: i32 = bevy::math::IVec3::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::IVec3>) -> i32 {
        let output: i32 = bevy::math::IVec3::element_product(_self.into_inner()).into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::IVec3>) -> i32 {
        let output: i32 = bevy::math::IVec3::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::IVec3>, other: Ref<bevy::math::IVec3>) -> bool {
        let output: bool = <bevy::math::IVec3 as std::cmp::PartialEq<
            bevy::math::IVec3,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a 4D vector from `self` and the given `w` value.
    fn extend(_self: Val<bevy::math::IVec3>, w: i32) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec3::extend(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [i32; 3]) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::from_array(a).into();
        output
    }
    ///  Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.
    ///  A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
    ///  into the first lowest bit, element `y` into the second, etc.
    fn is_negative_bitmask(_self: Val<bevy::math::IVec3>) -> u32 {
        let output: u32 = bevy::math::IVec3::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    ///  Computes the squared length of `self`.
    fn length_squared(_self: Val<bevy::math::IVec3>) -> i32 {
        let output: i32 = bevy::math::IVec3::length_squared(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::IVec3>) -> i32 {
        let output: i32 = bevy::math::IVec3::max_element(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::IVec3>) -> i32 {
        let output: i32 = bevy::math::IVec3::min_element(_self.into_inner()).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::IVec3>,
        rhs: Ref<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Mul<
            &bevy::math::IVec3,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Mul<
            bevy::math::IVec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::IVec3>, rhs: i32) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Mul<
            i32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::IVec3>) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: i32, y: i32, z: i32) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::new(x, y, z).into();
        output
    }
    fn rem(
        _self: Val<bevy::math::IVec3>,
        rhs: Ref<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Rem<
            &bevy::math::IVec3,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Rem<
            bevy::math::IVec3,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::IVec3>, rhs: i32) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Rem<
            i32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
    ///  # Panics
    ///  This function will panic if any `rhs` element is 0 or the division results in overflow.
    ///  [Euclidean division]: i32::rem_euclid
    fn rem_euclid(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.
    fn saturating_add(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.
    fn saturating_add_unsigned(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating division of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.
    fn saturating_div(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.
    fn saturating_mul(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.
    fn saturating_sub(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.
    ///  In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.
    fn saturating_sub_unsigned(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec3>,
        if_true: Val<bevy::math::IVec3>,
        if_false: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with elements representing the sign of `self`.
    ///   - `0` if the number is zero
    ///   - `1` if the number is positive
    ///   - `-1` if the number is negative
    fn signum(_self: Val<bevy::math::IVec3>) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: i32) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::IVec3>,
        rhs: Ref<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Sub<
            &bevy::math::IVec3,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Sub<
            bevy::math::IVec3,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::IVec3>, rhs: i32) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Sub<
            i32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  `[x, y, z]`
    fn to_array(_self: Ref<bevy::math::IVec3>) -> [i32; 3] {
        let output: [i32; 3] = bevy::math::IVec3::to_array(&_self).into();
        output
    }
    ///  Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
    ///  Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].
    fn truncate(_self: Val<bevy::math::IVec3>) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec3::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::IVec3>, x: i32) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::IVec3>, y: i32) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `z`.
    fn with_z(_self: Val<bevy::math::IVec3>, z: i32) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.
    fn wrapping_add(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.
    ///  In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.
    fn wrapping_add_unsigned(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping division of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.
    fn wrapping_div(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.
    fn wrapping_mul(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.
    fn wrapping_sub(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.
    ///  In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.
    fn wrapping_sub_unsigned(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "i_vec_4_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::IVec4 {
    ///  Returns a vector containing the absolute value of each element of `self`.
    fn abs(_self: Val<bevy::math::IVec4>) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::abs(_self.into_inner())
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::IVec4>,
        rhs: Ref<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Add<
            &bevy::math::IVec4,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Add<
            bevy::math::IVec4,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::IVec4>, rhs: i32) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Add<
            i32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f64`.
    fn as_dvec4(_self: Ref<bevy::math::IVec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::IVec4::as_dvec4(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `i64`.
    fn as_i64vec4(_self: Ref<bevy::math::IVec4>) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::IVec4::as_i64vec4(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u64`.
    fn as_u64vec4(_self: Ref<bevy::math::IVec4>) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::IVec4::as_u64vec4(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u32`.
    fn as_uvec4(_self: Ref<bevy::math::IVec4>) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::IVec4::as_uvec4(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec4(_self: Ref<bevy::math::IVec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::IVec4::as_vec4(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::IVec4>) -> () {
        let output: () = <bevy::math::IVec4 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`i32::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::IVec4>,
        min: Val<bevy::math::IVec4>,
        max: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::IVec4>) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Compute the squared euclidean distance between two points in space.
    fn distance_squared(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> i32 {
        let output: i32 = bevy::math::IVec4::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::IVec4>,
        rhs: Ref<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Div<
            &bevy::math::IVec4,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Div<
            bevy::math::IVec4,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::IVec4>, rhs: i32) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Div<
            i32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
    ///  # Panics
    ///  This function will panic if any `rhs` element is 0 or the division results in overflow.
    fn div_euclid(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) -> i32 {
        let output: i32 = bevy::math::IVec4::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::IVec4>) -> i32 {
        let output: i32 = bevy::math::IVec4::element_product(_self.into_inner()).into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::IVec4>) -> i32 {
        let output: i32 = bevy::math::IVec4::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::IVec4>, other: Ref<bevy::math::IVec4>) -> bool {
        let output: bool = <bevy::math::IVec4 as std::cmp::PartialEq<
            bevy::math::IVec4,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [i32; 4]) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::from_array(a).into();
        output
    }
    ///  Returns a bitmask with the lowest 4 bits set to the sign bits from the elements of `self`.
    ///  A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
    ///  into the first lowest bit, element `y` into the second, etc.
    fn is_negative_bitmask(_self: Val<bevy::math::IVec4>) -> u32 {
        let output: u32 = bevy::math::IVec4::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    ///  Computes the squared length of `self`.
    fn length_squared(_self: Val<bevy::math::IVec4>) -> i32 {
        let output: i32 = bevy::math::IVec4::length_squared(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::IVec4>) -> i32 {
        let output: i32 = bevy::math::IVec4::max_element(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::IVec4>) -> i32 {
        let output: i32 = bevy::math::IVec4::min_element(_self.into_inner()).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::IVec4>,
        rhs: Ref<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Mul<
            &bevy::math::IVec4,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Mul<
            bevy::math::IVec4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::IVec4>, rhs: i32) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Mul<
            i32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::IVec4>) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: i32, y: i32, z: i32, w: i32) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::new(x, y, z, w).into();
        output
    }
    fn rem(
        _self: Val<bevy::math::IVec4>,
        rhs: Ref<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Rem<
            &bevy::math::IVec4,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Rem<
            bevy::math::IVec4,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::IVec4>, rhs: i32) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Rem<
            i32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
    ///  # Panics
    ///  This function will panic if any `rhs` element is 0 or the division results in overflow.
    ///  [Euclidean division]: i32::rem_euclid
    fn rem_euclid(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.
    fn saturating_add(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.
    fn saturating_add_unsigned(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating division of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.
    fn saturating_div(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.
    fn saturating_mul(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.
    fn saturating_sub(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.
    ///  In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.
    fn saturating_sub_unsigned(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec4>,
        if_true: Val<bevy::math::IVec4>,
        if_false: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with elements representing the sign of `self`.
    ///   - `0` if the number is zero
    ///   - `1` if the number is positive
    ///   - `-1` if the number is negative
    fn signum(_self: Val<bevy::math::IVec4>) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: i32) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::IVec4>,
        rhs: Ref<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Sub<
            &bevy::math::IVec4,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Sub<
            bevy::math::IVec4,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::IVec4>, rhs: i32) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Sub<
            i32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  `[x, y, z, w]`
    fn to_array(_self: Ref<bevy::math::IVec4>) -> [i32; 4] {
        let output: [i32; 4] = bevy::math::IVec4::to_array(&_self).into();
        output
    }
    ///  Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
    ///  Truncation to [`IVec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].
    fn truncate(_self: Val<bevy::math::IVec4>) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec4::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `w`.
    fn with_w(_self: Val<bevy::math::IVec4>, w: i32) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::with_w(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::IVec4>, x: i32) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::IVec4>, y: i32) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `z`.
    fn with_z(_self: Val<bevy::math::IVec4>, z: i32) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.
    fn wrapping_add(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.
    ///  In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.
    fn wrapping_add_unsigned(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping division of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.
    fn wrapping_div(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.
    fn wrapping_mul(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.
    fn wrapping_sub(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.
    ///  In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.
    fn wrapping_sub_unsigned(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "i_64_vec_2_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::I64Vec2 {
    ///  Returns a vector containing the absolute value of each element of `self`.
    fn abs(_self: Val<bevy::math::I64Vec2>) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::abs(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Ref<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Add<
            &bevy::math::I64Vec2,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Add<
            bevy::math::I64Vec2,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::I64Vec2>, rhs: i64) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Add<
            i64,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f64`.
    fn as_dvec2(_self: Ref<bevy::math::I64Vec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::I64Vec2::as_dvec2(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i32`.
    fn as_ivec2(_self: Ref<bevy::math::I64Vec2>) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::I64Vec2::as_ivec2(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u64`.
    fn as_u64vec2(_self: Ref<bevy::math::I64Vec2>) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::I64Vec2::as_u64vec2(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u32`.
    fn as_uvec2(_self: Ref<bevy::math::I64Vec2>) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::I64Vec2::as_uvec2(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec2(_self: Ref<bevy::math::I64Vec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::I64Vec2::as_vec2(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::I64Vec2>) -> () {
        let output: () = <bevy::math::I64Vec2 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`i64::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::I64Vec2>,
        min: Val<bevy::math::I64Vec2>,
        max: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::I64Vec2>) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Compute the squared euclidean distance between two points in space.
    fn distance_squared(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> i64 {
        let output: i64 = bevy::math::I64Vec2::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Ref<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Div<
            &bevy::math::I64Vec2,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Div<
            bevy::math::I64Vec2,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::I64Vec2>, rhs: i64) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Div<
            i64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
    ///  # Panics
    ///  This function will panic if any `rhs` element is 0 or the division results in overflow.
    fn div_euclid(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) -> i64 {
        let output: i64 = bevy::math::I64Vec2::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::I64Vec2>) -> i64 {
        let output: i64 = bevy::math::I64Vec2::element_product(_self.into_inner())
            .into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::I64Vec2>) -> i64 {
        let output: i64 = bevy::math::I64Vec2::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::I64Vec2>, other: Ref<bevy::math::I64Vec2>) -> bool {
        let output: bool = <bevy::math::I64Vec2 as std::cmp::PartialEq<
            bevy::math::I64Vec2,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a 3D vector from `self` and the given `z` value.
    fn extend(_self: Val<bevy::math::I64Vec2>, z: i64) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec2::extend(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [i64; 2]) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::from_array(a).into();
        output
    }
    ///  Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `self`.
    ///  A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
    ///  into the first lowest bit, element `y` into the second, etc.
    fn is_negative_bitmask(_self: Val<bevy::math::I64Vec2>) -> u32 {
        let output: u32 = bevy::math::I64Vec2::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    ///  Computes the squared length of `self`.
    fn length_squared(_self: Val<bevy::math::I64Vec2>) -> i64 {
        let output: i64 = bevy::math::I64Vec2::length_squared(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::I64Vec2>) -> i64 {
        let output: i64 = bevy::math::I64Vec2::max_element(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::I64Vec2>) -> i64 {
        let output: i64 = bevy::math::I64Vec2::min_element(_self.into_inner()).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Ref<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Mul<
            &bevy::math::I64Vec2,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Mul<
            bevy::math::I64Vec2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::I64Vec2>, rhs: i64) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Mul<
            i64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::I64Vec2>) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: i64, y: i64) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::new(x, y).into();
        output
    }
    ///  Returns a vector that is equal to `self` rotated by 90 degrees.
    fn perp(_self: Val<bevy::math::I64Vec2>) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::perp(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  The perpendicular dot product of `self` and `rhs`.
    ///  Also known as the wedge product, 2D cross product, and determinant.
    fn perp_dot(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) -> i64 {
        let output: i64 = bevy::math::I64Vec2::perp_dot(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Ref<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Rem<
            &bevy::math::I64Vec2,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Rem<
            bevy::math::I64Vec2,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::I64Vec2>, rhs: i64) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Rem<
            i64,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
    ///  # Panics
    ///  This function will panic if any `rhs` element is 0 or the division results in overflow.
    ///  [Euclidean division]: i64::rem_euclid
    fn rem_euclid(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
    ///  then this just rotation. This is what you usually want. Otherwise,
    ///  it will be like a rotation with a multiplication by `self`'s length.
    fn rotate(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::rotate(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.
    fn saturating_add(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.
    fn saturating_add_unsigned(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating division of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.
    fn saturating_div(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.
    fn saturating_mul(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.
    fn saturating_sub(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.
    ///  In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.
    fn saturating_sub_unsigned(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec2>,
        if_true: Val<bevy::math::I64Vec2>,
        if_false: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with elements representing the sign of `self`.
    ///   - `0` if the number is zero
    ///   - `1` if the number is positive
    ///   - `-1` if the number is negative
    fn signum(_self: Val<bevy::math::I64Vec2>) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: i64) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Ref<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Sub<
            &bevy::math::I64Vec2,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Sub<
            bevy::math::I64Vec2,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::I64Vec2>, rhs: i64) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Sub<
            i64,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  `[x, y]`
    fn to_array(_self: Ref<bevy::math::I64Vec2>) -> [i64; 2] {
        let output: [i64; 2] = bevy::math::I64Vec2::to_array(&_self).into();
        output
    }
    ///  Creates a 2D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::I64Vec2>, x: i64) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 2D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::I64Vec2>, y: i64) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.
    fn wrapping_add(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.
    ///  In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.
    fn wrapping_add_unsigned(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping division of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.
    fn wrapping_div(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.
    fn wrapping_mul(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.
    fn wrapping_sub(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.
    ///  In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.
    fn wrapping_sub_unsigned(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "i_64_vec_3_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::I64Vec3 {
    ///  Returns a vector containing the absolute value of each element of `self`.
    fn abs(_self: Val<bevy::math::I64Vec3>) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::abs(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Ref<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Add<
            &bevy::math::I64Vec3,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Add<
            bevy::math::I64Vec3,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::I64Vec3>, rhs: i64) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Add<
            i64,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f64`.
    fn as_dvec3(_self: Ref<bevy::math::I64Vec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::I64Vec3::as_dvec3(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i32`.
    fn as_ivec3(_self: Ref<bevy::math::I64Vec3>) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::I64Vec3::as_ivec3(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u64`.
    fn as_u64vec3(_self: Ref<bevy::math::I64Vec3>) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::I64Vec3::as_u64vec3(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u32`.
    fn as_uvec3(_self: Ref<bevy::math::I64Vec3>) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::I64Vec3::as_uvec3(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec3(_self: Ref<bevy::math::I64Vec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::I64Vec3::as_vec3(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec3a(_self: Ref<bevy::math::I64Vec3>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::I64Vec3::as_vec3a(&_self)
            .into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::I64Vec3>) -> () {
        let output: () = <bevy::math::I64Vec3 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`i64::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::I64Vec3>,
        min: Val<bevy::math::I64Vec3>,
        max: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::I64Vec3>) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the cross product of `self` and `rhs`.
    fn cross(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::cross(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Compute the squared euclidean distance between two points in space.
    fn distance_squared(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> i64 {
        let output: i64 = bevy::math::I64Vec3::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Ref<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Div<
            &bevy::math::I64Vec3,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Div<
            bevy::math::I64Vec3,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::I64Vec3>, rhs: i64) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Div<
            i64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
    ///  # Panics
    ///  This function will panic if any `rhs` element is 0 or the division results in overflow.
    fn div_euclid(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) -> i64 {
        let output: i64 = bevy::math::I64Vec3::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::I64Vec3>) -> i64 {
        let output: i64 = bevy::math::I64Vec3::element_product(_self.into_inner())
            .into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::I64Vec3>) -> i64 {
        let output: i64 = bevy::math::I64Vec3::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::I64Vec3>, other: Ref<bevy::math::I64Vec3>) -> bool {
        let output: bool = <bevy::math::I64Vec3 as std::cmp::PartialEq<
            bevy::math::I64Vec3,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a 4D vector from `self` and the given `w` value.
    fn extend(_self: Val<bevy::math::I64Vec3>, w: i64) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec3::extend(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [i64; 3]) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::from_array(a).into();
        output
    }
    ///  Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.
    ///  A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
    ///  into the first lowest bit, element `y` into the second, etc.
    fn is_negative_bitmask(_self: Val<bevy::math::I64Vec3>) -> u32 {
        let output: u32 = bevy::math::I64Vec3::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    ///  Computes the squared length of `self`.
    fn length_squared(_self: Val<bevy::math::I64Vec3>) -> i64 {
        let output: i64 = bevy::math::I64Vec3::length_squared(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::I64Vec3>) -> i64 {
        let output: i64 = bevy::math::I64Vec3::max_element(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::I64Vec3>) -> i64 {
        let output: i64 = bevy::math::I64Vec3::min_element(_self.into_inner()).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Ref<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Mul<
            &bevy::math::I64Vec3,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Mul<
            bevy::math::I64Vec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::I64Vec3>, rhs: i64) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Mul<
            i64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::I64Vec3>) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: i64, y: i64, z: i64) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::new(x, y, z).into();
        output
    }
    fn rem(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Ref<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Rem<
            &bevy::math::I64Vec3,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Rem<
            bevy::math::I64Vec3,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::I64Vec3>, rhs: i64) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Rem<
            i64,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
    ///  # Panics
    ///  This function will panic if any `rhs` element is 0 or the division results in overflow.
    ///  [Euclidean division]: i64::rem_euclid
    fn rem_euclid(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.
    fn saturating_add(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.
    fn saturating_add_unsigned(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating division of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.
    fn saturating_div(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.
    fn saturating_mul(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.
    fn saturating_sub(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.
    ///  In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.
    fn saturating_sub_unsigned(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec3>,
        if_true: Val<bevy::math::I64Vec3>,
        if_false: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with elements representing the sign of `self`.
    ///   - `0` if the number is zero
    ///   - `1` if the number is positive
    ///   - `-1` if the number is negative
    fn signum(_self: Val<bevy::math::I64Vec3>) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: i64) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Ref<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Sub<
            &bevy::math::I64Vec3,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Sub<
            bevy::math::I64Vec3,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::I64Vec3>, rhs: i64) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Sub<
            i64,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  `[x, y, z]`
    fn to_array(_self: Ref<bevy::math::I64Vec3>) -> [i64; 3] {
        let output: [i64; 3] = bevy::math::I64Vec3::to_array(&_self).into();
        output
    }
    ///  Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
    ///  Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].
    fn truncate(_self: Val<bevy::math::I64Vec3>) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec3::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::I64Vec3>, x: i64) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::I64Vec3>, y: i64) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `z`.
    fn with_z(_self: Val<bevy::math::I64Vec3>, z: i64) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.
    fn wrapping_add(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.
    ///  In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.
    fn wrapping_add_unsigned(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping division of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.
    fn wrapping_div(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.
    fn wrapping_mul(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.
    fn wrapping_sub(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.
    ///  In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.
    fn wrapping_sub_unsigned(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "i_64_vec_4_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::I64Vec4 {
    ///  Returns a vector containing the absolute value of each element of `self`.
    fn abs(_self: Val<bevy::math::I64Vec4>) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::abs(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Ref<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Add<
            &bevy::math::I64Vec4,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Add<
            bevy::math::I64Vec4,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::I64Vec4>, rhs: i64) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Add<
            i64,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f64`.
    fn as_dvec4(_self: Ref<bevy::math::I64Vec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::I64Vec4::as_dvec4(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i32`.
    fn as_ivec4(_self: Ref<bevy::math::I64Vec4>) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::I64Vec4::as_ivec4(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u64`.
    fn as_u64vec4(_self: Ref<bevy::math::I64Vec4>) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::I64Vec4::as_u64vec4(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u32`.
    fn as_uvec4(_self: Ref<bevy::math::I64Vec4>) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::I64Vec4::as_uvec4(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec4(_self: Ref<bevy::math::I64Vec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::I64Vec4::as_vec4(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::I64Vec4>) -> () {
        let output: () = <bevy::math::I64Vec4 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`i64::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::I64Vec4>,
        min: Val<bevy::math::I64Vec4>,
        max: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::I64Vec4>) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Compute the squared euclidean distance between two points in space.
    fn distance_squared(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> i64 {
        let output: i64 = bevy::math::I64Vec4::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Ref<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Div<
            &bevy::math::I64Vec4,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Div<
            bevy::math::I64Vec4,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::I64Vec4>, rhs: i64) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Div<
            i64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
    ///  # Panics
    ///  This function will panic if any `rhs` element is 0 or the division results in overflow.
    fn div_euclid(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) -> i64 {
        let output: i64 = bevy::math::I64Vec4::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::I64Vec4>) -> i64 {
        let output: i64 = bevy::math::I64Vec4::element_product(_self.into_inner())
            .into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::I64Vec4>) -> i64 {
        let output: i64 = bevy::math::I64Vec4::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::I64Vec4>, other: Ref<bevy::math::I64Vec4>) -> bool {
        let output: bool = <bevy::math::I64Vec4 as std::cmp::PartialEq<
            bevy::math::I64Vec4,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [i64; 4]) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::from_array(a).into();
        output
    }
    ///  Returns a bitmask with the lowest 4 bits set to the sign bits from the elements of `self`.
    ///  A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
    ///  into the first lowest bit, element `y` into the second, etc.
    fn is_negative_bitmask(_self: Val<bevy::math::I64Vec4>) -> u32 {
        let output: u32 = bevy::math::I64Vec4::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    ///  Computes the squared length of `self`.
    fn length_squared(_self: Val<bevy::math::I64Vec4>) -> i64 {
        let output: i64 = bevy::math::I64Vec4::length_squared(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::I64Vec4>) -> i64 {
        let output: i64 = bevy::math::I64Vec4::max_element(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::I64Vec4>) -> i64 {
        let output: i64 = bevy::math::I64Vec4::min_element(_self.into_inner()).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Ref<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Mul<
            &bevy::math::I64Vec4,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Mul<
            bevy::math::I64Vec4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::I64Vec4>, rhs: i64) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Mul<
            i64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::I64Vec4>) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: i64, y: i64, z: i64, w: i64) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::new(x, y, z, w)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Ref<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Rem<
            &bevy::math::I64Vec4,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Rem<
            bevy::math::I64Vec4,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::I64Vec4>, rhs: i64) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Rem<
            i64,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
    ///  # Panics
    ///  This function will panic if any `rhs` element is 0 or the division results in overflow.
    ///  [Euclidean division]: i64::rem_euclid
    fn rem_euclid(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.
    fn saturating_add(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.
    fn saturating_add_unsigned(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating division of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.
    fn saturating_div(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.
    fn saturating_mul(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.
    fn saturating_sub(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.
    ///  In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.
    fn saturating_sub_unsigned(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec4>,
        if_true: Val<bevy::math::I64Vec4>,
        if_false: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with elements representing the sign of `self`.
    ///   - `0` if the number is zero
    ///   - `1` if the number is positive
    ///   - `-1` if the number is negative
    fn signum(_self: Val<bevy::math::I64Vec4>) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: i64) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Ref<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Sub<
            &bevy::math::I64Vec4,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Sub<
            bevy::math::I64Vec4,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::I64Vec4>, rhs: i64) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Sub<
            i64,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  `[x, y, z, w]`
    fn to_array(_self: Ref<bevy::math::I64Vec4>) -> [i64; 4] {
        let output: [i64; 4] = bevy::math::I64Vec4::to_array(&_self).into();
        output
    }
    ///  Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
    ///  Truncation to [`I64Vec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].
    fn truncate(_self: Val<bevy::math::I64Vec4>) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec4::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `w`.
    fn with_w(_self: Val<bevy::math::I64Vec4>, w: i64) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::with_w(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::I64Vec4>, x: i64) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::I64Vec4>, y: i64) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `z`.
    fn with_z(_self: Val<bevy::math::I64Vec4>, z: i64) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.
    fn wrapping_add(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.
    ///  In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.
    fn wrapping_add_unsigned(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping division of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.
    fn wrapping_div(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.
    fn wrapping_mul(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.
    fn wrapping_sub(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.
    ///  In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.
    fn wrapping_sub_unsigned(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "u_vec_2_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::UVec2 {
    fn add(
        _self: Val<bevy::math::UVec2>,
        rhs: Ref<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Add<
            &bevy::math::UVec2,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Add<
            bevy::math::UVec2,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::UVec2>, rhs: u32) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Add<
            u32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f64`.
    fn as_dvec2(_self: Ref<bevy::math::UVec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::UVec2::as_dvec2(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `i64`.
    fn as_i64vec2(_self: Ref<bevy::math::UVec2>) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::UVec2::as_i64vec2(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i32`.
    fn as_ivec2(_self: Ref<bevy::math::UVec2>) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::UVec2::as_ivec2(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `u64`.
    fn as_u64vec2(_self: Ref<bevy::math::UVec2>) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::UVec2::as_u64vec2(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec2(_self: Ref<bevy::math::UVec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::UVec2::as_vec2(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::UVec2>) -> () {
        let output: () = <bevy::math::UVec2 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`u32::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::UVec2>,
        min: Val<bevy::math::UVec2>,
        max: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::UVec2>) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::UVec2>,
        rhs: Ref<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Div<
            &bevy::math::UVec2,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Div<
            bevy::math::UVec2,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::UVec2>, rhs: u32) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Div<
            u32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) -> u32 {
        let output: u32 = bevy::math::UVec2::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::UVec2>) -> u32 {
        let output: u32 = bevy::math::UVec2::element_product(_self.into_inner()).into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::UVec2>) -> u32 {
        let output: u32 = bevy::math::UVec2::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::UVec2>, other: Ref<bevy::math::UVec2>) -> bool {
        let output: bool = <bevy::math::UVec2 as std::cmp::PartialEq<
            bevy::math::UVec2,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a 3D vector from `self` and the given `z` value.
    fn extend(_self: Val<bevy::math::UVec2>, z: u32) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec2::extend(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [u32; 2]) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::from_array(a).into();
        output
    }
    ///  Computes the squared length of `self`.
    fn length_squared(_self: Val<bevy::math::UVec2>) -> u32 {
        let output: u32 = bevy::math::UVec2::length_squared(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::UVec2>) -> u32 {
        let output: u32 = bevy::math::UVec2::max_element(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::UVec2>) -> u32 {
        let output: u32 = bevy::math::UVec2::min_element(_self.into_inner()).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::UVec2>,
        rhs: Ref<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Mul<
            &bevy::math::UVec2,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Mul<
            bevy::math::UVec2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::UVec2>, rhs: u32) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Mul<
            u32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: u32, y: u32) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::new(x, y).into();
        output
    }
    fn rem(
        _self: Val<bevy::math::UVec2>,
        rhs: Ref<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Rem<
            &bevy::math::UVec2,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Rem<
            bevy::math::UVec2,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::UVec2>, rhs: u32) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Rem<
            u32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns a vector containing the saturating addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.
    fn saturating_add(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating addition of `self` and signed vector `rhs`.
    ///  In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.
    fn saturating_add_signed(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating division of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.
    fn saturating_div(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.
    fn saturating_mul(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.
    fn saturating_sub(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec2>,
        if_true: Val<bevy::math::UVec2>,
        if_false: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: u32) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::UVec2>,
        rhs: Ref<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Sub<
            &bevy::math::UVec2,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Sub<
            bevy::math::UVec2,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::UVec2>, rhs: u32) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Sub<
            u32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  `[x, y]`
    fn to_array(_self: Ref<bevy::math::UVec2>) -> [u32; 2] {
        let output: [u32; 2] = bevy::math::UVec2::to_array(&_self).into();
        output
    }
    ///  Creates a 2D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::UVec2>, x: u32) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 2D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::UVec2>, y: u32) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.
    fn wrapping_add(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.
    ///  In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.
    fn wrapping_add_signed(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping division of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.
    fn wrapping_div(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.
    fn wrapping_mul(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.
    fn wrapping_sub(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "u_vec_3_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::UVec3 {
    fn add(
        _self: Val<bevy::math::UVec3>,
        rhs: Ref<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Add<
            &bevy::math::UVec3,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Add<
            bevy::math::UVec3,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::UVec3>, rhs: u32) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Add<
            u32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f64`.
    fn as_dvec3(_self: Ref<bevy::math::UVec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::UVec3::as_dvec3(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `i64`.
    fn as_i64vec3(_self: Ref<bevy::math::UVec3>) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::UVec3::as_i64vec3(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i32`.
    fn as_ivec3(_self: Ref<bevy::math::UVec3>) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::UVec3::as_ivec3(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `u64`.
    fn as_u64vec3(_self: Ref<bevy::math::UVec3>) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::UVec3::as_u64vec3(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec3(_self: Ref<bevy::math::UVec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::UVec3::as_vec3(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec3a(_self: Ref<bevy::math::UVec3>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::UVec3::as_vec3a(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::UVec3>) -> () {
        let output: () = <bevy::math::UVec3 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`u32::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::UVec3>,
        min: Val<bevy::math::UVec3>,
        max: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::UVec3>) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the cross product of `self` and `rhs`.
    fn cross(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::cross(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::UVec3>,
        rhs: Ref<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Div<
            &bevy::math::UVec3,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Div<
            bevy::math::UVec3,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::UVec3>, rhs: u32) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Div<
            u32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) -> u32 {
        let output: u32 = bevy::math::UVec3::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::UVec3>) -> u32 {
        let output: u32 = bevy::math::UVec3::element_product(_self.into_inner()).into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::UVec3>) -> u32 {
        let output: u32 = bevy::math::UVec3::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::UVec3>, other: Ref<bevy::math::UVec3>) -> bool {
        let output: bool = <bevy::math::UVec3 as std::cmp::PartialEq<
            bevy::math::UVec3,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a 4D vector from `self` and the given `w` value.
    fn extend(_self: Val<bevy::math::UVec3>, w: u32) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec3::extend(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [u32; 3]) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::from_array(a).into();
        output
    }
    ///  Computes the squared length of `self`.
    fn length_squared(_self: Val<bevy::math::UVec3>) -> u32 {
        let output: u32 = bevy::math::UVec3::length_squared(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::UVec3>) -> u32 {
        let output: u32 = bevy::math::UVec3::max_element(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::UVec3>) -> u32 {
        let output: u32 = bevy::math::UVec3::min_element(_self.into_inner()).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::UVec3>,
        rhs: Ref<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Mul<
            &bevy::math::UVec3,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Mul<
            bevy::math::UVec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::UVec3>, rhs: u32) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Mul<
            u32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: u32, y: u32, z: u32) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::new(x, y, z).into();
        output
    }
    fn rem(
        _self: Val<bevy::math::UVec3>,
        rhs: Ref<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Rem<
            &bevy::math::UVec3,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Rem<
            bevy::math::UVec3,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::UVec3>, rhs: u32) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Rem<
            u32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns a vector containing the saturating addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.
    fn saturating_add(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating addition of `self` and signed vector `rhs`.
    ///  In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.
    fn saturating_add_signed(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating division of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.
    fn saturating_div(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.
    fn saturating_mul(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.
    fn saturating_sub(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec3>,
        if_true: Val<bevy::math::UVec3>,
        if_false: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: u32) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::UVec3>,
        rhs: Ref<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Sub<
            &bevy::math::UVec3,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Sub<
            bevy::math::UVec3,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::UVec3>, rhs: u32) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Sub<
            u32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  `[x, y, z]`
    fn to_array(_self: Ref<bevy::math::UVec3>) -> [u32; 3] {
        let output: [u32; 3] = bevy::math::UVec3::to_array(&_self).into();
        output
    }
    ///  Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
    ///  Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].
    fn truncate(_self: Val<bevy::math::UVec3>) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec3::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::UVec3>, x: u32) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::UVec3>, y: u32) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `z`.
    fn with_z(_self: Val<bevy::math::UVec3>, z: u32) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.
    fn wrapping_add(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.
    ///  In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.
    fn wrapping_add_signed(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping division of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.
    fn wrapping_div(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.
    fn wrapping_mul(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.
    fn wrapping_sub(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "u_vec_4_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::UVec4 {
    fn add(
        _self: Val<bevy::math::UVec4>,
        rhs: Ref<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Add<
            &bevy::math::UVec4,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Add<
            bevy::math::UVec4,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::UVec4>, rhs: u32) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Add<
            u32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f64`.
    fn as_dvec4(_self: Ref<bevy::math::UVec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::UVec4::as_dvec4(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `i64`.
    fn as_i64vec4(_self: Ref<bevy::math::UVec4>) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::UVec4::as_i64vec4(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i32`.
    fn as_ivec4(_self: Ref<bevy::math::UVec4>) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::UVec4::as_ivec4(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `u64`.
    fn as_u64vec4(_self: Ref<bevy::math::UVec4>) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::UVec4::as_u64vec4(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec4(_self: Ref<bevy::math::UVec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::UVec4::as_vec4(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::UVec4>) -> () {
        let output: () = <bevy::math::UVec4 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`u32::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::UVec4>,
        min: Val<bevy::math::UVec4>,
        max: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::UVec4>) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::UVec4>,
        rhs: Ref<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Div<
            &bevy::math::UVec4,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Div<
            bevy::math::UVec4,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::UVec4>, rhs: u32) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Div<
            u32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) -> u32 {
        let output: u32 = bevy::math::UVec4::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::UVec4>) -> u32 {
        let output: u32 = bevy::math::UVec4::element_product(_self.into_inner()).into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::UVec4>) -> u32 {
        let output: u32 = bevy::math::UVec4::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::UVec4>, other: Ref<bevy::math::UVec4>) -> bool {
        let output: bool = <bevy::math::UVec4 as std::cmp::PartialEq<
            bevy::math::UVec4,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [u32; 4]) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::from_array(a).into();
        output
    }
    ///  Computes the squared length of `self`.
    fn length_squared(_self: Val<bevy::math::UVec4>) -> u32 {
        let output: u32 = bevy::math::UVec4::length_squared(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::UVec4>) -> u32 {
        let output: u32 = bevy::math::UVec4::max_element(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::UVec4>) -> u32 {
        let output: u32 = bevy::math::UVec4::min_element(_self.into_inner()).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::UVec4>,
        rhs: Ref<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Mul<
            &bevy::math::UVec4,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Mul<
            bevy::math::UVec4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::UVec4>, rhs: u32) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Mul<
            u32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: u32, y: u32, z: u32, w: u32) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::new(x, y, z, w).into();
        output
    }
    fn rem(
        _self: Val<bevy::math::UVec4>,
        rhs: Ref<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Rem<
            &bevy::math::UVec4,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Rem<
            bevy::math::UVec4,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::UVec4>, rhs: u32) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Rem<
            u32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns a vector containing the saturating addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.
    fn saturating_add(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating addition of `self` and signed vector `rhs`.
    ///  In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.
    fn saturating_add_signed(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating division of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.
    fn saturating_div(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.
    fn saturating_mul(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.
    fn saturating_sub(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec4>,
        if_true: Val<bevy::math::UVec4>,
        if_false: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: u32) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::UVec4>,
        rhs: Ref<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Sub<
            &bevy::math::UVec4,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Sub<
            bevy::math::UVec4,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::UVec4>, rhs: u32) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Sub<
            u32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  `[x, y, z, w]`
    fn to_array(_self: Ref<bevy::math::UVec4>) -> [u32; 4] {
        let output: [u32; 4] = bevy::math::UVec4::to_array(&_self).into();
        output
    }
    ///  Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
    ///  Truncation to [`UVec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].
    fn truncate(_self: Val<bevy::math::UVec4>) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec4::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `w`.
    fn with_w(_self: Val<bevy::math::UVec4>, w: u32) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::with_w(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::UVec4>, x: u32) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::UVec4>, y: u32) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `z`.
    fn with_z(_self: Val<bevy::math::UVec4>, z: u32) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.
    fn wrapping_add(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.
    ///  In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.
    fn wrapping_add_signed(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping division of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.
    fn wrapping_div(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.
    fn wrapping_mul(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.
    fn wrapping_sub(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "u_64_vec_2_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::U64Vec2 {
    fn add(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Ref<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Add<
            &bevy::math::U64Vec2,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Add<
            bevy::math::U64Vec2,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::U64Vec2>, rhs: u64) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Add<
            u64,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f64`.
    fn as_dvec2(_self: Ref<bevy::math::U64Vec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::U64Vec2::as_dvec2(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i64`.
    fn as_i64vec2(_self: Ref<bevy::math::U64Vec2>) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::U64Vec2::as_i64vec2(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i32`.
    fn as_ivec2(_self: Ref<bevy::math::U64Vec2>) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::U64Vec2::as_ivec2(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u32`.
    fn as_uvec2(_self: Ref<bevy::math::U64Vec2>) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::U64Vec2::as_uvec2(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec2(_self: Ref<bevy::math::U64Vec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::U64Vec2::as_vec2(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::U64Vec2>) -> () {
        let output: () = <bevy::math::U64Vec2 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`u64::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::U64Vec2>,
        min: Val<bevy::math::U64Vec2>,
        max: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::U64Vec2>) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Ref<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Div<
            &bevy::math::U64Vec2,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Div<
            bevy::math::U64Vec2,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::U64Vec2>, rhs: u64) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Div<
            u64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) -> u64 {
        let output: u64 = bevy::math::U64Vec2::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::U64Vec2>) -> u64 {
        let output: u64 = bevy::math::U64Vec2::element_product(_self.into_inner())
            .into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::U64Vec2>) -> u64 {
        let output: u64 = bevy::math::U64Vec2::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::U64Vec2>, other: Ref<bevy::math::U64Vec2>) -> bool {
        let output: bool = <bevy::math::U64Vec2 as std::cmp::PartialEq<
            bevy::math::U64Vec2,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a 3D vector from `self` and the given `z` value.
    fn extend(_self: Val<bevy::math::U64Vec2>, z: u64) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec2::extend(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [u64; 2]) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::from_array(a).into();
        output
    }
    ///  Computes the squared length of `self`.
    fn length_squared(_self: Val<bevy::math::U64Vec2>) -> u64 {
        let output: u64 = bevy::math::U64Vec2::length_squared(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::U64Vec2>) -> u64 {
        let output: u64 = bevy::math::U64Vec2::max_element(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::U64Vec2>) -> u64 {
        let output: u64 = bevy::math::U64Vec2::min_element(_self.into_inner()).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Ref<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Mul<
            &bevy::math::U64Vec2,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Mul<
            bevy::math::U64Vec2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::U64Vec2>, rhs: u64) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Mul<
            u64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: u64, y: u64) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::new(x, y).into();
        output
    }
    fn rem(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Ref<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Rem<
            &bevy::math::U64Vec2,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Rem<
            bevy::math::U64Vec2,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::U64Vec2>, rhs: u64) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Rem<
            u64,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns a vector containing the saturating addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.
    fn saturating_add(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating addition of `self` and signed vector `rhs`.
    ///  In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.
    fn saturating_add_signed(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating division of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.
    fn saturating_div(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.
    fn saturating_mul(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.
    fn saturating_sub(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec2>,
        if_true: Val<bevy::math::U64Vec2>,
        if_false: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: u64) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Ref<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Sub<
            &bevy::math::U64Vec2,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Sub<
            bevy::math::U64Vec2,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::U64Vec2>, rhs: u64) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Sub<
            u64,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  `[x, y]`
    fn to_array(_self: Ref<bevy::math::U64Vec2>) -> [u64; 2] {
        let output: [u64; 2] = bevy::math::U64Vec2::to_array(&_self).into();
        output
    }
    ///  Creates a 2D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::U64Vec2>, x: u64) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 2D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::U64Vec2>, y: u64) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.
    fn wrapping_add(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.
    ///  In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.
    fn wrapping_add_signed(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping division of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.
    fn wrapping_div(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.
    fn wrapping_mul(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.
    fn wrapping_sub(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "u_64_vec_3_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::U64Vec3 {
    fn add(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Ref<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Add<
            &bevy::math::U64Vec3,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Add<
            bevy::math::U64Vec3,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::U64Vec3>, rhs: u64) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Add<
            u64,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f64`.
    fn as_dvec3(_self: Ref<bevy::math::U64Vec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::U64Vec3::as_dvec3(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i64`.
    fn as_i64vec3(_self: Ref<bevy::math::U64Vec3>) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::U64Vec3::as_i64vec3(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i32`.
    fn as_ivec3(_self: Ref<bevy::math::U64Vec3>) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::U64Vec3::as_ivec3(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u32`.
    fn as_uvec3(_self: Ref<bevy::math::U64Vec3>) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::U64Vec3::as_uvec3(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec3(_self: Ref<bevy::math::U64Vec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::U64Vec3::as_vec3(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec3a(_self: Ref<bevy::math::U64Vec3>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::U64Vec3::as_vec3a(&_self)
            .into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::U64Vec3>) -> () {
        let output: () = <bevy::math::U64Vec3 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`u64::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::U64Vec3>,
        min: Val<bevy::math::U64Vec3>,
        max: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::U64Vec3>) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the cross product of `self` and `rhs`.
    fn cross(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::cross(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Ref<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Div<
            &bevy::math::U64Vec3,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Div<
            bevy::math::U64Vec3,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::U64Vec3>, rhs: u64) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Div<
            u64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) -> u64 {
        let output: u64 = bevy::math::U64Vec3::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::U64Vec3>) -> u64 {
        let output: u64 = bevy::math::U64Vec3::element_product(_self.into_inner())
            .into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::U64Vec3>) -> u64 {
        let output: u64 = bevy::math::U64Vec3::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::U64Vec3>, other: Ref<bevy::math::U64Vec3>) -> bool {
        let output: bool = <bevy::math::U64Vec3 as std::cmp::PartialEq<
            bevy::math::U64Vec3,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a 4D vector from `self` and the given `w` value.
    fn extend(_self: Val<bevy::math::U64Vec3>, w: u64) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec3::extend(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [u64; 3]) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::from_array(a).into();
        output
    }
    ///  Computes the squared length of `self`.
    fn length_squared(_self: Val<bevy::math::U64Vec3>) -> u64 {
        let output: u64 = bevy::math::U64Vec3::length_squared(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::U64Vec3>) -> u64 {
        let output: u64 = bevy::math::U64Vec3::max_element(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::U64Vec3>) -> u64 {
        let output: u64 = bevy::math::U64Vec3::min_element(_self.into_inner()).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Ref<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Mul<
            &bevy::math::U64Vec3,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Mul<
            bevy::math::U64Vec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::U64Vec3>, rhs: u64) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Mul<
            u64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: u64, y: u64, z: u64) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::new(x, y, z).into();
        output
    }
    fn rem(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Ref<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Rem<
            &bevy::math::U64Vec3,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Rem<
            bevy::math::U64Vec3,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::U64Vec3>, rhs: u64) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Rem<
            u64,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns a vector containing the saturating addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.
    fn saturating_add(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating addition of `self` and signed vector `rhs`.
    ///  In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.
    fn saturating_add_signed(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating division of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.
    fn saturating_div(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.
    fn saturating_mul(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.
    fn saturating_sub(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec3>,
        if_true: Val<bevy::math::U64Vec3>,
        if_false: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: u64) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Ref<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Sub<
            &bevy::math::U64Vec3,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Sub<
            bevy::math::U64Vec3,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::U64Vec3>, rhs: u64) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Sub<
            u64,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  `[x, y, z]`
    fn to_array(_self: Ref<bevy::math::U64Vec3>) -> [u64; 3] {
        let output: [u64; 3] = bevy::math::U64Vec3::to_array(&_self).into();
        output
    }
    ///  Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
    ///  Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].
    fn truncate(_self: Val<bevy::math::U64Vec3>) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec3::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::U64Vec3>, x: u64) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::U64Vec3>, y: u64) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `z`.
    fn with_z(_self: Val<bevy::math::U64Vec3>, z: u64) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.
    fn wrapping_add(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.
    ///  In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.
    fn wrapping_add_signed(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping division of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.
    fn wrapping_div(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.
    fn wrapping_mul(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.
    fn wrapping_sub(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "u_64_vec_4_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::U64Vec4 {
    fn add(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Ref<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Add<
            &bevy::math::U64Vec4,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Add<
            bevy::math::U64Vec4,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::U64Vec4>, rhs: u64) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Add<
            u64,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f64`.
    fn as_dvec4(_self: Ref<bevy::math::U64Vec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::U64Vec4::as_dvec4(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i64`.
    fn as_i64vec4(_self: Ref<bevy::math::U64Vec4>) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::U64Vec4::as_i64vec4(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i32`.
    fn as_ivec4(_self: Ref<bevy::math::U64Vec4>) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::U64Vec4::as_ivec4(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u32`.
    fn as_uvec4(_self: Ref<bevy::math::U64Vec4>) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::U64Vec4::as_uvec4(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec4(_self: Ref<bevy::math::U64Vec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::U64Vec4::as_vec4(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::U64Vec4>) -> () {
        let output: () = <bevy::math::U64Vec4 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`u64::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::U64Vec4>,
        min: Val<bevy::math::U64Vec4>,
        max: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::U64Vec4>) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Ref<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Div<
            &bevy::math::U64Vec4,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Div<
            bevy::math::U64Vec4,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::U64Vec4>, rhs: u64) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Div<
            u64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) -> u64 {
        let output: u64 = bevy::math::U64Vec4::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::U64Vec4>) -> u64 {
        let output: u64 = bevy::math::U64Vec4::element_product(_self.into_inner())
            .into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::U64Vec4>) -> u64 {
        let output: u64 = bevy::math::U64Vec4::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::U64Vec4>, other: Ref<bevy::math::U64Vec4>) -> bool {
        let output: bool = <bevy::math::U64Vec4 as std::cmp::PartialEq<
            bevy::math::U64Vec4,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [u64; 4]) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::from_array(a).into();
        output
    }
    ///  Computes the squared length of `self`.
    fn length_squared(_self: Val<bevy::math::U64Vec4>) -> u64 {
        let output: u64 = bevy::math::U64Vec4::length_squared(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::U64Vec4>) -> u64 {
        let output: u64 = bevy::math::U64Vec4::max_element(_self.into_inner()).into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::U64Vec4>) -> u64 {
        let output: u64 = bevy::math::U64Vec4::min_element(_self.into_inner()).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Ref<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Mul<
            &bevy::math::U64Vec4,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Mul<
            bevy::math::U64Vec4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::U64Vec4>, rhs: u64) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Mul<
            u64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: u64, y: u64, z: u64, w: u64) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::new(x, y, z, w)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Ref<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Rem<
            &bevy::math::U64Vec4,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Rem<
            bevy::math::U64Vec4,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::U64Vec4>, rhs: u64) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Rem<
            u64,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns a vector containing the saturating addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.
    fn saturating_add(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating addition of `self` and signed vector `rhs`.
    ///  In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.
    fn saturating_add_signed(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating division of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.
    fn saturating_div(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.
    fn saturating_mul(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the saturating subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.
    fn saturating_sub(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec4>,
        if_true: Val<bevy::math::U64Vec4>,
        if_false: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: u64) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Ref<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Sub<
            &bevy::math::U64Vec4,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Sub<
            bevy::math::U64Vec4,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::U64Vec4>, rhs: u64) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Sub<
            u64,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  `[x, y, z, w]`
    fn to_array(_self: Ref<bevy::math::U64Vec4>) -> [u64; 4] {
        let output: [u64; 4] = bevy::math::U64Vec4::to_array(&_self).into();
        output
    }
    ///  Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
    ///  Truncation to [`U64Vec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].
    fn truncate(_self: Val<bevy::math::U64Vec4>) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec4::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `w`.
    fn with_w(_self: Val<bevy::math::U64Vec4>, w: u64) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::with_w(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::U64Vec4>, x: u64) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::U64Vec4>, y: u64) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `z`.
    fn with_z(_self: Val<bevy::math::U64Vec4>, z: u64) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.
    fn wrapping_add(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.
    ///  In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.
    fn wrapping_add_signed(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping division of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.
    fn wrapping_div(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping multiplication of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.
    fn wrapping_mul(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the wrapping subtraction of `self` and `rhs`.
    ///  In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.
    fn wrapping_sub(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "vec_2_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::Vec2 {
    ///  Returns a vector containing the absolute value of each element of `self`.
    fn abs(_self: Val<bevy::math::Vec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::abs(_self.into_inner())
            .into();
        output
    }
    ///  Returns true if the absolute difference of all elements between `self` and `rhs` is
    ///  less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two vectors contain similar elements. It works best when
    ///  comparing with a known value. The `max_abs_diff` that should be used used depends on
    ///  the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
        max_abs_diff: f32,
    ) -> bool {
        let output: bool = bevy::math::Vec2::abs_diff_eq(
                _self.into_inner(),
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::Vec2>,
        rhs: Ref<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Add<
            &bevy::math::Vec2,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Add<
            bevy::math::Vec2,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Vec2>, rhs: f32) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Add<
            f32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn angle_between(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) -> f32 {
        let output: f32 = bevy::math::Vec2::angle_between(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the angle of rotation (in radians) from `self` to `rhs` in the range `[-π, +π]`.
    ///  The inputs do not need to be unit vectors however they must be non-zero.
    fn angle_to(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) -> f32 {
        let output: f32 = bevy::math::Vec2::angle_to(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Casts all elements of `self` to `f64`.
    fn as_dvec2(_self: Ref<bevy::math::Vec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::Vec2::as_dvec2(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `i64`.
    fn as_i64vec2(_self: Ref<bevy::math::Vec2>) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::Vec2::as_i64vec2(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i32`.
    fn as_ivec2(_self: Ref<bevy::math::Vec2>) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::Vec2::as_ivec2(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `u64`.
    fn as_u64vec2(_self: Ref<bevy::math::Vec2>) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::Vec2::as_u64vec2(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u32`.
    fn as_uvec2(_self: Ref<bevy::math::Vec2>) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::Vec2::as_uvec2(&_self).into();
        output
    }
    ///  Returns a vector containing the smallest integer greater than or equal to a number for
    ///  each element of `self`.
    fn ceil(_self: Val<bevy::math::Vec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::ceil(_self.into_inner())
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`f32::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::Vec2>,
        min: Val<bevy::math::Vec2>,
        max: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with a length no less than `min` and no more than `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.
    fn clamp_length(
        _self: Val<bevy::math::Vec2>,
        min: f32,
        max: f32,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::clamp_length(
                _self.into_inner(),
                min,
                max,
            )
            .into();
        output
    }
    ///  Returns a vector with a length no more than `max`.
    ///  # Panics
    ///  Will panic if `max` is negative when `glam_assert` is enabled.
    fn clamp_length_max(
        _self: Val<bevy::math::Vec2>,
        max: f32,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::clamp_length_max(
                _self.into_inner(),
                max,
            )
            .into();
        output
    }
    ///  Returns a vector with a length no less than `min`.
    ///  # Panics
    ///  Will panic if `min` is negative when `glam_assert` is enabled.
    fn clamp_length_min(
        _self: Val<bevy::math::Vec2>,
        min: f32,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::clamp_length_min(
                _self.into_inner(),
                min,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::Vec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with signs of `rhs` and the magnitudes of `self`.
    fn copysign(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::copysign(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the Euclidean distance between two points in space.
    fn distance(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) -> f32 {
        let output: f32 = bevy::math::Vec2::distance(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Compute the squared euclidean distance between two points in space.
    fn distance_squared(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> f32 {
        let output: f32 = bevy::math::Vec2::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::Vec2>,
        rhs: Ref<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Div<
            &bevy::math::Vec2,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Div<
            bevy::math::Vec2,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::Vec2>, rhs: f32) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Div<
            f32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
    fn div_euclid(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) -> f32 {
        let output: f32 = bevy::math::Vec2::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::Vec2>) -> f32 {
        let output: f32 = bevy::math::Vec2::element_product(_self.into_inner()).into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::Vec2>) -> f32 {
        let output: f32 = bevy::math::Vec2::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::Vec2>, other: Ref<bevy::math::Vec2>) -> bool {
        let output: bool = <bevy::math::Vec2 as std::cmp::PartialEq<
            bevy::math::Vec2,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Returns a vector containing `e^self` (the exponential function) for each element of
    ///  `self`.
    fn exp(_self: Val<bevy::math::Vec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::exp(_self.into_inner())
            .into();
        output
    }
    ///  Creates a 3D vector from `self` and the given `z` value.
    fn extend(_self: Val<bevy::math::Vec2>, z: f32) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec2::extend(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    ///  Returns a vector containing the largest integer less than or equal to a number for each
    ///  element of `self`.
    fn floor(_self: Val<bevy::math::Vec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::floor(_self.into_inner())
            .into();
        output
    }
    ///  Returns a vector containing the fractional part of the vector as `self - self.trunc()`.
    ///  Note that this differs from the GLSL implementation of `fract` which returns
    ///  `self - self.floor()`.
    ///  Note that this is fast but not precise for large numbers.
    fn fract(_self: Val<bevy::math::Vec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::fract(_self.into_inner())
            .into();
        output
    }
    ///  Returns a vector containing the fractional part of the vector as `self - self.floor()`.
    ///  Note that this differs from the Rust implementation of `fract` which returns
    ///  `self - self.trunc()`.
    ///  Note that this is fast but not precise for large numbers.
    fn fract_gl(_self: Val<bevy::math::Vec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::fract_gl(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 2D vector containing `[angle.cos(), angle.sin()]`. This can be used in
    ///  conjunction with the [`rotate()`][Self::rotate()] method, e.g.
    ///  `Vec2::from_angle(PI).rotate(Vec2::Y)` will create the vector `[-1, 0]`
    ///  and rotate [`Vec2::Y`] around it returning `-Vec2::Y`.
    fn from_angle(angle: f32) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::from_angle(angle).into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [f32; 2]) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::from_array(a).into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.  If any element is either
    ///  `NaN`, positive or negative infinity, this will return `false`.
    fn is_finite(_self: Val<bevy::math::Vec2>) -> bool {
        let output: bool = bevy::math::Vec2::is_finite(_self.into_inner()).into();
        output
    }
    ///  Performs `is_finite` on each element of self, returning a vector mask of the results.
    ///  In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.
    fn is_finite_mask(_self: Val<bevy::math::Vec2>) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::Vec2::is_finite_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `true` if any elements are `NaN`.
    fn is_nan(_self: Val<bevy::math::Vec2>) -> bool {
        let output: bool = bevy::math::Vec2::is_nan(_self.into_inner()).into();
        output
    }
    ///  Performs `is_nan` on each element of self, returning a vector mask of the results.
    ///  In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.
    fn is_nan_mask(_self: Val<bevy::math::Vec2>) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::Vec2::is_nan_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `self`.
    ///  A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
    ///  into the first lowest bit, element `y` into the second, etc.
    fn is_negative_bitmask(_self: Val<bevy::math::Vec2>) -> u32 {
        let output: u32 = bevy::math::Vec2::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    ///  Returns whether `self` is length `1.0` or not.
    ///  Uses a precision threshold of approximately `1e-4`.
    fn is_normalized(_self: Val<bevy::math::Vec2>) -> bool {
        let output: bool = bevy::math::Vec2::is_normalized(_self.into_inner()).into();
        output
    }
    ///  Computes the length of `self`.
    fn length(_self: Val<bevy::math::Vec2>) -> f32 {
        let output: f32 = bevy::math::Vec2::length(_self.into_inner()).into();
        output
    }
    ///  Computes `1.0 / length()`.
    ///  For valid results, `self` must _not_ be of length zero.
    fn length_recip(_self: Val<bevy::math::Vec2>) -> f32 {
        let output: f32 = bevy::math::Vec2::length_recip(_self.into_inner()).into();
        output
    }
    ///  Computes the squared length of `self`.
    ///  This is faster than `length()` as it avoids a square root operation.
    fn length_squared(_self: Val<bevy::math::Vec2>) -> f32 {
        let output: f32 = bevy::math::Vec2::length_squared(_self.into_inner()).into();
        output
    }
    ///  Performs a linear interpolation between `self` and `rhs` based on the value `s`.
    ///  When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
    ///  will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
    ///  extrapolated.
    fn lerp(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
        s: f32,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::lerp(
                _self.into_inner(),
                rhs.into_inner(),
                s,
            )
            .into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::Vec2>) -> f32 {
        let output: f32 = bevy::math::Vec2::max_element(_self.into_inner()).into();
        output
    }
    ///  Calculates the midpoint between `self` and `rhs`.
    ///  The midpoint is the average of, or halfway point between, two vectors.
    ///  `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`
    ///  while being slightly cheaper to compute.
    fn midpoint(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::midpoint(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::Vec2>) -> f32 {
        let output: f32 = bevy::math::Vec2::min_element(_self.into_inner()).into();
        output
    }
    ///  Moves towards `rhs` based on the value `d`.
    ///  When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to
    ///  `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.
    fn move_towards(
        _self: Ref<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
        d: f32,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::move_towards(
                &_self,
                rhs.into_inner(),
                d,
            )
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Vec2>,
        rhs: Ref<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Mul<
            &bevy::math::Vec2,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Mul<
            bevy::math::Vec2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Vec2>, rhs: f32) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Mul<
            f32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
    ///  error, yielding a more accurate result than an unfused multiply-add.
    ///  Using `mul_add` *may* be more performant than an unfused multiply-add if the target
    ///  architecture has a dedicated fma CPU instruction. However, this is not always true,
    ///  and will be heavily dependant on designing algorithms with specific target hardware in
    ///  mind.
    fn mul_add(
        _self: Val<bevy::math::Vec2>,
        a: Val<bevy::math::Vec2>,
        b: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::mul_add(
                _self.into_inner(),
                a.into_inner(),
                b.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::Vec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: f32, y: f32) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::new(x, y).into();
        output
    }
    ///  Returns `self` normalized to length 1.0.
    ///  For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.
    ///  See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].
    ///  Panics
    ///  Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.
    fn normalize(_self: Val<bevy::math::Vec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::normalize(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `self` normalized to length 1.0 if possible, else returns a
    ///  fallback value.
    ///  In particular, if the input is zero (or very close to zero), or non-finite,
    ///  the result of this operation will be the fallback value.
    ///  See also [`Self::try_normalize()`].
    fn normalize_or(
        _self: Val<bevy::math::Vec2>,
        fallback: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::normalize_or(
                _self.into_inner(),
                fallback.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `self` normalized to length 1.0 if possible, else returns zero.
    ///  In particular, if the input is zero (or very close to zero), or non-finite,
    ///  the result of this operation will be zero.
    ///  See also [`Self::try_normalize()`].
    fn normalize_or_zero(_self: Val<bevy::math::Vec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::normalize_or_zero(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector that is equal to `self` rotated by 90 degrees.
    fn perp(_self: Val<bevy::math::Vec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::perp(_self.into_inner())
            .into();
        output
    }
    ///  The perpendicular dot product of `self` and `rhs`.
    ///  Also known as the wedge product, 2D cross product, and determinant.
    fn perp_dot(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) -> f32 {
        let output: f32 = bevy::math::Vec2::perp_dot(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing each element of `self` raised to the power of `n`.
    fn powf(_self: Val<bevy::math::Vec2>, n: f32) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::powf(_self.into_inner(), n)
            .into();
        output
    }
    ///  Returns the vector projection of `self` onto `rhs`.
    ///  `rhs` must be of non-zero length.
    ///  # Panics
    ///  Will panic if `rhs` is zero length when `glam_assert` is enabled.
    fn project_onto(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::project_onto(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the vector projection of `self` onto `rhs`.
    ///  `rhs` must be normalized.
    ///  # Panics
    ///  Will panic if `rhs` is not normalized when `glam_assert` is enabled.
    fn project_onto_normalized(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::project_onto_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
    fn recip(_self: Val<bevy::math::Vec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::recip(_self.into_inner())
            .into();
        output
    }
    ///  Returns the reflection vector for a given incident vector `self` and surface normal
    ///  `normal`.
    ///  `normal` must be normalized.
    ///  # Panics
    ///  Will panic if `normal` is not normalized when `glam_assert` is enabled.
    fn reflect(
        _self: Val<bevy::math::Vec2>,
        normal: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::reflect(
                _self.into_inner(),
                normal.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the refraction direction for a given incident vector `self`, surface normal
    ///  `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,
    ///  a zero vector will be returned.
    ///  `self` and `normal` must be normalized.
    ///  # Panics
    ///  Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.
    fn refract(
        _self: Val<bevy::math::Vec2>,
        normal: Val<bevy::math::Vec2>,
        eta: f32,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::refract(
                _self.into_inner(),
                normal.into_inner(),
                eta,
            )
            .into();
        output
    }
    ///  Returns the vector rejection of `self` from `rhs`.
    ///  The vector rejection is the vector perpendicular to the projection of `self` onto
    ///  `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
    ///  `rhs` must be of non-zero length.
    ///  # Panics
    ///  Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
    fn reject_from(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::reject_from(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the vector rejection of `self` from `rhs`.
    ///  The vector rejection is the vector perpendicular to the projection of `self` onto
    ///  `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
    ///  `rhs` must be normalized.
    ///  # Panics
    ///  Will panic if `rhs` is not normalized when `glam_assert` is enabled.
    fn reject_from_normalized(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::reject_from_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::Vec2>,
        rhs: Ref<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Rem<
            &bevy::math::Vec2,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Rem<
            bevy::math::Vec2,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::Vec2>, rhs: f32) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Rem<
            f32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
    ///  [Euclidean division]: f32::rem_euclid
    fn rem_euclid(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
    ///  then this just rotation. This is what you usually want. Otherwise,
    ///  it will be like a rotation with a multiplication by `self`'s length.
    fn rotate(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::rotate(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Rotates towards `rhs` up to `max_angle` (in radians).
    ///  When `max_angle` is `0.0`, the result will be equal to `self`. When `max_angle` is equal to
    ///  `self.angle_between(rhs)`, the result will be equal to `rhs`. If `max_angle` is negative,
    ///  rotates towards the exact opposite of `rhs`. Will not go past the target.
    fn rotate_towards(
        _self: Ref<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
        max_angle: f32,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::rotate_towards(
                &_self,
                rhs.into_inner(),
                max_angle,
            )
            .into();
        output
    }
    ///  Returns a vector containing the nearest integer to a number for each element of `self`.
    ///  Round half-way cases away from 0.0.
    fn round(_self: Val<bevy::math::Vec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::round(_self.into_inner())
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec2>,
        if_true: Val<bevy::math::Vec2>,
        if_false: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with elements representing the sign of `self`.
    ///  - `1.0` if the number is positive, `+0.0` or `INFINITY`
    ///  - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
    ///  - `NAN` if the number is `NAN`
    fn signum(_self: Val<bevy::math::Vec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::signum(_self.into_inner())
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: f32) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::Vec2>,
        rhs: Ref<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Sub<
            &bevy::math::Vec2,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Sub<
            bevy::math::Vec2,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::Vec2>, rhs: f32) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Sub<
            f32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the angle (in radians) of this vector in the range `[-π, +π]`.
    ///  The input does not need to be a unit vector however it must be non-zero.
    fn to_angle(_self: Val<bevy::math::Vec2>) -> f32 {
        let output: f32 = bevy::math::Vec2::to_angle(_self.into_inner()).into();
        output
    }
    ///  `[x, y]`
    fn to_array(_self: Ref<bevy::math::Vec2>) -> [f32; 2] {
        let output: [f32; 2] = bevy::math::Vec2::to_array(&_self).into();
        output
    }
    ///  Returns a vector containing the integer part each element of `self`. This means numbers are
    ///  always truncated towards zero.
    fn trunc(_self: Val<bevy::math::Vec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::trunc(_self.into_inner())
            .into();
        output
    }
    ///  Creates a 2D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::Vec2>, x: f32) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 2D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::Vec2>, y: f32) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "vec_3_a_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::Vec3A {
    ///  Returns a vector containing the absolute value of each element of `self`.
    fn abs(_self: Val<bevy::math::Vec3A>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::abs(_self.into_inner())
            .into();
        output
    }
    ///  Returns true if the absolute difference of all elements between `self` and `rhs` is
    ///  less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two vectors contain similar elements. It works best when
    ///  comparing with a known value. The `max_abs_diff` that should be used used depends on
    ///  the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
        max_abs_diff: f32,
    ) -> bool {
        let output: bool = bevy::math::Vec3A::abs_diff_eq(
                _self.into_inner(),
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::Vec3A>,
        rhs: Ref<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Add<
            &bevy::math::Vec3A,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Add<
            bevy::math::Vec3A,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Vec3A>, rhs: f32) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Add<
            f32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the angle (in radians) between two vectors in the range `[0, +π]`.
    ///  The inputs do not need to be unit vectors however they must be non-zero.
    fn angle_between(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) -> f32 {
        let output: f32 = bevy::math::Vec3A::angle_between(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns some vector that is orthogonal to the given one.
    ///  The input vector must be finite and non-zero.
    ///  The output vector is not necessarily unit length. For that use
    ///  [`Self::any_orthonormal_vector()`] instead.
    fn any_orthogonal_vector(_self: Ref<bevy::math::Vec3A>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::any_orthogonal_vector(
                &_self,
            )
            .into();
        output
    }
    ///  Returns any unit vector that is orthogonal to the given one.
    ///  The input vector must be unit length.
    ///  # Panics
    ///  Will panic if `self` is not normalized when `glam_assert` is enabled.
    fn any_orthonormal_vector(_self: Ref<bevy::math::Vec3A>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::any_orthonormal_vector(
                &_self,
            )
            .into();
        output
    }
    ///  Casts all elements of `self` to `f64`.
    fn as_dvec3(_self: Ref<bevy::math::Vec3A>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::Vec3A::as_dvec3(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `i64`.
    fn as_i64vec3(_self: Ref<bevy::math::Vec3A>) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::Vec3A::as_i64vec3(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i32`.
    fn as_ivec3(_self: Ref<bevy::math::Vec3A>) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::Vec3A::as_ivec3(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `u64`.
    fn as_u64vec3(_self: Ref<bevy::math::Vec3A>) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::Vec3A::as_u64vec3(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u32`.
    fn as_uvec3(_self: Ref<bevy::math::Vec3A>) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::Vec3A::as_uvec3(&_self).into();
        output
    }
    ///  Returns a vector containing the smallest integer greater than or equal to a number for
    ///  each element of `self`.
    fn ceil(_self: Val<bevy::math::Vec3A>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::ceil(_self.into_inner())
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`f32::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::Vec3A>,
        min: Val<bevy::math::Vec3A>,
        max: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with a length no less than `min` and no more than `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.
    fn clamp_length(
        _self: Val<bevy::math::Vec3A>,
        min: f32,
        max: f32,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::clamp_length(
                _self.into_inner(),
                min,
                max,
            )
            .into();
        output
    }
    ///  Returns a vector with a length no more than `max`.
    ///  # Panics
    ///  Will panic if `max` is negative when `glam_assert` is enabled.
    fn clamp_length_max(
        _self: Val<bevy::math::Vec3A>,
        max: f32,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::clamp_length_max(
                _self.into_inner(),
                max,
            )
            .into();
        output
    }
    ///  Returns a vector with a length no less than `min`.
    ///  # Panics
    ///  Will panic if `min` is negative when `glam_assert` is enabled.
    fn clamp_length_min(
        _self: Val<bevy::math::Vec3A>,
        min: f32,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::clamp_length_min(
                _self.into_inner(),
                min,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::Vec3A>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::BVec3A> {
        let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::BVec3A> {
        let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::BVec3A> {
        let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::BVec3A> {
        let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::BVec3A> {
        let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::BVec3A> {
        let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with signs of `rhs` and the magnitudes of `self`.
    fn copysign(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::copysign(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the cross product of `self` and `rhs`.
    fn cross(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::cross(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the Euclidean distance between two points in space.
    fn distance(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) -> f32 {
        let output: f32 = bevy::math::Vec3A::distance(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Compute the squared euclidean distance between two points in space.
    fn distance_squared(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> f32 {
        let output: f32 = bevy::math::Vec3A::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::Vec3A>,
        rhs: Ref<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Div<
            &bevy::math::Vec3A,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Div<
            bevy::math::Vec3A,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::Vec3A>, rhs: f32) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Div<
            f32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
    fn div_euclid(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) -> f32 {
        let output: f32 = bevy::math::Vec3A::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::Vec3A>) -> f32 {
        let output: f32 = bevy::math::Vec3A::element_product(_self.into_inner()).into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::Vec3A>) -> f32 {
        let output: f32 = bevy::math::Vec3A::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>) -> bool {
        let output: bool = <bevy::math::Vec3A as std::cmp::PartialEq<
            bevy::math::Vec3A,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    ///  Returns a vector containing `e^self` (the exponential function) for each element of
    ///  `self`.
    fn exp(_self: Val<bevy::math::Vec3A>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::exp(_self.into_inner())
            .into();
        output
    }
    ///  Creates a 4D vector from `self` and the given `w` value.
    fn extend(_self: Val<bevy::math::Vec3A>, w: f32) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec3A::extend(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    ///  Returns a vector containing the largest integer less than or equal to a number for each
    ///  element of `self`.
    fn floor(_self: Val<bevy::math::Vec3A>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::floor(_self.into_inner())
            .into();
        output
    }
    ///  Returns a vector containing the fractional part of the vector as `self - self.trunc()`.
    ///  Note that this differs from the GLSL implementation of `fract` which returns
    ///  `self - self.floor()`.
    ///  Note that this is fast but not precise for large numbers.
    fn fract(_self: Val<bevy::math::Vec3A>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::fract(_self.into_inner())
            .into();
        output
    }
    ///  Returns a vector containing the fractional part of the vector as `self - self.floor()`.
    ///  Note that this differs from the Rust implementation of `fract` which returns
    ///  `self - self.trunc()`.
    ///  Note that this is fast but not precise for large numbers.
    fn fract_gl(_self: Val<bevy::math::Vec3A>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::fract_gl(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [f32; 3]) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::from_array(a).into();
        output
    }
    ///  Creates a [`Vec3A`] from the `x`, `y` and `z` elements of `self` discarding `w`.
    ///  On architectures where SIMD is supported such as SSE2 on `x86_64` this conversion is a noop.
    fn from_vec4(v: Val<bevy::math::Vec4>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::from_vec4(v.into_inner())
            .into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.  If any element is either
    ///  `NaN`, positive or negative infinity, this will return `false`.
    fn is_finite(_self: Val<bevy::math::Vec3A>) -> bool {
        let output: bool = bevy::math::Vec3A::is_finite(_self.into_inner()).into();
        output
    }
    ///  Performs `is_finite` on each element of self, returning a vector mask of the results.
    ///  In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.
    fn is_finite_mask(_self: Val<bevy::math::Vec3A>) -> Val<bevy::math::BVec3A> {
        let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::is_finite_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `true` if any elements are `NaN`.
    fn is_nan(_self: Val<bevy::math::Vec3A>) -> bool {
        let output: bool = bevy::math::Vec3A::is_nan(_self.into_inner()).into();
        output
    }
    ///  Performs `is_nan` on each element of self, returning a vector mask of the results.
    ///  In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.
    fn is_nan_mask(_self: Val<bevy::math::Vec3A>) -> Val<bevy::math::BVec3A> {
        let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::is_nan_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.
    ///  A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
    ///  into the first lowest bit, element `y` into the second, etc.
    fn is_negative_bitmask(_self: Val<bevy::math::Vec3A>) -> u32 {
        let output: u32 = bevy::math::Vec3A::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    ///  Returns whether `self` is length `1.0` or not.
    ///  Uses a precision threshold of approximately `1e-4`.
    fn is_normalized(_self: Val<bevy::math::Vec3A>) -> bool {
        let output: bool = bevy::math::Vec3A::is_normalized(_self.into_inner()).into();
        output
    }
    ///  Computes the length of `self`.
    fn length(_self: Val<bevy::math::Vec3A>) -> f32 {
        let output: f32 = bevy::math::Vec3A::length(_self.into_inner()).into();
        output
    }
    ///  Computes `1.0 / length()`.
    ///  For valid results, `self` must _not_ be of length zero.
    fn length_recip(_self: Val<bevy::math::Vec3A>) -> f32 {
        let output: f32 = bevy::math::Vec3A::length_recip(_self.into_inner()).into();
        output
    }
    ///  Computes the squared length of `self`.
    ///  This is faster than `length()` as it avoids a square root operation.
    fn length_squared(_self: Val<bevy::math::Vec3A>) -> f32 {
        let output: f32 = bevy::math::Vec3A::length_squared(_self.into_inner()).into();
        output
    }
    ///  Performs a linear interpolation between `self` and `rhs` based on the value `s`.
    ///  When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
    ///  will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
    ///  extrapolated.
    fn lerp(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
        s: f32,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::lerp(
                _self.into_inner(),
                rhs.into_inner(),
                s,
            )
            .into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::Vec3A>) -> f32 {
        let output: f32 = bevy::math::Vec3A::max_element(_self.into_inner()).into();
        output
    }
    ///  Calculates the midpoint between `self` and `rhs`.
    ///  The midpoint is the average of, or halfway point between, two vectors.
    ///  `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`
    ///  while being slightly cheaper to compute.
    fn midpoint(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::midpoint(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::Vec3A>) -> f32 {
        let output: f32 = bevy::math::Vec3A::min_element(_self.into_inner()).into();
        output
    }
    ///  Moves towards `rhs` based on the value `d`.
    ///  When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to
    ///  `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.
    fn move_towards(
        _self: Ref<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
        d: f32,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::move_towards(
                &_self,
                rhs.into_inner(),
                d,
            )
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Vec3A>,
        rhs: Ref<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Mul<
            &bevy::math::Vec3A,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Mul<
            bevy::math::Vec3A,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Vec3A>, rhs: f32) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Mul<
            f32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
    ///  error, yielding a more accurate result than an unfused multiply-add.
    ///  Using `mul_add` *may* be more performant than an unfused multiply-add if the target
    ///  architecture has a dedicated fma CPU instruction. However, this is not always true,
    ///  and will be heavily dependant on designing algorithms with specific target hardware in
    ///  mind.
    fn mul_add(
        _self: Val<bevy::math::Vec3A>,
        a: Val<bevy::math::Vec3A>,
        b: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::mul_add(
                _self.into_inner(),
                a.into_inner(),
                b.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::Vec3A>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: f32, y: f32, z: f32) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::new(x, y, z).into();
        output
    }
    ///  Returns `self` normalized to length 1.0.
    ///  For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.
    ///  See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].
    ///  Panics
    ///  Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.
    fn normalize(_self: Val<bevy::math::Vec3A>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::normalize(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `self` normalized to length 1.0 if possible, else returns a
    ///  fallback value.
    ///  In particular, if the input is zero (or very close to zero), or non-finite,
    ///  the result of this operation will be the fallback value.
    ///  See also [`Self::try_normalize()`].
    fn normalize_or(
        _self: Val<bevy::math::Vec3A>,
        fallback: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::normalize_or(
                _self.into_inner(),
                fallback.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `self` normalized to length 1.0 if possible, else returns zero.
    ///  In particular, if the input is zero (or very close to zero), or non-finite,
    ///  the result of this operation will be zero.
    ///  See also [`Self::try_normalize()`].
    fn normalize_or_zero(_self: Val<bevy::math::Vec3A>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::normalize_or_zero(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing each element of `self` raised to the power of `n`.
    fn powf(_self: Val<bevy::math::Vec3A>, n: f32) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::powf(
                _self.into_inner(),
                n,
            )
            .into();
        output
    }
    ///  Returns the vector projection of `self` onto `rhs`.
    ///  `rhs` must be of non-zero length.
    ///  # Panics
    ///  Will panic if `rhs` is zero length when `glam_assert` is enabled.
    fn project_onto(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::project_onto(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the vector projection of `self` onto `rhs`.
    ///  `rhs` must be normalized.
    ///  # Panics
    ///  Will panic if `rhs` is not normalized when `glam_assert` is enabled.
    fn project_onto_normalized(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::project_onto_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
    fn recip(_self: Val<bevy::math::Vec3A>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::recip(_self.into_inner())
            .into();
        output
    }
    ///  Returns the reflection vector for a given incident vector `self` and surface normal
    ///  `normal`.
    ///  `normal` must be normalized.
    ///  # Panics
    ///  Will panic if `normal` is not normalized when `glam_assert` is enabled.
    fn reflect(
        _self: Val<bevy::math::Vec3A>,
        normal: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::reflect(
                _self.into_inner(),
                normal.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the refraction direction for a given incident vector `self`, surface normal
    ///  `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,
    ///  a zero vector will be returned.
    ///  `self` and `normal` must be normalized.
    ///  # Panics
    ///  Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.
    fn refract(
        _self: Val<bevy::math::Vec3A>,
        normal: Val<bevy::math::Vec3A>,
        eta: f32,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::refract(
                _self.into_inner(),
                normal.into_inner(),
                eta,
            )
            .into();
        output
    }
    ///  Returns the vector rejection of `self` from `rhs`.
    ///  The vector rejection is the vector perpendicular to the projection of `self` onto
    ///  `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
    ///  `rhs` must be of non-zero length.
    ///  # Panics
    ///  Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
    fn reject_from(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::reject_from(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the vector rejection of `self` from `rhs`.
    ///  The vector rejection is the vector perpendicular to the projection of `self` onto
    ///  `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
    ///  `rhs` must be normalized.
    ///  # Panics
    ///  Will panic if `rhs` is not normalized when `glam_assert` is enabled.
    fn reject_from_normalized(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::reject_from_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::Vec3A>,
        rhs: Ref<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Rem<
            &bevy::math::Vec3A,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Rem<
            bevy::math::Vec3A,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::Vec3A>, rhs: f32) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Rem<
            f32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
    ///  [Euclidean division]: f32::rem_euclid
    fn rem_euclid(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the nearest integer to a number for each element of `self`.
    ///  Round half-way cases away from 0.0.
    fn round(_self: Val<bevy::math::Vec3A>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::round(_self.into_inner())
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec3A>,
        if_true: Val<bevy::math::Vec3A>,
        if_false: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with elements representing the sign of `self`.
    ///  - `1.0` if the number is positive, `+0.0` or `INFINITY`
    ///  - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
    ///  - `NAN` if the number is `NAN`
    fn signum(_self: Val<bevy::math::Vec3A>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: f32) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::Vec3A>,
        rhs: Ref<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Sub<
            &bevy::math::Vec3A,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Sub<
            bevy::math::Vec3A,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::Vec3A>, rhs: f32) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Sub<
            f32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  `[x, y, z]`
    fn to_array(_self: Ref<bevy::math::Vec3A>) -> [f32; 3] {
        let output: [f32; 3] = bevy::math::Vec3A::to_array(&_self).into();
        output
    }
    ///  Returns a vector containing the integer part each element of `self`. This means numbers are
    ///  always truncated towards zero.
    fn trunc(_self: Val<bevy::math::Vec3A>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::trunc(_self.into_inner())
            .into();
        output
    }
    ///  Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
    ///  Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].
    fn truncate(_self: Val<bevy::math::Vec3A>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec3A::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::Vec3A>, x: f32) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::Vec3A>, y: f32) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `z`.
    fn with_z(_self: Val<bevy::math::Vec3A>, z: f32) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "vec_4_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::Vec4 {
    ///  Returns a vector containing the absolute value of each element of `self`.
    fn abs(_self: Val<bevy::math::Vec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::abs(_self.into_inner())
            .into();
        output
    }
    ///  Returns true if the absolute difference of all elements between `self` and `rhs` is
    ///  less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two vectors contain similar elements. It works best when
    ///  comparing with a known value. The `max_abs_diff` that should be used used depends on
    ///  the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
        max_abs_diff: f32,
    ) -> bool {
        let output: bool = bevy::math::Vec4::abs_diff_eq(
                _self.into_inner(),
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::Vec4>,
        rhs: Ref<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Add<
            &bevy::math::Vec4,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Add<
            bevy::math::Vec4,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Vec4>, rhs: f32) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Add<
            f32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Casts all elements of `self` to `f64`.
    fn as_dvec4(_self: Ref<bevy::math::Vec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::Vec4::as_dvec4(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `i64`.
    fn as_i64vec4(_self: Ref<bevy::math::Vec4>) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::Vec4::as_i64vec4(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i32`.
    fn as_ivec4(_self: Ref<bevy::math::Vec4>) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::Vec4::as_ivec4(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `u64`.
    fn as_u64vec4(_self: Ref<bevy::math::Vec4>) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::Vec4::as_u64vec4(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u32`.
    fn as_uvec4(_self: Ref<bevy::math::Vec4>) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::Vec4::as_uvec4(&_self).into();
        output
    }
    ///  Returns a vector containing the smallest integer greater than or equal to a number for
    ///  each element of `self`.
    fn ceil(_self: Val<bevy::math::Vec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::ceil(_self.into_inner())
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`f32::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::Vec4>,
        min: Val<bevy::math::Vec4>,
        max: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with a length no less than `min` and no more than `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.
    fn clamp_length(
        _self: Val<bevy::math::Vec4>,
        min: f32,
        max: f32,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::clamp_length(
                _self.into_inner(),
                min,
                max,
            )
            .into();
        output
    }
    ///  Returns a vector with a length no more than `max`.
    ///  # Panics
    ///  Will panic if `max` is negative when `glam_assert` is enabled.
    fn clamp_length_max(
        _self: Val<bevy::math::Vec4>,
        max: f32,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::clamp_length_max(
                _self.into_inner(),
                max,
            )
            .into();
        output
    }
    ///  Returns a vector with a length no less than `min`.
    ///  # Panics
    ///  Will panic if `min` is negative when `glam_assert` is enabled.
    fn clamp_length_min(
        _self: Val<bevy::math::Vec4>,
        min: f32,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::clamp_length_min(
                _self.into_inner(),
                min,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::Vec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::BVec4A> {
        let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::BVec4A> {
        let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::BVec4A> {
        let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::BVec4A> {
        let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::BVec4A> {
        let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::BVec4A> {
        let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with signs of `rhs` and the magnitudes of `self`.
    fn copysign(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::copysign(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the Euclidean distance between two points in space.
    fn distance(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) -> f32 {
        let output: f32 = bevy::math::Vec4::distance(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Compute the squared euclidean distance between two points in space.
    fn distance_squared(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> f32 {
        let output: f32 = bevy::math::Vec4::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::Vec4>,
        rhs: Ref<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Div<
            &bevy::math::Vec4,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Div<
            bevy::math::Vec4,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::Vec4>, rhs: f32) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Div<
            f32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
    fn div_euclid(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) -> f32 {
        let output: f32 = bevy::math::Vec4::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::Vec4>) -> f32 {
        let output: f32 = bevy::math::Vec4::element_product(_self.into_inner()).into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::Vec4>) -> f32 {
        let output: f32 = bevy::math::Vec4::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>) -> bool {
        let output: bool = <bevy::math::Vec4 as std::cmp::PartialEq<
            bevy::math::Vec4,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    ///  Returns a vector containing `e^self` (the exponential function) for each element of
    ///  `self`.
    fn exp(_self: Val<bevy::math::Vec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::exp(_self.into_inner())
            .into();
        output
    }
    ///  Returns a vector containing the largest integer less than or equal to a number for each
    ///  element of `self`.
    fn floor(_self: Val<bevy::math::Vec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::floor(_self.into_inner())
            .into();
        output
    }
    ///  Returns a vector containing the fractional part of the vector as `self - self.trunc()`.
    ///  Note that this differs from the GLSL implementation of `fract` which returns
    ///  `self - self.floor()`.
    ///  Note that this is fast but not precise for large numbers.
    fn fract(_self: Val<bevy::math::Vec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::fract(_self.into_inner())
            .into();
        output
    }
    ///  Returns a vector containing the fractional part of the vector as `self - self.floor()`.
    ///  Note that this differs from the Rust implementation of `fract` which returns
    ///  `self - self.trunc()`.
    ///  Note that this is fast but not precise for large numbers.
    fn fract_gl(_self: Val<bevy::math::Vec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::fract_gl(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [f32; 4]) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::from_array(a).into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.  If any element is either
    ///  `NaN`, positive or negative infinity, this will return `false`.
    fn is_finite(_self: Val<bevy::math::Vec4>) -> bool {
        let output: bool = bevy::math::Vec4::is_finite(_self.into_inner()).into();
        output
    }
    ///  Performs `is_finite` on each element of self, returning a vector mask of the results.
    ///  In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.
    fn is_finite_mask(_self: Val<bevy::math::Vec4>) -> Val<bevy::math::BVec4A> {
        let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::is_finite_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `true` if any elements are `NaN`.
    fn is_nan(_self: Val<bevy::math::Vec4>) -> bool {
        let output: bool = bevy::math::Vec4::is_nan(_self.into_inner()).into();
        output
    }
    ///  Performs `is_nan` on each element of self, returning a vector mask of the results.
    ///  In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.
    fn is_nan_mask(_self: Val<bevy::math::Vec4>) -> Val<bevy::math::BVec4A> {
        let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::is_nan_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a bitmask with the lowest 4 bits set to the sign bits from the elements of `self`.
    ///  A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
    ///  into the first lowest bit, element `y` into the second, etc.
    fn is_negative_bitmask(_self: Val<bevy::math::Vec4>) -> u32 {
        let output: u32 = bevy::math::Vec4::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    ///  Returns whether `self` is length `1.0` or not.
    ///  Uses a precision threshold of approximately `1e-4`.
    fn is_normalized(_self: Val<bevy::math::Vec4>) -> bool {
        let output: bool = bevy::math::Vec4::is_normalized(_self.into_inner()).into();
        output
    }
    ///  Computes the length of `self`.
    fn length(_self: Val<bevy::math::Vec4>) -> f32 {
        let output: f32 = bevy::math::Vec4::length(_self.into_inner()).into();
        output
    }
    ///  Computes `1.0 / length()`.
    ///  For valid results, `self` must _not_ be of length zero.
    fn length_recip(_self: Val<bevy::math::Vec4>) -> f32 {
        let output: f32 = bevy::math::Vec4::length_recip(_self.into_inner()).into();
        output
    }
    ///  Computes the squared length of `self`.
    ///  This is faster than `length()` as it avoids a square root operation.
    fn length_squared(_self: Val<bevy::math::Vec4>) -> f32 {
        let output: f32 = bevy::math::Vec4::length_squared(_self.into_inner()).into();
        output
    }
    ///  Performs a linear interpolation between `self` and `rhs` based on the value `s`.
    ///  When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
    ///  will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
    ///  extrapolated.
    fn lerp(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
        s: f32,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::lerp(
                _self.into_inner(),
                rhs.into_inner(),
                s,
            )
            .into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::Vec4>) -> f32 {
        let output: f32 = bevy::math::Vec4::max_element(_self.into_inner()).into();
        output
    }
    ///  Calculates the midpoint between `self` and `rhs`.
    ///  The midpoint is the average of, or halfway point between, two vectors.
    ///  `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`
    ///  while being slightly cheaper to compute.
    fn midpoint(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::midpoint(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::Vec4>) -> f32 {
        let output: f32 = bevy::math::Vec4::min_element(_self.into_inner()).into();
        output
    }
    ///  Moves towards `rhs` based on the value `d`.
    ///  When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to
    ///  `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.
    fn move_towards(
        _self: Ref<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
        d: f32,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::move_towards(
                &_self,
                rhs.into_inner(),
                d,
            )
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Vec4>,
        rhs: Ref<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Mul<
            &bevy::math::Vec4,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Mul<
            bevy::math::Vec4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Vec4>, rhs: f32) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Mul<
            f32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
    ///  error, yielding a more accurate result than an unfused multiply-add.
    ///  Using `mul_add` *may* be more performant than an unfused multiply-add if the target
    ///  architecture has a dedicated fma CPU instruction. However, this is not always true,
    ///  and will be heavily dependant on designing algorithms with specific target hardware in
    ///  mind.
    fn mul_add(
        _self: Val<bevy::math::Vec4>,
        a: Val<bevy::math::Vec4>,
        b: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::mul_add(
                _self.into_inner(),
                a.into_inner(),
                b.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::Vec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: f32, y: f32, z: f32, w: f32) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::new(x, y, z, w).into();
        output
    }
    ///  Returns `self` normalized to length 1.0.
    ///  For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.
    ///  See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].
    ///  Panics
    ///  Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.
    fn normalize(_self: Val<bevy::math::Vec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::normalize(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `self` normalized to length 1.0 if possible, else returns a
    ///  fallback value.
    ///  In particular, if the input is zero (or very close to zero), or non-finite,
    ///  the result of this operation will be the fallback value.
    ///  See also [`Self::try_normalize()`].
    fn normalize_or(
        _self: Val<bevy::math::Vec4>,
        fallback: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::normalize_or(
                _self.into_inner(),
                fallback.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `self` normalized to length 1.0 if possible, else returns zero.
    ///  In particular, if the input is zero (or very close to zero), or non-finite,
    ///  the result of this operation will be zero.
    ///  See also [`Self::try_normalize()`].
    fn normalize_or_zero(_self: Val<bevy::math::Vec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::normalize_or_zero(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing each element of `self` raised to the power of `n`.
    fn powf(_self: Val<bevy::math::Vec4>, n: f32) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::powf(_self.into_inner(), n)
            .into();
        output
    }
    ///  Returns the vector projection of `self` onto `rhs`.
    ///  `rhs` must be of non-zero length.
    ///  # Panics
    ///  Will panic if `rhs` is zero length when `glam_assert` is enabled.
    fn project_onto(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::project_onto(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the vector projection of `self` onto `rhs`.
    ///  `rhs` must be normalized.
    ///  # Panics
    ///  Will panic if `rhs` is not normalized when `glam_assert` is enabled.
    fn project_onto_normalized(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::project_onto_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
    fn recip(_self: Val<bevy::math::Vec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::recip(_self.into_inner())
            .into();
        output
    }
    ///  Returns the reflection vector for a given incident vector `self` and surface normal
    ///  `normal`.
    ///  `normal` must be normalized.
    ///  # Panics
    ///  Will panic if `normal` is not normalized when `glam_assert` is enabled.
    fn reflect(
        _self: Val<bevy::math::Vec4>,
        normal: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::reflect(
                _self.into_inner(),
                normal.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the refraction direction for a given incident vector `self`, surface normal
    ///  `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,
    ///  a zero vector will be returned.
    ///  `self` and `normal` must be normalized.
    ///  # Panics
    ///  Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.
    fn refract(
        _self: Val<bevy::math::Vec4>,
        normal: Val<bevy::math::Vec4>,
        eta: f32,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::refract(
                _self.into_inner(),
                normal.into_inner(),
                eta,
            )
            .into();
        output
    }
    ///  Returns the vector rejection of `self` from `rhs`.
    ///  The vector rejection is the vector perpendicular to the projection of `self` onto
    ///  `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
    ///  `rhs` must be of non-zero length.
    ///  # Panics
    ///  Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
    fn reject_from(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::reject_from(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the vector rejection of `self` from `rhs`.
    ///  The vector rejection is the vector perpendicular to the projection of `self` onto
    ///  `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
    ///  `rhs` must be normalized.
    ///  # Panics
    ///  Will panic if `rhs` is not normalized when `glam_assert` is enabled.
    fn reject_from_normalized(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::reject_from_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::Vec4>,
        rhs: Ref<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Rem<
            &bevy::math::Vec4,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Rem<
            bevy::math::Vec4,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::Vec4>, rhs: f32) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Rem<
            f32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
    ///  [Euclidean division]: f32::rem_euclid
    fn rem_euclid(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the nearest integer to a number for each element of `self`.
    ///  Round half-way cases away from 0.0.
    fn round(_self: Val<bevy::math::Vec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::round(_self.into_inner())
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec4A>,
        if_true: Val<bevy::math::Vec4>,
        if_false: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with elements representing the sign of `self`.
    ///  - `1.0` if the number is positive, `+0.0` or `INFINITY`
    ///  - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
    ///  - `NAN` if the number is `NAN`
    fn signum(_self: Val<bevy::math::Vec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::signum(_self.into_inner())
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: f32) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::Vec4>,
        rhs: Ref<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Sub<
            &bevy::math::Vec4,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Sub<
            bevy::math::Vec4,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::Vec4>, rhs: f32) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Sub<
            f32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  `[x, y, z, w]`
    fn to_array(_self: Ref<bevy::math::Vec4>) -> [f32; 4] {
        let output: [f32; 4] = bevy::math::Vec4::to_array(&_self).into();
        output
    }
    ///  Returns a vector containing the integer part each element of `self`. This means numbers are
    ///  always truncated towards zero.
    fn trunc(_self: Val<bevy::math::Vec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::trunc(_self.into_inner())
            .into();
        output
    }
    ///  Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
    ///  Truncation to [`Vec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].
    ///  To truncate to [`Vec3A`] use [`Vec3A::from()`].
    fn truncate(_self: Val<bevy::math::Vec4>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec4::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `w`.
    fn with_w(_self: Val<bevy::math::Vec4>, w: f32) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::with_w(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::Vec4>, x: f32) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::Vec4>, y: f32) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `z`.
    fn with_z(_self: Val<bevy::math::Vec4>, z: f32) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "b_vec_2_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::BVec2 {
    ///  Returns true if all the elements are true, false otherwise.
    fn all(_self: Val<bevy::math::BVec2>) -> bool {
        let output: bool = bevy::math::BVec2::all(_self.into_inner()).into();
        output
    }
    ///  Returns true if any of the elements are true, false otherwise.
    fn any(_self: Val<bevy::math::BVec2>) -> bool {
        let output: bool = bevy::math::BVec2::any(_self.into_inner()).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::BVec2>) -> () {
        let output: () = <bevy::math::BVec2 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a bitmask with the lowest 2 bits set from the elements of `self`.
    ///  A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
    ///  into the first lowest bit, element `y` into the second, etc.
    fn bitmask(_self: Val<bevy::math::BVec2>) -> u32 {
        let output: u32 = bevy::math::BVec2::bitmask(_self.into_inner()).into();
        output
    }
    fn clone(_self: Ref<bevy::math::BVec2>) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = <bevy::math::BVec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::BVec2>, other: Ref<bevy::math::BVec2>) -> bool {
        let output: bool = <bevy::math::BVec2 as std::cmp::PartialEq<
            bevy::math::BVec2,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a new vector mask from a bool array.
    fn from_array(a: [bool; 2]) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::BVec2::from_array(a).into();
        output
    }
    ///  Creates a new vector mask.
    fn new(x: bool, y: bool) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::BVec2::new(x, y).into();
        output
    }
    ///  Sets the element at `index`.
    ///  Panics if `index` is greater than 1.
    fn set(mut _self: Mut<bevy::math::BVec2>, index: usize, value: bool) -> () {
        let output: () = bevy::math::BVec2::set(&mut _self, index, value).into();
        output
    }
    ///  Creates a vector mask with all elements set to `v`.
    fn splat(v: bool) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::BVec2::splat(v).into();
        output
    }
    ///  Tests the value at `index`.
    ///  Panics if `index` is greater than 1.
    fn test(_self: Ref<bevy::math::BVec2>, index: usize) -> bool {
        let output: bool = bevy::math::BVec2::test(&_self, index).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "b_vec_3_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::BVec3 {
    ///  Returns true if all the elements are true, false otherwise.
    fn all(_self: Val<bevy::math::BVec3>) -> bool {
        let output: bool = bevy::math::BVec3::all(_self.into_inner()).into();
        output
    }
    ///  Returns true if any of the elements are true, false otherwise.
    fn any(_self: Val<bevy::math::BVec3>) -> bool {
        let output: bool = bevy::math::BVec3::any(_self.into_inner()).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::BVec3>) -> () {
        let output: () = <bevy::math::BVec3 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a bitmask with the lowest 3 bits set from the elements of `self`.
    ///  A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
    ///  into the first lowest bit, element `y` into the second, etc.
    fn bitmask(_self: Val<bevy::math::BVec3>) -> u32 {
        let output: u32 = bevy::math::BVec3::bitmask(_self.into_inner()).into();
        output
    }
    fn clone(_self: Ref<bevy::math::BVec3>) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = <bevy::math::BVec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::BVec3>, other: Ref<bevy::math::BVec3>) -> bool {
        let output: bool = <bevy::math::BVec3 as std::cmp::PartialEq<
            bevy::math::BVec3,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a new vector mask from a bool array.
    fn from_array(a: [bool; 3]) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::BVec3::from_array(a).into();
        output
    }
    ///  Creates a new vector mask.
    fn new(x: bool, y: bool, z: bool) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::BVec3::new(x, y, z).into();
        output
    }
    ///  Sets the element at `index`.
    ///  Panics if `index` is greater than 2.
    fn set(mut _self: Mut<bevy::math::BVec3>, index: usize, value: bool) -> () {
        let output: () = bevy::math::BVec3::set(&mut _self, index, value).into();
        output
    }
    ///  Creates a vector mask with all elements set to `v`.
    fn splat(v: bool) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::BVec3::splat(v).into();
        output
    }
    ///  Tests the value at `index`.
    ///  Panics if `index` is greater than 2.
    fn test(_self: Ref<bevy::math::BVec3>, index: usize) -> bool {
        let output: bool = bevy::math::BVec3::test(&_self, index).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "b_vec_4_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::BVec4 {
    ///  Returns true if all the elements are true, false otherwise.
    fn all(_self: Val<bevy::math::BVec4>) -> bool {
        let output: bool = bevy::math::BVec4::all(_self.into_inner()).into();
        output
    }
    ///  Returns true if any of the elements are true, false otherwise.
    fn any(_self: Val<bevy::math::BVec4>) -> bool {
        let output: bool = bevy::math::BVec4::any(_self.into_inner()).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::BVec4>) -> () {
        let output: () = <bevy::math::BVec4 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a bitmask with the lowest 4 bits set from the elements of `self`.
    ///  A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
    ///  into the first lowest bit, element `y` into the second, etc.
    fn bitmask(_self: Val<bevy::math::BVec4>) -> u32 {
        let output: u32 = bevy::math::BVec4::bitmask(_self.into_inner()).into();
        output
    }
    fn clone(_self: Ref<bevy::math::BVec4>) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = <bevy::math::BVec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::BVec4>, other: Ref<bevy::math::BVec4>) -> bool {
        let output: bool = <bevy::math::BVec4 as std::cmp::PartialEq<
            bevy::math::BVec4,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a new vector mask from a bool array.
    fn from_array(a: [bool; 4]) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::BVec4::from_array(a).into();
        output
    }
    ///  Creates a new vector mask.
    fn new(x: bool, y: bool, z: bool, w: bool) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::BVec4::new(x, y, z, w).into();
        output
    }
    ///  Sets the element at `index`.
    ///  Panics if `index` is greater than 3.
    fn set(mut _self: Mut<bevy::math::BVec4>, index: usize, value: bool) -> () {
        let output: () = bevy::math::BVec4::set(&mut _self, index, value).into();
        output
    }
    ///  Creates a vector mask with all elements set to `v`.
    fn splat(v: bool) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::BVec4::splat(v).into();
        output
    }
    ///  Tests the value at `index`.
    ///  Panics if `index` is greater than 3.
    fn test(_self: Ref<bevy::math::BVec4>, index: usize) -> bool {
        let output: bool = bevy::math::BVec4::test(&_self, index).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "d_vec_2_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::DVec2 {
    ///  Returns a vector containing the absolute value of each element of `self`.
    fn abs(_self: Val<bevy::math::DVec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::abs(_self.into_inner())
            .into();
        output
    }
    ///  Returns true if the absolute difference of all elements between `self` and `rhs` is
    ///  less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two vectors contain similar elements. It works best when
    ///  comparing with a known value. The `max_abs_diff` that should be used used depends on
    ///  the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
        max_abs_diff: f64,
    ) -> bool {
        let output: bool = bevy::math::DVec2::abs_diff_eq(
                _self.into_inner(),
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::DVec2>,
        rhs: Ref<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Add<
            &bevy::math::DVec2,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Add<
            bevy::math::DVec2,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::DVec2>, rhs: f64) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Add<
            f64,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn angle_between(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) -> f64 {
        let output: f64 = bevy::math::DVec2::angle_between(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the angle of rotation (in radians) from `self` to `rhs` in the range `[-π, +π]`.
    ///  The inputs do not need to be unit vectors however they must be non-zero.
    fn angle_to(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) -> f64 {
        let output: f64 = bevy::math::DVec2::angle_to(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Casts all elements of `self` to `i64`.
    fn as_i64vec2(_self: Ref<bevy::math::DVec2>) -> Val<bevy::math::I64Vec2> {
        let output: Val<bevy::math::I64Vec2> = bevy::math::DVec2::as_i64vec2(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i32`.
    fn as_ivec2(_self: Ref<bevy::math::DVec2>) -> Val<bevy::math::IVec2> {
        let output: Val<bevy::math::IVec2> = bevy::math::DVec2::as_ivec2(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `u64`.
    fn as_u64vec2(_self: Ref<bevy::math::DVec2>) -> Val<bevy::math::U64Vec2> {
        let output: Val<bevy::math::U64Vec2> = bevy::math::DVec2::as_u64vec2(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u32`.
    fn as_uvec2(_self: Ref<bevy::math::DVec2>) -> Val<bevy::math::UVec2> {
        let output: Val<bevy::math::UVec2> = bevy::math::DVec2::as_uvec2(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec2(_self: Ref<bevy::math::DVec2>) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::DVec2::as_vec2(&_self).into();
        output
    }
    ///  Returns a vector containing the smallest integer greater than or equal to a number for
    ///  each element of `self`.
    fn ceil(_self: Val<bevy::math::DVec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::ceil(_self.into_inner())
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`f64::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::DVec2>,
        min: Val<bevy::math::DVec2>,
        max: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with a length no less than `min` and no more than `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.
    fn clamp_length(
        _self: Val<bevy::math::DVec2>,
        min: f64,
        max: f64,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::clamp_length(
                _self.into_inner(),
                min,
                max,
            )
            .into();
        output
    }
    ///  Returns a vector with a length no more than `max`.
    ///  # Panics
    ///  Will panic if `max` is negative when `glam_assert` is enabled.
    fn clamp_length_max(
        _self: Val<bevy::math::DVec2>,
        max: f64,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::clamp_length_max(
                _self.into_inner(),
                max,
            )
            .into();
        output
    }
    ///  Returns a vector with a length no less than `min`.
    ///  # Panics
    ///  Will panic if `min` is negative when `glam_assert` is enabled.
    fn clamp_length_min(
        _self: Val<bevy::math::DVec2>,
        min: f64,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::clamp_length_min(
                _self.into_inner(),
                min,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::DVec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with signs of `rhs` and the magnitudes of `self`.
    fn copysign(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::copysign(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the Euclidean distance between two points in space.
    fn distance(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) -> f64 {
        let output: f64 = bevy::math::DVec2::distance(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Compute the squared euclidean distance between two points in space.
    fn distance_squared(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> f64 {
        let output: f64 = bevy::math::DVec2::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::DVec2>,
        rhs: Ref<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Div<
            &bevy::math::DVec2,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Div<
            bevy::math::DVec2,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::DVec2>, rhs: f64) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Div<
            f64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
    fn div_euclid(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) -> f64 {
        let output: f64 = bevy::math::DVec2::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::DVec2>) -> f64 {
        let output: f64 = bevy::math::DVec2::element_product(_self.into_inner()).into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::DVec2>) -> f64 {
        let output: f64 = bevy::math::DVec2::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::DVec2>, other: Ref<bevy::math::DVec2>) -> bool {
        let output: bool = <bevy::math::DVec2 as std::cmp::PartialEq<
            bevy::math::DVec2,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Returns a vector containing `e^self` (the exponential function) for each element of
    ///  `self`.
    fn exp(_self: Val<bevy::math::DVec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::exp(_self.into_inner())
            .into();
        output
    }
    ///  Creates a 3D vector from `self` and the given `z` value.
    fn extend(_self: Val<bevy::math::DVec2>, z: f64) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec2::extend(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    ///  Returns a vector containing the largest integer less than or equal to a number for each
    ///  element of `self`.
    fn floor(_self: Val<bevy::math::DVec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::floor(_self.into_inner())
            .into();
        output
    }
    ///  Returns a vector containing the fractional part of the vector as `self - self.trunc()`.
    ///  Note that this differs from the GLSL implementation of `fract` which returns
    ///  `self - self.floor()`.
    ///  Note that this is fast but not precise for large numbers.
    fn fract(_self: Val<bevy::math::DVec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::fract(_self.into_inner())
            .into();
        output
    }
    ///  Returns a vector containing the fractional part of the vector as `self - self.floor()`.
    ///  Note that this differs from the Rust implementation of `fract` which returns
    ///  `self - self.trunc()`.
    ///  Note that this is fast but not precise for large numbers.
    fn fract_gl(_self: Val<bevy::math::DVec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::fract_gl(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 2D vector containing `[angle.cos(), angle.sin()]`. This can be used in
    ///  conjunction with the [`rotate()`][Self::rotate()] method, e.g.
    ///  `DVec2::from_angle(PI).rotate(DVec2::Y)` will create the vector `[-1, 0]`
    ///  and rotate [`DVec2::Y`] around it returning `-DVec2::Y`.
    fn from_angle(angle: f64) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::from_angle(angle).into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [f64; 2]) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::from_array(a).into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.  If any element is either
    ///  `NaN`, positive or negative infinity, this will return `false`.
    fn is_finite(_self: Val<bevy::math::DVec2>) -> bool {
        let output: bool = bevy::math::DVec2::is_finite(_self.into_inner()).into();
        output
    }
    ///  Performs `is_finite` on each element of self, returning a vector mask of the results.
    ///  In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.
    fn is_finite_mask(_self: Val<bevy::math::DVec2>) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::DVec2::is_finite_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `true` if any elements are `NaN`.
    fn is_nan(_self: Val<bevy::math::DVec2>) -> bool {
        let output: bool = bevy::math::DVec2::is_nan(_self.into_inner()).into();
        output
    }
    ///  Performs `is_nan` on each element of self, returning a vector mask of the results.
    ///  In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.
    fn is_nan_mask(_self: Val<bevy::math::DVec2>) -> Val<bevy::math::BVec2> {
        let output: Val<bevy::math::BVec2> = bevy::math::DVec2::is_nan_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `self`.
    ///  A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
    ///  into the first lowest bit, element `y` into the second, etc.
    fn is_negative_bitmask(_self: Val<bevy::math::DVec2>) -> u32 {
        let output: u32 = bevy::math::DVec2::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    ///  Returns whether `self` is length `1.0` or not.
    ///  Uses a precision threshold of approximately `1e-4`.
    fn is_normalized(_self: Val<bevy::math::DVec2>) -> bool {
        let output: bool = bevy::math::DVec2::is_normalized(_self.into_inner()).into();
        output
    }
    ///  Computes the length of `self`.
    fn length(_self: Val<bevy::math::DVec2>) -> f64 {
        let output: f64 = bevy::math::DVec2::length(_self.into_inner()).into();
        output
    }
    ///  Computes `1.0 / length()`.
    ///  For valid results, `self` must _not_ be of length zero.
    fn length_recip(_self: Val<bevy::math::DVec2>) -> f64 {
        let output: f64 = bevy::math::DVec2::length_recip(_self.into_inner()).into();
        output
    }
    ///  Computes the squared length of `self`.
    ///  This is faster than `length()` as it avoids a square root operation.
    fn length_squared(_self: Val<bevy::math::DVec2>) -> f64 {
        let output: f64 = bevy::math::DVec2::length_squared(_self.into_inner()).into();
        output
    }
    ///  Performs a linear interpolation between `self` and `rhs` based on the value `s`.
    ///  When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
    ///  will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
    ///  extrapolated.
    fn lerp(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
        s: f64,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::lerp(
                _self.into_inner(),
                rhs.into_inner(),
                s,
            )
            .into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::DVec2>) -> f64 {
        let output: f64 = bevy::math::DVec2::max_element(_self.into_inner()).into();
        output
    }
    ///  Calculates the midpoint between `self` and `rhs`.
    ///  The midpoint is the average of, or halfway point between, two vectors.
    ///  `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`
    ///  while being slightly cheaper to compute.
    fn midpoint(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::midpoint(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::DVec2>) -> f64 {
        let output: f64 = bevy::math::DVec2::min_element(_self.into_inner()).into();
        output
    }
    ///  Moves towards `rhs` based on the value `d`.
    ///  When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to
    ///  `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.
    fn move_towards(
        _self: Ref<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
        d: f64,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::move_towards(
                &_self,
                rhs.into_inner(),
                d,
            )
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::DVec2>,
        rhs: Ref<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Mul<
            &bevy::math::DVec2,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Mul<
            bevy::math::DVec2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DVec2>, rhs: f64) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Mul<
            f64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
    ///  error, yielding a more accurate result than an unfused multiply-add.
    ///  Using `mul_add` *may* be more performant than an unfused multiply-add if the target
    ///  architecture has a dedicated fma CPU instruction. However, this is not always true,
    ///  and will be heavily dependant on designing algorithms with specific target hardware in
    ///  mind.
    fn mul_add(
        _self: Val<bevy::math::DVec2>,
        a: Val<bevy::math::DVec2>,
        b: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::mul_add(
                _self.into_inner(),
                a.into_inner(),
                b.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::DVec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: f64, y: f64) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::new(x, y).into();
        output
    }
    ///  Returns `self` normalized to length 1.0.
    ///  For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.
    ///  See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].
    ///  Panics
    ///  Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.
    fn normalize(_self: Val<bevy::math::DVec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::normalize(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `self` normalized to length 1.0 if possible, else returns a
    ///  fallback value.
    ///  In particular, if the input is zero (or very close to zero), or non-finite,
    ///  the result of this operation will be the fallback value.
    ///  See also [`Self::try_normalize()`].
    fn normalize_or(
        _self: Val<bevy::math::DVec2>,
        fallback: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::normalize_or(
                _self.into_inner(),
                fallback.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `self` normalized to length 1.0 if possible, else returns zero.
    ///  In particular, if the input is zero (or very close to zero), or non-finite,
    ///  the result of this operation will be zero.
    ///  See also [`Self::try_normalize()`].
    fn normalize_or_zero(_self: Val<bevy::math::DVec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::normalize_or_zero(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector that is equal to `self` rotated by 90 degrees.
    fn perp(_self: Val<bevy::math::DVec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::perp(_self.into_inner())
            .into();
        output
    }
    ///  The perpendicular dot product of `self` and `rhs`.
    ///  Also known as the wedge product, 2D cross product, and determinant.
    fn perp_dot(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) -> f64 {
        let output: f64 = bevy::math::DVec2::perp_dot(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing each element of `self` raised to the power of `n`.
    fn powf(_self: Val<bevy::math::DVec2>, n: f64) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::powf(
                _self.into_inner(),
                n,
            )
            .into();
        output
    }
    ///  Returns the vector projection of `self` onto `rhs`.
    ///  `rhs` must be of non-zero length.
    ///  # Panics
    ///  Will panic if `rhs` is zero length when `glam_assert` is enabled.
    fn project_onto(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::project_onto(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the vector projection of `self` onto `rhs`.
    ///  `rhs` must be normalized.
    ///  # Panics
    ///  Will panic if `rhs` is not normalized when `glam_assert` is enabled.
    fn project_onto_normalized(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::project_onto_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
    fn recip(_self: Val<bevy::math::DVec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::recip(_self.into_inner())
            .into();
        output
    }
    ///  Returns the reflection vector for a given incident vector `self` and surface normal
    ///  `normal`.
    ///  `normal` must be normalized.
    ///  # Panics
    ///  Will panic if `normal` is not normalized when `glam_assert` is enabled.
    fn reflect(
        _self: Val<bevy::math::DVec2>,
        normal: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::reflect(
                _self.into_inner(),
                normal.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the refraction direction for a given incident vector `self`, surface normal
    ///  `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,
    ///  a zero vector will be returned.
    ///  `self` and `normal` must be normalized.
    ///  # Panics
    ///  Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.
    fn refract(
        _self: Val<bevy::math::DVec2>,
        normal: Val<bevy::math::DVec2>,
        eta: f64,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::refract(
                _self.into_inner(),
                normal.into_inner(),
                eta,
            )
            .into();
        output
    }
    ///  Returns the vector rejection of `self` from `rhs`.
    ///  The vector rejection is the vector perpendicular to the projection of `self` onto
    ///  `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
    ///  `rhs` must be of non-zero length.
    ///  # Panics
    ///  Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
    fn reject_from(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::reject_from(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the vector rejection of `self` from `rhs`.
    ///  The vector rejection is the vector perpendicular to the projection of `self` onto
    ///  `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
    ///  `rhs` must be normalized.
    ///  # Panics
    ///  Will panic if `rhs` is not normalized when `glam_assert` is enabled.
    fn reject_from_normalized(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::reject_from_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::DVec2>,
        rhs: Ref<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Rem<
            &bevy::math::DVec2,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Rem<
            bevy::math::DVec2,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::DVec2>, rhs: f64) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Rem<
            f64,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
    ///  [Euclidean division]: f64::rem_euclid
    fn rem_euclid(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
    ///  then this just rotation. This is what you usually want. Otherwise,
    ///  it will be like a rotation with a multiplication by `self`'s length.
    fn rotate(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::rotate(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Rotates towards `rhs` up to `max_angle` (in radians).
    ///  When `max_angle` is `0.0`, the result will be equal to `self`. When `max_angle` is equal to
    ///  `self.angle_between(rhs)`, the result will be equal to `rhs`. If `max_angle` is negative,
    ///  rotates towards the exact opposite of `rhs`. Will not go past the target.
    fn rotate_towards(
        _self: Ref<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
        max_angle: f64,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::rotate_towards(
                &_self,
                rhs.into_inner(),
                max_angle,
            )
            .into();
        output
    }
    ///  Returns a vector containing the nearest integer to a number for each element of `self`.
    ///  Round half-way cases away from 0.0.
    fn round(_self: Val<bevy::math::DVec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::round(_self.into_inner())
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec2>,
        if_true: Val<bevy::math::DVec2>,
        if_false: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with elements representing the sign of `self`.
    ///  - `1.0` if the number is positive, `+0.0` or `INFINITY`
    ///  - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
    ///  - `NAN` if the number is `NAN`
    fn signum(_self: Val<bevy::math::DVec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: f64) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::DVec2>,
        rhs: Ref<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Sub<
            &bevy::math::DVec2,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Sub<
            bevy::math::DVec2,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::DVec2>, rhs: f64) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Sub<
            f64,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the angle (in radians) of this vector in the range `[-π, +π]`.
    ///  The input does not need to be a unit vector however it must be non-zero.
    fn to_angle(_self: Val<bevy::math::DVec2>) -> f64 {
        let output: f64 = bevy::math::DVec2::to_angle(_self.into_inner()).into();
        output
    }
    ///  `[x, y]`
    fn to_array(_self: Ref<bevy::math::DVec2>) -> [f64; 2] {
        let output: [f64; 2] = bevy::math::DVec2::to_array(&_self).into();
        output
    }
    ///  Returns a vector containing the integer part each element of `self`. This means numbers are
    ///  always truncated towards zero.
    fn trunc(_self: Val<bevy::math::DVec2>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::trunc(_self.into_inner())
            .into();
        output
    }
    ///  Creates a 2D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::DVec2>, x: f64) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 2D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::DVec2>, y: f64) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "d_vec_3_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::DVec3 {
    ///  Returns a vector containing the absolute value of each element of `self`.
    fn abs(_self: Val<bevy::math::DVec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::abs(_self.into_inner())
            .into();
        output
    }
    ///  Returns true if the absolute difference of all elements between `self` and `rhs` is
    ///  less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two vectors contain similar elements. It works best when
    ///  comparing with a known value. The `max_abs_diff` that should be used used depends on
    ///  the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
        max_abs_diff: f64,
    ) -> bool {
        let output: bool = bevy::math::DVec3::abs_diff_eq(
                _self.into_inner(),
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::DVec3>,
        rhs: Ref<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Add<
            &bevy::math::DVec3,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Add<
            bevy::math::DVec3,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::DVec3>, rhs: f64) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Add<
            f64,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the angle (in radians) between two vectors in the range `[0, +π]`.
    ///  The inputs do not need to be unit vectors however they must be non-zero.
    fn angle_between(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) -> f64 {
        let output: f64 = bevy::math::DVec3::angle_between(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns some vector that is orthogonal to the given one.
    ///  The input vector must be finite and non-zero.
    ///  The output vector is not necessarily unit length. For that use
    ///  [`Self::any_orthonormal_vector()`] instead.
    fn any_orthogonal_vector(_self: Ref<bevy::math::DVec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::any_orthogonal_vector(
                &_self,
            )
            .into();
        output
    }
    ///  Returns any unit vector that is orthogonal to the given one.
    ///  The input vector must be unit length.
    ///  # Panics
    ///  Will panic if `self` is not normalized when `glam_assert` is enabled.
    fn any_orthonormal_vector(_self: Ref<bevy::math::DVec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::any_orthonormal_vector(
                &_self,
            )
            .into();
        output
    }
    ///  Casts all elements of `self` to `i64`.
    fn as_i64vec3(_self: Ref<bevy::math::DVec3>) -> Val<bevy::math::I64Vec3> {
        let output: Val<bevy::math::I64Vec3> = bevy::math::DVec3::as_i64vec3(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i32`.
    fn as_ivec3(_self: Ref<bevy::math::DVec3>) -> Val<bevy::math::IVec3> {
        let output: Val<bevy::math::IVec3> = bevy::math::DVec3::as_ivec3(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `u64`.
    fn as_u64vec3(_self: Ref<bevy::math::DVec3>) -> Val<bevy::math::U64Vec3> {
        let output: Val<bevy::math::U64Vec3> = bevy::math::DVec3::as_u64vec3(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u32`.
    fn as_uvec3(_self: Ref<bevy::math::DVec3>) -> Val<bevy::math::UVec3> {
        let output: Val<bevy::math::UVec3> = bevy::math::DVec3::as_uvec3(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec3(_self: Ref<bevy::math::DVec3>) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::DVec3::as_vec3(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec3a(_self: Ref<bevy::math::DVec3>) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::DVec3::as_vec3a(&_self).into();
        output
    }
    ///  Returns a vector containing the smallest integer greater than or equal to a number for
    ///  each element of `self`.
    fn ceil(_self: Val<bevy::math::DVec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::ceil(_self.into_inner())
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`f64::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::DVec3>,
        min: Val<bevy::math::DVec3>,
        max: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with a length no less than `min` and no more than `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.
    fn clamp_length(
        _self: Val<bevy::math::DVec3>,
        min: f64,
        max: f64,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::clamp_length(
                _self.into_inner(),
                min,
                max,
            )
            .into();
        output
    }
    ///  Returns a vector with a length no more than `max`.
    ///  # Panics
    ///  Will panic if `max` is negative when `glam_assert` is enabled.
    fn clamp_length_max(
        _self: Val<bevy::math::DVec3>,
        max: f64,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::clamp_length_max(
                _self.into_inner(),
                max,
            )
            .into();
        output
    }
    ///  Returns a vector with a length no less than `min`.
    ///  # Panics
    ///  Will panic if `min` is negative when `glam_assert` is enabled.
    fn clamp_length_min(
        _self: Val<bevy::math::DVec3>,
        min: f64,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::clamp_length_min(
                _self.into_inner(),
                min,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::DVec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with signs of `rhs` and the magnitudes of `self`.
    fn copysign(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::copysign(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the cross product of `self` and `rhs`.
    fn cross(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::cross(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the Euclidean distance between two points in space.
    fn distance(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) -> f64 {
        let output: f64 = bevy::math::DVec3::distance(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Compute the squared euclidean distance between two points in space.
    fn distance_squared(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> f64 {
        let output: f64 = bevy::math::DVec3::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::DVec3>,
        rhs: Ref<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Div<
            &bevy::math::DVec3,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Div<
            bevy::math::DVec3,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::DVec3>, rhs: f64) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Div<
            f64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
    fn div_euclid(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) -> f64 {
        let output: f64 = bevy::math::DVec3::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::DVec3>) -> f64 {
        let output: f64 = bevy::math::DVec3::element_product(_self.into_inner()).into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::DVec3>) -> f64 {
        let output: f64 = bevy::math::DVec3::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::DVec3>, other: Ref<bevy::math::DVec3>) -> bool {
        let output: bool = <bevy::math::DVec3 as std::cmp::PartialEq<
            bevy::math::DVec3,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Returns a vector containing `e^self` (the exponential function) for each element of
    ///  `self`.
    fn exp(_self: Val<bevy::math::DVec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::exp(_self.into_inner())
            .into();
        output
    }
    ///  Creates a 4D vector from `self` and the given `w` value.
    fn extend(_self: Val<bevy::math::DVec3>, w: f64) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec3::extend(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    ///  Returns a vector containing the largest integer less than or equal to a number for each
    ///  element of `self`.
    fn floor(_self: Val<bevy::math::DVec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::floor(_self.into_inner())
            .into();
        output
    }
    ///  Returns a vector containing the fractional part of the vector as `self - self.trunc()`.
    ///  Note that this differs from the GLSL implementation of `fract` which returns
    ///  `self - self.floor()`.
    ///  Note that this is fast but not precise for large numbers.
    fn fract(_self: Val<bevy::math::DVec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::fract(_self.into_inner())
            .into();
        output
    }
    ///  Returns a vector containing the fractional part of the vector as `self - self.floor()`.
    ///  Note that this differs from the Rust implementation of `fract` which returns
    ///  `self - self.trunc()`.
    ///  Note that this is fast but not precise for large numbers.
    fn fract_gl(_self: Val<bevy::math::DVec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::fract_gl(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [f64; 3]) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::from_array(a).into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.  If any element is either
    ///  `NaN`, positive or negative infinity, this will return `false`.
    fn is_finite(_self: Val<bevy::math::DVec3>) -> bool {
        let output: bool = bevy::math::DVec3::is_finite(_self.into_inner()).into();
        output
    }
    ///  Performs `is_finite` on each element of self, returning a vector mask of the results.
    ///  In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.
    fn is_finite_mask(_self: Val<bevy::math::DVec3>) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::DVec3::is_finite_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `true` if any elements are `NaN`.
    fn is_nan(_self: Val<bevy::math::DVec3>) -> bool {
        let output: bool = bevy::math::DVec3::is_nan(_self.into_inner()).into();
        output
    }
    ///  Performs `is_nan` on each element of self, returning a vector mask of the results.
    ///  In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.
    fn is_nan_mask(_self: Val<bevy::math::DVec3>) -> Val<bevy::math::BVec3> {
        let output: Val<bevy::math::BVec3> = bevy::math::DVec3::is_nan_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.
    ///  A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
    ///  into the first lowest bit, element `y` into the second, etc.
    fn is_negative_bitmask(_self: Val<bevy::math::DVec3>) -> u32 {
        let output: u32 = bevy::math::DVec3::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    ///  Returns whether `self` is length `1.0` or not.
    ///  Uses a precision threshold of approximately `1e-4`.
    fn is_normalized(_self: Val<bevy::math::DVec3>) -> bool {
        let output: bool = bevy::math::DVec3::is_normalized(_self.into_inner()).into();
        output
    }
    ///  Computes the length of `self`.
    fn length(_self: Val<bevy::math::DVec3>) -> f64 {
        let output: f64 = bevy::math::DVec3::length(_self.into_inner()).into();
        output
    }
    ///  Computes `1.0 / length()`.
    ///  For valid results, `self` must _not_ be of length zero.
    fn length_recip(_self: Val<bevy::math::DVec3>) -> f64 {
        let output: f64 = bevy::math::DVec3::length_recip(_self.into_inner()).into();
        output
    }
    ///  Computes the squared length of `self`.
    ///  This is faster than `length()` as it avoids a square root operation.
    fn length_squared(_self: Val<bevy::math::DVec3>) -> f64 {
        let output: f64 = bevy::math::DVec3::length_squared(_self.into_inner()).into();
        output
    }
    ///  Performs a linear interpolation between `self` and `rhs` based on the value `s`.
    ///  When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
    ///  will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
    ///  extrapolated.
    fn lerp(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
        s: f64,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::lerp(
                _self.into_inner(),
                rhs.into_inner(),
                s,
            )
            .into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::DVec3>) -> f64 {
        let output: f64 = bevy::math::DVec3::max_element(_self.into_inner()).into();
        output
    }
    ///  Calculates the midpoint between `self` and `rhs`.
    ///  The midpoint is the average of, or halfway point between, two vectors.
    ///  `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`
    ///  while being slightly cheaper to compute.
    fn midpoint(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::midpoint(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::DVec3>) -> f64 {
        let output: f64 = bevy::math::DVec3::min_element(_self.into_inner()).into();
        output
    }
    ///  Moves towards `rhs` based on the value `d`.
    ///  When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to
    ///  `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.
    fn move_towards(
        _self: Ref<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
        d: f64,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::move_towards(
                &_self,
                rhs.into_inner(),
                d,
            )
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::DVec3>,
        rhs: Ref<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Mul<
            &bevy::math::DVec3,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Mul<
            bevy::math::DVec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DVec3>, rhs: f64) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Mul<
            f64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
    ///  error, yielding a more accurate result than an unfused multiply-add.
    ///  Using `mul_add` *may* be more performant than an unfused multiply-add if the target
    ///  architecture has a dedicated fma CPU instruction. However, this is not always true,
    ///  and will be heavily dependant on designing algorithms with specific target hardware in
    ///  mind.
    fn mul_add(
        _self: Val<bevy::math::DVec3>,
        a: Val<bevy::math::DVec3>,
        b: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::mul_add(
                _self.into_inner(),
                a.into_inner(),
                b.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::DVec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: f64, y: f64, z: f64) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::new(x, y, z).into();
        output
    }
    ///  Returns `self` normalized to length 1.0.
    ///  For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.
    ///  See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].
    ///  Panics
    ///  Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.
    fn normalize(_self: Val<bevy::math::DVec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::normalize(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `self` normalized to length 1.0 if possible, else returns a
    ///  fallback value.
    ///  In particular, if the input is zero (or very close to zero), or non-finite,
    ///  the result of this operation will be the fallback value.
    ///  See also [`Self::try_normalize()`].
    fn normalize_or(
        _self: Val<bevy::math::DVec3>,
        fallback: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::normalize_or(
                _self.into_inner(),
                fallback.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `self` normalized to length 1.0 if possible, else returns zero.
    ///  In particular, if the input is zero (or very close to zero), or non-finite,
    ///  the result of this operation will be zero.
    ///  See also [`Self::try_normalize()`].
    fn normalize_or_zero(_self: Val<bevy::math::DVec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::normalize_or_zero(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing each element of `self` raised to the power of `n`.
    fn powf(_self: Val<bevy::math::DVec3>, n: f64) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::powf(
                _self.into_inner(),
                n,
            )
            .into();
        output
    }
    ///  Returns the vector projection of `self` onto `rhs`.
    ///  `rhs` must be of non-zero length.
    ///  # Panics
    ///  Will panic if `rhs` is zero length when `glam_assert` is enabled.
    fn project_onto(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::project_onto(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the vector projection of `self` onto `rhs`.
    ///  `rhs` must be normalized.
    ///  # Panics
    ///  Will panic if `rhs` is not normalized when `glam_assert` is enabled.
    fn project_onto_normalized(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::project_onto_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
    fn recip(_self: Val<bevy::math::DVec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::recip(_self.into_inner())
            .into();
        output
    }
    ///  Returns the reflection vector for a given incident vector `self` and surface normal
    ///  `normal`.
    ///  `normal` must be normalized.
    ///  # Panics
    ///  Will panic if `normal` is not normalized when `glam_assert` is enabled.
    fn reflect(
        _self: Val<bevy::math::DVec3>,
        normal: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::reflect(
                _self.into_inner(),
                normal.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the refraction direction for a given incident vector `self`, surface normal
    ///  `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,
    ///  a zero vector will be returned.
    ///  `self` and `normal` must be normalized.
    ///  # Panics
    ///  Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.
    fn refract(
        _self: Val<bevy::math::DVec3>,
        normal: Val<bevy::math::DVec3>,
        eta: f64,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::refract(
                _self.into_inner(),
                normal.into_inner(),
                eta,
            )
            .into();
        output
    }
    ///  Returns the vector rejection of `self` from `rhs`.
    ///  The vector rejection is the vector perpendicular to the projection of `self` onto
    ///  `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
    ///  `rhs` must be of non-zero length.
    ///  # Panics
    ///  Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
    fn reject_from(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::reject_from(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the vector rejection of `self` from `rhs`.
    ///  The vector rejection is the vector perpendicular to the projection of `self` onto
    ///  `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
    ///  `rhs` must be normalized.
    ///  # Panics
    ///  Will panic if `rhs` is not normalized when `glam_assert` is enabled.
    fn reject_from_normalized(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::reject_from_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::DVec3>,
        rhs: Ref<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Rem<
            &bevy::math::DVec3,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Rem<
            bevy::math::DVec3,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::DVec3>, rhs: f64) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Rem<
            f64,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
    ///  [Euclidean division]: f64::rem_euclid
    fn rem_euclid(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the nearest integer to a number for each element of `self`.
    ///  Round half-way cases away from 0.0.
    fn round(_self: Val<bevy::math::DVec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::round(_self.into_inner())
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec3>,
        if_true: Val<bevy::math::DVec3>,
        if_false: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with elements representing the sign of `self`.
    ///  - `1.0` if the number is positive, `+0.0` or `INFINITY`
    ///  - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
    ///  - `NAN` if the number is `NAN`
    fn signum(_self: Val<bevy::math::DVec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: f64) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::DVec3>,
        rhs: Ref<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Sub<
            &bevy::math::DVec3,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Sub<
            bevy::math::DVec3,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::DVec3>, rhs: f64) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Sub<
            f64,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  `[x, y, z]`
    fn to_array(_self: Ref<bevy::math::DVec3>) -> [f64; 3] {
        let output: [f64; 3] = bevy::math::DVec3::to_array(&_self).into();
        output
    }
    ///  Returns a vector containing the integer part each element of `self`. This means numbers are
    ///  always truncated towards zero.
    fn trunc(_self: Val<bevy::math::DVec3>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::trunc(_self.into_inner())
            .into();
        output
    }
    ///  Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
    ///  Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].
    fn truncate(_self: Val<bevy::math::DVec3>) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec3::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::DVec3>, x: f64) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::DVec3>, y: f64) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    ///  Creates a 3D vector from `self` with the given value of `z`.
    fn with_z(_self: Val<bevy::math::DVec3>, z: f64) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "d_vec_4_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::DVec4 {
    ///  Returns a vector containing the absolute value of each element of `self`.
    fn abs(_self: Val<bevy::math::DVec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::abs(_self.into_inner())
            .into();
        output
    }
    ///  Returns true if the absolute difference of all elements between `self` and `rhs` is
    ///  less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two vectors contain similar elements. It works best when
    ///  comparing with a known value. The `max_abs_diff` that should be used used depends on
    ///  the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
        max_abs_diff: f64,
    ) -> bool {
        let output: bool = bevy::math::DVec4::abs_diff_eq(
                _self.into_inner(),
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::DVec4>,
        rhs: Ref<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Add<
            &bevy::math::DVec4,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Add<
            bevy::math::DVec4,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::DVec4>, rhs: f64) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Add<
            f64,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i64`.
    fn as_i64vec4(_self: Ref<bevy::math::DVec4>) -> Val<bevy::math::I64Vec4> {
        let output: Val<bevy::math::I64Vec4> = bevy::math::DVec4::as_i64vec4(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `i32`.
    fn as_ivec4(_self: Ref<bevy::math::DVec4>) -> Val<bevy::math::IVec4> {
        let output: Val<bevy::math::IVec4> = bevy::math::DVec4::as_ivec4(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `u64`.
    fn as_u64vec4(_self: Ref<bevy::math::DVec4>) -> Val<bevy::math::U64Vec4> {
        let output: Val<bevy::math::U64Vec4> = bevy::math::DVec4::as_u64vec4(&_self)
            .into();
        output
    }
    ///  Casts all elements of `self` to `u32`.
    fn as_uvec4(_self: Ref<bevy::math::DVec4>) -> Val<bevy::math::UVec4> {
        let output: Val<bevy::math::UVec4> = bevy::math::DVec4::as_uvec4(&_self).into();
        output
    }
    ///  Casts all elements of `self` to `f32`.
    fn as_vec4(_self: Ref<bevy::math::DVec4>) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::DVec4::as_vec4(&_self).into();
        output
    }
    ///  Returns a vector containing the smallest integer greater than or equal to a number for
    ///  each element of `self`.
    fn ceil(_self: Val<bevy::math::DVec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::ceil(_self.into_inner())
            .into();
        output
    }
    ///  Component-wise clamping of values, similar to [`f64::clamp`].
    ///  Each element in `min` must be less-or-equal to the corresponding element in `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max` when `glam_assert` is enabled.
    fn clamp(
        _self: Val<bevy::math::DVec4>,
        min: Val<bevy::math::DVec4>,
        max: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with a length no less than `min` and no more than `max`.
    ///  # Panics
    ///  Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.
    fn clamp_length(
        _self: Val<bevy::math::DVec4>,
        min: f64,
        max: f64,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::clamp_length(
                _self.into_inner(),
                min,
                max,
            )
            .into();
        output
    }
    ///  Returns a vector with a length no more than `max`.
    ///  # Panics
    ///  Will panic if `max` is negative when `glam_assert` is enabled.
    fn clamp_length_max(
        _self: Val<bevy::math::DVec4>,
        max: f64,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::clamp_length_max(
                _self.into_inner(),
                max,
            )
            .into();
        output
    }
    ///  Returns a vector with a length no less than `min`.
    ///  # Panics
    ///  Will panic if `min` is negative when `glam_assert` is enabled.
    fn clamp_length_min(
        _self: Val<bevy::math::DVec4>,
        min: f64,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::clamp_length_min(
                _self.into_inner(),
                min,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::DVec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `==` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
    ///  elements.
    fn cmpeq(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
    ///  elements.
    fn cmpge(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `>` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
    ///  elements.
    fn cmpgt(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
    ///  elements.
    fn cmple(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `<` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
    ///  elements.
    fn cmplt(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector mask containing the result of a `!=` comparison for each element of
    ///  `self` and `rhs`.
    ///  In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
    ///  elements.
    fn cmpne(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with signs of `rhs` and the magnitudes of `self`.
    fn copysign(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::copysign(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the Euclidean distance between two points in space.
    fn distance(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) -> f64 {
        let output: f64 = bevy::math::DVec4::distance(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Compute the squared euclidean distance between two points in space.
    fn distance_squared(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> f64 {
        let output: f64 = bevy::math::DVec4::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::DVec4>,
        rhs: Ref<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Div<
            &bevy::math::DVec4,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Div<
            bevy::math::DVec4,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::DVec4>, rhs: f64) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Div<
            f64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.
    fn div_euclid(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`.
    fn dot(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) -> f64 {
        let output: f64 = bevy::math::DVec4::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns a vector where every component is the dot product of `self` and `rhs`.
    fn dot_into_vec(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the product of all elements of `self`.
    ///  In other words, this computes `self.x * self.y * ..`.
    fn element_product(_self: Val<bevy::math::DVec4>) -> f64 {
        let output: f64 = bevy::math::DVec4::element_product(_self.into_inner()).into();
        output
    }
    ///  Returns the sum of all elements of `self`.
    ///  In other words, this computes `self.x + self.y + ..`.
    fn element_sum(_self: Val<bevy::math::DVec4>) -> f64 {
        let output: f64 = bevy::math::DVec4::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::DVec4>, other: Ref<bevy::math::DVec4>) -> bool {
        let output: bool = <bevy::math::DVec4 as std::cmp::PartialEq<
            bevy::math::DVec4,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Returns a vector containing `e^self` (the exponential function) for each element of
    ///  `self`.
    fn exp(_self: Val<bevy::math::DVec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::exp(_self.into_inner())
            .into();
        output
    }
    ///  Returns a vector containing the largest integer less than or equal to a number for each
    ///  element of `self`.
    fn floor(_self: Val<bevy::math::DVec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::floor(_self.into_inner())
            .into();
        output
    }
    ///  Returns a vector containing the fractional part of the vector as `self - self.trunc()`.
    ///  Note that this differs from the GLSL implementation of `fract` which returns
    ///  `self - self.floor()`.
    ///  Note that this is fast but not precise for large numbers.
    fn fract(_self: Val<bevy::math::DVec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::fract(_self.into_inner())
            .into();
        output
    }
    ///  Returns a vector containing the fractional part of the vector as `self - self.floor()`.
    ///  Note that this differs from the Rust implementation of `fract` which returns
    ///  `self - self.trunc()`.
    ///  Note that this is fast but not precise for large numbers.
    fn fract_gl(_self: Val<bevy::math::DVec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::fract_gl(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new vector from an array.
    fn from_array(a: [f64; 4]) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::from_array(a).into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.  If any element is either
    ///  `NaN`, positive or negative infinity, this will return `false`.
    fn is_finite(_self: Val<bevy::math::DVec4>) -> bool {
        let output: bool = bevy::math::DVec4::is_finite(_self.into_inner()).into();
        output
    }
    ///  Performs `is_finite` on each element of self, returning a vector mask of the results.
    ///  In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.
    fn is_finite_mask(_self: Val<bevy::math::DVec4>) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::DVec4::is_finite_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `true` if any elements are `NaN`.
    fn is_nan(_self: Val<bevy::math::DVec4>) -> bool {
        let output: bool = bevy::math::DVec4::is_nan(_self.into_inner()).into();
        output
    }
    ///  Performs `is_nan` on each element of self, returning a vector mask of the results.
    ///  In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.
    fn is_nan_mask(_self: Val<bevy::math::DVec4>) -> Val<bevy::math::BVec4> {
        let output: Val<bevy::math::BVec4> = bevy::math::DVec4::is_nan_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a bitmask with the lowest 4 bits set to the sign bits from the elements of `self`.
    ///  A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes
    ///  into the first lowest bit, element `y` into the second, etc.
    fn is_negative_bitmask(_self: Val<bevy::math::DVec4>) -> u32 {
        let output: u32 = bevy::math::DVec4::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    ///  Returns whether `self` is length `1.0` or not.
    ///  Uses a precision threshold of approximately `1e-4`.
    fn is_normalized(_self: Val<bevy::math::DVec4>) -> bool {
        let output: bool = bevy::math::DVec4::is_normalized(_self.into_inner()).into();
        output
    }
    ///  Computes the length of `self`.
    fn length(_self: Val<bevy::math::DVec4>) -> f64 {
        let output: f64 = bevy::math::DVec4::length(_self.into_inner()).into();
        output
    }
    ///  Computes `1.0 / length()`.
    ///  For valid results, `self` must _not_ be of length zero.
    fn length_recip(_self: Val<bevy::math::DVec4>) -> f64 {
        let output: f64 = bevy::math::DVec4::length_recip(_self.into_inner()).into();
        output
    }
    ///  Computes the squared length of `self`.
    ///  This is faster than `length()` as it avoids a square root operation.
    fn length_squared(_self: Val<bevy::math::DVec4>) -> f64 {
        let output: f64 = bevy::math::DVec4::length_squared(_self.into_inner()).into();
        output
    }
    ///  Performs a linear interpolation between `self` and `rhs` based on the value `s`.
    ///  When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
    ///  will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
    ///  extrapolated.
    fn lerp(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
        s: f64,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::lerp(
                _self.into_inner(),
                rhs.into_inner(),
                s,
            )
            .into();
        output
    }
    ///  Returns a vector containing the maximum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
    fn max(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal maximum of `self`.
    ///  In other words this computes `max(x, y, ..)`.
    fn max_element(_self: Val<bevy::math::DVec4>) -> f64 {
        let output: f64 = bevy::math::DVec4::max_element(_self.into_inner()).into();
        output
    }
    ///  Calculates the midpoint between `self` and `rhs`.
    ///  The midpoint is the average of, or halfway point between, two vectors.
    ///  `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`
    ///  while being slightly cheaper to compute.
    fn midpoint(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::midpoint(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the minimum values for each element of `self` and `rhs`.
    ///  In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
    fn min(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the horizontal minimum of `self`.
    ///  In other words this computes `min(x, y, ..)`.
    fn min_element(_self: Val<bevy::math::DVec4>) -> f64 {
        let output: f64 = bevy::math::DVec4::min_element(_self.into_inner()).into();
        output
    }
    ///  Moves towards `rhs` based on the value `d`.
    ///  When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to
    ///  `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.
    fn move_towards(
        _self: Ref<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
        d: f64,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::move_towards(
                &_self,
                rhs.into_inner(),
                d,
            )
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::DVec4>,
        rhs: Ref<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Mul<
            &bevy::math::DVec4,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Mul<
            bevy::math::DVec4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DVec4>, rhs: f64) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Mul<
            f64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
    ///  error, yielding a more accurate result than an unfused multiply-add.
    ///  Using `mul_add` *may* be more performant than an unfused multiply-add if the target
    ///  architecture has a dedicated fma CPU instruction. However, this is not always true,
    ///  and will be heavily dependant on designing algorithms with specific target hardware in
    ///  mind.
    fn mul_add(
        _self: Val<bevy::math::DVec4>,
        a: Val<bevy::math::DVec4>,
        b: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::mul_add(
                _self.into_inner(),
                a.into_inner(),
                b.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::DVec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new vector.
    fn new(x: f64, y: f64, z: f64, w: f64) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::new(x, y, z, w).into();
        output
    }
    ///  Returns `self` normalized to length 1.0.
    ///  For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.
    ///  See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].
    ///  Panics
    ///  Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.
    fn normalize(_self: Val<bevy::math::DVec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::normalize(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `self` normalized to length 1.0 if possible, else returns a
    ///  fallback value.
    ///  In particular, if the input is zero (or very close to zero), or non-finite,
    ///  the result of this operation will be the fallback value.
    ///  See also [`Self::try_normalize()`].
    fn normalize_or(
        _self: Val<bevy::math::DVec4>,
        fallback: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::normalize_or(
                _self.into_inner(),
                fallback.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `self` normalized to length 1.0 if possible, else returns zero.
    ///  In particular, if the input is zero (or very close to zero), or non-finite,
    ///  the result of this operation will be zero.
    ///  See also [`Self::try_normalize()`].
    fn normalize_or_zero(_self: Val<bevy::math::DVec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::normalize_or_zero(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing each element of `self` raised to the power of `n`.
    fn powf(_self: Val<bevy::math::DVec4>, n: f64) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::powf(
                _self.into_inner(),
                n,
            )
            .into();
        output
    }
    ///  Returns the vector projection of `self` onto `rhs`.
    ///  `rhs` must be of non-zero length.
    ///  # Panics
    ///  Will panic if `rhs` is zero length when `glam_assert` is enabled.
    fn project_onto(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::project_onto(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the vector projection of `self` onto `rhs`.
    ///  `rhs` must be normalized.
    ///  # Panics
    ///  Will panic if `rhs` is not normalized when `glam_assert` is enabled.
    fn project_onto_normalized(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::project_onto_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
    fn recip(_self: Val<bevy::math::DVec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::recip(_self.into_inner())
            .into();
        output
    }
    ///  Returns the reflection vector for a given incident vector `self` and surface normal
    ///  `normal`.
    ///  `normal` must be normalized.
    ///  # Panics
    ///  Will panic if `normal` is not normalized when `glam_assert` is enabled.
    fn reflect(
        _self: Val<bevy::math::DVec4>,
        normal: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::reflect(
                _self.into_inner(),
                normal.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the refraction direction for a given incident vector `self`, surface normal
    ///  `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,
    ///  a zero vector will be returned.
    ///  `self` and `normal` must be normalized.
    ///  # Panics
    ///  Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.
    fn refract(
        _self: Val<bevy::math::DVec4>,
        normal: Val<bevy::math::DVec4>,
        eta: f64,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::refract(
                _self.into_inner(),
                normal.into_inner(),
                eta,
            )
            .into();
        output
    }
    ///  Returns the vector rejection of `self` from `rhs`.
    ///  The vector rejection is the vector perpendicular to the projection of `self` onto
    ///  `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
    ///  `rhs` must be of non-zero length.
    ///  # Panics
    ///  Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
    fn reject_from(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::reject_from(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the vector rejection of `self` from `rhs`.
    ///  The vector rejection is the vector perpendicular to the projection of `self` onto
    ///  `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
    ///  `rhs` must be normalized.
    ///  # Panics
    ///  Will panic if `rhs` is not normalized when `glam_assert` is enabled.
    fn reject_from_normalized(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::reject_from_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::DVec4>,
        rhs: Ref<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Rem<
            &bevy::math::DVec4,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Rem<
            bevy::math::DVec4,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::DVec4>, rhs: f64) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Rem<
            f64,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.
    ///  [Euclidean division]: f64::rem_euclid
    fn rem_euclid(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector containing the nearest integer to a number for each element of `self`.
    ///  Round half-way cases away from 0.0.
    fn round(_self: Val<bevy::math::DVec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::round(_self.into_inner())
            .into();
        output
    }
    ///  Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
    ///  for each element of `self`.
    ///  A true element in the mask uses the corresponding element from `if_true`, and false
    ///  uses the element from `if_false`.
    fn select(
        mask: Val<bevy::math::BVec4>,
        if_true: Val<bevy::math::DVec4>,
        if_false: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    ///  Returns a vector with elements representing the sign of `self`.
    ///  - `1.0` if the number is positive, `+0.0` or `INFINITY`
    ///  - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
    ///  - `NAN` if the number is `NAN`
    fn signum(_self: Val<bevy::math::DVec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a vector with all elements set to `v`.
    fn splat(v: f64) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::splat(v).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::DVec4>,
        rhs: Ref<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Sub<
            &bevy::math::DVec4,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Sub<
            bevy::math::DVec4,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::DVec4>, rhs: f64) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Sub<
            f64,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  `[x, y, z, w]`
    fn to_array(_self: Ref<bevy::math::DVec4>) -> [f64; 4] {
        let output: [f64; 4] = bevy::math::DVec4::to_array(&_self).into();
        output
    }
    ///  Returns a vector containing the integer part each element of `self`. This means numbers are
    ///  always truncated towards zero.
    fn trunc(_self: Val<bevy::math::DVec4>) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::trunc(_self.into_inner())
            .into();
        output
    }
    ///  Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
    ///  Truncation to [`DVec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].
    fn truncate(_self: Val<bevy::math::DVec4>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec4::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `w`.
    fn with_w(_self: Val<bevy::math::DVec4>, w: f64) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::with_w(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `x`.
    fn with_x(_self: Val<bevy::math::DVec4>, x: f64) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `y`.
    fn with_y(_self: Val<bevy::math::DVec4>, y: f64) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    ///  Creates a 4D vector from `self` with the given value of `z`.
    fn with_z(_self: Val<bevy::math::DVec4>, z: f64) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "mat_2_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::Mat2 {
    ///  Takes the absolute value of each element in `self`
    fn abs(_self: Ref<bevy::math::Mat2>) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::abs(&_self).into();
        output
    }
    ///  Returns true if the absolute difference of all elements between `self` and `rhs`
    ///  is less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two matrices contain similar elements. It works best
    ///  when comparing with a known value. The `max_abs_diff` that should be used used
    ///  depends on the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Ref<bevy::math::Mat2>,
        rhs: Val<bevy::math::Mat2>,
        max_abs_diff: f32,
    ) -> bool {
        let output: bool = bevy::math::Mat2::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::Mat2>,
        rhs: Val<bevy::math::Mat2>,
    ) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as std::ops::Add<
            bevy::math::Mat2,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Adds two 2x2 matrices.
    fn add_mat2(
        _self: Ref<bevy::math::Mat2>,
        rhs: Ref<bevy::math::Mat2>,
    ) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::add_mat2(&_self, &rhs)
            .into();
        output
    }
    fn as_dmat2(_self: Ref<bevy::math::Mat2>) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = bevy::math::Mat2::as_dmat2(&_self).into();
        output
    }
    fn clone(_self: Ref<bevy::math::Mat2>) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the matrix column for the given `index`.
    ///  # Panics
    ///  Panics if `index` is greater than 1.
    fn col(_self: Ref<bevy::math::Mat2>, index: usize) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Mat2::col(&_self, index).into();
        output
    }
    ///  Returns the determinant of `self`.
    fn determinant(_self: Ref<bevy::math::Mat2>) -> f32 {
        let output: f32 = bevy::math::Mat2::determinant(&_self).into();
        output
    }
    fn div(_self: Val<bevy::math::Mat2>, rhs: f32) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as std::ops::Div<
            f32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Divides a 2x2 matrix by a scalar.
    fn div_scalar(_self: Ref<bevy::math::Mat2>, rhs: f32) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::div_scalar(&_self, rhs)
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::Mat2>, rhs: Ref<bevy::math::Mat2>) -> bool {
        let output: bool = <bevy::math::Mat2 as std::cmp::PartialEq<
            bevy::math::Mat2,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    ///  Creates a 2x2 matrix containing a rotation of `angle` (in radians).
    fn from_angle(angle: f32) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_angle(angle).into();
        output
    }
    ///  Creates a 2x2 matrix from two column vectors.
    fn from_cols(
        x_axis: Val<bevy::math::Vec2>,
        y_axis: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 2x2 matrix with its diagonal set to `diagonal` and all other entries set to 0.
    fn from_diagonal(diagonal: Val<bevy::math::Vec2>) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_diagonal(
                diagonal.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 2x2 matrix from a 3x3 matrix, discarding the 2nd row and column.
    fn from_mat3(m: Val<bevy::math::Mat3>) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_mat3(m.into_inner())
            .into();
        output
    }
    ///  Creates a 2x2 matrix from the minor of the given 3x3 matrix, discarding the `i`th column
    ///  and `j`th row.
    ///  # Panics
    ///  Panics if `i` or `j` is greater than 2.
    fn from_mat3_minor(
        m: Val<bevy::math::Mat3>,
        i: usize,
        j: usize,
    ) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_mat3_minor(
                m.into_inner(),
                i,
                j,
            )
            .into();
        output
    }
    ///  Creates a 2x2 matrix from a 3x3 matrix, discarding the 2nd row and column.
    fn from_mat3a(m: Val<bevy::math::Mat3A>) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_mat3a(m.into_inner())
            .into();
        output
    }
    ///  Creates a 2x2 matrix from the minor of the given 3x3 matrix, discarding the `i`th column
    ///  and `j`th row.
    ///  # Panics
    ///  Panics if `i` or `j` is greater than 2.
    fn from_mat3a_minor(
        m: Val<bevy::math::Mat3A>,
        i: usize,
        j: usize,
    ) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_mat3a_minor(
                m.into_inner(),
                i,
                j,
            )
            .into();
        output
    }
    ///  Creates a 2x2 matrix containing the combining non-uniform `scale` and rotation of
    ///  `angle` (in radians).
    fn from_scale_angle(
        scale: Val<bevy::math::Vec2>,
        angle: f32,
    ) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_scale_angle(
                scale.into_inner(),
                angle,
            )
            .into();
        output
    }
    ///  Returns the inverse of `self`.
    ///  If the matrix is not invertible the returned matrix will be invalid.
    ///  # Panics
    ///  Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
    fn inverse(_self: Ref<bevy::math::Mat2>) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::inverse(&_self).into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.
    ///  If any element is either `NaN`, positive or negative infinity, this will return `false`.
    fn is_finite(_self: Ref<bevy::math::Mat2>) -> bool {
        let output: bool = bevy::math::Mat2::is_finite(&_self).into();
        output
    }
    ///  Returns `true` if any elements are `NaN`.
    fn is_nan(_self: Ref<bevy::math::Mat2>) -> bool {
        let output: bool = bevy::math::Mat2::is_nan(&_self).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Mat2>,
        rhs: Val<bevy::math::Mat2>,
    ) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as std::ops::Mul<
            bevy::math::Mat2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Mat2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = <bevy::math::Mat2 as std::ops::Mul<
            bevy::math::Vec2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat2>, rhs: f32) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as std::ops::Mul<
            f32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Multiplies two 2x2 matrices.
    fn mul_mat2(
        _self: Ref<bevy::math::Mat2>,
        rhs: Ref<bevy::math::Mat2>,
    ) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::mul_mat2(&_self, &rhs)
            .into();
        output
    }
    ///  Multiplies a 2x2 matrix by a scalar.
    fn mul_scalar(_self: Ref<bevy::math::Mat2>, rhs: f32) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::mul_scalar(&_self, rhs)
            .into();
        output
    }
    ///  Transforms a 2D vector.
    fn mul_vec2(
        _self: Ref<bevy::math::Mat2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Mat2::mul_vec2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::Mat2>) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the matrix row for the given `index`.
    ///  # Panics
    ///  Panics if `index` is greater than 1.
    fn row(_self: Ref<bevy::math::Mat2>, index: usize) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Mat2::row(&_self, index).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::Mat2>,
        rhs: Val<bevy::math::Mat2>,
    ) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as std::ops::Sub<
            bevy::math::Mat2,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Subtracts two 2x2 matrices.
    fn sub_mat2(
        _self: Ref<bevy::math::Mat2>,
        rhs: Ref<bevy::math::Mat2>,
    ) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::sub_mat2(&_self, &rhs)
            .into();
        output
    }
    ///  Creates a `[f32; 4]` array storing data in column major order.
    ///  If you require data in row major order `transpose` the matrix first.
    fn to_cols_array(_self: Ref<bevy::math::Mat2>) -> [f32; 4] {
        let output: [f32; 4] = bevy::math::Mat2::to_cols_array(&_self).into();
        output
    }
    ///  Creates a `[[f32; 2]; 2]` 2D array storing data in column major order.
    ///  If you require data in row major order `transpose` the matrix first.
    fn to_cols_array_2d(_self: Ref<bevy::math::Mat2>) -> [[f32; 2]; 2] {
        let output: [[f32; 2]; 2] = bevy::math::Mat2::to_cols_array_2d(&_self).into();
        output
    }
    ///  Returns the transpose of `self`.
    fn transpose(_self: Ref<bevy::math::Mat2>) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::transpose(&_self).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "mat_3_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::Mat3 {
    ///  Takes the absolute value of each element in `self`
    fn abs(_self: Ref<bevy::math::Mat3>) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::abs(&_self).into();
        output
    }
    ///  Returns true if the absolute difference of all elements between `self` and `rhs`
    ///  is less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two matrices contain similar elements. It works best
    ///  when comparing with a known value. The `max_abs_diff` that should be used used
    ///  depends on the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Ref<bevy::math::Mat3>,
        rhs: Val<bevy::math::Mat3>,
        max_abs_diff: f32,
    ) -> bool {
        let output: bool = bevy::math::Mat3::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::Mat3>,
        rhs: Val<bevy::math::Mat3>,
    ) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Add<
            bevy::math::Mat3,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Adds two 3x3 matrices.
    fn add_mat3(
        _self: Ref<bevy::math::Mat3>,
        rhs: Ref<bevy::math::Mat3>,
    ) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::add_mat3(&_self, &rhs)
            .into();
        output
    }
    fn as_dmat3(_self: Ref<bevy::math::Mat3>) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::Mat3::as_dmat3(&_self).into();
        output
    }
    fn clone(_self: Ref<bevy::math::Mat3>) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the matrix column for the given `index`.
    ///  # Panics
    ///  Panics if `index` is greater than 2.
    fn col(_self: Ref<bevy::math::Mat3>, index: usize) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Mat3::col(&_self, index).into();
        output
    }
    ///  Returns the determinant of `self`.
    fn determinant(_self: Ref<bevy::math::Mat3>) -> f32 {
        let output: f32 = bevy::math::Mat3::determinant(&_self).into();
        output
    }
    fn div(_self: Val<bevy::math::Mat3>, rhs: f32) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Div<
            f32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Divides a 3x3 matrix by a scalar.
    fn div_scalar(_self: Ref<bevy::math::Mat3>, rhs: f32) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::div_scalar(&_self, rhs)
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::Mat3>, rhs: Ref<bevy::math::Mat3>) -> bool {
        let output: bool = <bevy::math::Mat3 as std::cmp::PartialEq<
            bevy::math::Mat3,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 2D rotation `angle` (in
    ///  radians).
    ///  The resulting matrix can be used to transform 2D points and vectors. See
    ///  [`Self::transform_point2()`] and [`Self::transform_vector2()`].
    fn from_angle(angle: f32) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_angle(angle).into();
        output
    }
    ///  Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in
    ///  radians).
    ///  # Panics
    ///  Will panic if `axis` is not normalized when `glam_assert` is enabled.
    fn from_axis_angle(
        axis: Val<bevy::math::Vec3>,
        angle: f32,
    ) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_axis_angle(
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    ///  Creates a 3x3 matrix from three column vectors.
    fn from_cols(
        x_axis: Val<bevy::math::Vec3>,
        y_axis: Val<bevy::math::Vec3>,
        z_axis: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
                z_axis.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.
    fn from_diagonal(diagonal: Val<bevy::math::Vec3>) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_diagonal(
                diagonal.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in
    ///  radians).
    fn from_euler(
        order: Val<bevy::math::EulerRot>,
        a: f32,
        b: f32,
        c: f32,
    ) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_euler(
                order.into_inner(),
                a,
                b,
                c,
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 2x2 matrix.
    ///  The resulting matrix can be used to transform 2D points and vectors. See
    ///  [`Self::transform_point2()`] and [`Self::transform_vector2()`].
    fn from_mat2(m: Val<bevy::math::Mat2>) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_mat2(m.into_inner())
            .into();
        output
    }
    ///  Creates a 3x3 matrix from a 4x4 matrix, discarding the 4th row and column.
    fn from_mat4(m: Val<bevy::math::Mat4>) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_mat4(m.into_inner())
            .into();
        output
    }
    ///  Creates a 3x3 matrix from the minor of the given 4x4 matrix, discarding the `i`th column
    ///  and `j`th row.
    ///  # Panics
    ///  Panics if `i` or `j` is greater than 3.
    fn from_mat4_minor(
        m: Val<bevy::math::Mat4>,
        i: usize,
        j: usize,
    ) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_mat4_minor(
                m.into_inner(),
                i,
                j,
            )
            .into();
        output
    }
    ///  Creates a 3D rotation matrix from the given quaternion.
    ///  # Panics
    ///  Will panic if `rotation` is not normalized when `glam_assert` is enabled.
    fn from_quat(rotation: Val<bevy::math::Quat>) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_quat(
                rotation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 3D rotation matrix from `angle` (in radians) around the x axis.
    fn from_rotation_x(angle: f32) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_rotation_x(angle)
            .into();
        output
    }
    ///  Creates a 3D rotation matrix from `angle` (in radians) around the y axis.
    fn from_rotation_y(angle: f32) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_rotation_y(angle)
            .into();
        output
    }
    ///  Creates a 3D rotation matrix from `angle` (in radians) around the z axis.
    fn from_rotation_z(angle: f32) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_rotation_z(angle)
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given non-uniform 2D `scale`.
    ///  The resulting matrix can be used to transform 2D points and vectors. See
    ///  [`Self::transform_point2()`] and [`Self::transform_vector2()`].
    ///  # Panics
    ///  Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
    fn from_scale(scale: Val<bevy::math::Vec2>) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in
    ///  radians) and `translation`.
    ///  The resulting matrix can be used to transform 2D points and vectors. See
    ///  [`Self::transform_point2()`] and [`Self::transform_vector2()`].
    fn from_scale_angle_translation(
        scale: Val<bevy::math::Vec2>,
        angle: f32,
        translation: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_scale_angle_translation(
                scale.into_inner(),
                angle,
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 2D `translation`.
    ///  The resulting matrix can be used to transform 2D points and vectors. See
    ///  [`Self::transform_point2()`] and [`Self::transform_vector2()`].
    fn from_translation(translation: Val<bevy::math::Vec2>) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the inverse of `self`.
    ///  If the matrix is not invertible the returned matrix will be invalid.
    ///  # Panics
    ///  Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
    fn inverse(_self: Ref<bevy::math::Mat3>) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::inverse(&_self).into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.
    ///  If any element is either `NaN`, positive or negative infinity, this will return `false`.
    fn is_finite(_self: Ref<bevy::math::Mat3>) -> bool {
        let output: bool = bevy::math::Mat3::is_finite(&_self).into();
        output
    }
    ///  Returns `true` if any elements are `NaN`.
    fn is_nan(_self: Ref<bevy::math::Mat3>) -> bool {
        let output: bool = bevy::math::Mat3::is_nan(&_self).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Mat3>,
        rhs: Val<bevy::math::Affine2>,
    ) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Mul<
            bevy::math::Affine2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Mat3>,
        rhs: Val<bevy::math::Mat3>,
    ) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Mul<
            bevy::math::Mat3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Mat3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Mat3 as std::ops::Mul<
            bevy::math::Vec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Mat3>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Mat3 as std::ops::Mul<
            bevy::math::Vec3A,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat3>, rhs: f32) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Mul<
            f32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Multiplies two 3x3 matrices.
    fn mul_mat3(
        _self: Ref<bevy::math::Mat3>,
        rhs: Ref<bevy::math::Mat3>,
    ) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::mul_mat3(&_self, &rhs)
            .into();
        output
    }
    ///  Multiplies a 3x3 matrix by a scalar.
    fn mul_scalar(_self: Ref<bevy::math::Mat3>, rhs: f32) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::mul_scalar(&_self, rhs)
            .into();
        output
    }
    ///  Transforms a 3D vector.
    fn mul_vec3(
        _self: Ref<bevy::math::Mat3>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Mat3::mul_vec3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Transforms a [`Vec3A`].
    fn mul_vec3a(
        _self: Ref<bevy::math::Mat3>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Mat3::mul_vec3a(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::Mat3>) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the matrix row for the given `index`.
    ///  # Panics
    ///  Panics if `index` is greater than 2.
    fn row(_self: Ref<bevy::math::Mat3>, index: usize) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Mat3::row(&_self, index).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::Mat3>,
        rhs: Val<bevy::math::Mat3>,
    ) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Sub<
            bevy::math::Mat3,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Subtracts two 3x3 matrices.
    fn sub_mat3(
        _self: Ref<bevy::math::Mat3>,
        rhs: Ref<bevy::math::Mat3>,
    ) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::sub_mat3(&_self, &rhs)
            .into();
        output
    }
    ///  Creates a `[f32; 9]` array storing data in column major order.
    ///  If you require data in row major order `transpose` the matrix first.
    fn to_cols_array(_self: Ref<bevy::math::Mat3>) -> [f32; 9] {
        let output: [f32; 9] = bevy::math::Mat3::to_cols_array(&_self).into();
        output
    }
    ///  Creates a `[[f32; 3]; 3]` 3D array storing data in column major order.
    ///  If you require data in row major order `transpose` the matrix first.
    fn to_cols_array_2d(_self: Ref<bevy::math::Mat3>) -> [[f32; 3]; 3] {
        let output: [[f32; 3]; 3] = bevy::math::Mat3::to_cols_array_2d(&_self).into();
        output
    }
    ///  Extract Euler angles with the given Euler rotation order.
    ///  Note if the input matrix contains scales, shears, or other non-rotation transformations then
    ///  the resulting Euler angles will be ill-defined.
    ///  # Panics
    ///  Will panic if any input matrix column is not normalized when `glam_assert` is enabled.
    fn to_euler(
        _self: Ref<bevy::math::Mat3>,
        order: Val<bevy::math::EulerRot>,
    ) -> (f32, f32, f32) {
        let output: (f32, f32, f32) = bevy::math::Mat3::to_euler(
                &_self,
                order.into_inner(),
            )
            .into();
        output
    }
    ///  Transforms the given 2D vector as a point.
    ///  This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.
    ///  This method assumes that `self` contains a valid affine transform.
    ///  # Panics
    ///  Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.
    fn transform_point2(
        _self: Ref<bevy::math::Mat3>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Mat3::transform_point2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Rotates the given 2D vector.
    ///  This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.
    ///  This method assumes that `self` contains a valid affine transform.
    ///  # Panics
    ///  Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.
    fn transform_vector2(
        _self: Ref<bevy::math::Mat3>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Mat3::transform_vector2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the transpose of `self`.
    fn transpose(_self: Ref<bevy::math::Mat3>) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::transpose(&_self).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "mat_3_a_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::Mat3A {
    ///  Takes the absolute value of each element in `self`
    fn abs(_self: Ref<bevy::math::Mat3A>) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::abs(&_self).into();
        output
    }
    ///  Returns true if the absolute difference of all elements between `self` and `rhs`
    ///  is less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two matrices contain similar elements. It works best
    ///  when comparing with a known value. The `max_abs_diff` that should be used used
    ///  depends on the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Ref<bevy::math::Mat3A>,
        rhs: Val<bevy::math::Mat3A>,
        max_abs_diff: f32,
    ) -> bool {
        let output: bool = bevy::math::Mat3A::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::Mat3A>,
        rhs: Val<bevy::math::Mat3A>,
    ) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Add<
            bevy::math::Mat3A,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Adds two 3x3 matrices.
    fn add_mat3(
        _self: Ref<bevy::math::Mat3A>,
        rhs: Ref<bevy::math::Mat3A>,
    ) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::add_mat3(&_self, &rhs)
            .into();
        output
    }
    fn as_dmat3(_self: Ref<bevy::math::Mat3A>) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::Mat3A::as_dmat3(&_self).into();
        output
    }
    fn clone(_self: Ref<bevy::math::Mat3A>) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the matrix column for the given `index`.
    ///  # Panics
    ///  Panics if `index` is greater than 2.
    fn col(_self: Ref<bevy::math::Mat3A>, index: usize) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Mat3A::col(&_self, index)
            .into();
        output
    }
    ///  Returns the determinant of `self`.
    fn determinant(_self: Ref<bevy::math::Mat3A>) -> f32 {
        let output: f32 = bevy::math::Mat3A::determinant(&_self).into();
        output
    }
    fn div(_self: Val<bevy::math::Mat3A>, rhs: f32) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Div<
            f32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Divides a 3x3 matrix by a scalar.
    fn div_scalar(_self: Ref<bevy::math::Mat3A>, rhs: f32) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::div_scalar(&_self, rhs)
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::Mat3A>, rhs: Ref<bevy::math::Mat3A>) -> bool {
        let output: bool = <bevy::math::Mat3A as std::cmp::PartialEq<
            bevy::math::Mat3A,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 2D rotation `angle` (in
    ///  radians).
    ///  The resulting matrix can be used to transform 2D points and vectors. See
    ///  [`Self::transform_point2()`] and [`Self::transform_vector2()`].
    fn from_angle(angle: f32) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_angle(angle).into();
        output
    }
    ///  Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in
    ///  radians).
    ///  # Panics
    ///  Will panic if `axis` is not normalized when `glam_assert` is enabled.
    fn from_axis_angle(
        axis: Val<bevy::math::Vec3>,
        angle: f32,
    ) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_axis_angle(
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    ///  Creates a 3x3 matrix from three column vectors.
    fn from_cols(
        x_axis: Val<bevy::math::Vec3A>,
        y_axis: Val<bevy::math::Vec3A>,
        z_axis: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
                z_axis.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.
    fn from_diagonal(diagonal: Val<bevy::math::Vec3>) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_diagonal(
                diagonal.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in
    ///  radians).
    fn from_euler(
        order: Val<bevy::math::EulerRot>,
        a: f32,
        b: f32,
        c: f32,
    ) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_euler(
                order.into_inner(),
                a,
                b,
                c,
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 2x2 matrix.
    ///  The resulting matrix can be used to transform 2D points and vectors. See
    ///  [`Self::transform_point2()`] and [`Self::transform_vector2()`].
    fn from_mat2(m: Val<bevy::math::Mat2>) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_mat2(m.into_inner())
            .into();
        output
    }
    ///  Creates a 3x3 matrix from a 4x4 matrix, discarding the 4th row and column.
    fn from_mat4(m: Val<bevy::math::Mat4>) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_mat4(m.into_inner())
            .into();
        output
    }
    ///  Creates a 3x3 matrix from the minor of the given 4x4 matrix, discarding the `i`th column
    ///  and `j`th row.
    ///  # Panics
    ///  Panics if `i` or `j` is greater than 3.
    fn from_mat4_minor(
        m: Val<bevy::math::Mat4>,
        i: usize,
        j: usize,
    ) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_mat4_minor(
                m.into_inner(),
                i,
                j,
            )
            .into();
        output
    }
    ///  Creates a 3D rotation matrix from the given quaternion.
    ///  # Panics
    ///  Will panic if `rotation` is not normalized when `glam_assert` is enabled.
    fn from_quat(rotation: Val<bevy::math::Quat>) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_quat(
                rotation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 3D rotation matrix from `angle` (in radians) around the x axis.
    fn from_rotation_x(angle: f32) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_rotation_x(angle)
            .into();
        output
    }
    ///  Creates a 3D rotation matrix from `angle` (in radians) around the y axis.
    fn from_rotation_y(angle: f32) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_rotation_y(angle)
            .into();
        output
    }
    ///  Creates a 3D rotation matrix from `angle` (in radians) around the z axis.
    fn from_rotation_z(angle: f32) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_rotation_z(angle)
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given non-uniform 2D `scale`.
    ///  The resulting matrix can be used to transform 2D points and vectors. See
    ///  [`Self::transform_point2()`] and [`Self::transform_vector2()`].
    ///  # Panics
    ///  Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
    fn from_scale(scale: Val<bevy::math::Vec2>) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in
    ///  radians) and `translation`.
    ///  The resulting matrix can be used to transform 2D points and vectors. See
    ///  [`Self::transform_point2()`] and [`Self::transform_vector2()`].
    fn from_scale_angle_translation(
        scale: Val<bevy::math::Vec2>,
        angle: f32,
        translation: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_scale_angle_translation(
                scale.into_inner(),
                angle,
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 2D `translation`.
    ///  The resulting matrix can be used to transform 2D points and vectors. See
    ///  [`Self::transform_point2()`] and [`Self::transform_vector2()`].
    fn from_translation(translation: Val<bevy::math::Vec2>) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the inverse of `self`.
    ///  If the matrix is not invertible the returned matrix will be invalid.
    ///  # Panics
    ///  Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
    fn inverse(_self: Ref<bevy::math::Mat3A>) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::inverse(&_self).into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.
    ///  If any element is either `NaN`, positive or negative infinity, this will return `false`.
    fn is_finite(_self: Ref<bevy::math::Mat3A>) -> bool {
        let output: bool = bevy::math::Mat3A::is_finite(&_self).into();
        output
    }
    ///  Returns `true` if any elements are `NaN`.
    fn is_nan(_self: Ref<bevy::math::Mat3A>) -> bool {
        let output: bool = bevy::math::Mat3A::is_nan(&_self).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Mat3A>,
        rhs: Val<bevy::math::Affine2>,
    ) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Mul<
            bevy::math::Affine2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Mat3A>,
        rhs: Val<bevy::math::Mat3A>,
    ) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Mul<
            bevy::math::Mat3A,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Mat3A>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = <bevy::math::Mat3A as std::ops::Mul<
            bevy::math::Vec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Mat3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Mat3A as std::ops::Mul<
            bevy::math::Vec3A,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat3A>, rhs: f32) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Mul<
            f32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Multiplies two 3x3 matrices.
    fn mul_mat3(
        _self: Ref<bevy::math::Mat3A>,
        rhs: Ref<bevy::math::Mat3A>,
    ) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::mul_mat3(&_self, &rhs)
            .into();
        output
    }
    ///  Multiplies a 3x3 matrix by a scalar.
    fn mul_scalar(_self: Ref<bevy::math::Mat3A>, rhs: f32) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::mul_scalar(&_self, rhs)
            .into();
        output
    }
    ///  Transforms a 3D vector.
    fn mul_vec3(
        _self: Ref<bevy::math::Mat3A>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Mat3A::mul_vec3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Transforms a [`Vec3A`].
    fn mul_vec3a(
        _self: Ref<bevy::math::Mat3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Mat3A::mul_vec3a(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::Mat3A>) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the matrix row for the given `index`.
    ///  # Panics
    ///  Panics if `index` is greater than 2.
    fn row(_self: Ref<bevy::math::Mat3A>, index: usize) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Mat3A::row(&_self, index)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::Mat3A>,
        rhs: Val<bevy::math::Mat3A>,
    ) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Sub<
            bevy::math::Mat3A,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Subtracts two 3x3 matrices.
    fn sub_mat3(
        _self: Ref<bevy::math::Mat3A>,
        rhs: Ref<bevy::math::Mat3A>,
    ) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::sub_mat3(&_self, &rhs)
            .into();
        output
    }
    ///  Creates a `[f32; 9]` array storing data in column major order.
    ///  If you require data in row major order `transpose` the matrix first.
    fn to_cols_array(_self: Ref<bevy::math::Mat3A>) -> [f32; 9] {
        let output: [f32; 9] = bevy::math::Mat3A::to_cols_array(&_self).into();
        output
    }
    ///  Creates a `[[f32; 3]; 3]` 3D array storing data in column major order.
    ///  If you require data in row major order `transpose` the matrix first.
    fn to_cols_array_2d(_self: Ref<bevy::math::Mat3A>) -> [[f32; 3]; 3] {
        let output: [[f32; 3]; 3] = bevy::math::Mat3A::to_cols_array_2d(&_self).into();
        output
    }
    ///  Extract Euler angles with the given Euler rotation order.
    ///  Note if the input matrix contains scales, shears, or other non-rotation transformations then
    ///  the resulting Euler angles will be ill-defined.
    ///  # Panics
    ///  Will panic if any input matrix column is not normalized when `glam_assert` is enabled.
    fn to_euler(
        _self: Ref<bevy::math::Mat3A>,
        order: Val<bevy::math::EulerRot>,
    ) -> (f32, f32, f32) {
        let output: (f32, f32, f32) = bevy::math::Mat3A::to_euler(
                &_self,
                order.into_inner(),
            )
            .into();
        output
    }
    ///  Transforms the given 2D vector as a point.
    ///  This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.
    ///  This method assumes that `self` contains a valid affine transform.
    ///  # Panics
    ///  Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.
    fn transform_point2(
        _self: Ref<bevy::math::Mat3A>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Mat3A::transform_point2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Rotates the given 2D vector.
    ///  This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.
    ///  This method assumes that `self` contains a valid affine transform.
    ///  # Panics
    ///  Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.
    fn transform_vector2(
        _self: Ref<bevy::math::Mat3A>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Mat3A::transform_vector2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the transpose of `self`.
    fn transpose(_self: Ref<bevy::math::Mat3A>) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::transpose(&_self).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "mat_4_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::Mat4 {
    ///  Takes the absolute value of each element in `self`
    fn abs(_self: Ref<bevy::math::Mat4>) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::abs(&_self).into();
        output
    }
    ///  Returns true if the absolute difference of all elements between `self` and `rhs`
    ///  is less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two matrices contain similar elements. It works best
    ///  when comparing with a known value. The `max_abs_diff` that should be used used
    ///  depends on the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Ref<bevy::math::Mat4>,
        rhs: Val<bevy::math::Mat4>,
        max_abs_diff: f32,
    ) -> bool {
        let output: bool = bevy::math::Mat4::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::Mat4>,
        rhs: Val<bevy::math::Mat4>,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Add<
            bevy::math::Mat4,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Adds two 4x4 matrices.
    fn add_mat4(
        _self: Ref<bevy::math::Mat4>,
        rhs: Ref<bevy::math::Mat4>,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::add_mat4(&_self, &rhs)
            .into();
        output
    }
    fn as_dmat4(_self: Ref<bevy::math::Mat4>) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::Mat4::as_dmat4(&_self).into();
        output
    }
    fn clone(_self: Ref<bevy::math::Mat4>) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the matrix column for the given `index`.
    ///  # Panics
    ///  Panics if `index` is greater than 3.
    fn col(_self: Ref<bevy::math::Mat4>, index: usize) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Mat4::col(&_self, index).into();
        output
    }
    ///  Returns the determinant of `self`.
    fn determinant(_self: Ref<bevy::math::Mat4>) -> f32 {
        let output: f32 = bevy::math::Mat4::determinant(&_self).into();
        output
    }
    fn div(_self: Val<bevy::math::Mat4>, rhs: f32) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Div<
            f32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Divides a 4x4 matrix by a scalar.
    fn div_scalar(_self: Ref<bevy::math::Mat4>, rhs: f32) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::div_scalar(&_self, rhs)
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::Mat4>, rhs: Ref<bevy::math::Mat4>) -> bool {
        let output: bool = <bevy::math::Mat4 as std::cmp::PartialEq<
            bevy::math::Mat4,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    ///  Creates an affine transformation matrix containing a 3D rotation around a normalized
    ///  rotation `axis` of `angle` (in radians).
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    ///  # Panics
    ///  Will panic if `axis` is not normalized when `glam_assert` is enabled.
    fn from_axis_angle(
        axis: Val<bevy::math::Vec3>,
        angle: f32,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_axis_angle(
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    ///  Creates a 4x4 matrix from four column vectors.
    fn from_cols(
        x_axis: Val<bevy::math::Vec4>,
        y_axis: Val<bevy::math::Vec4>,
        z_axis: Val<bevy::math::Vec4>,
        w_axis: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
                z_axis.into_inner(),
                w_axis.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 4x4 matrix with its diagonal set to `diagonal` and all other entries set to 0.
    fn from_diagonal(diagonal: Val<bevy::math::Vec4>) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_diagonal(
                diagonal.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a affine transformation matrix containing a rotation from the given euler
    ///  rotation sequence and angles (in radians).
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    fn from_euler(
        order: Val<bevy::math::EulerRot>,
        a: f32,
        b: f32,
        c: f32,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_euler(
                order.into_inner(),
                a,
                b,
                c,
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 3x3 linear transformation
    ///  matrix.
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    fn from_mat3(m: Val<bevy::math::Mat3>) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_mat3(m.into_inner())
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 3x3 linear transformation
    ///  matrix.
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    fn from_mat3a(m: Val<bevy::math::Mat3A>) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_mat3a(m.into_inner())
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given `rotation` quaternion.
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    ///  # Panics
    ///  Will panic if `rotation` is not normalized when `glam_assert` is enabled.
    fn from_quat(rotation: Val<bevy::math::Quat>) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_quat(
                rotation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 3D `translation`.
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    ///  # Panics
    ///  Will panic if `rotation` is not normalized when `glam_assert` is enabled.
    fn from_rotation_translation(
        rotation: Val<bevy::math::Quat>,
        translation: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_rotation_translation(
                rotation.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix containing a 3D rotation around the x axis of
    ///  `angle` (in radians).
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    fn from_rotation_x(angle: f32) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_rotation_x(angle)
            .into();
        output
    }
    ///  Creates an affine transformation matrix containing a 3D rotation around the y axis of
    ///  `angle` (in radians).
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    fn from_rotation_y(angle: f32) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_rotation_y(angle)
            .into();
        output
    }
    ///  Creates an affine transformation matrix containing a 3D rotation around the z axis of
    ///  `angle` (in radians).
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    fn from_rotation_z(angle: f32) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_rotation_z(angle)
            .into();
        output
    }
    ///  Creates an affine transformation matrix containing the given 3D non-uniform `scale`.
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    ///  # Panics
    ///  Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
    fn from_scale(scale: Val<bevy::math::Vec3>) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 3D `scale`, `rotation` and
    ///  `translation`.
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    ///  # Panics
    ///  Will panic if `rotation` is not normalized when `glam_assert` is enabled.
    fn from_scale_rotation_translation(
        scale: Val<bevy::math::Vec3>,
        rotation: Val<bevy::math::Quat>,
        translation: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_scale_rotation_translation(
                scale.into_inner(),
                rotation.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 3D `translation`.
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    fn from_translation(translation: Val<bevy::math::Vec3>) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the inverse of `self`.
    ///  If the matrix is not invertible the returned matrix will be invalid.
    ///  # Panics
    ///  Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
    fn inverse(_self: Ref<bevy::math::Mat4>) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::inverse(&_self).into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.
    ///  If any element is either `NaN`, positive or negative infinity, this will return `false`.
    fn is_finite(_self: Ref<bevy::math::Mat4>) -> bool {
        let output: bool = bevy::math::Mat4::is_finite(&_self).into();
        output
    }
    ///  Returns `true` if any elements are `NaN`.
    fn is_nan(_self: Ref<bevy::math::Mat4>) -> bool {
        let output: bool = bevy::math::Mat4::is_nan(&_self).into();
        output
    }
    ///  Creates a left-handed view matrix using a camera position, an up direction, and a focal
    ///  point.
    ///  For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
    ///  # Panics
    ///  Will panic if `up` is not normalized when `glam_assert` is enabled.
    fn look_at_lh(
        eye: Val<bevy::math::Vec3>,
        center: Val<bevy::math::Vec3>,
        up: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::look_at_lh(
                eye.into_inner(),
                center.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a right-handed view matrix using a camera position, an up direction, and a focal
    ///  point.
    ///  For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
    ///  # Panics
    ///  Will panic if `up` is not normalized when `glam_assert` is enabled.
    fn look_at_rh(
        eye: Val<bevy::math::Vec3>,
        center: Val<bevy::math::Vec3>,
        up: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::look_at_rh(
                eye.into_inner(),
                center.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a left-handed view matrix using a camera position, an up direction, and a facing
    ///  direction.
    ///  For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
    fn look_to_lh(
        eye: Val<bevy::math::Vec3>,
        dir: Val<bevy::math::Vec3>,
        up: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::look_to_lh(
                eye.into_inner(),
                dir.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a right-handed view matrix using a camera position, an up direction, and a facing
    ///  direction.
    ///  For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
    fn look_to_rh(
        eye: Val<bevy::math::Vec3>,
        dir: Val<bevy::math::Vec3>,
        up: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::look_to_rh(
                eye.into_inner(),
                dir.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Mat4>,
        rhs: Val<bevy::math::Affine3A>,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Mul<
            bevy::math::Affine3A,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Mat4>,
        rhs: Val<bevy::math::Mat4>,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Mul<
            bevy::math::Mat4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Mat4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = <bevy::math::Mat4 as std::ops::Mul<
            bevy::math::Vec4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat4>, rhs: f32) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Mul<
            f32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Multiplies two 4x4 matrices.
    fn mul_mat4(
        _self: Ref<bevy::math::Mat4>,
        rhs: Ref<bevy::math::Mat4>,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::mul_mat4(&_self, &rhs)
            .into();
        output
    }
    ///  Multiplies a 4x4 matrix by a scalar.
    fn mul_scalar(_self: Ref<bevy::math::Mat4>, rhs: f32) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::mul_scalar(&_self, rhs)
            .into();
        output
    }
    ///  Transforms a 4D vector.
    fn mul_vec4(
        _self: Ref<bevy::math::Mat4>,
        rhs: Val<bevy::math::Vec4>,
    ) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Mat4::mul_vec4(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::Mat4>) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a left-handed orthographic projection matrix with `[0,1]` depth range.
    ///  Useful to map a left-handed coordinate system to the normalized device coordinates that WebGPU/Direct3D/Metal expect.
    fn orthographic_lh(
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::orthographic_lh(
                left,
                right,
                bottom,
                top,
                near,
                far,
            )
            .into();
        output
    }
    ///  Creates a right-handed orthographic projection matrix with `[0,1]` depth range.
    ///  Useful to map a right-handed coordinate system to the normalized device coordinates that WebGPU/Direct3D/Metal expect.
    fn orthographic_rh(
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::orthographic_rh(
                left,
                right,
                bottom,
                top,
                near,
                far,
            )
            .into();
        output
    }
    ///  Creates a right-handed orthographic projection matrix with `[-1,1]` depth
    ///  range.  This is the same as the OpenGL `glOrtho` function in OpenGL.
    ///  See
    ///  <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml>
    ///  Useful to map a right-handed coordinate system to the normalized device coordinates that OpenGL expects.
    fn orthographic_rh_gl(
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::orthographic_rh_gl(
                left,
                right,
                bottom,
                top,
                near,
                far,
            )
            .into();
        output
    }
    ///  Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
    ///  Like `perspective_lh`, but with an infinite value for `z_far`.
    ///  The result is that points near `z_near` are mapped to depth `0`, and as they move towards infinity the depth approaches `1`.
    ///  # Panics
    ///  Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
    ///  enabled.
    fn perspective_infinite_lh(
        fov_y_radians: f32,
        aspect_ratio: f32,
        z_near: f32,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_infinite_lh(
                fov_y_radians,
                aspect_ratio,
                z_near,
            )
            .into();
        output
    }
    ///  Creates an infinite reverse left-handed perspective projection matrix with `[0,1]` depth range.
    ///  Similar to `perspective_infinite_lh`, but maps `Z = z_near` to a depth of `1` and `Z = infinity` to a depth of `0`.
    ///  # Panics
    ///  Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
    fn perspective_infinite_reverse_lh(
        fov_y_radians: f32,
        aspect_ratio: f32,
        z_near: f32,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_infinite_reverse_lh(
                fov_y_radians,
                aspect_ratio,
                z_near,
            )
            .into();
        output
    }
    ///  Creates an infinite reverse right-handed perspective projection matrix with `[0,1]` depth range.
    ///  Similar to `perspective_infinite_rh`, but maps `Z = z_near` to a depth of `1` and `Z = infinity` to a depth of `0`.
    ///  # Panics
    ///  Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
    fn perspective_infinite_reverse_rh(
        fov_y_radians: f32,
        aspect_ratio: f32,
        z_near: f32,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_infinite_reverse_rh(
                fov_y_radians,
                aspect_ratio,
                z_near,
            )
            .into();
        output
    }
    ///  Creates an infinite right-handed perspective projection matrix with `[0,1]` depth range.
    ///  Like `perspective_rh`, but with an infinite value for `z_far`.
    ///  The result is that points near `z_near` are mapped to depth `0`, and as they move towards infinity the depth approaches `1`.
    ///  # Panics
    ///  Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
    ///  enabled.
    fn perspective_infinite_rh(
        fov_y_radians: f32,
        aspect_ratio: f32,
        z_near: f32,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_infinite_rh(
                fov_y_radians,
                aspect_ratio,
                z_near,
            )
            .into();
        output
    }
    ///  Creates a left-handed perspective projection matrix with `[0,1]` depth range.
    ///  Useful to map the standard left-handed coordinate system into what WebGPU/Metal/Direct3D expect.
    ///  # Panics
    ///  Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
    ///  enabled.
    fn perspective_lh(
        fov_y_radians: f32,
        aspect_ratio: f32,
        z_near: f32,
        z_far: f32,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_lh(
                fov_y_radians,
                aspect_ratio,
                z_near,
                z_far,
            )
            .into();
        output
    }
    ///  Creates a right-handed perspective projection matrix with `[0,1]` depth range.
    ///  Useful to map the standard right-handed coordinate system into what WebGPU/Metal/Direct3D expect.
    ///  # Panics
    ///  Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
    ///  enabled.
    fn perspective_rh(
        fov_y_radians: f32,
        aspect_ratio: f32,
        z_near: f32,
        z_far: f32,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_rh(
                fov_y_radians,
                aspect_ratio,
                z_near,
                z_far,
            )
            .into();
        output
    }
    ///  Creates a right-handed perspective projection matrix with `[-1,1]` depth range.
    ///  Useful to map the standard right-handed coordinate system into what OpenGL expects.
    ///  This is the same as the OpenGL `gluPerspective` function.
    ///  See <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml>
    fn perspective_rh_gl(
        fov_y_radians: f32,
        aspect_ratio: f32,
        z_near: f32,
        z_far: f32,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_rh_gl(
                fov_y_radians,
                aspect_ratio,
                z_near,
                z_far,
            )
            .into();
        output
    }
    ///  Transforms the given 3D vector as a point, applying perspective correction.
    ///  This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is `1.0`.
    ///  The perspective divide is performed meaning the resulting 3D vector is divided by `w`.
    ///  This method assumes that `self` contains a projective transform.
    fn project_point3(
        _self: Ref<bevy::math::Mat4>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Mat4::project_point3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Transforms the given [`Vec3A`] as a 3D point, applying perspective correction.
    ///  This is the equivalent of multiplying the [`Vec3A`] as a 4D vector where `w` is `1.0`.
    ///  The perspective divide is performed meaning the resulting 3D vector is divided by `w`.
    ///  This method assumes that `self` contains a projective transform.
    fn project_point3a(
        _self: Ref<bevy::math::Mat4>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Mat4::project_point3a(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the matrix row for the given `index`.
    ///  # Panics
    ///  Panics if `index` is greater than 3.
    fn row(_self: Ref<bevy::math::Mat4>, index: usize) -> Val<bevy::math::Vec4> {
        let output: Val<bevy::math::Vec4> = bevy::math::Mat4::row(&_self, index).into();
        output
    }
    fn sub(
        _self: Val<bevy::math::Mat4>,
        rhs: Val<bevy::math::Mat4>,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Sub<
            bevy::math::Mat4,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Subtracts two 4x4 matrices.
    fn sub_mat4(
        _self: Ref<bevy::math::Mat4>,
        rhs: Ref<bevy::math::Mat4>,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::sub_mat4(&_self, &rhs)
            .into();
        output
    }
    ///  Creates a `[f32; 16]` array storing data in column major order.
    ///  If you require data in row major order `transpose` the matrix first.
    fn to_cols_array(_self: Ref<bevy::math::Mat4>) -> [f32; 16] {
        let output: [f32; 16] = bevy::math::Mat4::to_cols_array(&_self).into();
        output
    }
    ///  Creates a `[[f32; 4]; 4]` 4D array storing data in column major order.
    ///  If you require data in row major order `transpose` the matrix first.
    fn to_cols_array_2d(_self: Ref<bevy::math::Mat4>) -> [[f32; 4]; 4] {
        let output: [[f32; 4]; 4] = bevy::math::Mat4::to_cols_array_2d(&_self).into();
        output
    }
    ///  Extract Euler angles with the given Euler rotation order.
    ///  Note if the upper 3x3 matrix contain scales, shears, or other non-rotation transformations
    ///  then the resulting Euler angles will be ill-defined.
    ///  # Panics
    ///  Will panic if any column of the upper 3x3 rotation matrix is not normalized when
    ///  `glam_assert` is enabled.
    fn to_euler(
        _self: Ref<bevy::math::Mat4>,
        order: Val<bevy::math::EulerRot>,
    ) -> (f32, f32, f32) {
        let output: (f32, f32, f32) = bevy::math::Mat4::to_euler(
                &_self,
                order.into_inner(),
            )
            .into();
        output
    }
    ///  Transforms the given 3D vector as a point.
    ///  This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
    ///  `1.0`.
    ///  This method assumes that `self` contains a valid affine transform. It does not perform
    ///  a perspective divide, if `self` contains a perspective transform, or if you are unsure,
    ///  the [`Self::project_point3()`] method should be used instead.
    ///  # Panics
    ///  Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
    fn transform_point3(
        _self: Ref<bevy::math::Mat4>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Mat4::transform_point3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Transforms the given [`Vec3A`] as 3D point.
    ///  This is the equivalent of multiplying the [`Vec3A`] as a 4D vector where `w` is `1.0`.
    fn transform_point3a(
        _self: Ref<bevy::math::Mat4>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Mat4::transform_point3a(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Transforms the give 3D vector as a direction.
    ///  This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
    ///  `0.0`.
    ///  This method assumes that `self` contains a valid affine transform.
    ///  # Panics
    ///  Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
    fn transform_vector3(
        _self: Ref<bevy::math::Mat4>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Mat4::transform_vector3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Transforms the give [`Vec3A`] as 3D vector.
    ///  This is the equivalent of multiplying the [`Vec3A`] as a 4D vector where `w` is `0.0`.
    fn transform_vector3a(
        _self: Ref<bevy::math::Mat4>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Mat4::transform_vector3a(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the transpose of `self`.
    fn transpose(_self: Ref<bevy::math::Mat4>) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::transpose(&_self).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "d_mat_2_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::DMat2 {
    ///  Takes the absolute value of each element in `self`
    fn abs(_self: Ref<bevy::math::DMat2>) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::abs(&_self).into();
        output
    }
    ///  Returns true if the absolute difference of all elements between `self` and `rhs`
    ///  is less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two matrices contain similar elements. It works best
    ///  when comparing with a known value. The `max_abs_diff` that should be used used
    ///  depends on the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Ref<bevy::math::DMat2>,
        rhs: Val<bevy::math::DMat2>,
        max_abs_diff: f64,
    ) -> bool {
        let output: bool = bevy::math::DMat2::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::DMat2>,
        rhs: Val<bevy::math::DMat2>,
    ) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as std::ops::Add<
            bevy::math::DMat2,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Adds two 2x2 matrices.
    fn add_mat2(
        _self: Ref<bevy::math::DMat2>,
        rhs: Ref<bevy::math::DMat2>,
    ) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::add_mat2(&_self, &rhs)
            .into();
        output
    }
    fn as_mat2(_self: Ref<bevy::math::DMat2>) -> Val<bevy::math::Mat2> {
        let output: Val<bevy::math::Mat2> = bevy::math::DMat2::as_mat2(&_self).into();
        output
    }
    fn clone(_self: Ref<bevy::math::DMat2>) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the matrix column for the given `index`.
    ///  # Panics
    ///  Panics if `index` is greater than 1.
    fn col(_self: Ref<bevy::math::DMat2>, index: usize) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DMat2::col(&_self, index)
            .into();
        output
    }
    ///  Returns the determinant of `self`.
    fn determinant(_self: Ref<bevy::math::DMat2>) -> f64 {
        let output: f64 = bevy::math::DMat2::determinant(&_self).into();
        output
    }
    fn div(_self: Val<bevy::math::DMat2>, rhs: f64) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as std::ops::Div<
            f64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Divides a 2x2 matrix by a scalar.
    fn div_scalar(_self: Ref<bevy::math::DMat2>, rhs: f64) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::div_scalar(&_self, rhs)
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::DMat2>, rhs: Ref<bevy::math::DMat2>) -> bool {
        let output: bool = <bevy::math::DMat2 as std::cmp::PartialEq<
            bevy::math::DMat2,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    ///  Creates a 2x2 matrix containing a rotation of `angle` (in radians).
    fn from_angle(angle: f64) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_angle(angle).into();
        output
    }
    ///  Creates a 2x2 matrix from two column vectors.
    fn from_cols(
        x_axis: Val<bevy::math::DVec2>,
        y_axis: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 2x2 matrix with its diagonal set to `diagonal` and all other entries set to 0.
    fn from_diagonal(diagonal: Val<bevy::math::DVec2>) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_diagonal(
                diagonal.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 2x2 matrix from a 3x3 matrix, discarding the 2nd row and column.
    fn from_mat3(m: Val<bevy::math::DMat3>) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_mat3(m.into_inner())
            .into();
        output
    }
    ///  Creates a 2x2 matrix from the minor of the given 3x3 matrix, discarding the `i`th column
    ///  and `j`th row.
    ///  # Panics
    ///  Panics if `i` or `j` is greater than 2.
    fn from_mat3_minor(
        m: Val<bevy::math::DMat3>,
        i: usize,
        j: usize,
    ) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_mat3_minor(
                m.into_inner(),
                i,
                j,
            )
            .into();
        output
    }
    ///  Creates a 2x2 matrix containing the combining non-uniform `scale` and rotation of
    ///  `angle` (in radians).
    fn from_scale_angle(
        scale: Val<bevy::math::DVec2>,
        angle: f64,
    ) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_scale_angle(
                scale.into_inner(),
                angle,
            )
            .into();
        output
    }
    ///  Returns the inverse of `self`.
    ///  If the matrix is not invertible the returned matrix will be invalid.
    ///  # Panics
    ///  Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
    fn inverse(_self: Ref<bevy::math::DMat2>) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::inverse(&_self).into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.
    ///  If any element is either `NaN`, positive or negative infinity, this will return `false`.
    fn is_finite(_self: Ref<bevy::math::DMat2>) -> bool {
        let output: bool = bevy::math::DMat2::is_finite(&_self).into();
        output
    }
    ///  Returns `true` if any elements are `NaN`.
    fn is_nan(_self: Ref<bevy::math::DMat2>) -> bool {
        let output: bool = bevy::math::DMat2::is_nan(&_self).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::DMat2>,
        rhs: Val<bevy::math::DMat2>,
    ) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as std::ops::Mul<
            bevy::math::DMat2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::DMat2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = <bevy::math::DMat2 as std::ops::Mul<
            bevy::math::DVec2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DMat2>, rhs: f64) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as std::ops::Mul<
            f64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Multiplies two 2x2 matrices.
    fn mul_mat2(
        _self: Ref<bevy::math::DMat2>,
        rhs: Ref<bevy::math::DMat2>,
    ) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::mul_mat2(&_self, &rhs)
            .into();
        output
    }
    ///  Multiplies a 2x2 matrix by a scalar.
    fn mul_scalar(_self: Ref<bevy::math::DMat2>, rhs: f64) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::mul_scalar(&_self, rhs)
            .into();
        output
    }
    ///  Transforms a 2D vector.
    fn mul_vec2(
        _self: Ref<bevy::math::DMat2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DMat2::mul_vec2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::DMat2>) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the matrix row for the given `index`.
    ///  # Panics
    ///  Panics if `index` is greater than 1.
    fn row(_self: Ref<bevy::math::DMat2>, index: usize) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DMat2::row(&_self, index)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::DMat2>,
        rhs: Val<bevy::math::DMat2>,
    ) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as std::ops::Sub<
            bevy::math::DMat2,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Subtracts two 2x2 matrices.
    fn sub_mat2(
        _self: Ref<bevy::math::DMat2>,
        rhs: Ref<bevy::math::DMat2>,
    ) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::sub_mat2(&_self, &rhs)
            .into();
        output
    }
    ///  Creates a `[f64; 4]` array storing data in column major order.
    ///  If you require data in row major order `transpose` the matrix first.
    fn to_cols_array(_self: Ref<bevy::math::DMat2>) -> [f64; 4] {
        let output: [f64; 4] = bevy::math::DMat2::to_cols_array(&_self).into();
        output
    }
    ///  Creates a `[[f64; 2]; 2]` 2D array storing data in column major order.
    ///  If you require data in row major order `transpose` the matrix first.
    fn to_cols_array_2d(_self: Ref<bevy::math::DMat2>) -> [[f64; 2]; 2] {
        let output: [[f64; 2]; 2] = bevy::math::DMat2::to_cols_array_2d(&_self).into();
        output
    }
    ///  Returns the transpose of `self`.
    fn transpose(_self: Ref<bevy::math::DMat2>) -> Val<bevy::math::DMat2> {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::transpose(&_self).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "d_mat_3_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::DMat3 {
    ///  Takes the absolute value of each element in `self`
    fn abs(_self: Ref<bevy::math::DMat3>) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::abs(&_self).into();
        output
    }
    ///  Returns true if the absolute difference of all elements between `self` and `rhs`
    ///  is less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two matrices contain similar elements. It works best
    ///  when comparing with a known value. The `max_abs_diff` that should be used used
    ///  depends on the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Ref<bevy::math::DMat3>,
        rhs: Val<bevy::math::DMat3>,
        max_abs_diff: f64,
    ) -> bool {
        let output: bool = bevy::math::DMat3::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::DMat3>,
        rhs: Val<bevy::math::DMat3>,
    ) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Add<
            bevy::math::DMat3,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Adds two 3x3 matrices.
    fn add_mat3(
        _self: Ref<bevy::math::DMat3>,
        rhs: Ref<bevy::math::DMat3>,
    ) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::add_mat3(&_self, &rhs)
            .into();
        output
    }
    fn as_mat3(_self: Ref<bevy::math::DMat3>) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = bevy::math::DMat3::as_mat3(&_self).into();
        output
    }
    fn clone(_self: Ref<bevy::math::DMat3>) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the matrix column for the given `index`.
    ///  # Panics
    ///  Panics if `index` is greater than 2.
    fn col(_self: Ref<bevy::math::DMat3>, index: usize) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DMat3::col(&_self, index)
            .into();
        output
    }
    ///  Returns the determinant of `self`.
    fn determinant(_self: Ref<bevy::math::DMat3>) -> f64 {
        let output: f64 = bevy::math::DMat3::determinant(&_self).into();
        output
    }
    fn div(_self: Val<bevy::math::DMat3>, rhs: f64) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Div<
            f64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Divides a 3x3 matrix by a scalar.
    fn div_scalar(_self: Ref<bevy::math::DMat3>, rhs: f64) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::div_scalar(&_self, rhs)
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::DMat3>, rhs: Ref<bevy::math::DMat3>) -> bool {
        let output: bool = <bevy::math::DMat3 as std::cmp::PartialEq<
            bevy::math::DMat3,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 2D rotation `angle` (in
    ///  radians).
    ///  The resulting matrix can be used to transform 2D points and vectors. See
    ///  [`Self::transform_point2()`] and [`Self::transform_vector2()`].
    fn from_angle(angle: f64) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_angle(angle).into();
        output
    }
    ///  Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in
    ///  radians).
    ///  # Panics
    ///  Will panic if `axis` is not normalized when `glam_assert` is enabled.
    fn from_axis_angle(
        axis: Val<bevy::math::DVec3>,
        angle: f64,
    ) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_axis_angle(
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    ///  Creates a 3x3 matrix from three column vectors.
    fn from_cols(
        x_axis: Val<bevy::math::DVec3>,
        y_axis: Val<bevy::math::DVec3>,
        z_axis: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
                z_axis.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.
    fn from_diagonal(diagonal: Val<bevy::math::DVec3>) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_diagonal(
                diagonal.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in
    ///  radians).
    fn from_euler(
        order: Val<bevy::math::EulerRot>,
        a: f64,
        b: f64,
        c: f64,
    ) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_euler(
                order.into_inner(),
                a,
                b,
                c,
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 2x2 matrix.
    ///  The resulting matrix can be used to transform 2D points and vectors. See
    ///  [`Self::transform_point2()`] and [`Self::transform_vector2()`].
    fn from_mat2(m: Val<bevy::math::DMat2>) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_mat2(m.into_inner())
            .into();
        output
    }
    ///  Creates a 3x3 matrix from a 4x4 matrix, discarding the 4th row and column.
    fn from_mat4(m: Val<bevy::math::DMat4>) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_mat4(m.into_inner())
            .into();
        output
    }
    ///  Creates a 3x3 matrix from the minor of the given 4x4 matrix, discarding the `i`th column
    ///  and `j`th row.
    ///  # Panics
    ///  Panics if `i` or `j` is greater than 3.
    fn from_mat4_minor(
        m: Val<bevy::math::DMat4>,
        i: usize,
        j: usize,
    ) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_mat4_minor(
                m.into_inner(),
                i,
                j,
            )
            .into();
        output
    }
    ///  Creates a 3D rotation matrix from the given quaternion.
    ///  # Panics
    ///  Will panic if `rotation` is not normalized when `glam_assert` is enabled.
    fn from_quat(rotation: Val<bevy::math::DQuat>) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_quat(
                rotation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 3D rotation matrix from `angle` (in radians) around the x axis.
    fn from_rotation_x(angle: f64) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_rotation_x(angle)
            .into();
        output
    }
    ///  Creates a 3D rotation matrix from `angle` (in radians) around the y axis.
    fn from_rotation_y(angle: f64) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_rotation_y(angle)
            .into();
        output
    }
    ///  Creates a 3D rotation matrix from `angle` (in radians) around the z axis.
    fn from_rotation_z(angle: f64) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_rotation_z(angle)
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given non-uniform 2D `scale`.
    ///  The resulting matrix can be used to transform 2D points and vectors. See
    ///  [`Self::transform_point2()`] and [`Self::transform_vector2()`].
    ///  # Panics
    ///  Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
    fn from_scale(scale: Val<bevy::math::DVec2>) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in
    ///  radians) and `translation`.
    ///  The resulting matrix can be used to transform 2D points and vectors. See
    ///  [`Self::transform_point2()`] and [`Self::transform_vector2()`].
    fn from_scale_angle_translation(
        scale: Val<bevy::math::DVec2>,
        angle: f64,
        translation: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_scale_angle_translation(
                scale.into_inner(),
                angle,
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 2D `translation`.
    ///  The resulting matrix can be used to transform 2D points and vectors. See
    ///  [`Self::transform_point2()`] and [`Self::transform_vector2()`].
    fn from_translation(translation: Val<bevy::math::DVec2>) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the inverse of `self`.
    ///  If the matrix is not invertible the returned matrix will be invalid.
    ///  # Panics
    ///  Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
    fn inverse(_self: Ref<bevy::math::DMat3>) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::inverse(&_self).into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.
    ///  If any element is either `NaN`, positive or negative infinity, this will return `false`.
    fn is_finite(_self: Ref<bevy::math::DMat3>) -> bool {
        let output: bool = bevy::math::DMat3::is_finite(&_self).into();
        output
    }
    ///  Returns `true` if any elements are `NaN`.
    fn is_nan(_self: Ref<bevy::math::DMat3>) -> bool {
        let output: bool = bevy::math::DMat3::is_nan(&_self).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::DMat3>,
        rhs: Val<bevy::math::DAffine2>,
    ) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Mul<
            bevy::math::DAffine2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::DMat3>,
        rhs: Val<bevy::math::DMat3>,
    ) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Mul<
            bevy::math::DMat3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::DMat3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DMat3 as std::ops::Mul<
            bevy::math::DVec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DMat3>, rhs: f64) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Mul<
            f64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Multiplies two 3x3 matrices.
    fn mul_mat3(
        _self: Ref<bevy::math::DMat3>,
        rhs: Ref<bevy::math::DMat3>,
    ) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::mul_mat3(&_self, &rhs)
            .into();
        output
    }
    ///  Multiplies a 3x3 matrix by a scalar.
    fn mul_scalar(_self: Ref<bevy::math::DMat3>, rhs: f64) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::mul_scalar(&_self, rhs)
            .into();
        output
    }
    ///  Transforms a 3D vector.
    fn mul_vec3(
        _self: Ref<bevy::math::DMat3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DMat3::mul_vec3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::DMat3>) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the matrix row for the given `index`.
    ///  # Panics
    ///  Panics if `index` is greater than 2.
    fn row(_self: Ref<bevy::math::DMat3>, index: usize) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DMat3::row(&_self, index)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::DMat3>,
        rhs: Val<bevy::math::DMat3>,
    ) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Sub<
            bevy::math::DMat3,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Subtracts two 3x3 matrices.
    fn sub_mat3(
        _self: Ref<bevy::math::DMat3>,
        rhs: Ref<bevy::math::DMat3>,
    ) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::sub_mat3(&_self, &rhs)
            .into();
        output
    }
    ///  Creates a `[f64; 9]` array storing data in column major order.
    ///  If you require data in row major order `transpose` the matrix first.
    fn to_cols_array(_self: Ref<bevy::math::DMat3>) -> [f64; 9] {
        let output: [f64; 9] = bevy::math::DMat3::to_cols_array(&_self).into();
        output
    }
    ///  Creates a `[[f64; 3]; 3]` 3D array storing data in column major order.
    ///  If you require data in row major order `transpose` the matrix first.
    fn to_cols_array_2d(_self: Ref<bevy::math::DMat3>) -> [[f64; 3]; 3] {
        let output: [[f64; 3]; 3] = bevy::math::DMat3::to_cols_array_2d(&_self).into();
        output
    }
    ///  Extract Euler angles with the given Euler rotation order.
    ///  Note if the input matrix contains scales, shears, or other non-rotation transformations then
    ///  the resulting Euler angles will be ill-defined.
    ///  # Panics
    ///  Will panic if any input matrix column is not normalized when `glam_assert` is enabled.
    fn to_euler(
        _self: Ref<bevy::math::DMat3>,
        order: Val<bevy::math::EulerRot>,
    ) -> (f64, f64, f64) {
        let output: (f64, f64, f64) = bevy::math::DMat3::to_euler(
                &_self,
                order.into_inner(),
            )
            .into();
        output
    }
    ///  Transforms the given 2D vector as a point.
    ///  This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.
    ///  This method assumes that `self` contains a valid affine transform.
    ///  # Panics
    ///  Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.
    fn transform_point2(
        _self: Ref<bevy::math::DMat3>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DMat3::transform_point2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Rotates the given 2D vector.
    ///  This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.
    ///  This method assumes that `self` contains a valid affine transform.
    ///  # Panics
    ///  Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.
    fn transform_vector2(
        _self: Ref<bevy::math::DMat3>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DMat3::transform_vector2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the transpose of `self`.
    fn transpose(_self: Ref<bevy::math::DMat3>) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::transpose(&_self).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "d_mat_4_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::DMat4 {
    ///  Takes the absolute value of each element in `self`
    fn abs(_self: Ref<bevy::math::DMat4>) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::abs(&_self).into();
        output
    }
    ///  Returns true if the absolute difference of all elements between `self` and `rhs`
    ///  is less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two matrices contain similar elements. It works best
    ///  when comparing with a known value. The `max_abs_diff` that should be used used
    ///  depends on the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Ref<bevy::math::DMat4>,
        rhs: Val<bevy::math::DMat4>,
        max_abs_diff: f64,
    ) -> bool {
        let output: bool = bevy::math::DMat4::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(
        _self: Val<bevy::math::DMat4>,
        rhs: Val<bevy::math::DMat4>,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Add<
            bevy::math::DMat4,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Adds two 4x4 matrices.
    fn add_mat4(
        _self: Ref<bevy::math::DMat4>,
        rhs: Ref<bevy::math::DMat4>,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::add_mat4(&_self, &rhs)
            .into();
        output
    }
    fn as_mat4(_self: Ref<bevy::math::DMat4>) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = bevy::math::DMat4::as_mat4(&_self).into();
        output
    }
    fn clone(_self: Ref<bevy::math::DMat4>) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the matrix column for the given `index`.
    ///  # Panics
    ///  Panics if `index` is greater than 3.
    fn col(_self: Ref<bevy::math::DMat4>, index: usize) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DMat4::col(&_self, index)
            .into();
        output
    }
    ///  Returns the determinant of `self`.
    fn determinant(_self: Ref<bevy::math::DMat4>) -> f64 {
        let output: f64 = bevy::math::DMat4::determinant(&_self).into();
        output
    }
    fn div(_self: Val<bevy::math::DMat4>, rhs: f64) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Div<
            f64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Divides a 4x4 matrix by a scalar.
    fn div_scalar(_self: Ref<bevy::math::DMat4>, rhs: f64) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::div_scalar(&_self, rhs)
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::DMat4>, rhs: Ref<bevy::math::DMat4>) -> bool {
        let output: bool = <bevy::math::DMat4 as std::cmp::PartialEq<
            bevy::math::DMat4,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    ///  Creates an affine transformation matrix containing a 3D rotation around a normalized
    ///  rotation `axis` of `angle` (in radians).
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    ///  # Panics
    ///  Will panic if `axis` is not normalized when `glam_assert` is enabled.
    fn from_axis_angle(
        axis: Val<bevy::math::DVec3>,
        angle: f64,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_axis_angle(
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    ///  Creates a 4x4 matrix from four column vectors.
    fn from_cols(
        x_axis: Val<bevy::math::DVec4>,
        y_axis: Val<bevy::math::DVec4>,
        z_axis: Val<bevy::math::DVec4>,
        w_axis: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
                z_axis.into_inner(),
                w_axis.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a 4x4 matrix with its diagonal set to `diagonal` and all other entries set to 0.
    fn from_diagonal(diagonal: Val<bevy::math::DVec4>) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_diagonal(
                diagonal.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a affine transformation matrix containing a rotation from the given euler
    ///  rotation sequence and angles (in radians).
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    fn from_euler(
        order: Val<bevy::math::EulerRot>,
        a: f64,
        b: f64,
        c: f64,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_euler(
                order.into_inner(),
                a,
                b,
                c,
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 3x3 linear transformation
    ///  matrix.
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    fn from_mat3(m: Val<bevy::math::DMat3>) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_mat3(m.into_inner())
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given `rotation` quaternion.
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    ///  # Panics
    ///  Will panic if `rotation` is not normalized when `glam_assert` is enabled.
    fn from_quat(rotation: Val<bevy::math::DQuat>) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_quat(
                rotation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 3D `translation`.
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    ///  # Panics
    ///  Will panic if `rotation` is not normalized when `glam_assert` is enabled.
    fn from_rotation_translation(
        rotation: Val<bevy::math::DQuat>,
        translation: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_rotation_translation(
                rotation.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix containing a 3D rotation around the x axis of
    ///  `angle` (in radians).
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    fn from_rotation_x(angle: f64) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_rotation_x(angle)
            .into();
        output
    }
    ///  Creates an affine transformation matrix containing a 3D rotation around the y axis of
    ///  `angle` (in radians).
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    fn from_rotation_y(angle: f64) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_rotation_y(angle)
            .into();
        output
    }
    ///  Creates an affine transformation matrix containing a 3D rotation around the z axis of
    ///  `angle` (in radians).
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    fn from_rotation_z(angle: f64) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_rotation_z(angle)
            .into();
        output
    }
    ///  Creates an affine transformation matrix containing the given 3D non-uniform `scale`.
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    ///  # Panics
    ///  Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
    fn from_scale(scale: Val<bevy::math::DVec3>) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 3D `scale`, `rotation` and
    ///  `translation`.
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    ///  # Panics
    ///  Will panic if `rotation` is not normalized when `glam_assert` is enabled.
    fn from_scale_rotation_translation(
        scale: Val<bevy::math::DVec3>,
        rotation: Val<bevy::math::DQuat>,
        translation: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_scale_rotation_translation(
                scale.into_inner(),
                rotation.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transformation matrix from the given 3D `translation`.
    ///  The resulting matrix can be used to transform 3D points and vectors. See
    ///  [`Self::transform_point3()`] and [`Self::transform_vector3()`].
    fn from_translation(translation: Val<bevy::math::DVec3>) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the inverse of `self`.
    ///  If the matrix is not invertible the returned matrix will be invalid.
    ///  # Panics
    ///  Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
    fn inverse(_self: Ref<bevy::math::DMat4>) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::inverse(&_self).into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.
    ///  If any element is either `NaN`, positive or negative infinity, this will return `false`.
    fn is_finite(_self: Ref<bevy::math::DMat4>) -> bool {
        let output: bool = bevy::math::DMat4::is_finite(&_self).into();
        output
    }
    ///  Returns `true` if any elements are `NaN`.
    fn is_nan(_self: Ref<bevy::math::DMat4>) -> bool {
        let output: bool = bevy::math::DMat4::is_nan(&_self).into();
        output
    }
    ///  Creates a left-handed view matrix using a camera position, an up direction, and a focal
    ///  point.
    ///  For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
    ///  # Panics
    ///  Will panic if `up` is not normalized when `glam_assert` is enabled.
    fn look_at_lh(
        eye: Val<bevy::math::DVec3>,
        center: Val<bevy::math::DVec3>,
        up: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::look_at_lh(
                eye.into_inner(),
                center.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a right-handed view matrix using a camera position, an up direction, and a focal
    ///  point.
    ///  For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
    ///  # Panics
    ///  Will panic if `up` is not normalized when `glam_assert` is enabled.
    fn look_at_rh(
        eye: Val<bevy::math::DVec3>,
        center: Val<bevy::math::DVec3>,
        up: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::look_at_rh(
                eye.into_inner(),
                center.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a left-handed view matrix using a camera position, an up direction, and a facing
    ///  direction.
    ///  For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
    fn look_to_lh(
        eye: Val<bevy::math::DVec3>,
        dir: Val<bevy::math::DVec3>,
        up: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::look_to_lh(
                eye.into_inner(),
                dir.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a right-handed view matrix using a camera position, an up direction, and a facing
    ///  direction.
    ///  For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
    fn look_to_rh(
        eye: Val<bevy::math::DVec3>,
        dir: Val<bevy::math::DVec3>,
        up: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::look_to_rh(
                eye.into_inner(),
                dir.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::DMat4>,
        rhs: Val<bevy::math::DAffine3>,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Mul<
            bevy::math::DAffine3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::DMat4>,
        rhs: Val<bevy::math::DMat4>,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Mul<
            bevy::math::DMat4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::DMat4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = <bevy::math::DMat4 as std::ops::Mul<
            bevy::math::DVec4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DMat4>, rhs: f64) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Mul<
            f64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Multiplies two 4x4 matrices.
    fn mul_mat4(
        _self: Ref<bevy::math::DMat4>,
        rhs: Ref<bevy::math::DMat4>,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::mul_mat4(&_self, &rhs)
            .into();
        output
    }
    ///  Multiplies a 4x4 matrix by a scalar.
    fn mul_scalar(_self: Ref<bevy::math::DMat4>, rhs: f64) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::mul_scalar(&_self, rhs)
            .into();
        output
    }
    ///  Transforms a 4D vector.
    fn mul_vec4(
        _self: Ref<bevy::math::DMat4>,
        rhs: Val<bevy::math::DVec4>,
    ) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DMat4::mul_vec4(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::DMat4>) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a left-handed orthographic projection matrix with `[0,1]` depth range.
    ///  Useful to map a left-handed coordinate system to the normalized device coordinates that WebGPU/Direct3D/Metal expect.
    fn orthographic_lh(
        left: f64,
        right: f64,
        bottom: f64,
        top: f64,
        near: f64,
        far: f64,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::orthographic_lh(
                left,
                right,
                bottom,
                top,
                near,
                far,
            )
            .into();
        output
    }
    ///  Creates a right-handed orthographic projection matrix with `[0,1]` depth range.
    ///  Useful to map a right-handed coordinate system to the normalized device coordinates that WebGPU/Direct3D/Metal expect.
    fn orthographic_rh(
        left: f64,
        right: f64,
        bottom: f64,
        top: f64,
        near: f64,
        far: f64,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::orthographic_rh(
                left,
                right,
                bottom,
                top,
                near,
                far,
            )
            .into();
        output
    }
    ///  Creates a right-handed orthographic projection matrix with `[-1,1]` depth
    ///  range.  This is the same as the OpenGL `glOrtho` function in OpenGL.
    ///  See
    ///  <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml>
    ///  Useful to map a right-handed coordinate system to the normalized device coordinates that OpenGL expects.
    fn orthographic_rh_gl(
        left: f64,
        right: f64,
        bottom: f64,
        top: f64,
        near: f64,
        far: f64,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::orthographic_rh_gl(
                left,
                right,
                bottom,
                top,
                near,
                far,
            )
            .into();
        output
    }
    ///  Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
    ///  Like `perspective_lh`, but with an infinite value for `z_far`.
    ///  The result is that points near `z_near` are mapped to depth `0`, and as they move towards infinity the depth approaches `1`.
    ///  # Panics
    ///  Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
    ///  enabled.
    fn perspective_infinite_lh(
        fov_y_radians: f64,
        aspect_ratio: f64,
        z_near: f64,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_infinite_lh(
                fov_y_radians,
                aspect_ratio,
                z_near,
            )
            .into();
        output
    }
    ///  Creates an infinite reverse left-handed perspective projection matrix with `[0,1]` depth range.
    ///  Similar to `perspective_infinite_lh`, but maps `Z = z_near` to a depth of `1` and `Z = infinity` to a depth of `0`.
    ///  # Panics
    ///  Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
    fn perspective_infinite_reverse_lh(
        fov_y_radians: f64,
        aspect_ratio: f64,
        z_near: f64,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_infinite_reverse_lh(
                fov_y_radians,
                aspect_ratio,
                z_near,
            )
            .into();
        output
    }
    ///  Creates an infinite reverse right-handed perspective projection matrix with `[0,1]` depth range.
    ///  Similar to `perspective_infinite_rh`, but maps `Z = z_near` to a depth of `1` and `Z = infinity` to a depth of `0`.
    ///  # Panics
    ///  Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
    fn perspective_infinite_reverse_rh(
        fov_y_radians: f64,
        aspect_ratio: f64,
        z_near: f64,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_infinite_reverse_rh(
                fov_y_radians,
                aspect_ratio,
                z_near,
            )
            .into();
        output
    }
    ///  Creates an infinite right-handed perspective projection matrix with `[0,1]` depth range.
    ///  Like `perspective_rh`, but with an infinite value for `z_far`.
    ///  The result is that points near `z_near` are mapped to depth `0`, and as they move towards infinity the depth approaches `1`.
    ///  # Panics
    ///  Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
    ///  enabled.
    fn perspective_infinite_rh(
        fov_y_radians: f64,
        aspect_ratio: f64,
        z_near: f64,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_infinite_rh(
                fov_y_radians,
                aspect_ratio,
                z_near,
            )
            .into();
        output
    }
    ///  Creates a left-handed perspective projection matrix with `[0,1]` depth range.
    ///  Useful to map the standard left-handed coordinate system into what WebGPU/Metal/Direct3D expect.
    ///  # Panics
    ///  Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
    ///  enabled.
    fn perspective_lh(
        fov_y_radians: f64,
        aspect_ratio: f64,
        z_near: f64,
        z_far: f64,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_lh(
                fov_y_radians,
                aspect_ratio,
                z_near,
                z_far,
            )
            .into();
        output
    }
    ///  Creates a right-handed perspective projection matrix with `[0,1]` depth range.
    ///  Useful to map the standard right-handed coordinate system into what WebGPU/Metal/Direct3D expect.
    ///  # Panics
    ///  Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
    ///  enabled.
    fn perspective_rh(
        fov_y_radians: f64,
        aspect_ratio: f64,
        z_near: f64,
        z_far: f64,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_rh(
                fov_y_radians,
                aspect_ratio,
                z_near,
                z_far,
            )
            .into();
        output
    }
    ///  Creates a right-handed perspective projection matrix with `[-1,1]` depth range.
    ///  Useful to map the standard right-handed coordinate system into what OpenGL expects.
    ///  This is the same as the OpenGL `gluPerspective` function.
    ///  See <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml>
    fn perspective_rh_gl(
        fov_y_radians: f64,
        aspect_ratio: f64,
        z_near: f64,
        z_far: f64,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_rh_gl(
                fov_y_radians,
                aspect_ratio,
                z_near,
                z_far,
            )
            .into();
        output
    }
    ///  Transforms the given 3D vector as a point, applying perspective correction.
    ///  This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is `1.0`.
    ///  The perspective divide is performed meaning the resulting 3D vector is divided by `w`.
    ///  This method assumes that `self` contains a projective transform.
    fn project_point3(
        _self: Ref<bevy::math::DMat4>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DMat4::project_point3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the matrix row for the given `index`.
    ///  # Panics
    ///  Panics if `index` is greater than 3.
    fn row(_self: Ref<bevy::math::DMat4>, index: usize) -> Val<bevy::math::DVec4> {
        let output: Val<bevy::math::DVec4> = bevy::math::DMat4::row(&_self, index)
            .into();
        output
    }
    fn sub(
        _self: Val<bevy::math::DMat4>,
        rhs: Val<bevy::math::DMat4>,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Sub<
            bevy::math::DMat4,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Subtracts two 4x4 matrices.
    fn sub_mat4(
        _self: Ref<bevy::math::DMat4>,
        rhs: Ref<bevy::math::DMat4>,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::sub_mat4(&_self, &rhs)
            .into();
        output
    }
    ///  Creates a `[f64; 16]` array storing data in column major order.
    ///  If you require data in row major order `transpose` the matrix first.
    fn to_cols_array(_self: Ref<bevy::math::DMat4>) -> [f64; 16] {
        let output: [f64; 16] = bevy::math::DMat4::to_cols_array(&_self).into();
        output
    }
    ///  Creates a `[[f64; 4]; 4]` 4D array storing data in column major order.
    ///  If you require data in row major order `transpose` the matrix first.
    fn to_cols_array_2d(_self: Ref<bevy::math::DMat4>) -> [[f64; 4]; 4] {
        let output: [[f64; 4]; 4] = bevy::math::DMat4::to_cols_array_2d(&_self).into();
        output
    }
    ///  Extract Euler angles with the given Euler rotation order.
    ///  Note if the upper 3x3 matrix contain scales, shears, or other non-rotation transformations
    ///  then the resulting Euler angles will be ill-defined.
    ///  # Panics
    ///  Will panic if any column of the upper 3x3 rotation matrix is not normalized when
    ///  `glam_assert` is enabled.
    fn to_euler(
        _self: Ref<bevy::math::DMat4>,
        order: Val<bevy::math::EulerRot>,
    ) -> (f64, f64, f64) {
        let output: (f64, f64, f64) = bevy::math::DMat4::to_euler(
                &_self,
                order.into_inner(),
            )
            .into();
        output
    }
    ///  Transforms the given 3D vector as a point.
    ///  This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
    ///  `1.0`.
    ///  This method assumes that `self` contains a valid affine transform. It does not perform
    ///  a perspective divide, if `self` contains a perspective transform, or if you are unsure,
    ///  the [`Self::project_point3()`] method should be used instead.
    ///  # Panics
    ///  Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
    fn transform_point3(
        _self: Ref<bevy::math::DMat4>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DMat4::transform_point3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Transforms the give 3D vector as a direction.
    ///  This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
    ///  `0.0`.
    ///  This method assumes that `self` contains a valid affine transform.
    ///  # Panics
    ///  Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
    fn transform_vector3(
        _self: Ref<bevy::math::DMat4>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DMat4::transform_vector3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the transpose of `self`.
    fn transpose(_self: Ref<bevy::math::DMat4>) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::transpose(&_self).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "affine_2_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::Affine2 {
    ///  Returns true if the absolute difference of all elements between `self` and `rhs`
    ///  is less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two 3x4 matrices contain similar elements. It works
    ///  best when comparing with a known value. The `max_abs_diff` that should be used used
    ///  depends on the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Ref<bevy::math::Affine2>,
        rhs: Val<bevy::math::Affine2>,
        max_abs_diff: f32,
    ) -> bool {
        let output: bool = bevy::math::Affine2::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::Affine2>) -> Val<bevy::math::Affine2> {
        let output: Val<bevy::math::Affine2> = <bevy::math::Affine2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::Affine2>, rhs: Ref<bevy::math::Affine2>) -> bool {
        let output: bool = <bevy::math::Affine2 as std::cmp::PartialEq<
            bevy::math::Affine2,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    ///  Creates an affine transform from the given rotation `angle`.
    fn from_angle(angle: f32) -> Val<bevy::math::Affine2> {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_angle(angle)
            .into();
        output
    }
    ///  Creates an affine transform from the given 2D rotation `angle` (in radians) and
    ///  `translation`.
    ///  Equivalent to `Affine2::from_translation(translation) * Affine2::from_angle(angle)`
    fn from_angle_translation(
        angle: f32,
        translation: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Affine2> {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_angle_translation(
                angle,
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform from three column vectors.
    fn from_cols(
        x_axis: Val<bevy::math::Vec2>,
        y_axis: Val<bevy::math::Vec2>,
        z_axis: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Affine2> {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
                z_axis.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation)
    fn from_mat2(matrix2: Val<bevy::math::Mat2>) -> Val<bevy::math::Affine2> {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_mat2(
                matrix2.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation) and a
    ///  translation vector.
    ///  Equivalent to
    ///  `Affine2::from_translation(translation) * Affine2::from_mat2(mat2)`
    fn from_mat2_translation(
        matrix2: Val<bevy::math::Mat2>,
        translation: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Affine2> {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_mat2_translation(
                matrix2.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  The given `Mat3` must be an affine transform,
    fn from_mat3(m: Val<bevy::math::Mat3>) -> Val<bevy::math::Affine2> {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_mat3(
                m.into_inner(),
            )
            .into();
        output
    }
    ///  The given [`Mat3A`] must be an affine transform,
    fn from_mat3a(m: Val<bevy::math::Mat3A>) -> Val<bevy::math::Affine2> {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_mat3a(
                m.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform that changes scale.
    ///  Note that if any scale is zero the transform will be non-invertible.
    fn from_scale(scale: Val<bevy::math::Vec2>) -> Val<bevy::math::Affine2> {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform from the given 2D `scale`, rotation `angle` (in radians) and
    ///  `translation`.
    ///  Equivalent to `Affine2::from_translation(translation) *
    ///  Affine2::from_angle(angle) * Affine2::from_scale(scale)`
    fn from_scale_angle_translation(
        scale: Val<bevy::math::Vec2>,
        angle: f32,
        translation: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Affine2> {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_scale_angle_translation(
                scale.into_inner(),
                angle,
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transformation from the given 2D `translation`.
    fn from_translation(translation: Val<bevy::math::Vec2>) -> Val<bevy::math::Affine2> {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Return the inverse of this transform.
    ///  Note that if the transform is not invertible the result will be invalid.
    fn inverse(_self: Ref<bevy::math::Affine2>) -> Val<bevy::math::Affine2> {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::inverse(&_self)
            .into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.
    ///  If any element is either `NaN`, positive or negative infinity, this will return
    ///  `false`.
    fn is_finite(_self: Ref<bevy::math::Affine2>) -> bool {
        let output: bool = bevy::math::Affine2::is_finite(&_self).into();
        output
    }
    ///  Returns `true` if any elements are `NaN`.
    fn is_nan(_self: Ref<bevy::math::Affine2>) -> bool {
        let output: bool = bevy::math::Affine2::is_nan(&_self).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Affine2>,
        rhs: Val<bevy::math::Affine2>,
    ) -> Val<bevy::math::Affine2> {
        let output: Val<bevy::math::Affine2> = <bevy::math::Affine2 as std::ops::Mul<
            bevy::math::Affine2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Affine2>,
        rhs: Val<bevy::math::Mat3>,
    ) -> Val<bevy::math::Mat3> {
        let output: Val<bevy::math::Mat3> = <bevy::math::Affine2 as std::ops::Mul<
            bevy::math::Mat3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Affine2>,
        rhs: Val<bevy::math::Mat3A>,
    ) -> Val<bevy::math::Mat3A> {
        let output: Val<bevy::math::Mat3A> = <bevy::math::Affine2 as std::ops::Mul<
            bevy::math::Mat3A,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Creates a `[f32; 6]` array storing data in column major order.
    fn to_cols_array(_self: Ref<bevy::math::Affine2>) -> [f32; 6] {
        let output: [f32; 6] = bevy::math::Affine2::to_cols_array(&_self).into();
        output
    }
    ///  Creates a `[[f32; 2]; 3]` 2D array storing data in
    ///  column major order.
    ///  If you require data in row major order `transpose` the matrix first.
    fn to_cols_array_2d(_self: Ref<bevy::math::Affine2>) -> [[f32; 2]; 3] {
        let output: [[f32; 2]; 3] = bevy::math::Affine2::to_cols_array_2d(&_self).into();
        output
    }
    ///  Transforms the given 2D point, applying shear, scale, rotation and translation.
    fn transform_point2(
        _self: Ref<bevy::math::Affine2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Affine2::transform_point2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Transforms the given 2D vector, applying shear, scale and rotation (but NOT
    ///  translation).
    ///  To also apply translation, use [`Self::transform_point2()`] instead.
    fn transform_vector2(
        _self: Ref<bevy::math::Affine2>,
        rhs: Val<bevy::math::Vec2>,
    ) -> Val<bevy::math::Vec2> {
        let output: Val<bevy::math::Vec2> = bevy::math::Affine2::transform_vector2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "affine_3_a_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::Affine3A {
    ///  Returns true if the absolute difference of all elements between `self` and `rhs`
    ///  is less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two 3x4 matrices contain similar elements. It works
    ///  best when comparing with a known value. The `max_abs_diff` that should be used used
    ///  depends on the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Ref<bevy::math::Affine3A>,
        rhs: Val<bevy::math::Affine3A>,
        max_abs_diff: f32,
    ) -> bool {
        let output: bool = bevy::math::Affine3A::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::Affine3A>) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = <bevy::math::Affine3A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::Affine3A>, rhs: Ref<bevy::math::Affine3A>) -> bool {
        let output: bool = <bevy::math::Affine3A as std::cmp::PartialEq<
            bevy::math::Affine3A,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    ///  Creates an affine transform containing a 3D rotation around a normalized
    ///  rotation `axis` of `angle` (in radians).
    fn from_axis_angle(
        axis: Val<bevy::math::Vec3>,
        angle: f32,
    ) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_axis_angle(
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    ///  Creates an affine transform from three column vectors.
    fn from_cols(
        x_axis: Val<bevy::math::Vec3A>,
        y_axis: Val<bevy::math::Vec3A>,
        z_axis: Val<bevy::math::Vec3A>,
        w_axis: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
                z_axis.into_inner(),
                w_axis.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform from a 3x3 matrix (expressing scale, shear and
    ///  rotation)
    fn from_mat3(mat3: Val<bevy::math::Mat3>) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_mat3(
                mat3.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform from a 3x3 matrix (expressing scale, shear and rotation)
    ///  and a translation vector.
    ///  Equivalent to `Affine3A::from_translation(translation) * Affine3A::from_mat3(mat3)`
    fn from_mat3_translation(
        mat3: Val<bevy::math::Mat3>,
        translation: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_mat3_translation(
                mat3.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  The given `Mat4` must be an affine transform,
    ///  i.e. contain no perspective transform.
    fn from_mat4(m: Val<bevy::math::Mat4>) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_mat4(
                m.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform from the given `rotation` quaternion.
    fn from_quat(rotation: Val<bevy::math::Quat>) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_quat(
                rotation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform from the given 3D `rotation` and `translation`.
    ///  Equivalent to `Affine3A::from_translation(translation) * Affine3A::from_quat(rotation)`
    fn from_rotation_translation(
        rotation: Val<bevy::math::Quat>,
        translation: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_rotation_translation(
                rotation.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform containing a 3D rotation around the x axis of
    ///  `angle` (in radians).
    fn from_rotation_x(angle: f32) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_rotation_x(
                angle,
            )
            .into();
        output
    }
    ///  Creates an affine transform containing a 3D rotation around the y axis of
    ///  `angle` (in radians).
    fn from_rotation_y(angle: f32) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_rotation_y(
                angle,
            )
            .into();
        output
    }
    ///  Creates an affine transform containing a 3D rotation around the z axis of
    ///  `angle` (in radians).
    fn from_rotation_z(angle: f32) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_rotation_z(
                angle,
            )
            .into();
        output
    }
    ///  Creates an affine transform that changes scale.
    ///  Note that if any scale is zero the transform will be non-invertible.
    fn from_scale(scale: Val<bevy::math::Vec3>) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform from the given 3D `scale`, `rotation` and
    ///  `translation`.
    ///  Equivalent to `Affine3A::from_translation(translation) *
    ///  Affine3A::from_quat(rotation) * Affine3A::from_scale(scale)`
    fn from_scale_rotation_translation(
        scale: Val<bevy::math::Vec3>,
        rotation: Val<bevy::math::Quat>,
        translation: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_scale_rotation_translation(
                scale.into_inner(),
                rotation.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transformation from the given 3D `translation`.
    fn from_translation(
        translation: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Return the inverse of this transform.
    ///  Note that if the transform is not invertible the result will be invalid.
    fn inverse(_self: Ref<bevy::math::Affine3A>) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::inverse(&_self)
            .into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.
    ///  If any element is either `NaN`, positive or negative infinity, this will return
    ///  `false`.
    fn is_finite(_self: Ref<bevy::math::Affine3A>) -> bool {
        let output: bool = bevy::math::Affine3A::is_finite(&_self).into();
        output
    }
    ///  Returns `true` if any elements are `NaN`.
    fn is_nan(_self: Ref<bevy::math::Affine3A>) -> bool {
        let output: bool = bevy::math::Affine3A::is_nan(&_self).into();
        output
    }
    ///  Creates a left-handed view transform using a camera position, an up direction, and a focal
    ///  point.
    ///  For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
    ///  # Panics
    ///  Will panic if `up` is not normalized when `glam_assert` is enabled.
    fn look_at_lh(
        eye: Val<bevy::math::Vec3>,
        center: Val<bevy::math::Vec3>,
        up: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::look_at_lh(
                eye.into_inner(),
                center.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a right-handed view transform using a camera position, an up direction, and a focal
    ///  point.
    ///  For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
    ///  # Panics
    ///  Will panic if `up` is not normalized when `glam_assert` is enabled.
    fn look_at_rh(
        eye: Val<bevy::math::Vec3>,
        center: Val<bevy::math::Vec3>,
        up: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::look_at_rh(
                eye.into_inner(),
                center.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a left-handed view transform using a camera position, an up direction, and a facing
    ///  direction.
    ///  For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
    fn look_to_lh(
        eye: Val<bevy::math::Vec3>,
        dir: Val<bevy::math::Vec3>,
        up: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::look_to_lh(
                eye.into_inner(),
                dir.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a right-handed view transform using a camera position, an up direction, and a facing
    ///  direction.
    ///  For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
    fn look_to_rh(
        eye: Val<bevy::math::Vec3>,
        dir: Val<bevy::math::Vec3>,
        up: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::look_to_rh(
                eye.into_inner(),
                dir.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Affine3A>,
        rhs: Val<bevy::math::Affine3A>,
    ) -> Val<bevy::math::Affine3A> {
        let output: Val<bevy::math::Affine3A> = <bevy::math::Affine3A as std::ops::Mul<
            bevy::math::Affine3A,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::Affine3A>,
        rhs: Val<bevy::math::Mat4>,
    ) -> Val<bevy::math::Mat4> {
        let output: Val<bevy::math::Mat4> = <bevy::math::Affine3A as std::ops::Mul<
            bevy::math::Mat4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Creates a `[f32; 12]` array storing data in column major order.
    fn to_cols_array(_self: Ref<bevy::math::Affine3A>) -> [f32; 12] {
        let output: [f32; 12] = bevy::math::Affine3A::to_cols_array(&_self).into();
        output
    }
    ///  Creates a `[[f32; 3]; 4]` 3D array storing data in
    ///  column major order.
    ///  If you require data in row major order `transpose` the matrix first.
    fn to_cols_array_2d(_self: Ref<bevy::math::Affine3A>) -> [[f32; 3]; 4] {
        let output: [[f32; 3]; 4] = bevy::math::Affine3A::to_cols_array_2d(&_self)
            .into();
        output
    }
    ///  Transforms the given 3D points, applying shear, scale, rotation and translation.
    fn transform_point3(
        _self: Ref<bevy::math::Affine3A>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Affine3A::transform_point3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Transforms the given [`Vec3A`], applying shear, scale, rotation and translation.
    fn transform_point3a(
        _self: Ref<bevy::math::Affine3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Affine3A::transform_point3a(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Transforms the given 3D vector, applying shear, scale and rotation (but NOT
    ///  translation).
    ///  To also apply translation, use [`Self::transform_point3()`] instead.
    fn transform_vector3(
        _self: Ref<bevy::math::Affine3A>,
        rhs: Val<bevy::math::Vec3>,
    ) -> Val<bevy::math::Vec3> {
        let output: Val<bevy::math::Vec3> = bevy::math::Affine3A::transform_vector3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Transforms the given [`Vec3A`], applying shear, scale and rotation (but NOT
    ///  translation).
    ///  To also apply translation, use [`Self::transform_point3a()`] instead.
    fn transform_vector3a(
        _self: Ref<bevy::math::Affine3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) -> Val<bevy::math::Vec3A> {
        let output: Val<bevy::math::Vec3A> = bevy::math::Affine3A::transform_vector3a(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "d_affine_2_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::DAffine2 {
    ///  Returns true if the absolute difference of all elements between `self` and `rhs`
    ///  is less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two 3x4 matrices contain similar elements. It works
    ///  best when comparing with a known value. The `max_abs_diff` that should be used used
    ///  depends on the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Ref<bevy::math::DAffine2>,
        rhs: Val<bevy::math::DAffine2>,
        max_abs_diff: f64,
    ) -> bool {
        let output: bool = bevy::math::DAffine2::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::DAffine2>) -> Val<bevy::math::DAffine2> {
        let output: Val<bevy::math::DAffine2> = <bevy::math::DAffine2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::DAffine2>, rhs: Ref<bevy::math::DAffine2>) -> bool {
        let output: bool = <bevy::math::DAffine2 as std::cmp::PartialEq<
            bevy::math::DAffine2,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    ///  Creates an affine transform from the given rotation `angle`.
    fn from_angle(angle: f64) -> Val<bevy::math::DAffine2> {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_angle(angle)
            .into();
        output
    }
    ///  Creates an affine transform from the given 2D rotation `angle` (in radians) and
    ///  `translation`.
    ///  Equivalent to `DAffine2::from_translation(translation) * DAffine2::from_angle(angle)`
    fn from_angle_translation(
        angle: f64,
        translation: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DAffine2> {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_angle_translation(
                angle,
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform from three column vectors.
    fn from_cols(
        x_axis: Val<bevy::math::DVec2>,
        y_axis: Val<bevy::math::DVec2>,
        z_axis: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DAffine2> {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
                z_axis.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation)
    fn from_mat2(matrix2: Val<bevy::math::DMat2>) -> Val<bevy::math::DAffine2> {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_mat2(
                matrix2.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation) and a
    ///  translation vector.
    ///  Equivalent to
    ///  `DAffine2::from_translation(translation) * DAffine2::from_mat2(mat2)`
    fn from_mat2_translation(
        matrix2: Val<bevy::math::DMat2>,
        translation: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DAffine2> {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_mat2_translation(
                matrix2.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  The given `DMat3` must be an affine transform,
    fn from_mat3(m: Val<bevy::math::DMat3>) -> Val<bevy::math::DAffine2> {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_mat3(
                m.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform that changes scale.
    ///  Note that if any scale is zero the transform will be non-invertible.
    fn from_scale(scale: Val<bevy::math::DVec2>) -> Val<bevy::math::DAffine2> {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform from the given 2D `scale`, rotation `angle` (in radians) and
    ///  `translation`.
    ///  Equivalent to `DAffine2::from_translation(translation) *
    ///  DAffine2::from_angle(angle) * DAffine2::from_scale(scale)`
    fn from_scale_angle_translation(
        scale: Val<bevy::math::DVec2>,
        angle: f64,
        translation: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DAffine2> {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_scale_angle_translation(
                scale.into_inner(),
                angle,
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transformation from the given 2D `translation`.
    fn from_translation(
        translation: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DAffine2> {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Return the inverse of this transform.
    ///  Note that if the transform is not invertible the result will be invalid.
    fn inverse(_self: Ref<bevy::math::DAffine2>) -> Val<bevy::math::DAffine2> {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::inverse(&_self)
            .into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.
    ///  If any element is either `NaN`, positive or negative infinity, this will return
    ///  `false`.
    fn is_finite(_self: Ref<bevy::math::DAffine2>) -> bool {
        let output: bool = bevy::math::DAffine2::is_finite(&_self).into();
        output
    }
    ///  Returns `true` if any elements are `NaN`.
    fn is_nan(_self: Ref<bevy::math::DAffine2>) -> bool {
        let output: bool = bevy::math::DAffine2::is_nan(&_self).into();
        output
    }
    fn mul(
        _self: Val<bevy::math::DAffine2>,
        rhs: Val<bevy::math::DAffine2>,
    ) -> Val<bevy::math::DAffine2> {
        let output: Val<bevy::math::DAffine2> = <bevy::math::DAffine2 as std::ops::Mul<
            bevy::math::DAffine2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::DAffine2>,
        rhs: Val<bevy::math::DMat3>,
    ) -> Val<bevy::math::DMat3> {
        let output: Val<bevy::math::DMat3> = <bevy::math::DAffine2 as std::ops::Mul<
            bevy::math::DMat3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Creates a `[f64; 6]` array storing data in column major order.
    fn to_cols_array(_self: Ref<bevy::math::DAffine2>) -> [f64; 6] {
        let output: [f64; 6] = bevy::math::DAffine2::to_cols_array(&_self).into();
        output
    }
    ///  Creates a `[[f64; 2]; 3]` 2D array storing data in
    ///  column major order.
    ///  If you require data in row major order `transpose` the matrix first.
    fn to_cols_array_2d(_self: Ref<bevy::math::DAffine2>) -> [[f64; 2]; 3] {
        let output: [[f64; 2]; 3] = bevy::math::DAffine2::to_cols_array_2d(&_self)
            .into();
        output
    }
    ///  Transforms the given 2D point, applying shear, scale, rotation and translation.
    fn transform_point2(
        _self: Ref<bevy::math::DAffine2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DAffine2::transform_point2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Transforms the given 2D vector, applying shear, scale and rotation (but NOT
    ///  translation).
    ///  To also apply translation, use [`Self::transform_point2()`] instead.
    fn transform_vector2(
        _self: Ref<bevy::math::DAffine2>,
        rhs: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DVec2> {
        let output: Val<bevy::math::DVec2> = bevy::math::DAffine2::transform_vector2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "d_affine_3_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::DAffine3 {
    ///  Returns true if the absolute difference of all elements between `self` and `rhs`
    ///  is less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two 3x4 matrices contain similar elements. It works
    ///  best when comparing with a known value. The `max_abs_diff` that should be used used
    ///  depends on the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Ref<bevy::math::DAffine3>,
        rhs: Val<bevy::math::DAffine3>,
        max_abs_diff: f64,
    ) -> bool {
        let output: bool = bevy::math::DAffine3::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::DAffine3>) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = <bevy::math::DAffine3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::DAffine3>, rhs: Ref<bevy::math::DAffine3>) -> bool {
        let output: bool = <bevy::math::DAffine3 as std::cmp::PartialEq<
            bevy::math::DAffine3,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    ///  Creates an affine transform containing a 3D rotation around a normalized
    ///  rotation `axis` of `angle` (in radians).
    fn from_axis_angle(
        axis: Val<bevy::math::DVec3>,
        angle: f64,
    ) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_axis_angle(
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    ///  Creates an affine transform from three column vectors.
    fn from_cols(
        x_axis: Val<bevy::math::DVec3>,
        y_axis: Val<bevy::math::DVec3>,
        z_axis: Val<bevy::math::DVec3>,
        w_axis: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
                z_axis.into_inner(),
                w_axis.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform from a 3x3 matrix (expressing scale, shear and
    ///  rotation)
    fn from_mat3(mat3: Val<bevy::math::DMat3>) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_mat3(
                mat3.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform from a 3x3 matrix (expressing scale, shear and rotation)
    ///  and a translation vector.
    ///  Equivalent to `DAffine3::from_translation(translation) * DAffine3::from_mat3(mat3)`
    fn from_mat3_translation(
        mat3: Val<bevy::math::DMat3>,
        translation: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_mat3_translation(
                mat3.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  The given `DMat4` must be an affine transform,
    ///  i.e. contain no perspective transform.
    fn from_mat4(m: Val<bevy::math::DMat4>) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_mat4(
                m.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform from the given `rotation` quaternion.
    fn from_quat(rotation: Val<bevy::math::DQuat>) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_quat(
                rotation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform from the given 3D `rotation` and `translation`.
    ///  Equivalent to `DAffine3::from_translation(translation) * DAffine3::from_quat(rotation)`
    fn from_rotation_translation(
        rotation: Val<bevy::math::DQuat>,
        translation: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_rotation_translation(
                rotation.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform containing a 3D rotation around the x axis of
    ///  `angle` (in radians).
    fn from_rotation_x(angle: f64) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_rotation_x(
                angle,
            )
            .into();
        output
    }
    ///  Creates an affine transform containing a 3D rotation around the y axis of
    ///  `angle` (in radians).
    fn from_rotation_y(angle: f64) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_rotation_y(
                angle,
            )
            .into();
        output
    }
    ///  Creates an affine transform containing a 3D rotation around the z axis of
    ///  `angle` (in radians).
    fn from_rotation_z(angle: f64) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_rotation_z(
                angle,
            )
            .into();
        output
    }
    ///  Creates an affine transform that changes scale.
    ///  Note that if any scale is zero the transform will be non-invertible.
    fn from_scale(scale: Val<bevy::math::DVec3>) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transform from the given 3D `scale`, `rotation` and
    ///  `translation`.
    ///  Equivalent to `DAffine3::from_translation(translation) *
    ///  DAffine3::from_quat(rotation) * DAffine3::from_scale(scale)`
    fn from_scale_rotation_translation(
        scale: Val<bevy::math::DVec3>,
        rotation: Val<bevy::math::DQuat>,
        translation: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_scale_rotation_translation(
                scale.into_inner(),
                rotation.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Creates an affine transformation from the given 3D `translation`.
    fn from_translation(
        translation: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    ///  Return the inverse of this transform.
    ///  Note that if the transform is not invertible the result will be invalid.
    fn inverse(_self: Ref<bevy::math::DAffine3>) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::inverse(&_self)
            .into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.
    ///  If any element is either `NaN`, positive or negative infinity, this will return
    ///  `false`.
    fn is_finite(_self: Ref<bevy::math::DAffine3>) -> bool {
        let output: bool = bevy::math::DAffine3::is_finite(&_self).into();
        output
    }
    ///  Returns `true` if any elements are `NaN`.
    fn is_nan(_self: Ref<bevy::math::DAffine3>) -> bool {
        let output: bool = bevy::math::DAffine3::is_nan(&_self).into();
        output
    }
    ///  Creates a left-handed view transform using a camera position, an up direction, and a focal
    ///  point.
    ///  For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
    ///  # Panics
    ///  Will panic if `up` is not normalized when `glam_assert` is enabled.
    fn look_at_lh(
        eye: Val<bevy::math::DVec3>,
        center: Val<bevy::math::DVec3>,
        up: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::look_at_lh(
                eye.into_inner(),
                center.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a right-handed view transform using a camera position, an up direction, and a focal
    ///  point.
    ///  For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
    ///  # Panics
    ///  Will panic if `up` is not normalized when `glam_assert` is enabled.
    fn look_at_rh(
        eye: Val<bevy::math::DVec3>,
        center: Val<bevy::math::DVec3>,
        up: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::look_at_rh(
                eye.into_inner(),
                center.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a left-handed view transform using a camera position, an up direction, and a facing
    ///  direction.
    ///  For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
    fn look_to_lh(
        eye: Val<bevy::math::DVec3>,
        dir: Val<bevy::math::DVec3>,
        up: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::look_to_lh(
                eye.into_inner(),
                dir.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a right-handed view transform using a camera position, an up direction, and a facing
    ///  direction.
    ///  For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
    fn look_to_rh(
        eye: Val<bevy::math::DVec3>,
        dir: Val<bevy::math::DVec3>,
        up: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::look_to_rh(
                eye.into_inner(),
                dir.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::DAffine3>,
        rhs: Val<bevy::math::DAffine3>,
    ) -> Val<bevy::math::DAffine3> {
        let output: Val<bevy::math::DAffine3> = <bevy::math::DAffine3 as std::ops::Mul<
            bevy::math::DAffine3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(
        _self: Val<bevy::math::DAffine3>,
        rhs: Val<bevy::math::DMat4>,
    ) -> Val<bevy::math::DMat4> {
        let output: Val<bevy::math::DMat4> = <bevy::math::DAffine3 as std::ops::Mul<
            bevy::math::DMat4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Creates a `[f64; 12]` array storing data in column major order.
    fn to_cols_array(_self: Ref<bevy::math::DAffine3>) -> [f64; 12] {
        let output: [f64; 12] = bevy::math::DAffine3::to_cols_array(&_self).into();
        output
    }
    ///  Creates a `[[f64; 3]; 4]` 3D array storing data in
    ///  column major order.
    ///  If you require data in row major order `transpose` the matrix first.
    fn to_cols_array_2d(_self: Ref<bevy::math::DAffine3>) -> [[f64; 3]; 4] {
        let output: [[f64; 3]; 4] = bevy::math::DAffine3::to_cols_array_2d(&_self)
            .into();
        output
    }
    ///  Transforms the given 3D points, applying shear, scale, rotation and translation.
    fn transform_point3(
        _self: Ref<bevy::math::DAffine3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DAffine3::transform_point3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Transforms the given 3D vector, applying shear, scale and rotation (but NOT
    ///  translation).
    ///  To also apply translation, use [`Self::transform_point3()`] instead.
    fn transform_vector3(
        _self: Ref<bevy::math::DAffine3>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DAffine3::transform_vector3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "d_quat_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::DQuat {
    ///  Returns true if the absolute difference of all elements between `self` and `rhs`
    ///  is less than or equal to `max_abs_diff`.
    ///  This can be used to compare if two quaternions contain similar elements. It works
    ///  best when comparing with a known value. The `max_abs_diff` that should be used used
    ///  depends on the values being compared against.
    ///  For more see
    ///  [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
    fn abs_diff_eq(
        _self: Val<bevy::math::DQuat>,
        rhs: Val<bevy::math::DQuat>,
        max_abs_diff: f64,
    ) -> bool {
        let output: bool = bevy::math::DQuat::abs_diff_eq(
                _self.into_inner(),
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    ///  Adds two quaternions.
    ///  The sum is not guaranteed to be normalized.
    ///  Note that addition is not the same as combining the rotations represented by the
    ///  two quaternions! That corresponds to multiplication.
    fn add(
        _self: Val<bevy::math::DQuat>,
        rhs: Val<bevy::math::DQuat>,
    ) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as std::ops::Add<
            bevy::math::DQuat,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Returns the angle (in radians) for the minimal rotation
    ///  for transforming this quaternion into another.
    ///  Both quaternions must be normalized.
    ///  # Panics
    ///  Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
    fn angle_between(_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>) -> f64 {
        let output: f64 = bevy::math::DQuat::angle_between(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn as_quat(_self: Val<bevy::math::DQuat>) -> Val<bevy::math::Quat> {
        let output: Val<bevy::math::Quat> = bevy::math::DQuat::as_quat(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::DQuat>) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  Returns the quaternion conjugate of `self`. For a unit quaternion the
    ///  conjugate is also the inverse.
    fn conjugate(_self: Val<bevy::math::DQuat>) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::conjugate(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Divides a quaternion by a scalar value.
    ///  The quotient is not guaranteed to be normalized.
    fn div(_self: Val<bevy::math::DQuat>, rhs: f64) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as std::ops::Div<
            f64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Computes the dot product of `self` and `rhs`. The dot product is
    ///  equal to the cosine of the angle between two quaternion rotations.
    fn dot(_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>) -> f64 {
        let output: f64 = bevy::math::DQuat::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::DQuat>, rhs: Ref<bevy::math::DQuat>) -> bool {
        let output: bool = <bevy::math::DQuat as std::cmp::PartialEq<
            bevy::math::DQuat,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    ///  Creates a quaternion from a 3x3 rotation matrix inside a 3D affine transform.
    ///  Note if the input affine matrix contain scales, shears, or other non-rotation
    ///  transformations then the resulting quaternion will be ill-defined.
    ///  # Panics
    ///  Will panic if any input affine matrix column is not normalized when `glam_assert` is
    ///  enabled.
    fn from_affine3(a: Ref<bevy::math::DAffine3>) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_affine3(&a).into();
        output
    }
    ///  Creates a rotation quaternion from an array.
    ///  # Preconditions
    ///  This function does not check if the input is normalized, it is up to the user to
    ///  provide normalized input or to normalized the resulting quaternion.
    fn from_array(a: [f64; 4]) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_array(a).into();
        output
    }
    ///  Create a quaternion for a normalized rotation `axis` and `angle` (in radians).
    ///  The axis must be a unit vector.
    ///  # Panics
    ///  Will panic if `axis` is not normalized when `glam_assert` is enabled.
    fn from_axis_angle(
        axis: Val<bevy::math::DVec3>,
        angle: f64,
    ) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_axis_angle(
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    ///  Creates a quaternion from the given Euler rotation sequence and the angles (in radians).
    fn from_euler(
        euler: Val<bevy::math::EulerRot>,
        a: f64,
        b: f64,
        c: f64,
    ) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_euler(
                euler.into_inner(),
                a,
                b,
                c,
            )
            .into();
        output
    }
    ///  Creates a quaternion from a 3x3 rotation matrix.
    ///  Note if the input matrix contain scales, shears, or other non-rotation transformations then
    ///  the resulting quaternion will be ill-defined.
    ///  # Panics
    ///  Will panic if any input matrix column is not normalized when `glam_assert` is enabled.
    fn from_mat3(mat: Ref<bevy::math::DMat3>) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_mat3(&mat).into();
        output
    }
    ///  Creates a quaternion from the upper 3x3 rotation matrix inside a homogeneous 4x4 matrix.
    ///  Note if the upper 3x3 matrix contain scales, shears, or other non-rotation transformations
    ///  then the resulting quaternion will be ill-defined.
    ///  # Panics
    ///  Will panic if any column of the upper 3x3 rotation matrix is not normalized when
    ///  `glam_assert` is enabled.
    fn from_mat4(mat: Ref<bevy::math::DMat4>) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_mat4(&mat).into();
        output
    }
    ///  Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the
    ///  plane spanned by the two vectors.  Will rotate at most 180 degrees.
    ///  The inputs must be unit vectors.
    ///  `from_rotation_arc(from, to) * from ≈ to`.
    ///  For near-singular cases (from≈to and from≈-to) the current implementation
    ///  is only accurate to about 0.001 (for `f32`).
    ///  # Panics
    ///  Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
    fn from_rotation_arc(
        from: Val<bevy::math::DVec3>,
        to: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_arc(
                from.into_inner(),
                to.into_inner(),
            )
            .into();
        output
    }
    ///  Gets the minimal rotation for transforming `from` to `to`.  The resulting rotation is
    ///  around the z axis. Will rotate at most 180 degrees.
    ///  The inputs must be unit vectors.
    ///  `from_rotation_arc_2d(from, to) * from ≈ to`.
    ///  For near-singular cases (from≈to and from≈-to) the current implementation
    ///  is only accurate to about 0.001 (for `f32`).
    ///  # Panics
    ///  Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
    fn from_rotation_arc_2d(
        from: Val<bevy::math::DVec2>,
        to: Val<bevy::math::DVec2>,
    ) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_arc_2d(
                from.into_inner(),
                to.into_inner(),
            )
            .into();
        output
    }
    ///  Gets the minimal rotation for transforming `from` to either `to` or `-to`.  This means
    ///  that the resulting quaternion will rotate `from` so that it is colinear with `to`.
    ///  The rotation is in the plane spanned by the two vectors.  Will rotate at most 90
    ///  degrees.
    ///  The inputs must be unit vectors.
    ///  `to.dot(from_rotation_arc_colinear(from, to) * from).abs() ≈ 1`.
    ///  # Panics
    ///  Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
    fn from_rotation_arc_colinear(
        from: Val<bevy::math::DVec3>,
        to: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_arc_colinear(
                from.into_inner(),
                to.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a quaternion from the `angle` (in radians) around the x axis.
    fn from_rotation_x(angle: f64) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_x(angle)
            .into();
        output
    }
    ///  Creates a quaternion from the `angle` (in radians) around the y axis.
    fn from_rotation_y(angle: f64) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_y(angle)
            .into();
        output
    }
    ///  Creates a quaternion from the `angle` (in radians) around the z axis.
    fn from_rotation_z(angle: f64) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_z(angle)
            .into();
        output
    }
    ///  Create a quaternion that rotates `v.length()` radians around `v.normalize()`.
    ///  `from_scaled_axis(Vec3::ZERO)` results in the identity quaternion.
    fn from_scaled_axis(v: Val<bevy::math::DVec3>) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_scaled_axis(
                v.into_inner(),
            )
            .into();
        output
    }
    ///  Creates a new rotation quaternion from a 4D vector.
    ///  # Preconditions
    ///  This function does not check if the input is normalized, it is up to the user to
    ///  provide normalized input or to normalized the resulting quaternion.
    fn from_vec4(v: Val<bevy::math::DVec4>) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_vec4(v.into_inner())
            .into();
        output
    }
    ///  Creates a new rotation quaternion.
    ///  This should generally not be called manually unless you know what you are doing.
    ///  Use one of the other constructors instead such as `identity` or `from_axis_angle`.
    ///  `from_xyzw` is mostly used by unit tests and `serde` deserialization.
    ///  # Preconditions
    ///  This function does not check if the input is normalized, it is up to the user to
    ///  provide normalized input or to normalized the resulting quaternion.
    fn from_xyzw(x: f64, y: f64, z: f64, w: f64) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_xyzw(x, y, z, w)
            .into();
        output
    }
    ///  Returns the inverse of a normalized quaternion.
    ///  Typically quaternion inverse returns the conjugate of a normalized quaternion.
    ///  Because `self` is assumed to already be unit length this method *does not* normalize
    ///  before returning the conjugate.
    ///  # Panics
    ///  Will panic if `self` is not normalized when `glam_assert` is enabled.
    fn inverse(_self: Val<bevy::math::DQuat>) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::inverse(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `true` if, and only if, all elements are finite.
    ///  If any element is either `NaN`, positive or negative infinity, this will return `false`.
    fn is_finite(_self: Val<bevy::math::DQuat>) -> bool {
        let output: bool = bevy::math::DQuat::is_finite(_self.into_inner()).into();
        output
    }
    ///  Returns `true` if any elements are `NAN`.
    fn is_nan(_self: Val<bevy::math::DQuat>) -> bool {
        let output: bool = bevy::math::DQuat::is_nan(_self.into_inner()).into();
        output
    }
    fn is_near_identity(_self: Val<bevy::math::DQuat>) -> bool {
        let output: bool = bevy::math::DQuat::is_near_identity(_self.into_inner())
            .into();
        output
    }
    ///  Returns whether `self` of length `1.0` or not.
    ///  Uses a precision threshold of `1e-6`.
    fn is_normalized(_self: Val<bevy::math::DQuat>) -> bool {
        let output: bool = bevy::math::DQuat::is_normalized(_self.into_inner()).into();
        output
    }
    ///  Computes the length of `self`.
    fn length(_self: Val<bevy::math::DQuat>) -> f64 {
        let output: f64 = bevy::math::DQuat::length(_self.into_inner()).into();
        output
    }
    ///  Computes `1.0 / length()`.
    ///  For valid results, `self` must _not_ be of length zero.
    fn length_recip(_self: Val<bevy::math::DQuat>) -> f64 {
        let output: f64 = bevy::math::DQuat::length_recip(_self.into_inner()).into();
        output
    }
    ///  Computes the squared length of `self`.
    ///  This is generally faster than `length()` as it avoids a square
    ///  root operation.
    fn length_squared(_self: Val<bevy::math::DQuat>) -> f64 {
        let output: f64 = bevy::math::DQuat::length_squared(_self.into_inner()).into();
        output
    }
    ///  Performs a linear interpolation between `self` and `rhs` based on
    ///  the value `s`.
    ///  When `s` is `0.0`, the result will be equal to `self`.  When `s`
    ///  is `1.0`, the result will be equal to `rhs`.
    ///  # Panics
    ///  Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
    fn lerp(
        _self: Val<bevy::math::DQuat>,
        end: Val<bevy::math::DQuat>,
        s: f64,
    ) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::lerp(
                _self.into_inner(),
                end.into_inner(),
                s,
            )
            .into();
        output
    }
    ///  Multiplies two quaternions. If they each represent a rotation, the result will
    ///  represent the combined rotation.
    ///  Note that due to floating point rounding the result may not be perfectly
    ///  normalized.
    ///  # Panics
    ///  Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
    fn mul(
        _self: Val<bevy::math::DQuat>,
        rhs: Val<bevy::math::DQuat>,
    ) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as std::ops::Mul<
            bevy::math::DQuat,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Multiplies a quaternion and a 3D vector, returning the rotated vector.
    ///  # Panics
    ///  Will panic if `self` is not normalized when `glam_assert` is enabled.
    fn mul(
        _self: Val<bevy::math::DQuat>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = <bevy::math::DQuat as std::ops::Mul<
            bevy::math::DVec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  Multiplies a quaternion by a scalar value.
    ///  The product is not guaranteed to be normalized.
    fn mul(_self: Val<bevy::math::DQuat>, rhs: f64) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as std::ops::Mul<
            f64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    ///  Multiplies two quaternions. If they each represent a rotation, the result will
    ///  represent the combined rotation.
    ///  Note that due to floating point rounding the result may not be perfectly normalized.
    ///  # Panics
    ///  Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
    fn mul_quat(
        _self: Val<bevy::math::DQuat>,
        rhs: Val<bevy::math::DQuat>,
    ) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::mul_quat(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    ///  Multiplies a quaternion and a 3D vector, returning the rotated vector.
    ///  # Panics
    ///  Will panic if `self` is not normalized when `glam_assert` is enabled.
    fn mul_vec3(
        _self: Val<bevy::math::DQuat>,
        rhs: Val<bevy::math::DVec3>,
    ) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DQuat::mul_vec3(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::DQuat>) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns `self` normalized to length 1.0.
    ///  For valid results, `self` must _not_ be of length zero.
    ///  Panics
    ///  Will panic if `self` is zero length when `glam_assert` is enabled.
    fn normalize(_self: Val<bevy::math::DQuat>) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::normalize(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Rotates towards `rhs` up to `max_angle` (in radians).
    ///  When `max_angle` is `0.0`, the result will be equal to `self`. When `max_angle` is equal to
    ///  `self.angle_between(rhs)`, the result will be equal to `rhs`. If `max_angle` is negative,
    ///  rotates towards the exact opposite of `rhs`. Will not go past the target.
    ///  Both quaternions must be normalized.
    ///  # Panics
    ///  Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
    fn rotate_towards(
        _self: Ref<bevy::math::DQuat>,
        rhs: Val<bevy::math::DQuat>,
        max_angle: f64,
    ) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::rotate_towards(
                &_self,
                rhs.into_inner(),
                max_angle,
            )
            .into();
        output
    }
    ///  Performs a spherical linear interpolation between `self` and `end`
    ///  based on the value `s`.
    ///  When `s` is `0.0`, the result will be equal to `self`.  When `s`
    ///  is `1.0`, the result will be equal to `end`.
    ///  # Panics
    ///  Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
    fn slerp(
        _self: Val<bevy::math::DQuat>,
        end: Val<bevy::math::DQuat>,
        s: f64,
    ) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::slerp(
                _self.into_inner(),
                end.into_inner(),
                s,
            )
            .into();
        output
    }
    ///  Subtracts the `rhs` quaternion from `self`.
    ///  The difference is not guaranteed to be normalized.
    fn sub(
        _self: Val<bevy::math::DQuat>,
        rhs: Val<bevy::math::DQuat>,
    ) -> Val<bevy::math::DQuat> {
        let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as std::ops::Sub<
            bevy::math::DQuat,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    ///  `[x, y, z, w]`
    fn to_array(_self: Ref<bevy::math::DQuat>) -> [f64; 4] {
        let output: [f64; 4] = bevy::math::DQuat::to_array(&_self).into();
        output
    }
    ///  Returns the rotation angles for the given euler rotation sequence.
    fn to_euler(
        _self: Val<bevy::math::DQuat>,
        order: Val<bevy::math::EulerRot>,
    ) -> (f64, f64, f64) {
        let output: (f64, f64, f64) = bevy::math::DQuat::to_euler(
                _self.into_inner(),
                order.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the rotation axis scaled by the rotation in radians.
    fn to_scaled_axis(_self: Val<bevy::math::DQuat>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DQuat::to_scaled_axis(
                _self.into_inner(),
            )
            .into();
        output
    }
    ///  Returns the vector part of the quaternion.
    fn xyz(_self: Val<bevy::math::DQuat>) -> Val<bevy::math::DVec3> {
        let output: Val<bevy::math::DVec3> = bevy::math::DQuat::xyz(_self.into_inner())
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "euler_rot_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::EulerRot {
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::EulerRot>) -> () {
        let output: () = <bevy::math::EulerRot as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::EulerRot>) -> Val<bevy::math::EulerRot> {
        let output: Val<bevy::math::EulerRot> = <bevy::math::EulerRot as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::EulerRot>, other: Ref<bevy::math::EulerRot>) -> bool {
        let output: bool = <bevy::math::EulerRot as std::cmp::PartialEq<
            bevy::math::EulerRot,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(
    remote,
    name = "b_vec_3_a_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::BVec3A {
    ///  Returns true if all the elements are true, false otherwise.
    fn all(_self: Val<bevy::math::BVec3A>) -> bool {
        let output: bool = bevy::math::BVec3A::all(_self.into_inner()).into();
        output
    }
    ///  Returns true if any of the elements are true, false otherwise.
    fn any(_self: Val<bevy::math::BVec3A>) -> bool {
        let output: bool = bevy::math::BVec3A::any(_self.into_inner()).into();
        output
    }
    ///  Returns a bitmask with the lowest 3 bits set from the elements of `self`.
    ///  A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
    ///  into the first lowest bit, element `y` into the second, etc.
    fn bitmask(_self: Val<bevy::math::BVec3A>) -> u32 {
        let output: u32 = bevy::math::BVec3A::bitmask(_self.into_inner()).into();
        output
    }
    fn clone(_self: Ref<bevy::math::BVec3A>) -> Val<bevy::math::BVec3A> {
        let output: Val<bevy::math::BVec3A> = <bevy::math::BVec3A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::BVec3A>, rhs: Ref<bevy::math::BVec3A>) -> bool {
        let output: bool = <bevy::math::BVec3A as std::cmp::PartialEq<
            bevy::math::BVec3A,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    ///  Creates a new vector mask from a bool array.
    fn from_array(a: [bool; 3]) -> Val<bevy::math::BVec3A> {
        let output: Val<bevy::math::BVec3A> = bevy::math::BVec3A::from_array(a).into();
        output
    }
    ///  Creates a new vector mask.
    fn new(x: bool, y: bool, z: bool) -> Val<bevy::math::BVec3A> {
        let output: Val<bevy::math::BVec3A> = bevy::math::BVec3A::new(x, y, z).into();
        output
    }
    ///  Sets the element at `index`.
    ///  Panics if `index` is greater than 2.
    fn set(mut _self: Mut<bevy::math::BVec3A>, index: usize, value: bool) -> () {
        let output: () = bevy::math::BVec3A::set(&mut _self, index, value).into();
        output
    }
    ///  Creates a vector mask with all elements set to `v`.
    fn splat(v: bool) -> Val<bevy::math::BVec3A> {
        let output: Val<bevy::math::BVec3A> = bevy::math::BVec3A::splat(v).into();
        output
    }
    ///  Tests the value at `index`.
    ///  Panics if `index` is greater than 2.
    fn test(_self: Ref<bevy::math::BVec3A>, index: usize) -> bool {
        let output: bool = bevy::math::BVec3A::test(&_self, index).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "b_vec_4_a_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl bevy::math::BVec4A {
    ///  Returns true if all the elements are true, false otherwise.
    fn all(_self: Val<bevy::math::BVec4A>) -> bool {
        let output: bool = bevy::math::BVec4A::all(_self.into_inner()).into();
        output
    }
    ///  Returns true if any of the elements are true, false otherwise.
    fn any(_self: Val<bevy::math::BVec4A>) -> bool {
        let output: bool = bevy::math::BVec4A::any(_self.into_inner()).into();
        output
    }
    ///  Returns a bitmask with the lowest 4 bits set from the elements of `self`.
    ///  A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
    ///  into the first lowest bit, element `y` into the second, etc.
    fn bitmask(_self: Val<bevy::math::BVec4A>) -> u32 {
        let output: u32 = bevy::math::BVec4A::bitmask(_self.into_inner()).into();
        output
    }
    fn clone(_self: Ref<bevy::math::BVec4A>) -> Val<bevy::math::BVec4A> {
        let output: Val<bevy::math::BVec4A> = <bevy::math::BVec4A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::BVec4A>, rhs: Ref<bevy::math::BVec4A>) -> bool {
        let output: bool = <bevy::math::BVec4A as std::cmp::PartialEq<
            bevy::math::BVec4A,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    ///  Creates a new vector mask from a bool array.
    fn from_array(a: [bool; 4]) -> Val<bevy::math::BVec4A> {
        let output: Val<bevy::math::BVec4A> = bevy::math::BVec4A::from_array(a).into();
        output
    }
    ///  Creates a new vector mask.
    fn new(x: bool, y: bool, z: bool, w: bool) -> Val<bevy::math::BVec4A> {
        let output: Val<bevy::math::BVec4A> = bevy::math::BVec4A::new(x, y, z, w).into();
        output
    }
    ///  Sets the element at `index`.
    ///  Panics if `index` is greater than 3.
    fn set(mut _self: Mut<bevy::math::BVec4A>, index: usize, value: bool) -> () {
        let output: () = bevy::math::BVec4A::set(&mut _self, index, value).into();
        output
    }
    ///  Creates a vector mask with all elements set to `v`.
    fn splat(v: bool) -> Val<bevy::math::BVec4A> {
        let output: Val<bevy::math::BVec4A> = bevy::math::BVec4A::splat(v).into();
        output
    }
    ///  Tests the value at `index`.
    ///  Panics if `index` is greater than 3.
    fn test(_self: Ref<bevy::math::BVec4A>, index: usize) -> bool {
        let output: bool = bevy::math::BVec4A::test(&_self, index).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "smol_str_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl smol_str::SmolStr {
    fn clone(_self: Ref<smol_str::SmolStr>) -> Val<smol_str::SmolStr> {
        let output: Val<smol_str::SmolStr> = <smol_str::SmolStr as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<smol_str::SmolStr>, other: Ref<smol_str::SmolStr>) -> bool {
        let output: bool = <smol_str::SmolStr as std::cmp::PartialEq<
            smol_str::SmolStr,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn is_empty(_self: Ref<smol_str::SmolStr>) -> bool {
        let output: bool = smol_str::SmolStr::is_empty(&_self).into();
        output
    }
    fn is_heap_allocated(_self: Ref<smol_str::SmolStr>) -> bool {
        let output: bool = smol_str::SmolStr::is_heap_allocated(&_self).into();
        output
    }
    fn len(_self: Ref<smol_str::SmolStr>) -> usize {
        let output: usize = smol_str::SmolStr::len(&_self).into();
        output
    }
    fn to_string(_self: Ref<smol_str::SmolStr>) -> std::string::String {
        let output: std::string::String = smol_str::SmolStr::to_string(&_self).into();
        output
    }
}
#[script_bindings(
    remote,
    name = "uuid_functions",
    bms_core_path = "bevy_mod_scripting_core",
    generated
)]
impl uuid::Uuid {
    ///  Returns a 128bit value containing the value.
    ///  The bytes in the UUID will be packed directly into a `u128`.
    ///  # Examples
    ///  ```
    ///  # use uuid::Uuid;
    ///  # fn main() -> Result<(), uuid::Error> {
    ///  let uuid = Uuid::parse_str("a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8")?;
    ///  assert_eq!(
    ///      uuid.as_u128(),
    ///      0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8,
    ///  );
    ///  # Ok(())
    ///  # }
    ///  ```
    fn as_u128(_self: Ref<uuid::Uuid>) -> u128 {
        let output: u128 = uuid::Uuid::as_u128(&_self).into();
        output
    }
    ///  Returns two 64bit values containing the value.
    ///  The bytes in the UUID will be split into two `u64`.
    ///  The first u64 represents the 64 most significant bits,
    ///  the second one represents the 64 least significant.
    ///  # Examples
    ///  ```
    ///  # use uuid::Uuid;
    ///  # fn main() -> Result<(), uuid::Error> {
    ///  let uuid = Uuid::parse_str("a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8")?;
    ///  assert_eq!(
    ///      uuid.as_u64_pair(),
    ///      (0xa1a2a3a4b1b2c1c2, 0xd1d2d3d4d5d6d7d8),
    ///  );
    ///  # Ok(())
    ///  # }
    ///  ```
    fn as_u64_pair(_self: Ref<uuid::Uuid>) -> (u64, u64) {
        let output: (u64, u64) = uuid::Uuid::as_u64_pair(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<uuid::Uuid>) -> () {
        let output: () = <uuid::Uuid as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(_self: Ref<uuid::Uuid>) -> Val<uuid::Uuid> {
        let output: Val<uuid::Uuid> = <uuid::Uuid as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    ///  A buffer that can be used for `encode_...` calls, that is
    ///  guaranteed to be long enough for any of the format adapters.
    ///  # Examples
    ///  ```
    ///  # use uuid::Uuid;
    ///  let uuid = Uuid::nil();
    ///  assert_eq!(
    ///      uuid.simple().encode_lower(&mut Uuid::encode_buffer()),
    ///      "00000000000000000000000000000000"
    ///  );
    ///  assert_eq!(
    ///      uuid.hyphenated()
    ///          .encode_lower(&mut Uuid::encode_buffer()),
    ///      "00000000-0000-0000-0000-000000000000"
    ///  );
    ///  assert_eq!(
    ///      uuid.urn().encode_lower(&mut Uuid::encode_buffer()),
    ///      "urn:uuid:00000000-0000-0000-0000-000000000000"
    ///  );
    ///  ```
    fn encode_buffer() -> [u8; 45] {
        let output: [u8; 45] = uuid::Uuid::encode_buffer().into();
        output
    }
    fn eq(_self: Ref<uuid::Uuid>, other: Ref<uuid::Uuid>) -> bool {
        let output: bool = <uuid::Uuid as std::cmp::PartialEq<
            uuid::Uuid,
        >>::eq(&_self, &other)
            .into();
        output
    }
    ///  Creates a UUID using the supplied bytes.
    ///  # Examples
    ///  Basic usage:
    ///  ```
    ///  # fn main() -> Result<(), uuid::Error> {
    ///  # use uuid::Uuid;
    ///  let bytes = [
    ///      0xa1, 0xa2, 0xa3, 0xa4,
    ///      0xb1, 0xb2,
    ///      0xc1, 0xc2,
    ///      0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
    ///  ];
    ///  let uuid = Uuid::from_bytes(bytes);
    ///  assert_eq!(
    ///      uuid.hyphenated().to_string(),
    ///      "a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8"
    ///  );
    ///  # Ok(())
    ///  # }
    ///  ```
    fn from_bytes(bytes: [u8; 16]) -> Val<uuid::Uuid> {
        let output: Val<uuid::Uuid> = uuid::Uuid::from_bytes(bytes).into();
        output
    }
    ///  Creates a UUID using the supplied bytes in little endian order.
    ///  The individual fields encoded in the buffer will be flipped.
    ///  # Examples
    ///  Basic usage:
    ///  ```
    ///  # fn main() -> Result<(), uuid::Error> {
    ///  # use uuid::Uuid;
    ///  let bytes = [
    ///      0xa1, 0xa2, 0xa3, 0xa4,
    ///      0xb1, 0xb2,
    ///      0xc1, 0xc2,
    ///      0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
    ///  ];
    ///  let uuid = Uuid::from_bytes_le(bytes);
    ///  assert_eq!(
    ///      "a4a3a2a1-b2b1-c2c1-d1d2-d3d4d5d6d7d8",
    ///      uuid.hyphenated().to_string(),
    ///  );
    ///  # Ok(())
    ///  # }
    ///  ```
    fn from_bytes_le(b: [u8; 16]) -> Val<uuid::Uuid> {
        let output: Val<uuid::Uuid> = uuid::Uuid::from_bytes_le(b).into();
        output
    }
    ///  Creates a UUID from a 128bit value.
    ///  # Examples
    ///  Basic usage:
    ///  ```
    ///  # use uuid::Uuid;
    ///  let v = 0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8u128;
    ///  let uuid = Uuid::from_u128(v);
    ///  assert_eq!(
    ///      "a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8",
    ///      uuid.hyphenated().to_string(),
    ///  );
    ///  ```
    fn from_u128(v: u128) -> Val<uuid::Uuid> {
        let output: Val<uuid::Uuid> = uuid::Uuid::from_u128(v).into();
        output
    }
    ///  Creates a UUID from a 128bit value in little-endian order.
    ///  The entire value will be flipped to convert into big-endian order.
    ///  This is based on the endianness of the UUID, rather than the target
    ///  environment so bytes will be flipped on both big and little endian
    ///  machines.
    ///  # Examples
    ///  Basic usage:
    ///  ```
    ///  # use uuid::Uuid;
    ///  let v = 0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8u128;
    ///  let uuid = Uuid::from_u128_le(v);
    ///  assert_eq!(
    ///      "d8d7d6d5-d4d3-d2d1-c2c1-b2b1a4a3a2a1",
    ///      uuid.hyphenated().to_string(),
    ///  );
    ///  ```
    fn from_u128_le(v: u128) -> Val<uuid::Uuid> {
        let output: Val<uuid::Uuid> = uuid::Uuid::from_u128_le(v).into();
        output
    }
    ///  Creates a UUID from two 64bit values.
    ///  # Examples
    ///  Basic usage:
    ///  ```
    ///  # use uuid::Uuid;
    ///  let hi = 0xa1a2a3a4b1b2c1c2u64;
    ///  let lo = 0xd1d2d3d4d5d6d7d8u64;
    ///  let uuid = Uuid::from_u64_pair(hi, lo);
    ///  assert_eq!(
    ///      "a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8",
    ///      uuid.hyphenated().to_string(),
    ///  );
    ///  ```
    fn from_u64_pair(high_bits: u64, low_bits: u64) -> Val<uuid::Uuid> {
        let output: Val<uuid::Uuid> = uuid::Uuid::from_u64_pair(high_bits, low_bits)
            .into();
        output
    }
    ///  If the UUID is the correct version (v1, or v6) this will return the
    ///  node value as a 6-byte array. For other versions this will return `None`.
    fn get_node_id(
        _self: Ref<uuid::Uuid>,
    ) -> bevy::reflect::erased_serde::__private::serde::__private::Option<[u8; 6]> {
        let output: bevy::reflect::erased_serde::__private::serde::__private::Option<
            [u8; 6],
        > = uuid::Uuid::get_node_id(&_self).into();
        output
    }
    ///  Returns the version number of the UUID.
    ///  This represents the algorithm used to generate the value.
    ///  This method is the future-proof alternative to [`Uuid::get_version`].
    ///  # Examples
    ///  Basic usage:
    ///  ```
    ///  # use uuid::Uuid;
    ///  # fn main() -> Result<(), uuid::Error> {
    ///  let my_uuid = Uuid::parse_str("02f09a3f-1624-3b1d-8409-44eff7708208")?;
    ///  assert_eq!(3, my_uuid.get_version_num());
    ///  # Ok(())
    ///  # }
    ///  ```
    ///  # References
    ///  * [Version Field in RFC 9562](https://www.ietf.org/rfc/rfc9562.html#section-4.2)
    fn get_version_num(_self: Ref<uuid::Uuid>) -> usize {
        let output: usize = uuid::Uuid::get_version_num(&_self).into();
        output
    }
    ///  Consumes self and returns the underlying byte value of the UUID.
    ///  # Examples
    ///  ```
    ///  # use uuid::Uuid;
    ///  let bytes = [
    ///      0xa1, 0xa2, 0xa3, 0xa4,
    ///      0xb1, 0xb2,
    ///      0xc1, 0xc2,
    ///      0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
    ///  ];
    ///  let uuid = Uuid::from_bytes(bytes);
    ///  assert_eq!(bytes, uuid.into_bytes());
    ///  ```
    fn into_bytes(_self: Val<uuid::Uuid>) -> [u8; 16] {
        let output: [u8; 16] = uuid::Uuid::into_bytes(_self.into_inner()).into();
        output
    }
    ///  Tests if the UUID is max (all ones).
    fn is_max(_self: Ref<uuid::Uuid>) -> bool {
        let output: bool = uuid::Uuid::is_max(&_self).into();
        output
    }
    ///  Tests if the UUID is nil (all zeros).
    fn is_nil(_self: Ref<uuid::Uuid>) -> bool {
        let output: bool = uuid::Uuid::is_nil(&_self).into();
        output
    }
    ///  The 'max UUID' (all ones).
    ///  The max UUID is a special form of UUID that is specified to have all
    ///  128 bits set to one.
    ///  # References
    ///  * [Max UUID in RFC 9562](https://www.ietf.org/rfc/rfc9562.html#section-5.10)
    ///  # Examples
    ///  Basic usage:
    ///  ```
    ///  # use uuid::Uuid;
    ///  let uuid = Uuid::max();
    ///  assert_eq!(
    ///      "ffffffff-ffff-ffff-ffff-ffffffffffff",
    ///      uuid.hyphenated().to_string(),
    ///  );
    ///  ```
    fn max() -> Val<uuid::Uuid> {
        let output: Val<uuid::Uuid> = uuid::Uuid::max().into();
        output
    }
    ///  Creates a random UUID.
    ///  This uses the [`getrandom`] crate to utilise the operating system's RNG
    ///  as the source of random numbers. If you'd like to use a custom
    ///  generator, don't use this method: generate random bytes using your
    ///  custom generator and pass them to the
    ///  [`uuid::Builder::from_random_bytes`][from_random_bytes] function
    ///  instead.
    ///  Note that usage of this method requires the `v4` feature of this crate
    ///  to be enabled.
    ///  # Examples
    ///  Basic usage:
    ///  ```
    ///  # use uuid::{Uuid, Version};
    ///  let uuid = Uuid::new_v4();
    ///  assert_eq!(Some(Version::Random), uuid.get_version());
    ///  ```
    ///  # References
    ///  * [UUID Version 4 in RFC 9562](https://www.ietf.org/rfc/rfc9562.html#section-5.4)
    ///  [`getrandom`]: https://crates.io/crates/getrandom
    ///  [from_random_bytes]: struct.Builder.html#method.from_random_bytes
    fn new_v4() -> Val<uuid::Uuid> {
        let output: Val<uuid::Uuid> = uuid::Uuid::new_v4().into();
        output
    }
    ///  The 'nil UUID' (all zeros).
    ///  The nil UUID is a special form of UUID that is specified to have all
    ///  128 bits set to zero.
    ///  # References
    ///  * [Nil UUID in RFC 9562](https://www.ietf.org/rfc/rfc9562.html#section-5.9)
    ///  # Examples
    ///  Basic usage:
    ///  ```
    ///  # use uuid::Uuid;
    ///  let uuid = Uuid::nil();
    ///  assert_eq!(
    ///      "00000000-0000-0000-0000-000000000000",
    ///      uuid.hyphenated().to_string(),
    ///  );
    ///  ```
    fn nil() -> Val<uuid::Uuid> {
        let output: Val<uuid::Uuid> = uuid::Uuid::nil().into();
        output
    }
    ///  Returns the bytes of the UUID in little-endian order.
    ///  The bytes will be flipped to convert into little-endian order. This is
    ///  based on the endianness of the UUID, rather than the target environment
    ///  so bytes will be flipped on both big and little endian machines.
    ///  # Examples
    ///  ```
    ///  use uuid::Uuid;
    ///  # fn main() -> Result<(), uuid::Error> {
    ///  let uuid = Uuid::parse_str("a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8")?;
    ///  assert_eq!(
    ///      uuid.to_bytes_le(),
    ///      ([
    ///          0xa4, 0xa3, 0xa2, 0xa1, 0xb2, 0xb1, 0xc2, 0xc1, 0xd1, 0xd2,
    ///          0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8
    ///      ])
    ///  );
    ///  # Ok(())
    ///  # }
    ///  ```
    fn to_bytes_le(_self: Ref<uuid::Uuid>) -> [u8; 16] {
        let output: [u8; 16] = uuid::Uuid::to_bytes_le(&_self).into();
        output
    }
    ///  Returns a 128bit little-endian value containing the value.
    ///  The bytes in the `u128` will be flipped to convert into big-endian
    ///  order. This is based on the endianness of the UUID, rather than the
    ///  target environment so bytes will be flipped on both big and little
    ///  endian machines.
    ///  Note that this will produce a different result than
    ///  [`Uuid::to_fields_le`], because the entire UUID is reversed, rather
    ///  than reversing the individual fields in-place.
    ///  # Examples
    ///  ```
    ///  # use uuid::Uuid;
    ///  # fn main() -> Result<(), uuid::Error> {
    ///  let uuid = Uuid::parse_str("a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8")?;
    ///  assert_eq!(
    ///      uuid.to_u128_le(),
    ///      0xd8d7d6d5d4d3d2d1c2c1b2b1a4a3a2a1,
    ///  );
    ///  # Ok(())
    ///  # }
    ///  ```
    fn to_u128_le(_self: Ref<uuid::Uuid>) -> u128 {
        let output: u128 = uuid::Uuid::to_u128_le(&_self).into();
        output
    }
}
impl ::bevy::app::Plugin for BevyReflectScriptingPlugin {
    fn build(&self, app: &mut ::bevy::prelude::App) {
        let mut world = app.world_mut();
        register_atomic_bool_functions(&mut world);
        register_atomic_i_16_functions(&mut world);
        register_atomic_i_32_functions(&mut world);
        register_atomic_i_64_functions(&mut world);
        register_atomic_i_8_functions(&mut world);
        register_atomic_isize_functions(&mut world);
        register_atomic_u_16_functions(&mut world);
        register_atomic_u_32_functions(&mut world);
        register_atomic_u_64_functions(&mut world);
        register_atomic_u_8_functions(&mut world);
        register_atomic_usize_functions(&mut world);
        register_duration_functions(&mut world);
        register_instant_functions(&mut world);
        register_range_full_functions(&mut world);
        register_quat_functions(&mut world);
        register_vec_3_functions(&mut world);
        register_i_vec_2_functions(&mut world);
        register_i_vec_3_functions(&mut world);
        register_i_vec_4_functions(&mut world);
        register_i_64_vec_2_functions(&mut world);
        register_i_64_vec_3_functions(&mut world);
        register_i_64_vec_4_functions(&mut world);
        register_u_vec_2_functions(&mut world);
        register_u_vec_3_functions(&mut world);
        register_u_vec_4_functions(&mut world);
        register_u_64_vec_2_functions(&mut world);
        register_u_64_vec_3_functions(&mut world);
        register_u_64_vec_4_functions(&mut world);
        register_vec_2_functions(&mut world);
        register_vec_3_a_functions(&mut world);
        register_vec_4_functions(&mut world);
        register_b_vec_2_functions(&mut world);
        register_b_vec_3_functions(&mut world);
        register_b_vec_4_functions(&mut world);
        register_d_vec_2_functions(&mut world);
        register_d_vec_3_functions(&mut world);
        register_d_vec_4_functions(&mut world);
        register_mat_2_functions(&mut world);
        register_mat_3_functions(&mut world);
        register_mat_3_a_functions(&mut world);
        register_mat_4_functions(&mut world);
        register_d_mat_2_functions(&mut world);
        register_d_mat_3_functions(&mut world);
        register_d_mat_4_functions(&mut world);
        register_affine_2_functions(&mut world);
        register_affine_3_a_functions(&mut world);
        register_d_affine_2_functions(&mut world);
        register_d_affine_3_functions(&mut world);
        register_d_quat_functions(&mut world);
        register_euler_rot_functions(&mut world);
        register_b_vec_3_a_functions(&mut world);
        register_b_vec_4_a_functions(&mut world);
        register_smol_str_functions(&mut world);
        register_uuid_functions(&mut world);
    }
}
