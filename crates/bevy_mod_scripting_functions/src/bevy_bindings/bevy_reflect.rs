// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use bevy_mod_scripting_core::{
    AddContextInitializer, StoreDocumentation,
    bindings::{
        ReflectReference,
        function::{
            from::{Ref, Mut, Val},
            namespace::NamespaceBuilder,
        },
    },
};
use crate::*;
pub struct BevyReflectScriptingPlugin;
impl ::bevy::app::Plugin for BevyReflectScriptingPlugin {
    fn build(&self, app: &mut ::bevy::prelude::App) {
        let mut world = app.world_mut();
        NamespaceBuilder::<::std::sync::atomic::AtomicBool>::new(world)
            .register(
                "into_inner",
                |_self: Val<std::sync::atomic::AtomicBool>| {
                    let output: bool = std::sync::atomic::AtomicBool::into_inner(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |v: bool| {
                    let output: Val<std::sync::atomic::AtomicBool> = std::sync::atomic::AtomicBool::new(
                            v,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::std::sync::atomic::AtomicI16>::new(world)
            .register(
                "into_inner",
                |_self: Val<std::sync::atomic::AtomicI16>| {
                    let output: i16 = std::sync::atomic::AtomicI16::into_inner(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |v: i16| {
                    let output: Val<std::sync::atomic::AtomicI16> = std::sync::atomic::AtomicI16::new(
                            v,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::std::sync::atomic::AtomicI32>::new(world)
            .register(
                "into_inner",
                |_self: Val<std::sync::atomic::AtomicI32>| {
                    let output: i32 = std::sync::atomic::AtomicI32::into_inner(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |v: i32| {
                    let output: Val<std::sync::atomic::AtomicI32> = std::sync::atomic::AtomicI32::new(
                            v,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::std::sync::atomic::AtomicI64>::new(world)
            .register(
                "into_inner",
                |_self: Val<std::sync::atomic::AtomicI64>| {
                    let output: i64 = std::sync::atomic::AtomicI64::into_inner(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |v: i64| {
                    let output: Val<std::sync::atomic::AtomicI64> = std::sync::atomic::AtomicI64::new(
                            v,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::std::sync::atomic::AtomicI8>::new(world)
            .register(
                "into_inner",
                |_self: Val<std::sync::atomic::AtomicI8>| {
                    let output: i8 = std::sync::atomic::AtomicI8::into_inner(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |v: i8| {
                    let output: Val<std::sync::atomic::AtomicI8> = std::sync::atomic::AtomicI8::new(
                            v,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::std::sync::atomic::AtomicIsize>::new(world)
            .register(
                "into_inner",
                |_self: Val<std::sync::atomic::AtomicIsize>| {
                    let output: isize = std::sync::atomic::AtomicIsize::into_inner(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |v: isize| {
                    let output: Val<std::sync::atomic::AtomicIsize> = std::sync::atomic::AtomicIsize::new(
                            v,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::std::sync::atomic::AtomicU16>::new(world)
            .register(
                "into_inner",
                |_self: Val<std::sync::atomic::AtomicU16>| {
                    let output: u16 = std::sync::atomic::AtomicU16::into_inner(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |v: u16| {
                    let output: Val<std::sync::atomic::AtomicU16> = std::sync::atomic::AtomicU16::new(
                            v,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::std::sync::atomic::AtomicU32>::new(world)
            .register(
                "into_inner",
                |_self: Val<std::sync::atomic::AtomicU32>| {
                    let output: u32 = std::sync::atomic::AtomicU32::into_inner(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |v: u32| {
                    let output: Val<std::sync::atomic::AtomicU32> = std::sync::atomic::AtomicU32::new(
                            v,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::std::sync::atomic::AtomicU64>::new(world)
            .register(
                "into_inner",
                |_self: Val<std::sync::atomic::AtomicU64>| {
                    let output: u64 = std::sync::atomic::AtomicU64::into_inner(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |v: u64| {
                    let output: Val<std::sync::atomic::AtomicU64> = std::sync::atomic::AtomicU64::new(
                            v,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::std::sync::atomic::AtomicU8>::new(world)
            .register(
                "into_inner",
                |_self: Val<std::sync::atomic::AtomicU8>| {
                    let output: u8 = std::sync::atomic::AtomicU8::into_inner(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |v: u8| {
                    let output: Val<std::sync::atomic::AtomicU8> = std::sync::atomic::AtomicU8::new(
                            v,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::std::sync::atomic::AtomicUsize>::new(world)
            .register(
                "into_inner",
                |_self: Val<std::sync::atomic::AtomicUsize>| {
                    let output: usize = std::sync::atomic::AtomicUsize::into_inner(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |v: usize| {
                    let output: Val<std::sync::atomic::AtomicUsize> = std::sync::atomic::AtomicUsize::new(
                            v,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::utils::Duration>::new(world)
            .register(
                "abs_diff",
                |_self: Val<bevy::utils::Duration>, other: Val<bevy::utils::Duration>| {
                    let output: Val<bevy::utils::Duration> = bevy::utils::Duration::abs_diff(
                            _self.into_inner(),
                            other.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::utils::Duration>, rhs: Val<bevy::utils::Duration>| {
                    let output: Val<bevy::utils::Duration> = <bevy::utils::Duration as std::ops::Add<
                        bevy::utils::Duration,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "as_micros",
                |_self: Ref<bevy::utils::Duration>| {
                    let output: u128 = bevy::utils::Duration::as_micros(&_self).into();
                    output
                },
            )
            .register(
                "as_millis",
                |_self: Ref<bevy::utils::Duration>| {
                    let output: u128 = bevy::utils::Duration::as_millis(&_self).into();
                    output
                },
            )
            .register(
                "as_nanos",
                |_self: Ref<bevy::utils::Duration>| {
                    let output: u128 = bevy::utils::Duration::as_nanos(&_self).into();
                    output
                },
            )
            .register(
                "as_secs",
                |_self: Ref<bevy::utils::Duration>| {
                    let output: u64 = bevy::utils::Duration::as_secs(&_self).into();
                    output
                },
            )
            .register(
                "as_secs_f32",
                |_self: Ref<bevy::utils::Duration>| {
                    let output: f32 = bevy::utils::Duration::as_secs_f32(&_self).into();
                    output
                },
            )
            .register(
                "as_secs_f64",
                |_self: Ref<bevy::utils::Duration>| {
                    let output: f64 = bevy::utils::Duration::as_secs_f64(&_self).into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::utils::Duration>| {
                    let output: () = <bevy::utils::Duration as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::utils::Duration>| {
                    let output: Val<bevy::utils::Duration> = <bevy::utils::Duration as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::utils::Duration>, rhs: u32| {
                    let output: Val<bevy::utils::Duration> = <bevy::utils::Duration as std::ops::Div<
                        u32,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div_duration_f32",
                |_self: Val<bevy::utils::Duration>, rhs: Val<bevy::utils::Duration>| {
                    let output: f32 = bevy::utils::Duration::div_duration_f32(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div_duration_f64",
                |_self: Val<bevy::utils::Duration>, rhs: Val<bevy::utils::Duration>| {
                    let output: f64 = bevy::utils::Duration::div_duration_f64(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div_f32",
                |_self: Val<bevy::utils::Duration>, rhs: f32| {
                    let output: Val<bevy::utils::Duration> = bevy::utils::Duration::div_f32(
                            _self.into_inner(),
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "div_f64",
                |_self: Val<bevy::utils::Duration>, rhs: f64| {
                    let output: Val<bevy::utils::Duration> = bevy::utils::Duration::div_f64(
                            _self.into_inner(),
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::utils::Duration>, other: Ref<bevy::utils::Duration>| {
                    let output: bool = <bevy::utils::Duration as std::cmp::PartialEq<
                        bevy::utils::Duration,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "from_micros",
                |micros: u64| {
                    let output: Val<bevy::utils::Duration> = bevy::utils::Duration::from_micros(
                            micros,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_millis",
                |millis: u64| {
                    let output: Val<bevy::utils::Duration> = bevy::utils::Duration::from_millis(
                            millis,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_nanos",
                |nanos: u64| {
                    let output: Val<bevy::utils::Duration> = bevy::utils::Duration::from_nanos(
                            nanos,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_secs",
                |secs: u64| {
                    let output: Val<bevy::utils::Duration> = bevy::utils::Duration::from_secs(
                            secs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_secs_f32",
                |secs: f32| {
                    let output: Val<bevy::utils::Duration> = bevy::utils::Duration::from_secs_f32(
                            secs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_secs_f64",
                |secs: f64| {
                    let output: Val<bevy::utils::Duration> = bevy::utils::Duration::from_secs_f64(
                            secs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_zero",
                |_self: Ref<bevy::utils::Duration>| {
                    let output: bool = bevy::utils::Duration::is_zero(&_self).into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::utils::Duration>, rhs: u32| {
                    let output: Val<bevy::utils::Duration> = <bevy::utils::Duration as std::ops::Mul<
                        u32,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul_f32",
                |_self: Val<bevy::utils::Duration>, rhs: f32| {
                    let output: Val<bevy::utils::Duration> = bevy::utils::Duration::mul_f32(
                            _self.into_inner(),
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_f64",
                |_self: Val<bevy::utils::Duration>, rhs: f64| {
                    let output: Val<bevy::utils::Duration> = bevy::utils::Duration::mul_f64(
                            _self.into_inner(),
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |secs: u64, nanos: u32| {
                    let output: Val<bevy::utils::Duration> = bevy::utils::Duration::new(
                            secs,
                            nanos,
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add",
                |_self: Val<bevy::utils::Duration>, rhs: Val<bevy::utils::Duration>| {
                    let output: Val<bevy::utils::Duration> = bevy::utils::Duration::saturating_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_mul",
                |_self: Val<bevy::utils::Duration>, rhs: u32| {
                    let output: Val<bevy::utils::Duration> = bevy::utils::Duration::saturating_mul(
                            _self.into_inner(),
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub",
                |_self: Val<bevy::utils::Duration>, rhs: Val<bevy::utils::Duration>| {
                    let output: Val<bevy::utils::Duration> = bevy::utils::Duration::saturating_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::utils::Duration>, rhs: Val<bevy::utils::Duration>| {
                    let output: Val<bevy::utils::Duration> = <bevy::utils::Duration as std::ops::Sub<
                        bevy::utils::Duration,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "subsec_micros",
                |_self: Ref<bevy::utils::Duration>| {
                    let output: u32 = bevy::utils::Duration::subsec_micros(&_self)
                        .into();
                    output
                },
            )
            .register(
                "subsec_millis",
                |_self: Ref<bevy::utils::Duration>| {
                    let output: u32 = bevy::utils::Duration::subsec_millis(&_self)
                        .into();
                    output
                },
            )
            .register(
                "subsec_nanos",
                |_self: Ref<bevy::utils::Duration>| {
                    let output: u32 = bevy::utils::Duration::subsec_nanos(&_self).into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::utils::Instant>::new(world)
            .register(
                "add",
                |_self: Val<bevy::utils::Instant>, other: Val<bevy::utils::Duration>| {
                    let output: Val<bevy::utils::Instant> = <bevy::utils::Instant as std::ops::Add<
                        bevy::utils::Duration,
                    >>::add(_self.into_inner(), other.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::utils::Instant>| {
                    let output: () = <bevy::utils::Instant as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::utils::Instant>| {
                    let output: Val<bevy::utils::Instant> = <bevy::utils::Instant as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "duration_since",
                |_self: Ref<bevy::utils::Instant>, earlier: Val<bevy::utils::Instant>| {
                    let output: Val<bevy::utils::Duration> = bevy::utils::Instant::duration_since(
                            &_self,
                            earlier.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "elapsed",
                |_self: Ref<bevy::utils::Instant>| {
                    let output: Val<bevy::utils::Duration> = bevy::utils::Instant::elapsed(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::utils::Instant>, other: Ref<bevy::utils::Instant>| {
                    let output: bool = <bevy::utils::Instant as std::cmp::PartialEq<
                        bevy::utils::Instant,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "now",
                || {
                    let output: Val<bevy::utils::Instant> = bevy::utils::Instant::now()
                        .into();
                    output
                },
            )
            .register(
                "saturating_duration_since",
                |_self: Ref<bevy::utils::Instant>, earlier: Val<bevy::utils::Instant>| {
                    let output: Val<bevy::utils::Duration> = bevy::utils::Instant::saturating_duration_since(
                            &_self,
                            earlier.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::utils::Instant>, other: Val<bevy::utils::Duration>| {
                    let output: Val<bevy::utils::Instant> = <bevy::utils::Instant as std::ops::Sub<
                        bevy::utils::Duration,
                    >>::sub(_self.into_inner(), other.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::utils::Instant>, other: Val<bevy::utils::Instant>| {
                    let output: Val<bevy::utils::Duration> = <bevy::utils::Instant as std::ops::Sub<
                        bevy::utils::Instant,
                    >>::sub(_self.into_inner(), other.into_inner())
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::std::ops::RangeFull>::new(world)
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<std::ops::RangeFull>| {
                    let output: () = <std::ops::RangeFull as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<std::ops::RangeFull>| {
                    let output: Val<std::ops::RangeFull> = <std::ops::RangeFull as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<std::ops::RangeFull>, other: Ref<std::ops::RangeFull>| {
                    let output: bool = <std::ops::RangeFull as std::cmp::PartialEq<
                        std::ops::RangeFull,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::Quat>::new(world)
            .register(
                "abs_diff_eq",
                |
                    _self: Val<bevy::math::Quat>,
                    rhs: Val<bevy::math::Quat>,
                    max_abs_diff: f32|
                {
                    let output: bool = bevy::math::Quat::abs_diff_eq(
                            _self.into_inner(),
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Quat> = <bevy::math::Quat as std::ops::Add<
                        bevy::math::Quat,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "angle_between",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>| {
                    let output: f32 = bevy::math::Quat::angle_between(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_dquat",
                |_self: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::DQuat> = bevy::math::Quat::as_dquat(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::Quat>| {
                    let output: Val<bevy::math::Quat> = <bevy::math::Quat as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "conjugate",
                |_self: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::conjugate(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::Quat>, rhs: f32| {
                    let output: Val<bevy::math::Quat> = <bevy::math::Quat as std::ops::Div<
                        f32,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>| {
                    let output: f32 = bevy::math::Quat::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::Quat>, rhs: Ref<bevy::math::Quat>| {
                    let output: bool = <bevy::math::Quat as std::cmp::PartialEq<
                        bevy::math::Quat,
                    >>::eq(&_self, &rhs)
                        .into();
                    output
                },
            )
            .register(
                "from_affine3",
                |a: Ref<bevy::math::Affine3A>| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::from_affine3(
                            &a,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [f32; 4]| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::from_array(a)
                        .into();
                    output
                },
            )
            .register(
                "from_axis_angle",
                |axis: Val<bevy::math::Vec3>, angle: f32| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::from_axis_angle(
                            axis.into_inner(),
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_euler",
                |euler: Val<bevy::math::EulerRot>, a: f32, b: f32, c: f32| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::from_euler(
                            euler.into_inner(),
                            a,
                            b,
                            c,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat3",
                |mat: Ref<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::from_mat3(&mat)
                        .into();
                    output
                },
            )
            .register(
                "from_mat3a",
                |mat: Ref<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::from_mat3a(
                            &mat,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat4",
                |mat: Ref<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::from_mat4(&mat)
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_arc",
                |from: Val<bevy::math::Vec3>, to: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_arc(
                            from.into_inner(),
                            to.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_arc_2d",
                |from: Val<bevy::math::Vec2>, to: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_arc_2d(
                            from.into_inner(),
                            to.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_arc_colinear",
                |from: Val<bevy::math::Vec3>, to: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_arc_colinear(
                            from.into_inner(),
                            to.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_x",
                |angle: f32| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_x(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_y",
                |angle: f32| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_y(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_z",
                |angle: f32| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_z(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scaled_axis",
                |v: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::from_scaled_axis(
                            v.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_vec4",
                |v: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::from_vec4(
                            v.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_xyzw",
                |x: f32, y: f32, z: f32, w: f32| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::from_xyzw(
                            x,
                            y,
                            z,
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "inverse",
                |_self: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::inverse(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Val<bevy::math::Quat>| {
                    let output: bool = bevy::math::Quat::is_finite(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Val<bevy::math::Quat>| {
                    let output: bool = bevy::math::Quat::is_nan(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_near_identity",
                |_self: Val<bevy::math::Quat>| {
                    let output: bool = bevy::math::Quat::is_near_identity(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_normalized",
                |_self: Val<bevy::math::Quat>| {
                    let output: bool = bevy::math::Quat::is_normalized(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "length",
                |_self: Val<bevy::math::Quat>| {
                    let output: f32 = bevy::math::Quat::length(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_recip",
                |_self: Val<bevy::math::Quat>| {
                    let output: f32 = bevy::math::Quat::length_recip(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::Quat>| {
                    let output: f32 = bevy::math::Quat::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "lerp",
                |_self: Val<bevy::math::Quat>, end: Val<bevy::math::Quat>, s: f32| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::lerp(
                            _self.into_inner(),
                            end.into_inner(),
                            s,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Quat> = <bevy::math::Quat as std::ops::Mul<
                        bevy::math::Quat,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Quat as std::ops::Mul<
                        bevy::math::Vec3,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Quat as std::ops::Mul<
                        bevy::math::Vec3A,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Quat>, rhs: f32| {
                    let output: Val<bevy::math::Quat> = <bevy::math::Quat as std::ops::Mul<
                        f32,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul_quat",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::mul_quat(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_vec3",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Quat::mul_vec3(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_vec3a",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Quat::mul_vec3a(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Quat> = <bevy::math::Quat as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "normalize",
                |_self: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::normalize(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rotate_towards",
                |
                    _self: Ref<bevy::math::Quat>,
                    rhs: Val<bevy::math::Quat>,
                    max_angle: f32|
                {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::rotate_towards(
                            &_self,
                            rhs.into_inner(),
                            max_angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "slerp",
                |_self: Val<bevy::math::Quat>, end: Val<bevy::math::Quat>, s: f32| {
                    let output: Val<bevy::math::Quat> = bevy::math::Quat::slerp(
                            _self.into_inner(),
                            end.into_inner(),
                            s,
                        )
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Quat> = <bevy::math::Quat as std::ops::Sub<
                        bevy::math::Quat,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::Quat>| {
                    let output: [f32; 4] = bevy::math::Quat::to_array(&_self).into();
                    output
                },
            )
            .register(
                "to_euler",
                |_self: Val<bevy::math::Quat>, order: Val<bevy::math::EulerRot>| {
                    let output: (f32, f32, f32) = bevy::math::Quat::to_euler(
                            _self.into_inner(),
                            order.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "to_scaled_axis",
                |_self: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Quat::to_scaled_axis(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "xyz",
                |_self: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Quat::xyz(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::Vec3>::new(world)
            .register(
                "abs",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::abs(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "abs_diff_eq",
                |
                    _self: Val<bevy::math::Vec3>,
                    rhs: Val<bevy::math::Vec3>,
                    max_abs_diff: f32|
                {
                    let output: bool = bevy::math::Vec3::abs_diff_eq(
                            _self.into_inner(),
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::Vec3>, rhs: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Add<
                        &bevy::math::Vec3,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::Vec3>, rhs: f32| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Add<
                        f32,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Add<
                        bevy::math::Vec3,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "angle_between",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: f32 = bevy::math::Vec3::angle_between(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "any_orthogonal_vector",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::any_orthogonal_vector(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "any_orthonormal_vector",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::any_orthonormal_vector(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_dvec3",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::Vec3::as_dvec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_i64vec3",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::Vec3::as_i64vec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_ivec3",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::Vec3::as_ivec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_u64vec3",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::Vec3::as_u64vec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_uvec3",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::Vec3::as_uvec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "ceil",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::ceil(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::Vec3>,
                    min: Val<bevy::math::Vec3>,
                    max: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length",
                |_self: Val<bevy::math::Vec3>, min: f32, max: f32| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::clamp_length(
                            _self.into_inner(),
                            min,
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length_max",
                |_self: Val<bevy::math::Vec3>, max: f32| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::clamp_length_max(
                            _self.into_inner(),
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length_min",
                |_self: Val<bevy::math::Vec3>, min: f32| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::clamp_length_min(
                            _self.into_inner(),
                            min,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "copysign",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::copysign(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cross",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::cross(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: f32 = bevy::math::Vec3::distance(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance_squared",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: f32 = bevy::math::Vec3::distance_squared(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::Vec3>, rhs: f32| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Div<
                        f32,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Div<
                        bevy::math::Vec3,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::Vec3>, rhs: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Div<
                        &bevy::math::Vec3,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "div_euclid",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::div_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: f32 = bevy::math::Vec3::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::Vec3>| {
                    let output: f32 = bevy::math::Vec3::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::Vec3>| {
                    let output: f32 = bevy::math::Vec3::element_sum(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::Vec3>, other: Ref<bevy::math::Vec3>| {
                    let output: bool = <bevy::math::Vec3 as std::cmp::PartialEq<
                        bevy::math::Vec3,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "exp",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::exp(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "extend",
                |_self: Val<bevy::math::Vec3>, w: f32| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec3::extend(
                            _self.into_inner(),
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "floor",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::floor(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "fract",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::fract(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "fract_gl",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::fract_gl(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [f32; 3]| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::from_array(a)
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Val<bevy::math::Vec3>| {
                    let output: bool = bevy::math::Vec3::is_finite(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_finite_mask",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::Vec3::is_finite_mask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Val<bevy::math::Vec3>| {
                    let output: bool = bevy::math::Vec3::is_nan(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_nan_mask",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::Vec3::is_nan_mask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_negative_bitmask",
                |_self: Val<bevy::math::Vec3>| {
                    let output: u32 = bevy::math::Vec3::is_negative_bitmask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_normalized",
                |_self: Val<bevy::math::Vec3>| {
                    let output: bool = bevy::math::Vec3::is_normalized(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "length",
                |_self: Val<bevy::math::Vec3>| {
                    let output: f32 = bevy::math::Vec3::length(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_recip",
                |_self: Val<bevy::math::Vec3>| {
                    let output: f32 = bevy::math::Vec3::length_recip(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::Vec3>| {
                    let output: f32 = bevy::math::Vec3::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "lerp",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>, s: f32| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::lerp(
                            _self.into_inner(),
                            rhs.into_inner(),
                            s,
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::Vec3>| {
                    let output: f32 = bevy::math::Vec3::max_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "midpoint",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::midpoint(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::Vec3>| {
                    let output: f32 = bevy::math::Vec3::min_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "move_towards",
                |_self: Ref<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>, d: f32| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::move_towards(
                            &_self,
                            rhs.into_inner(),
                            d,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Vec3>, rhs: f32| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Mul<
                        f32,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Mul<
                        bevy::math::Vec3,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Vec3>, rhs: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Mul<
                        &bevy::math::Vec3,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul_add",
                |
                    _self: Val<bevy::math::Vec3>,
                    a: Val<bevy::math::Vec3>,
                    b: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::mul_add(
                            _self.into_inner(),
                            a.into_inner(),
                            b.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: f32, y: f32, z: f32| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::new(x, y, z)
                        .into();
                    output
                },
            )
            .register(
                "normalize",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::normalize(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "normalize_or",
                |_self: Val<bevy::math::Vec3>, fallback: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::normalize_or(
                            _self.into_inner(),
                            fallback.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "normalize_or_zero",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::normalize_or_zero(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "powf",
                |_self: Val<bevy::math::Vec3>, n: f32| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::powf(
                            _self.into_inner(),
                            n,
                        )
                        .into();
                    output
                },
            )
            .register(
                "project_onto",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::project_onto(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "project_onto_normalized",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::project_onto_normalized(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "recip",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::recip(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "reflect",
                |_self: Val<bevy::math::Vec3>, normal: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::reflect(
                            _self.into_inner(),
                            normal.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "refract",
                |_self: Val<bevy::math::Vec3>, normal: Val<bevy::math::Vec3>, eta: f32| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::refract(
                            _self.into_inner(),
                            normal.into_inner(),
                            eta,
                        )
                        .into();
                    output
                },
            )
            .register(
                "reject_from",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::reject_from(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "reject_from_normalized",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::reject_from_normalized(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::Vec3>, rhs: f32| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Rem<
                        f32,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Rem<
                        bevy::math::Vec3,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::Vec3>, rhs: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Rem<
                        &bevy::math::Vec3,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem_euclid",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::rem_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "round",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::round(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec3>,
                    if_true: Val<bevy::math::Vec3>,
                    if_false: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "signum",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::signum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: f32| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Sub<
                        bevy::math::Vec3,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::Vec3>, rhs: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Sub<
                        &bevy::math::Vec3,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::Vec3>, rhs: f32| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Sub<
                        f32,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: [f32; 3] = bevy::math::Vec3::to_array(&_self).into();
                    output
                },
            )
            .register(
                "trunc",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::trunc(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "truncate",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec3::truncate(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::Vec3>, x: f32| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::Vec3>, y: f32| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_z",
                |_self: Val<bevy::math::Vec3>, z: f32| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec3::with_z(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::IVec2>::new(world)
            .register(
                "abs",
                |_self: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::abs(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::IVec2>, rhs: i32| {
                    let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Add<
                        i32,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Add<
                        bevy::math::IVec2,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::IVec2>, rhs: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Add<
                        &bevy::math::IVec2,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "as_dvec2",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::IVec2::as_dvec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_i64vec2",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::IVec2::as_i64vec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_u64vec2",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::IVec2::as_u64vec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_uvec2",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::IVec2::as_uvec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec2",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::IVec2::as_vec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: () = <bevy::math::IVec2 as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::IVec2>,
                    min: Val<bevy::math::IVec2>,
                    max: Val<bevy::math::IVec2>|
                {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance_squared",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: i32 = bevy::math::IVec2::distance_squared(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::IVec2>, rhs: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Div<
                        &bevy::math::IVec2,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::IVec2>, rhs: i32| {
                    let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Div<
                        i32,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Div<
                        bevy::math::IVec2,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "div_euclid",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::div_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: i32 = bevy::math::IVec2::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::IVec2>| {
                    let output: i32 = bevy::math::IVec2::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::IVec2>| {
                    let output: i32 = bevy::math::IVec2::element_sum(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::IVec2>, other: Ref<bevy::math::IVec2>| {
                    let output: bool = <bevy::math::IVec2 as std::cmp::PartialEq<
                        bevy::math::IVec2,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "extend",
                |_self: Val<bevy::math::IVec2>, z: i32| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec2::extend(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [i32; 2]| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::from_array(a)
                        .into();
                    output
                },
            )
            .register(
                "is_negative_bitmask",
                |_self: Val<bevy::math::IVec2>| {
                    let output: u32 = bevy::math::IVec2::is_negative_bitmask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::IVec2>| {
                    let output: i32 = bevy::math::IVec2::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::IVec2>| {
                    let output: i32 = bevy::math::IVec2::max_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::IVec2>| {
                    let output: i32 = bevy::math::IVec2::min_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::IVec2>, rhs: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Mul<
                        &bevy::math::IVec2,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::IVec2>, rhs: i32| {
                    let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Mul<
                        i32,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Mul<
                        bevy::math::IVec2,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: i32, y: i32| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::new(x, y)
                        .into();
                    output
                },
            )
            .register(
                "perp",
                |_self: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::perp(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "perp_dot",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: i32 = bevy::math::IVec2::perp_dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Rem<
                        bevy::math::IVec2,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::IVec2>, rhs: i32| {
                    let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Rem<
                        i32,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::IVec2>, rhs: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Rem<
                        &bevy::math::IVec2,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem_euclid",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::rem_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rotate",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::rotate(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add_unsigned",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_add_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_div",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_mul",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub_unsigned",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_sub_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec2>,
                    if_true: Val<bevy::math::IVec2>,
                    if_false: Val<bevy::math::IVec2>|
                {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "signum",
                |_self: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::signum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: i32| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::IVec2>, rhs: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Sub<
                        &bevy::math::IVec2,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::IVec2>, rhs: i32| {
                    let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Sub<
                        i32,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Sub<
                        bevy::math::IVec2,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: [i32; 2] = bevy::math::IVec2::to_array(&_self).into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::IVec2>, x: i32| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::IVec2>, y: i32| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add_unsigned",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_add_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_div",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_mul",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_sub",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_sub_unsigned",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_sub_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::IVec3>::new(world)
            .register(
                "abs",
                |_self: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::abs(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::IVec3>, rhs: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Add<
                        &bevy::math::IVec3,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Add<
                        bevy::math::IVec3,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::IVec3>, rhs: i32| {
                    let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Add<
                        i32,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "as_dvec3",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::IVec3::as_dvec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_i64vec3",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::IVec3::as_i64vec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_u64vec3",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::IVec3::as_u64vec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_uvec3",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::IVec3::as_uvec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec3",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::IVec3::as_vec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec3a",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::IVec3::as_vec3a(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: () = <bevy::math::IVec3 as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::IVec3>,
                    min: Val<bevy::math::IVec3>,
                    max: Val<bevy::math::IVec3>|
                {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cross",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::cross(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance_squared",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: i32 = bevy::math::IVec3::distance_squared(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::IVec3>, rhs: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Div<
                        &bevy::math::IVec3,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::IVec3>, rhs: i32| {
                    let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Div<
                        i32,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Div<
                        bevy::math::IVec3,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "div_euclid",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::div_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: i32 = bevy::math::IVec3::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::IVec3>| {
                    let output: i32 = bevy::math::IVec3::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::IVec3>| {
                    let output: i32 = bevy::math::IVec3::element_sum(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::IVec3>, other: Ref<bevy::math::IVec3>| {
                    let output: bool = <bevy::math::IVec3 as std::cmp::PartialEq<
                        bevy::math::IVec3,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "extend",
                |_self: Val<bevy::math::IVec3>, w: i32| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec3::extend(
                            _self.into_inner(),
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [i32; 3]| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::from_array(a)
                        .into();
                    output
                },
            )
            .register(
                "is_negative_bitmask",
                |_self: Val<bevy::math::IVec3>| {
                    let output: u32 = bevy::math::IVec3::is_negative_bitmask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::IVec3>| {
                    let output: i32 = bevy::math::IVec3::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::IVec3>| {
                    let output: i32 = bevy::math::IVec3::max_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::IVec3>| {
                    let output: i32 = bevy::math::IVec3::min_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Mul<
                        bevy::math::IVec3,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::IVec3>, rhs: i32| {
                    let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Mul<
                        i32,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::IVec3>, rhs: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Mul<
                        &bevy::math::IVec3,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: i32, y: i32, z: i32| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::new(x, y, z)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Rem<
                        bevy::math::IVec3,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::IVec3>, rhs: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Rem<
                        &bevy::math::IVec3,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::IVec3>, rhs: i32| {
                    let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Rem<
                        i32,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem_euclid",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::rem_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add_unsigned",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_add_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_div",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_mul",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub_unsigned",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_sub_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec3>,
                    if_true: Val<bevy::math::IVec3>,
                    if_false: Val<bevy::math::IVec3>|
                {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "signum",
                |_self: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::signum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: i32| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::IVec3>, rhs: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Sub<
                        &bevy::math::IVec3,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Sub<
                        bevy::math::IVec3,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::IVec3>, rhs: i32| {
                    let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Sub<
                        i32,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: [i32; 3] = bevy::math::IVec3::to_array(&_self).into();
                    output
                },
            )
            .register(
                "truncate",
                |_self: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::IVec3::truncate(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::IVec3>, x: i32| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::IVec3>, y: i32| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_z",
                |_self: Val<bevy::math::IVec3>, z: i32| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::with_z(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add_unsigned",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_add_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_div",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_mul",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_sub",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_sub_unsigned",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_sub_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::IVec4>::new(world)
            .register(
                "abs",
                |_self: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::abs(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::IVec4>, rhs: i32| {
                    let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Add<
                        i32,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Add<
                        bevy::math::IVec4,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::IVec4>, rhs: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Add<
                        &bevy::math::IVec4,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "as_dvec4",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::IVec4::as_dvec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_i64vec4",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::IVec4::as_i64vec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_u64vec4",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::IVec4::as_u64vec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_uvec4",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::UVec4> = bevy::math::IVec4::as_uvec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec4",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::IVec4::as_vec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: () = <bevy::math::IVec4 as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::IVec4>,
                    min: Val<bevy::math::IVec4>,
                    max: Val<bevy::math::IVec4>|
                {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance_squared",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: i32 = bevy::math::IVec4::distance_squared(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::IVec4>, rhs: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Div<
                        &bevy::math::IVec4,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::IVec4>, rhs: i32| {
                    let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Div<
                        i32,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Div<
                        bevy::math::IVec4,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "div_euclid",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::div_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: i32 = bevy::math::IVec4::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::IVec4>| {
                    let output: i32 = bevy::math::IVec4::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::IVec4>| {
                    let output: i32 = bevy::math::IVec4::element_sum(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::IVec4>, other: Ref<bevy::math::IVec4>| {
                    let output: bool = <bevy::math::IVec4 as std::cmp::PartialEq<
                        bevy::math::IVec4,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [i32; 4]| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::from_array(a)
                        .into();
                    output
                },
            )
            .register(
                "is_negative_bitmask",
                |_self: Val<bevy::math::IVec4>| {
                    let output: u32 = bevy::math::IVec4::is_negative_bitmask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::IVec4>| {
                    let output: i32 = bevy::math::IVec4::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::IVec4>| {
                    let output: i32 = bevy::math::IVec4::max_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::IVec4>| {
                    let output: i32 = bevy::math::IVec4::min_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::IVec4>, rhs: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Mul<
                        &bevy::math::IVec4,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Mul<
                        bevy::math::IVec4,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::IVec4>, rhs: i32| {
                    let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Mul<
                        i32,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: i32, y: i32, z: i32, w: i32| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::new(
                            x,
                            y,
                            z,
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::IVec4>, rhs: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Rem<
                        &bevy::math::IVec4,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::IVec4>, rhs: i32| {
                    let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Rem<
                        i32,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Rem<
                        bevy::math::IVec4,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "rem_euclid",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::rem_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add_unsigned",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_add_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_div",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_mul",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub_unsigned",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_sub_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec4>,
                    if_true: Val<bevy::math::IVec4>,
                    if_false: Val<bevy::math::IVec4>|
                {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "signum",
                |_self: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::signum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: i32| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Sub<
                        bevy::math::IVec4,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::IVec4>, rhs: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Sub<
                        &bevy::math::IVec4,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::IVec4>, rhs: i32| {
                    let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Sub<
                        i32,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: [i32; 4] = bevy::math::IVec4::to_array(&_self).into();
                    output
                },
            )
            .register(
                "truncate",
                |_self: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::IVec4::truncate(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_w",
                |_self: Val<bevy::math::IVec4>, w: i32| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::with_w(
                            _self.into_inner(),
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::IVec4>, x: i32| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::IVec4>, y: i32| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_z",
                |_self: Val<bevy::math::IVec4>, z: i32| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::with_z(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add_unsigned",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_add_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_div",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_mul",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_sub",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_sub_unsigned",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_sub_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::I64Vec2>::new(world)
            .register(
                "abs",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::abs(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::I64Vec2>, rhs: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Add<
                        &bevy::math::I64Vec2,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::I64Vec2>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Add<
                        i64,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Add<
                        bevy::math::I64Vec2,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "as_dvec2",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::I64Vec2::as_dvec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_ivec2",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::I64Vec2::as_ivec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_u64vec2",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::I64Vec2::as_u64vec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_uvec2",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::I64Vec2::as_uvec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec2",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::I64Vec2::as_vec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: () = <bevy::math::I64Vec2 as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::I64Vec2>,
                    min: Val<bevy::math::I64Vec2>,
                    max: Val<bevy::math::I64Vec2>|
                {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance_squared",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: i64 = bevy::math::I64Vec2::distance_squared(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::I64Vec2>, rhs: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Div<
                        &bevy::math::I64Vec2,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::I64Vec2>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Div<
                        i64,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Div<
                        bevy::math::I64Vec2,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "div_euclid",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::div_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: i64 = bevy::math::I64Vec2::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: i64 = bevy::math::I64Vec2::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: i64 = bevy::math::I64Vec2::element_sum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::I64Vec2>, other: Ref<bevy::math::I64Vec2>| {
                    let output: bool = <bevy::math::I64Vec2 as std::cmp::PartialEq<
                        bevy::math::I64Vec2,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "extend",
                |_self: Val<bevy::math::I64Vec2>, z: i64| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec2::extend(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [i64; 2]| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::from_array(
                            a,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_negative_bitmask",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: u32 = bevy::math::I64Vec2::is_negative_bitmask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: i64 = bevy::math::I64Vec2::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: i64 = bevy::math::I64Vec2::max_element(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: i64 = bevy::math::I64Vec2::min_element(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::I64Vec2>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Mul<
                        i64,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Mul<
                        bevy::math::I64Vec2,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::I64Vec2>, rhs: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Mul<
                        &bevy::math::I64Vec2,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: i64, y: i64| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::new(x, y)
                        .into();
                    output
                },
            )
            .register(
                "perp",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::perp(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "perp_dot",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: i64 = bevy::math::I64Vec2::perp_dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::I64Vec2>, rhs: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Rem<
                        &bevy::math::I64Vec2,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::I64Vec2>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Rem<
                        i64,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Rem<
                        bevy::math::I64Vec2,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "rem_euclid",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::rem_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rotate",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::rotate(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add_unsigned",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_add_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_div",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_mul",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub_unsigned",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_sub_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec2>,
                    if_true: Val<bevy::math::I64Vec2>,
                    if_false: Val<bevy::math::I64Vec2>|
                {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "signum",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::signum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: i64| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Sub<
                        bevy::math::I64Vec2,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::I64Vec2>, rhs: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Sub<
                        &bevy::math::I64Vec2,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::I64Vec2>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Sub<
                        i64,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: [i64; 2] = bevy::math::I64Vec2::to_array(&_self).into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::I64Vec2>, x: i64| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::I64Vec2>, y: i64| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add_unsigned",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_add_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_div",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_mul",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_sub",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_sub_unsigned",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_sub_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::I64Vec3>::new(world)
            .register(
                "abs",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::abs(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Add<
                        bevy::math::I64Vec3,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::I64Vec3>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Add<
                        i64,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::I64Vec3>, rhs: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Add<
                        &bevy::math::I64Vec3,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "as_dvec3",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::I64Vec3::as_dvec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_ivec3",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::I64Vec3::as_ivec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_u64vec3",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::I64Vec3::as_u64vec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_uvec3",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::I64Vec3::as_uvec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec3",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::I64Vec3::as_vec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec3a",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::I64Vec3::as_vec3a(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: () = <bevy::math::I64Vec3 as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::I64Vec3>,
                    min: Val<bevy::math::I64Vec3>,
                    max: Val<bevy::math::I64Vec3>|
                {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cross",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::cross(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance_squared",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: i64 = bevy::math::I64Vec3::distance_squared(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::I64Vec3>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Div<
                        i64,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Div<
                        bevy::math::I64Vec3,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::I64Vec3>, rhs: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Div<
                        &bevy::math::I64Vec3,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "div_euclid",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::div_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: i64 = bevy::math::I64Vec3::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: i64 = bevy::math::I64Vec3::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: i64 = bevy::math::I64Vec3::element_sum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::I64Vec3>, other: Ref<bevy::math::I64Vec3>| {
                    let output: bool = <bevy::math::I64Vec3 as std::cmp::PartialEq<
                        bevy::math::I64Vec3,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "extend",
                |_self: Val<bevy::math::I64Vec3>, w: i64| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec3::extend(
                            _self.into_inner(),
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [i64; 3]| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::from_array(
                            a,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_negative_bitmask",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: u32 = bevy::math::I64Vec3::is_negative_bitmask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: i64 = bevy::math::I64Vec3::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: i64 = bevy::math::I64Vec3::max_element(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: i64 = bevy::math::I64Vec3::min_element(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Mul<
                        bevy::math::I64Vec3,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::I64Vec3>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Mul<
                        i64,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::I64Vec3>, rhs: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Mul<
                        &bevy::math::I64Vec3,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: i64, y: i64, z: i64| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::new(
                            x,
                            y,
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::I64Vec3>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Rem<
                        i64,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Rem<
                        bevy::math::I64Vec3,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::I64Vec3>, rhs: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Rem<
                        &bevy::math::I64Vec3,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem_euclid",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::rem_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add_unsigned",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_add_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_div",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_mul",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub_unsigned",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_sub_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec3>,
                    if_true: Val<bevy::math::I64Vec3>,
                    if_false: Val<bevy::math::I64Vec3>|
                {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "signum",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::signum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: i64| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::I64Vec3>, rhs: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Sub<
                        &bevy::math::I64Vec3,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::I64Vec3>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Sub<
                        i64,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Sub<
                        bevy::math::I64Vec3,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: [i64; 3] = bevy::math::I64Vec3::to_array(&_self).into();
                    output
                },
            )
            .register(
                "truncate",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec3::truncate(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::I64Vec3>, x: i64| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::I64Vec3>, y: i64| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_z",
                |_self: Val<bevy::math::I64Vec3>, z: i64| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::with_z(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add_unsigned",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_add_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_div",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_mul",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_sub",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_sub_unsigned",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_sub_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::I64Vec4>::new(world)
            .register(
                "abs",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::abs(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Add<
                        bevy::math::I64Vec4,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::I64Vec4>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Add<
                        i64,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::I64Vec4>, rhs: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Add<
                        &bevy::math::I64Vec4,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "as_dvec4",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::I64Vec4::as_dvec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_ivec4",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::I64Vec4::as_ivec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_u64vec4",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::I64Vec4::as_u64vec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_uvec4",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::UVec4> = bevy::math::I64Vec4::as_uvec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec4",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::I64Vec4::as_vec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: () = <bevy::math::I64Vec4 as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::I64Vec4>,
                    min: Val<bevy::math::I64Vec4>,
                    max: Val<bevy::math::I64Vec4>|
                {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance_squared",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: i64 = bevy::math::I64Vec4::distance_squared(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::I64Vec4>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Div<
                        i64,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::I64Vec4>, rhs: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Div<
                        &bevy::math::I64Vec4,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Div<
                        bevy::math::I64Vec4,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "div_euclid",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::div_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: i64 = bevy::math::I64Vec4::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: i64 = bevy::math::I64Vec4::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: i64 = bevy::math::I64Vec4::element_sum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::I64Vec4>, other: Ref<bevy::math::I64Vec4>| {
                    let output: bool = <bevy::math::I64Vec4 as std::cmp::PartialEq<
                        bevy::math::I64Vec4,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [i64; 4]| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::from_array(
                            a,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_negative_bitmask",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: u32 = bevy::math::I64Vec4::is_negative_bitmask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: i64 = bevy::math::I64Vec4::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: i64 = bevy::math::I64Vec4::max_element(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: i64 = bevy::math::I64Vec4::min_element(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::I64Vec4>, rhs: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Mul<
                        &bevy::math::I64Vec4,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::I64Vec4>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Mul<
                        i64,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Mul<
                        bevy::math::I64Vec4,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: i64, y: i64, z: i64, w: i64| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::new(
                            x,
                            y,
                            z,
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::I64Vec4>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Rem<
                        i64,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::I64Vec4>, rhs: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Rem<
                        &bevy::math::I64Vec4,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Rem<
                        bevy::math::I64Vec4,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "rem_euclid",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::rem_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add_unsigned",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_add_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_div",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_mul",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub_unsigned",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_sub_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec4>,
                    if_true: Val<bevy::math::I64Vec4>,
                    if_false: Val<bevy::math::I64Vec4>|
                {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "signum",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::signum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: i64| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::I64Vec4>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Sub<
                        i64,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::I64Vec4>, rhs: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Sub<
                        &bevy::math::I64Vec4,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Sub<
                        bevy::math::I64Vec4,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: [i64; 4] = bevy::math::I64Vec4::to_array(&_self).into();
                    output
                },
            )
            .register(
                "truncate",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec4::truncate(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_w",
                |_self: Val<bevy::math::I64Vec4>, w: i64| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::with_w(
                            _self.into_inner(),
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::I64Vec4>, x: i64| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::I64Vec4>, y: i64| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_z",
                |_self: Val<bevy::math::I64Vec4>, z: i64| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::with_z(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add_unsigned",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_add_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_div",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_mul",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_sub",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_sub_unsigned",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_sub_unsigned(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::UVec2>::new(world)
            .register(
                "add",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Add<
                        bevy::math::UVec2,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::UVec2>, rhs: u32| {
                    let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Add<
                        u32,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::UVec2>, rhs: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Add<
                        &bevy::math::UVec2,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "as_dvec2",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::UVec2::as_dvec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_i64vec2",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::UVec2::as_i64vec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_ivec2",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::UVec2::as_ivec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_u64vec2",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::UVec2::as_u64vec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec2",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::UVec2::as_vec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: () = <bevy::math::UVec2 as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::UVec2>,
                    min: Val<bevy::math::UVec2>,
                    max: Val<bevy::math::UVec2>|
                {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::UVec2>, rhs: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Div<
                        &bevy::math::UVec2,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Div<
                        bevy::math::UVec2,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::UVec2>, rhs: u32| {
                    let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Div<
                        u32,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: u32 = bevy::math::UVec2::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::UVec2>| {
                    let output: u32 = bevy::math::UVec2::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::UVec2>| {
                    let output: u32 = bevy::math::UVec2::element_sum(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::UVec2>, other: Ref<bevy::math::UVec2>| {
                    let output: bool = <bevy::math::UVec2 as std::cmp::PartialEq<
                        bevy::math::UVec2,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "extend",
                |_self: Val<bevy::math::UVec2>, z: u32| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec2::extend(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [u32; 2]| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::from_array(a)
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::UVec2>| {
                    let output: u32 = bevy::math::UVec2::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::UVec2>| {
                    let output: u32 = bevy::math::UVec2::max_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::UVec2>| {
                    let output: u32 = bevy::math::UVec2::min_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Mul<
                        bevy::math::UVec2,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::UVec2>, rhs: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Mul<
                        &bevy::math::UVec2,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::UVec2>, rhs: u32| {
                    let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Mul<
                        u32,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: u32, y: u32| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::new(x, y)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Rem<
                        bevy::math::UVec2,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::UVec2>, rhs: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Rem<
                        &bevy::math::UVec2,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::UVec2>, rhs: u32| {
                    let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Rem<
                        u32,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "saturating_add",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add_signed",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_add_signed(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_div",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_mul",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec2>,
                    if_true: Val<bevy::math::UVec2>,
                    if_false: Val<bevy::math::UVec2>|
                {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: u32| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::UVec2>, rhs: u32| {
                    let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Sub<
                        u32,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::UVec2>, rhs: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Sub<
                        &bevy::math::UVec2,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Sub<
                        bevy::math::UVec2,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: [u32; 2] = bevy::math::UVec2::to_array(&_self).into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::UVec2>, x: u32| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::UVec2>, y: u32| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add_signed",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_add_signed(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_div",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_mul",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_sub",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::UVec3>::new(world)
            .register(
                "add",
                |_self: Val<bevy::math::UVec3>, rhs: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Add<
                        &bevy::math::UVec3,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::UVec3>, rhs: u32| {
                    let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Add<
                        u32,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Add<
                        bevy::math::UVec3,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "as_dvec3",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::UVec3::as_dvec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_i64vec3",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::UVec3::as_i64vec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_ivec3",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::UVec3::as_ivec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_u64vec3",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::UVec3::as_u64vec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec3",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::UVec3::as_vec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec3a",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::UVec3::as_vec3a(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: () = <bevy::math::UVec3 as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::UVec3>,
                    min: Val<bevy::math::UVec3>,
                    max: Val<bevy::math::UVec3>|
                {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cross",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::cross(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Div<
                        bevy::math::UVec3,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::UVec3>, rhs: u32| {
                    let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Div<
                        u32,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::UVec3>, rhs: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Div<
                        &bevy::math::UVec3,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: u32 = bevy::math::UVec3::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::UVec3>| {
                    let output: u32 = bevy::math::UVec3::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::UVec3>| {
                    let output: u32 = bevy::math::UVec3::element_sum(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::UVec3>, other: Ref<bevy::math::UVec3>| {
                    let output: bool = <bevy::math::UVec3 as std::cmp::PartialEq<
                        bevy::math::UVec3,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "extend",
                |_self: Val<bevy::math::UVec3>, w: u32| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec3::extend(
                            _self.into_inner(),
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [u32; 3]| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::from_array(a)
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::UVec3>| {
                    let output: u32 = bevy::math::UVec3::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::UVec3>| {
                    let output: u32 = bevy::math::UVec3::max_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::UVec3>| {
                    let output: u32 = bevy::math::UVec3::min_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::UVec3>, rhs: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Mul<
                        &bevy::math::UVec3,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::UVec3>, rhs: u32| {
                    let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Mul<
                        u32,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Mul<
                        bevy::math::UVec3,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: u32, y: u32, z: u32| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::new(x, y, z)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::UVec3>, rhs: u32| {
                    let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Rem<
                        u32,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::UVec3>, rhs: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Rem<
                        &bevy::math::UVec3,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Rem<
                        bevy::math::UVec3,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "saturating_add",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add_signed",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_add_signed(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_div",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_mul",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec3>,
                    if_true: Val<bevy::math::UVec3>,
                    if_false: Val<bevy::math::UVec3>|
                {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: u32| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::UVec3>, rhs: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Sub<
                        &bevy::math::UVec3,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::UVec3>, rhs: u32| {
                    let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Sub<
                        u32,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Sub<
                        bevy::math::UVec3,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: [u32; 3] = bevy::math::UVec3::to_array(&_self).into();
                    output
                },
            )
            .register(
                "truncate",
                |_self: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::UVec3::truncate(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::UVec3>, x: u32| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::UVec3>, y: u32| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_z",
                |_self: Val<bevy::math::UVec3>, z: u32| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::with_z(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add_signed",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_add_signed(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_div",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_mul",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_sub",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::UVec4>::new(world)
            .register(
                "add",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Add<
                        bevy::math::UVec4,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::UVec4>, rhs: u32| {
                    let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Add<
                        u32,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::UVec4>, rhs: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Add<
                        &bevy::math::UVec4,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "as_dvec4",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::UVec4::as_dvec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_i64vec4",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::UVec4::as_i64vec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_ivec4",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::UVec4::as_ivec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_u64vec4",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::UVec4::as_u64vec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec4",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::UVec4::as_vec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: () = <bevy::math::UVec4 as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::UVec4>,
                    min: Val<bevy::math::UVec4>,
                    max: Val<bevy::math::UVec4>|
                {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::UVec4>, rhs: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Div<
                        &bevy::math::UVec4,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::UVec4>, rhs: u32| {
                    let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Div<
                        u32,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Div<
                        bevy::math::UVec4,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: u32 = bevy::math::UVec4::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::UVec4>| {
                    let output: u32 = bevy::math::UVec4::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::UVec4>| {
                    let output: u32 = bevy::math::UVec4::element_sum(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::UVec4>, other: Ref<bevy::math::UVec4>| {
                    let output: bool = <bevy::math::UVec4 as std::cmp::PartialEq<
                        bevy::math::UVec4,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [u32; 4]| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::from_array(a)
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::UVec4>| {
                    let output: u32 = bevy::math::UVec4::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::UVec4>| {
                    let output: u32 = bevy::math::UVec4::max_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::UVec4>| {
                    let output: u32 = bevy::math::UVec4::min_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::UVec4>, rhs: u32| {
                    let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Mul<
                        u32,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Mul<
                        bevy::math::UVec4,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::UVec4>, rhs: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Mul<
                        &bevy::math::UVec4,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: u32, y: u32, z: u32, w: u32| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::new(
                            x,
                            y,
                            z,
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Rem<
                        bevy::math::UVec4,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::UVec4>, rhs: u32| {
                    let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Rem<
                        u32,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::UVec4>, rhs: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Rem<
                        &bevy::math::UVec4,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "saturating_add",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add_signed",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_add_signed(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_div",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_mul",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec4>,
                    if_true: Val<bevy::math::UVec4>,
                    if_false: Val<bevy::math::UVec4>|
                {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: u32| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::UVec4>, rhs: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Sub<
                        &bevy::math::UVec4,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::UVec4>, rhs: u32| {
                    let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Sub<
                        u32,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Sub<
                        bevy::math::UVec4,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: [u32; 4] = bevy::math::UVec4::to_array(&_self).into();
                    output
                },
            )
            .register(
                "truncate",
                |_self: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::UVec4::truncate(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_w",
                |_self: Val<bevy::math::UVec4>, w: u32| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::with_w(
                            _self.into_inner(),
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::UVec4>, x: u32| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::UVec4>, y: u32| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_z",
                |_self: Val<bevy::math::UVec4>, z: u32| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::with_z(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add_signed",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_add_signed(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_div",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_mul",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_sub",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::U64Vec2>::new(world)
            .register(
                "add",
                |_self: Val<bevy::math::U64Vec2>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Add<
                        u64,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::U64Vec2>, rhs: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Add<
                        &bevy::math::U64Vec2,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Add<
                        bevy::math::U64Vec2,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "as_dvec2",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::U64Vec2::as_dvec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_i64vec2",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::U64Vec2::as_i64vec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_ivec2",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::U64Vec2::as_ivec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_uvec2",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::U64Vec2::as_uvec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec2",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::U64Vec2::as_vec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: () = <bevy::math::U64Vec2 as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::U64Vec2>,
                    min: Val<bevy::math::U64Vec2>,
                    max: Val<bevy::math::U64Vec2>|
                {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Div<
                        bevy::math::U64Vec2,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::U64Vec2>, rhs: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Div<
                        &bevy::math::U64Vec2,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::U64Vec2>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Div<
                        u64,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: u64 = bevy::math::U64Vec2::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::U64Vec2>| {
                    let output: u64 = bevy::math::U64Vec2::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::U64Vec2>| {
                    let output: u64 = bevy::math::U64Vec2::element_sum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::U64Vec2>, other: Ref<bevy::math::U64Vec2>| {
                    let output: bool = <bevy::math::U64Vec2 as std::cmp::PartialEq<
                        bevy::math::U64Vec2,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "extend",
                |_self: Val<bevy::math::U64Vec2>, z: u64| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec2::extend(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [u64; 2]| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::from_array(
                            a,
                        )
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::U64Vec2>| {
                    let output: u64 = bevy::math::U64Vec2::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::U64Vec2>| {
                    let output: u64 = bevy::math::U64Vec2::max_element(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::U64Vec2>| {
                    let output: u64 = bevy::math::U64Vec2::min_element(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Mul<
                        bevy::math::U64Vec2,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::U64Vec2>, rhs: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Mul<
                        &bevy::math::U64Vec2,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::U64Vec2>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Mul<
                        u64,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: u64, y: u64| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::new(x, y)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Rem<
                        bevy::math::U64Vec2,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::U64Vec2>, rhs: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Rem<
                        &bevy::math::U64Vec2,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::U64Vec2>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Rem<
                        u64,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "saturating_add",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add_signed",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_add_signed(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_div",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_mul",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec2>,
                    if_true: Val<bevy::math::U64Vec2>,
                    if_false: Val<bevy::math::U64Vec2>|
                {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: u64| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::U64Vec2>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Sub<
                        u64,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::U64Vec2>, rhs: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Sub<
                        &bevy::math::U64Vec2,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Sub<
                        bevy::math::U64Vec2,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: [u64; 2] = bevy::math::U64Vec2::to_array(&_self).into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::U64Vec2>, x: u64| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::U64Vec2>, y: u64| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add_signed",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_add_signed(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_div",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_mul",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_sub",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::U64Vec3>::new(world)
            .register(
                "add",
                |_self: Val<bevy::math::U64Vec3>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Add<
                        u64,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::U64Vec3>, rhs: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Add<
                        &bevy::math::U64Vec3,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Add<
                        bevy::math::U64Vec3,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "as_dvec3",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::U64Vec3::as_dvec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_i64vec3",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::U64Vec3::as_i64vec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_ivec3",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::U64Vec3::as_ivec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_uvec3",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::U64Vec3::as_uvec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec3",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::U64Vec3::as_vec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec3a",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::U64Vec3::as_vec3a(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: () = <bevy::math::U64Vec3 as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::U64Vec3>,
                    min: Val<bevy::math::U64Vec3>,
                    max: Val<bevy::math::U64Vec3>|
                {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cross",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::cross(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::U64Vec3>, rhs: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Div<
                        &bevy::math::U64Vec3,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::U64Vec3>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Div<
                        u64,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Div<
                        bevy::math::U64Vec3,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: u64 = bevy::math::U64Vec3::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::U64Vec3>| {
                    let output: u64 = bevy::math::U64Vec3::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::U64Vec3>| {
                    let output: u64 = bevy::math::U64Vec3::element_sum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::U64Vec3>, other: Ref<bevy::math::U64Vec3>| {
                    let output: bool = <bevy::math::U64Vec3 as std::cmp::PartialEq<
                        bevy::math::U64Vec3,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "extend",
                |_self: Val<bevy::math::U64Vec3>, w: u64| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec3::extend(
                            _self.into_inner(),
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [u64; 3]| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::from_array(
                            a,
                        )
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::U64Vec3>| {
                    let output: u64 = bevy::math::U64Vec3::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::U64Vec3>| {
                    let output: u64 = bevy::math::U64Vec3::max_element(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::U64Vec3>| {
                    let output: u64 = bevy::math::U64Vec3::min_element(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::U64Vec3>, rhs: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Mul<
                        &bevy::math::U64Vec3,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::U64Vec3>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Mul<
                        u64,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Mul<
                        bevy::math::U64Vec3,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: u64, y: u64, z: u64| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::new(
                            x,
                            y,
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::U64Vec3>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Rem<
                        u64,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::U64Vec3>, rhs: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Rem<
                        &bevy::math::U64Vec3,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Rem<
                        bevy::math::U64Vec3,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "saturating_add",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add_signed",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_add_signed(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_div",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_mul",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec3>,
                    if_true: Val<bevy::math::U64Vec3>,
                    if_false: Val<bevy::math::U64Vec3>|
                {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: u64| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Sub<
                        bevy::math::U64Vec3,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::U64Vec3>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Sub<
                        u64,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::U64Vec3>, rhs: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Sub<
                        &bevy::math::U64Vec3,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: [u64; 3] = bevy::math::U64Vec3::to_array(&_self).into();
                    output
                },
            )
            .register(
                "truncate",
                |_self: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec3::truncate(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::U64Vec3>, x: u64| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::U64Vec3>, y: u64| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_z",
                |_self: Val<bevy::math::U64Vec3>, z: u64| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::with_z(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add_signed",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_add_signed(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_div",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_mul",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_sub",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::U64Vec4>::new(world)
            .register(
                "add",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Add<
                        bevy::math::U64Vec4,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::U64Vec4>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Add<
                        u64,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::U64Vec4>, rhs: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Add<
                        &bevy::math::U64Vec4,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "as_dvec4",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::U64Vec4::as_dvec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_i64vec4",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::U64Vec4::as_i64vec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_ivec4",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::U64Vec4::as_ivec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_uvec4",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::UVec4> = bevy::math::U64Vec4::as_uvec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec4",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::U64Vec4::as_vec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: () = <bevy::math::U64Vec4 as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::U64Vec4>,
                    min: Val<bevy::math::U64Vec4>,
                    max: Val<bevy::math::U64Vec4>|
                {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::U64Vec4>, rhs: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Div<
                        &bevy::math::U64Vec4,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Div<
                        bevy::math::U64Vec4,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::U64Vec4>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Div<
                        u64,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: u64 = bevy::math::U64Vec4::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::U64Vec4>| {
                    let output: u64 = bevy::math::U64Vec4::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::U64Vec4>| {
                    let output: u64 = bevy::math::U64Vec4::element_sum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::U64Vec4>, other: Ref<bevy::math::U64Vec4>| {
                    let output: bool = <bevy::math::U64Vec4 as std::cmp::PartialEq<
                        bevy::math::U64Vec4,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [u64; 4]| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::from_array(
                            a,
                        )
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::U64Vec4>| {
                    let output: u64 = bevy::math::U64Vec4::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::U64Vec4>| {
                    let output: u64 = bevy::math::U64Vec4::max_element(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::U64Vec4>| {
                    let output: u64 = bevy::math::U64Vec4::min_element(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Mul<
                        bevy::math::U64Vec4,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::U64Vec4>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Mul<
                        u64,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::U64Vec4>, rhs: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Mul<
                        &bevy::math::U64Vec4,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: u64, y: u64, z: u64, w: u64| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::new(
                            x,
                            y,
                            z,
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Rem<
                        bevy::math::U64Vec4,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::U64Vec4>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Rem<
                        u64,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::U64Vec4>, rhs: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Rem<
                        &bevy::math::U64Vec4,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "saturating_add",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_add_signed",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_add_signed(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_div",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_mul",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "saturating_sub",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec4>,
                    if_true: Val<bevy::math::U64Vec4>,
                    if_false: Val<bevy::math::U64Vec4>|
                {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: u64| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::U64Vec4>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Sub<
                        u64,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::U64Vec4>, rhs: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Sub<
                        &bevy::math::U64Vec4,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Sub<
                        bevy::math::U64Vec4,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: [u64; 4] = bevy::math::U64Vec4::to_array(&_self).into();
                    output
                },
            )
            .register(
                "truncate",
                |_self: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec4::truncate(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_w",
                |_self: Val<bevy::math::U64Vec4>, w: u64| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::with_w(
                            _self.into_inner(),
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::U64Vec4>, x: u64| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::U64Vec4>, y: u64| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_z",
                |_self: Val<bevy::math::U64Vec4>, z: u64| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::with_z(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_add(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_add_signed",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_add_signed(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_div",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_div(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_mul",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_mul(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "wrapping_sub",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_sub(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::Vec2>::new(world)
            .register(
                "abs",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::abs(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "abs_diff_eq",
                |
                    _self: Val<bevy::math::Vec2>,
                    rhs: Val<bevy::math::Vec2>,
                    max_abs_diff: f32|
                {
                    let output: bool = bevy::math::Vec2::abs_diff_eq(
                            _self.into_inner(),
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::Vec2>, rhs: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Add<
                        &bevy::math::Vec2,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::Vec2>, rhs: f32| {
                    let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Add<
                        f32,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Add<
                        bevy::math::Vec2,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "angle_between",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: f32 = bevy::math::Vec2::angle_between(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "angle_to",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: f32 = bevy::math::Vec2::angle_to(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_dvec2",
                |_self: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::Vec2::as_dvec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_i64vec2",
                |_self: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::Vec2::as_i64vec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_ivec2",
                |_self: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::Vec2::as_ivec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_u64vec2",
                |_self: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::Vec2::as_u64vec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_uvec2",
                |_self: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::Vec2::as_uvec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "ceil",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::ceil(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::Vec2>,
                    min: Val<bevy::math::Vec2>,
                    max: Val<bevy::math::Vec2>|
                {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length",
                |_self: Val<bevy::math::Vec2>, min: f32, max: f32| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::clamp_length(
                            _self.into_inner(),
                            min,
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length_max",
                |_self: Val<bevy::math::Vec2>, max: f32| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::clamp_length_max(
                            _self.into_inner(),
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length_min",
                |_self: Val<bevy::math::Vec2>, min: f32| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::clamp_length_min(
                            _self.into_inner(),
                            min,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "copysign",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::copysign(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: f32 = bevy::math::Vec2::distance(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance_squared",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: f32 = bevy::math::Vec2::distance_squared(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Div<
                        bevy::math::Vec2,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::Vec2>, rhs: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Div<
                        &bevy::math::Vec2,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::Vec2>, rhs: f32| {
                    let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Div<
                        f32,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div_euclid",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::div_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: f32 = bevy::math::Vec2::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::Vec2>| {
                    let output: f32 = bevy::math::Vec2::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::Vec2>| {
                    let output: f32 = bevy::math::Vec2::element_sum(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::Vec2>, other: Ref<bevy::math::Vec2>| {
                    let output: bool = <bevy::math::Vec2 as std::cmp::PartialEq<
                        bevy::math::Vec2,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "exp",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::exp(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "extend",
                |_self: Val<bevy::math::Vec2>, z: f32| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec2::extend(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "floor",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::floor(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "fract",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::fract(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "fract_gl",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::fract_gl(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_angle",
                |angle: f32| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::from_angle(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [f32; 2]| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::from_array(a)
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Val<bevy::math::Vec2>| {
                    let output: bool = bevy::math::Vec2::is_finite(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_finite_mask",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::Vec2::is_finite_mask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Val<bevy::math::Vec2>| {
                    let output: bool = bevy::math::Vec2::is_nan(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_nan_mask",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::Vec2::is_nan_mask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_negative_bitmask",
                |_self: Val<bevy::math::Vec2>| {
                    let output: u32 = bevy::math::Vec2::is_negative_bitmask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_normalized",
                |_self: Val<bevy::math::Vec2>| {
                    let output: bool = bevy::math::Vec2::is_normalized(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "length",
                |_self: Val<bevy::math::Vec2>| {
                    let output: f32 = bevy::math::Vec2::length(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_recip",
                |_self: Val<bevy::math::Vec2>| {
                    let output: f32 = bevy::math::Vec2::length_recip(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::Vec2>| {
                    let output: f32 = bevy::math::Vec2::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "lerp",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>, s: f32| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::lerp(
                            _self.into_inner(),
                            rhs.into_inner(),
                            s,
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::Vec2>| {
                    let output: f32 = bevy::math::Vec2::max_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "midpoint",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::midpoint(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::Vec2>| {
                    let output: f32 = bevy::math::Vec2::min_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "move_towards",
                |_self: Ref<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>, d: f32| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::move_towards(
                            &_self,
                            rhs.into_inner(),
                            d,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Vec2>, rhs: f32| {
                    let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Mul<
                        f32,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Vec2>, rhs: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Mul<
                        &bevy::math::Vec2,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Mul<
                        bevy::math::Vec2,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul_add",
                |
                    _self: Val<bevy::math::Vec2>,
                    a: Val<bevy::math::Vec2>,
                    b: Val<bevy::math::Vec2>|
                {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::mul_add(
                            _self.into_inner(),
                            a.into_inner(),
                            b.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: f32, y: f32| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::new(x, y)
                        .into();
                    output
                },
            )
            .register(
                "normalize",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::normalize(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "normalize_or",
                |_self: Val<bevy::math::Vec2>, fallback: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::normalize_or(
                            _self.into_inner(),
                            fallback.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "normalize_or_zero",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::normalize_or_zero(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "perp",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::perp(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "perp_dot",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: f32 = bevy::math::Vec2::perp_dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "powf",
                |_self: Val<bevy::math::Vec2>, n: f32| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::powf(
                            _self.into_inner(),
                            n,
                        )
                        .into();
                    output
                },
            )
            .register(
                "project_onto",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::project_onto(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "project_onto_normalized",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::project_onto_normalized(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "recip",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::recip(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "reflect",
                |_self: Val<bevy::math::Vec2>, normal: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::reflect(
                            _self.into_inner(),
                            normal.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "refract",
                |_self: Val<bevy::math::Vec2>, normal: Val<bevy::math::Vec2>, eta: f32| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::refract(
                            _self.into_inner(),
                            normal.into_inner(),
                            eta,
                        )
                        .into();
                    output
                },
            )
            .register(
                "reject_from",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::reject_from(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "reject_from_normalized",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::reject_from_normalized(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::Vec2>, rhs: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Rem<
                        &bevy::math::Vec2,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::Vec2>, rhs: f32| {
                    let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Rem<
                        f32,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Rem<
                        bevy::math::Vec2,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "rem_euclid",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::rem_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rotate",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::rotate(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rotate_towards",
                |
                    _self: Ref<bevy::math::Vec2>,
                    rhs: Val<bevy::math::Vec2>,
                    max_angle: f32|
                {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::rotate_towards(
                            &_self,
                            rhs.into_inner(),
                            max_angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "round",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::round(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec2>,
                    if_true: Val<bevy::math::Vec2>,
                    if_false: Val<bevy::math::Vec2>|
                {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "signum",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::signum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: f32| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Sub<
                        bevy::math::Vec2,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::Vec2>, rhs: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Sub<
                        &bevy::math::Vec2,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::Vec2>, rhs: f32| {
                    let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Sub<
                        f32,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "to_angle",
                |_self: Val<bevy::math::Vec2>| {
                    let output: f32 = bevy::math::Vec2::to_angle(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::Vec2>| {
                    let output: [f32; 2] = bevy::math::Vec2::to_array(&_self).into();
                    output
                },
            )
            .register(
                "trunc",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::trunc(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::Vec2>, x: f32| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::Vec2>, y: f32| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec2::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::Vec3A>::new(world)
            .register(
                "abs",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::abs(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "abs_diff_eq",
                |
                    _self: Val<bevy::math::Vec3A>,
                    rhs: Val<bevy::math::Vec3A>,
                    max_abs_diff: f32|
                {
                    let output: bool = bevy::math::Vec3A::abs_diff_eq(
                            _self.into_inner(),
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Add<
                        &bevy::math::Vec3A,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::Vec3A>, rhs: f32| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Add<
                        f32,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Add<
                        bevy::math::Vec3A,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "angle_between",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: f32 = bevy::math::Vec3A::angle_between(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "any_orthogonal_vector",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::any_orthogonal_vector(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "any_orthonormal_vector",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::any_orthonormal_vector(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_dvec3",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::Vec3A::as_dvec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_i64vec3",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::Vec3A::as_i64vec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_ivec3",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::Vec3A::as_ivec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_u64vec3",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::Vec3A::as_u64vec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_uvec3",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::Vec3A::as_uvec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "ceil",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::ceil(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::Vec3A>,
                    min: Val<bevy::math::Vec3A>,
                    max: Val<bevy::math::Vec3A>|
                {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length",
                |_self: Val<bevy::math::Vec3A>, min: f32, max: f32| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::clamp_length(
                            _self.into_inner(),
                            min,
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length_max",
                |_self: Val<bevy::math::Vec3A>, max: f32| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::clamp_length_max(
                            _self.into_inner(),
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length_min",
                |_self: Val<bevy::math::Vec3A>, min: f32| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::clamp_length_min(
                            _self.into_inner(),
                            min,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "copysign",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::copysign(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cross",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::cross(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: f32 = bevy::math::Vec3A::distance(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance_squared",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: f32 = bevy::math::Vec3A::distance_squared(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Div<
                        bevy::math::Vec3A,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::Vec3A>, rhs: f32| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Div<
                        f32,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Div<
                        &bevy::math::Vec3A,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "div_euclid",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::div_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: f32 = bevy::math::Vec3A::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: f32 = bevy::math::Vec3A::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: f32 = bevy::math::Vec3A::element_sum(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>| {
                    let output: bool = <bevy::math::Vec3A as std::cmp::PartialEq<
                        bevy::math::Vec3A,
                    >>::eq(&_self, &rhs)
                        .into();
                    output
                },
            )
            .register(
                "exp",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::exp(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "extend",
                |_self: Val<bevy::math::Vec3A>, w: f32| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec3A::extend(
                            _self.into_inner(),
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "floor",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::floor(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "fract",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::fract(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "fract_gl",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::fract_gl(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [f32; 3]| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::from_array(a)
                        .into();
                    output
                },
            )
            .register(
                "from_vec4",
                |v: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::from_vec4(
                            v.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: bool = bevy::math::Vec3A::is_finite(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_finite_mask",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::is_finite_mask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: bool = bevy::math::Vec3A::is_nan(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_nan_mask",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::is_nan_mask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_negative_bitmask",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: u32 = bevy::math::Vec3A::is_negative_bitmask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_normalized",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: bool = bevy::math::Vec3A::is_normalized(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "length",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: f32 = bevy::math::Vec3A::length(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_recip",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: f32 = bevy::math::Vec3A::length_recip(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: f32 = bevy::math::Vec3A::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "lerp",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>, s: f32| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::lerp(
                            _self.into_inner(),
                            rhs.into_inner(),
                            s,
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: f32 = bevy::math::Vec3A::max_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "midpoint",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::midpoint(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: f32 = bevy::math::Vec3A::min_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "move_towards",
                |_self: Ref<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>, d: f32| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::move_towards(
                            &_self,
                            rhs.into_inner(),
                            d,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Vec3A>, rhs: f32| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Mul<
                        f32,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Mul<
                        bevy::math::Vec3A,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Mul<
                        &bevy::math::Vec3A,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul_add",
                |
                    _self: Val<bevy::math::Vec3A>,
                    a: Val<bevy::math::Vec3A>,
                    b: Val<bevy::math::Vec3A>|
                {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::mul_add(
                            _self.into_inner(),
                            a.into_inner(),
                            b.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: f32, y: f32, z: f32| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::new(x, y, z)
                        .into();
                    output
                },
            )
            .register(
                "normalize",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::normalize(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "normalize_or",
                |_self: Val<bevy::math::Vec3A>, fallback: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::normalize_or(
                            _self.into_inner(),
                            fallback.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "normalize_or_zero",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::normalize_or_zero(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "powf",
                |_self: Val<bevy::math::Vec3A>, n: f32| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::powf(
                            _self.into_inner(),
                            n,
                        )
                        .into();
                    output
                },
            )
            .register(
                "project_onto",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::project_onto(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "project_onto_normalized",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::project_onto_normalized(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "recip",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::recip(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "reflect",
                |_self: Val<bevy::math::Vec3A>, normal: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::reflect(
                            _self.into_inner(),
                            normal.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "refract",
                |
                    _self: Val<bevy::math::Vec3A>,
                    normal: Val<bevy::math::Vec3A>,
                    eta: f32|
                {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::refract(
                            _self.into_inner(),
                            normal.into_inner(),
                            eta,
                        )
                        .into();
                    output
                },
            )
            .register(
                "reject_from",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::reject_from(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "reject_from_normalized",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::reject_from_normalized(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::Vec3A>, rhs: f32| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Rem<
                        f32,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Rem<
                        &bevy::math::Vec3A,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Rem<
                        bevy::math::Vec3A,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "rem_euclid",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::rem_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "round",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::round(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec3A>,
                    if_true: Val<bevy::math::Vec3A>,
                    if_false: Val<bevy::math::Vec3A>|
                {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "signum",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::signum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: f32| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::Vec3A>, rhs: f32| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Sub<
                        f32,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Sub<
                        bevy::math::Vec3A,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Sub<
                        &bevy::math::Vec3A,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: [f32; 3] = bevy::math::Vec3A::to_array(&_self).into();
                    output
                },
            )
            .register(
                "trunc",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::trunc(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "truncate",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Vec3A::truncate(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::Vec3A>, x: f32| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::Vec3A>, y: f32| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_z",
                |_self: Val<bevy::math::Vec3A>, z: f32| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::with_z(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::Vec4>::new(world)
            .register(
                "abs",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::abs(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "abs_diff_eq",
                |
                    _self: Val<bevy::math::Vec4>,
                    rhs: Val<bevy::math::Vec4>,
                    max_abs_diff: f32|
                {
                    let output: bool = bevy::math::Vec4::abs_diff_eq(
                            _self.into_inner(),
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Add<
                        &bevy::math::Vec4,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Add<
                        bevy::math::Vec4,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::Vec4>, rhs: f32| {
                    let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Add<
                        f32,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "as_dvec4",
                |_self: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::Vec4::as_dvec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_i64vec4",
                |_self: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::Vec4::as_i64vec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_ivec4",
                |_self: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::Vec4::as_ivec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_u64vec4",
                |_self: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::Vec4::as_u64vec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_uvec4",
                |_self: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::UVec4> = bevy::math::Vec4::as_uvec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "ceil",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::ceil(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::Vec4>,
                    min: Val<bevy::math::Vec4>,
                    max: Val<bevy::math::Vec4>|
                {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length",
                |_self: Val<bevy::math::Vec4>, min: f32, max: f32| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::clamp_length(
                            _self.into_inner(),
                            min,
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length_max",
                |_self: Val<bevy::math::Vec4>, max: f32| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::clamp_length_max(
                            _self.into_inner(),
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length_min",
                |_self: Val<bevy::math::Vec4>, min: f32| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::clamp_length_min(
                            _self.into_inner(),
                            min,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "copysign",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::copysign(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: f32 = bevy::math::Vec4::distance(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance_squared",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: f32 = bevy::math::Vec4::distance_squared(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Div<
                        &bevy::math::Vec4,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Div<
                        bevy::math::Vec4,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::Vec4>, rhs: f32| {
                    let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Div<
                        f32,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div_euclid",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::div_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: f32 = bevy::math::Vec4::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::Vec4>| {
                    let output: f32 = bevy::math::Vec4::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::Vec4>| {
                    let output: f32 = bevy::math::Vec4::element_sum(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>| {
                    let output: bool = <bevy::math::Vec4 as std::cmp::PartialEq<
                        bevy::math::Vec4,
                    >>::eq(&_self, &rhs)
                        .into();
                    output
                },
            )
            .register(
                "exp",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::exp(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "floor",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::floor(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "fract",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::fract(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "fract_gl",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::fract_gl(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [f32; 4]| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::from_array(a)
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Val<bevy::math::Vec4>| {
                    let output: bool = bevy::math::Vec4::is_finite(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_finite_mask",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::is_finite_mask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Val<bevy::math::Vec4>| {
                    let output: bool = bevy::math::Vec4::is_nan(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_nan_mask",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::is_nan_mask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_negative_bitmask",
                |_self: Val<bevy::math::Vec4>| {
                    let output: u32 = bevy::math::Vec4::is_negative_bitmask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_normalized",
                |_self: Val<bevy::math::Vec4>| {
                    let output: bool = bevy::math::Vec4::is_normalized(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "length",
                |_self: Val<bevy::math::Vec4>| {
                    let output: f32 = bevy::math::Vec4::length(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_recip",
                |_self: Val<bevy::math::Vec4>| {
                    let output: f32 = bevy::math::Vec4::length_recip(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::Vec4>| {
                    let output: f32 = bevy::math::Vec4::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "lerp",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>, s: f32| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::lerp(
                            _self.into_inner(),
                            rhs.into_inner(),
                            s,
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::Vec4>| {
                    let output: f32 = bevy::math::Vec4::max_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "midpoint",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::midpoint(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::Vec4>| {
                    let output: f32 = bevy::math::Vec4::min_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "move_towards",
                |_self: Ref<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>, d: f32| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::move_towards(
                            &_self,
                            rhs.into_inner(),
                            d,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Vec4>, rhs: f32| {
                    let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Mul<
                        f32,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Mul<
                        bevy::math::Vec4,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Mul<
                        &bevy::math::Vec4,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul_add",
                |
                    _self: Val<bevy::math::Vec4>,
                    a: Val<bevy::math::Vec4>,
                    b: Val<bevy::math::Vec4>|
                {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::mul_add(
                            _self.into_inner(),
                            a.into_inner(),
                            b.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: f32, y: f32, z: f32, w: f32| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::new(x, y, z, w)
                        .into();
                    output
                },
            )
            .register(
                "normalize",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::normalize(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "normalize_or",
                |_self: Val<bevy::math::Vec4>, fallback: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::normalize_or(
                            _self.into_inner(),
                            fallback.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "normalize_or_zero",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::normalize_or_zero(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "powf",
                |_self: Val<bevy::math::Vec4>, n: f32| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::powf(
                            _self.into_inner(),
                            n,
                        )
                        .into();
                    output
                },
            )
            .register(
                "project_onto",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::project_onto(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "project_onto_normalized",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::project_onto_normalized(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "recip",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::recip(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "reflect",
                |_self: Val<bevy::math::Vec4>, normal: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::reflect(
                            _self.into_inner(),
                            normal.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "refract",
                |_self: Val<bevy::math::Vec4>, normal: Val<bevy::math::Vec4>, eta: f32| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::refract(
                            _self.into_inner(),
                            normal.into_inner(),
                            eta,
                        )
                        .into();
                    output
                },
            )
            .register(
                "reject_from",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::reject_from(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "reject_from_normalized",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::reject_from_normalized(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::Vec4>, rhs: f32| {
                    let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Rem<
                        f32,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Rem<
                        &bevy::math::Vec4,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Rem<
                        bevy::math::Vec4,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "rem_euclid",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::rem_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "round",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::round(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec4A>,
                    if_true: Val<bevy::math::Vec4>,
                    if_false: Val<bevy::math::Vec4>|
                {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "signum",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::signum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: f32| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Sub<
                        bevy::math::Vec4,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::Vec4>, rhs: f32| {
                    let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Sub<
                        f32,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Sub<
                        &bevy::math::Vec4,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::Vec4>| {
                    let output: [f32; 4] = bevy::math::Vec4::to_array(&_self).into();
                    output
                },
            )
            .register(
                "trunc",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::trunc(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "truncate",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Vec4::truncate(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_w",
                |_self: Val<bevy::math::Vec4>, w: f32| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::with_w(
                            _self.into_inner(),
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::Vec4>, x: f32| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::Vec4>, y: f32| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_z",
                |_self: Val<bevy::math::Vec4>, z: f32| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Vec4::with_z(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::BVec2>::new(world)
            .register(
                "all",
                |_self: Val<bevy::math::BVec2>| {
                    let output: bool = bevy::math::BVec2::all(_self.into_inner()).into();
                    output
                },
            )
            .register(
                "any",
                |_self: Val<bevy::math::BVec2>| {
                    let output: bool = bevy::math::BVec2::any(_self.into_inner()).into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::BVec2>| {
                    let output: () = <bevy::math::BVec2 as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "bitmask",
                |_self: Val<bevy::math::BVec2>| {
                    let output: u32 = bevy::math::BVec2::bitmask(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::BVec2>| {
                    let output: Val<bevy::math::BVec2> = <bevy::math::BVec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::BVec2>, other: Ref<bevy::math::BVec2>| {
                    let output: bool = <bevy::math::BVec2 as std::cmp::PartialEq<
                        bevy::math::BVec2,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [bool; 2]| {
                    let output: Val<bevy::math::BVec2> = bevy::math::BVec2::from_array(a)
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: bool, y: bool| {
                    let output: Val<bevy::math::BVec2> = bevy::math::BVec2::new(x, y)
                        .into();
                    output
                },
            )
            .register(
                "set",
                |mut _self: Mut<bevy::math::BVec2>, index: usize, value: bool| {
                    let output: () = bevy::math::BVec2::set(&mut _self, index, value)
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: bool| {
                    let output: Val<bevy::math::BVec2> = bevy::math::BVec2::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "test",
                |_self: Ref<bevy::math::BVec2>, index: usize| {
                    let output: bool = bevy::math::BVec2::test(&_self, index).into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::BVec3>::new(world)
            .register(
                "all",
                |_self: Val<bevy::math::BVec3>| {
                    let output: bool = bevy::math::BVec3::all(_self.into_inner()).into();
                    output
                },
            )
            .register(
                "any",
                |_self: Val<bevy::math::BVec3>| {
                    let output: bool = bevy::math::BVec3::any(_self.into_inner()).into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::BVec3>| {
                    let output: () = <bevy::math::BVec3 as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "bitmask",
                |_self: Val<bevy::math::BVec3>| {
                    let output: u32 = bevy::math::BVec3::bitmask(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::BVec3>| {
                    let output: Val<bevy::math::BVec3> = <bevy::math::BVec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::BVec3>, other: Ref<bevy::math::BVec3>| {
                    let output: bool = <bevy::math::BVec3 as std::cmp::PartialEq<
                        bevy::math::BVec3,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [bool; 3]| {
                    let output: Val<bevy::math::BVec3> = bevy::math::BVec3::from_array(a)
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: bool, y: bool, z: bool| {
                    let output: Val<bevy::math::BVec3> = bevy::math::BVec3::new(x, y, z)
                        .into();
                    output
                },
            )
            .register(
                "set",
                |mut _self: Mut<bevy::math::BVec3>, index: usize, value: bool| {
                    let output: () = bevy::math::BVec3::set(&mut _self, index, value)
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: bool| {
                    let output: Val<bevy::math::BVec3> = bevy::math::BVec3::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "test",
                |_self: Ref<bevy::math::BVec3>, index: usize| {
                    let output: bool = bevy::math::BVec3::test(&_self, index).into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::BVec4>::new(world)
            .register(
                "all",
                |_self: Val<bevy::math::BVec4>| {
                    let output: bool = bevy::math::BVec4::all(_self.into_inner()).into();
                    output
                },
            )
            .register(
                "any",
                |_self: Val<bevy::math::BVec4>| {
                    let output: bool = bevy::math::BVec4::any(_self.into_inner()).into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::BVec4>| {
                    let output: () = <bevy::math::BVec4 as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "bitmask",
                |_self: Val<bevy::math::BVec4>| {
                    let output: u32 = bevy::math::BVec4::bitmask(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::BVec4>| {
                    let output: Val<bevy::math::BVec4> = <bevy::math::BVec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::BVec4>, other: Ref<bevy::math::BVec4>| {
                    let output: bool = <bevy::math::BVec4 as std::cmp::PartialEq<
                        bevy::math::BVec4,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [bool; 4]| {
                    let output: Val<bevy::math::BVec4> = bevy::math::BVec4::from_array(a)
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: bool, y: bool, z: bool, w: bool| {
                    let output: Val<bevy::math::BVec4> = bevy::math::BVec4::new(
                            x,
                            y,
                            z,
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "set",
                |mut _self: Mut<bevy::math::BVec4>, index: usize, value: bool| {
                    let output: () = bevy::math::BVec4::set(&mut _self, index, value)
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: bool| {
                    let output: Val<bevy::math::BVec4> = bevy::math::BVec4::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "test",
                |_self: Ref<bevy::math::BVec4>, index: usize| {
                    let output: bool = bevy::math::BVec4::test(&_self, index).into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::DVec2>::new(world)
            .register(
                "abs",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::abs(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "abs_diff_eq",
                |
                    _self: Val<bevy::math::DVec2>,
                    rhs: Val<bevy::math::DVec2>,
                    max_abs_diff: f64|
                {
                    let output: bool = bevy::math::DVec2::abs_diff_eq(
                            _self.into_inner(),
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Add<
                        bevy::math::DVec2,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::DVec2>, rhs: f64| {
                    let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Add<
                        f64,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::DVec2>, rhs: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Add<
                        &bevy::math::DVec2,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "angle_between",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: f64 = bevy::math::DVec2::angle_between(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "angle_to",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: f64 = bevy::math::DVec2::angle_to(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_i64vec2",
                |_self: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::I64Vec2> = bevy::math::DVec2::as_i64vec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_ivec2",
                |_self: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::IVec2> = bevy::math::DVec2::as_ivec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_u64vec2",
                |_self: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::U64Vec2> = bevy::math::DVec2::as_u64vec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_uvec2",
                |_self: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::UVec2> = bevy::math::DVec2::as_uvec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec2",
                |_self: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::DVec2::as_vec2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "ceil",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::ceil(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::DVec2>,
                    min: Val<bevy::math::DVec2>,
                    max: Val<bevy::math::DVec2>|
                {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length",
                |_self: Val<bevy::math::DVec2>, min: f64, max: f64| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::clamp_length(
                            _self.into_inner(),
                            min,
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length_max",
                |_self: Val<bevy::math::DVec2>, max: f64| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::clamp_length_max(
                            _self.into_inner(),
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length_min",
                |_self: Val<bevy::math::DVec2>, min: f64| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::clamp_length_min(
                            _self.into_inner(),
                            min,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "copysign",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::copysign(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: f64 = bevy::math::DVec2::distance(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance_squared",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: f64 = bevy::math::DVec2::distance_squared(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Div<
                        bevy::math::DVec2,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::DVec2>, rhs: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Div<
                        &bevy::math::DVec2,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::DVec2>, rhs: f64| {
                    let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Div<
                        f64,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div_euclid",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::div_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: f64 = bevy::math::DVec2::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::DVec2>| {
                    let output: f64 = bevy::math::DVec2::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::DVec2>| {
                    let output: f64 = bevy::math::DVec2::element_sum(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::DVec2>, other: Ref<bevy::math::DVec2>| {
                    let output: bool = <bevy::math::DVec2 as std::cmp::PartialEq<
                        bevy::math::DVec2,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "exp",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::exp(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "extend",
                |_self: Val<bevy::math::DVec2>, z: f64| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec2::extend(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "floor",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::floor(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "fract",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::fract(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "fract_gl",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::fract_gl(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_angle",
                |angle: f64| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::from_angle(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [f64; 2]| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::from_array(a)
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Val<bevy::math::DVec2>| {
                    let output: bool = bevy::math::DVec2::is_finite(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_finite_mask",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::DVec2::is_finite_mask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Val<bevy::math::DVec2>| {
                    let output: bool = bevy::math::DVec2::is_nan(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_nan_mask",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::BVec2> = bevy::math::DVec2::is_nan_mask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_negative_bitmask",
                |_self: Val<bevy::math::DVec2>| {
                    let output: u32 = bevy::math::DVec2::is_negative_bitmask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_normalized",
                |_self: Val<bevy::math::DVec2>| {
                    let output: bool = bevy::math::DVec2::is_normalized(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "length",
                |_self: Val<bevy::math::DVec2>| {
                    let output: f64 = bevy::math::DVec2::length(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_recip",
                |_self: Val<bevy::math::DVec2>| {
                    let output: f64 = bevy::math::DVec2::length_recip(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::DVec2>| {
                    let output: f64 = bevy::math::DVec2::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "lerp",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>, s: f64| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::lerp(
                            _self.into_inner(),
                            rhs.into_inner(),
                            s,
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::DVec2>| {
                    let output: f64 = bevy::math::DVec2::max_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "midpoint",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::midpoint(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::DVec2>| {
                    let output: f64 = bevy::math::DVec2::min_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "move_towards",
                |_self: Ref<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>, d: f64| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::move_towards(
                            &_self,
                            rhs.into_inner(),
                            d,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Mul<
                        bevy::math::DVec2,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DVec2>, rhs: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Mul<
                        &bevy::math::DVec2,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DVec2>, rhs: f64| {
                    let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Mul<
                        f64,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul_add",
                |
                    _self: Val<bevy::math::DVec2>,
                    a: Val<bevy::math::DVec2>,
                    b: Val<bevy::math::DVec2>|
                {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::mul_add(
                            _self.into_inner(),
                            a.into_inner(),
                            b.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: f64, y: f64| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::new(x, y)
                        .into();
                    output
                },
            )
            .register(
                "normalize",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::normalize(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "normalize_or",
                |_self: Val<bevy::math::DVec2>, fallback: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::normalize_or(
                            _self.into_inner(),
                            fallback.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "normalize_or_zero",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::normalize_or_zero(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "perp",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::perp(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "perp_dot",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: f64 = bevy::math::DVec2::perp_dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "powf",
                |_self: Val<bevy::math::DVec2>, n: f64| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::powf(
                            _self.into_inner(),
                            n,
                        )
                        .into();
                    output
                },
            )
            .register(
                "project_onto",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::project_onto(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "project_onto_normalized",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::project_onto_normalized(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "recip",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::recip(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "reflect",
                |_self: Val<bevy::math::DVec2>, normal: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::reflect(
                            _self.into_inner(),
                            normal.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "refract",
                |
                    _self: Val<bevy::math::DVec2>,
                    normal: Val<bevy::math::DVec2>,
                    eta: f64|
                {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::refract(
                            _self.into_inner(),
                            normal.into_inner(),
                            eta,
                        )
                        .into();
                    output
                },
            )
            .register(
                "reject_from",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::reject_from(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "reject_from_normalized",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::reject_from_normalized(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::DVec2>, rhs: f64| {
                    let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Rem<
                        f64,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::DVec2>, rhs: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Rem<
                        &bevy::math::DVec2,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Rem<
                        bevy::math::DVec2,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "rem_euclid",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::rem_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rotate",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::rotate(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rotate_towards",
                |
                    _self: Ref<bevy::math::DVec2>,
                    rhs: Val<bevy::math::DVec2>,
                    max_angle: f64|
                {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::rotate_towards(
                            &_self,
                            rhs.into_inner(),
                            max_angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "round",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::round(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec2>,
                    if_true: Val<bevy::math::DVec2>,
                    if_false: Val<bevy::math::DVec2>|
                {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "signum",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::signum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: f64| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::DVec2>, rhs: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Sub<
                        &bevy::math::DVec2,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Sub<
                        bevy::math::DVec2,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::DVec2>, rhs: f64| {
                    let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Sub<
                        f64,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "to_angle",
                |_self: Val<bevy::math::DVec2>| {
                    let output: f64 = bevy::math::DVec2::to_angle(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::DVec2>| {
                    let output: [f64; 2] = bevy::math::DVec2::to_array(&_self).into();
                    output
                },
            )
            .register(
                "trunc",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::trunc(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::DVec2>, x: f64| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::DVec2>, y: f64| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec2::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::DVec3>::new(world)
            .register(
                "abs",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::abs(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "abs_diff_eq",
                |
                    _self: Val<bevy::math::DVec3>,
                    rhs: Val<bevy::math::DVec3>,
                    max_abs_diff: f64|
                {
                    let output: bool = bevy::math::DVec3::abs_diff_eq(
                            _self.into_inner(),
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Add<
                        bevy::math::DVec3,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::DVec3>, rhs: f64| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Add<
                        f64,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::DVec3>, rhs: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Add<
                        &bevy::math::DVec3,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "angle_between",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: f64 = bevy::math::DVec3::angle_between(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "any_orthogonal_vector",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::any_orthogonal_vector(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "any_orthonormal_vector",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::any_orthonormal_vector(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_i64vec3",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::I64Vec3> = bevy::math::DVec3::as_i64vec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_ivec3",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::IVec3> = bevy::math::DVec3::as_ivec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_u64vec3",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::U64Vec3> = bevy::math::DVec3::as_u64vec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_uvec3",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::UVec3> = bevy::math::DVec3::as_uvec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec3",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::DVec3::as_vec3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec3a",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::DVec3::as_vec3a(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "ceil",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::ceil(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::DVec3>,
                    min: Val<bevy::math::DVec3>,
                    max: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length",
                |_self: Val<bevy::math::DVec3>, min: f64, max: f64| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::clamp_length(
                            _self.into_inner(),
                            min,
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length_max",
                |_self: Val<bevy::math::DVec3>, max: f64| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::clamp_length_max(
                            _self.into_inner(),
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length_min",
                |_self: Val<bevy::math::DVec3>, min: f64| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::clamp_length_min(
                            _self.into_inner(),
                            min,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "copysign",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::copysign(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cross",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::cross(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: f64 = bevy::math::DVec3::distance(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance_squared",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: f64 = bevy::math::DVec3::distance_squared(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::DVec3>, rhs: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Div<
                        &bevy::math::DVec3,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::DVec3>, rhs: f64| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Div<
                        f64,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Div<
                        bevy::math::DVec3,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "div_euclid",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::div_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: f64 = bevy::math::DVec3::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::DVec3>| {
                    let output: f64 = bevy::math::DVec3::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::DVec3>| {
                    let output: f64 = bevy::math::DVec3::element_sum(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::DVec3>, other: Ref<bevy::math::DVec3>| {
                    let output: bool = <bevy::math::DVec3 as std::cmp::PartialEq<
                        bevy::math::DVec3,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "exp",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::exp(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "extend",
                |_self: Val<bevy::math::DVec3>, w: f64| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec3::extend(
                            _self.into_inner(),
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "floor",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::floor(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "fract",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::fract(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "fract_gl",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::fract_gl(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [f64; 3]| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::from_array(a)
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Val<bevy::math::DVec3>| {
                    let output: bool = bevy::math::DVec3::is_finite(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_finite_mask",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::DVec3::is_finite_mask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Val<bevy::math::DVec3>| {
                    let output: bool = bevy::math::DVec3::is_nan(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_nan_mask",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::BVec3> = bevy::math::DVec3::is_nan_mask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_negative_bitmask",
                |_self: Val<bevy::math::DVec3>| {
                    let output: u32 = bevy::math::DVec3::is_negative_bitmask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_normalized",
                |_self: Val<bevy::math::DVec3>| {
                    let output: bool = bevy::math::DVec3::is_normalized(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "length",
                |_self: Val<bevy::math::DVec3>| {
                    let output: f64 = bevy::math::DVec3::length(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_recip",
                |_self: Val<bevy::math::DVec3>| {
                    let output: f64 = bevy::math::DVec3::length_recip(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::DVec3>| {
                    let output: f64 = bevy::math::DVec3::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "lerp",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>, s: f64| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::lerp(
                            _self.into_inner(),
                            rhs.into_inner(),
                            s,
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::DVec3>| {
                    let output: f64 = bevy::math::DVec3::max_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "midpoint",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::midpoint(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::DVec3>| {
                    let output: f64 = bevy::math::DVec3::min_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "move_towards",
                |_self: Ref<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>, d: f64| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::move_towards(
                            &_self,
                            rhs.into_inner(),
                            d,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DVec3>, rhs: f64| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Mul<
                        f64,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Mul<
                        bevy::math::DVec3,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DVec3>, rhs: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Mul<
                        &bevy::math::DVec3,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul_add",
                |
                    _self: Val<bevy::math::DVec3>,
                    a: Val<bevy::math::DVec3>,
                    b: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::mul_add(
                            _self.into_inner(),
                            a.into_inner(),
                            b.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: f64, y: f64, z: f64| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::new(x, y, z)
                        .into();
                    output
                },
            )
            .register(
                "normalize",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::normalize(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "normalize_or",
                |_self: Val<bevy::math::DVec3>, fallback: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::normalize_or(
                            _self.into_inner(),
                            fallback.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "normalize_or_zero",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::normalize_or_zero(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "powf",
                |_self: Val<bevy::math::DVec3>, n: f64| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::powf(
                            _self.into_inner(),
                            n,
                        )
                        .into();
                    output
                },
            )
            .register(
                "project_onto",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::project_onto(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "project_onto_normalized",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::project_onto_normalized(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "recip",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::recip(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "reflect",
                |_self: Val<bevy::math::DVec3>, normal: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::reflect(
                            _self.into_inner(),
                            normal.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "refract",
                |
                    _self: Val<bevy::math::DVec3>,
                    normal: Val<bevy::math::DVec3>,
                    eta: f64|
                {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::refract(
                            _self.into_inner(),
                            normal.into_inner(),
                            eta,
                        )
                        .into();
                    output
                },
            )
            .register(
                "reject_from",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::reject_from(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "reject_from_normalized",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::reject_from_normalized(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::DVec3>, rhs: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Rem<
                        &bevy::math::DVec3,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::DVec3>, rhs: f64| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Rem<
                        f64,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Rem<
                        bevy::math::DVec3,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "rem_euclid",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::rem_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "round",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::round(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec3>,
                    if_true: Val<bevy::math::DVec3>,
                    if_false: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "signum",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::signum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: f64| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::DVec3>, rhs: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Sub<
                        &bevy::math::DVec3,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Sub<
                        bevy::math::DVec3,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::DVec3>, rhs: f64| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Sub<
                        f64,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: [f64; 3] = bevy::math::DVec3::to_array(&_self).into();
                    output
                },
            )
            .register(
                "trunc",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::trunc(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "truncate",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DVec3::truncate(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::DVec3>, x: f64| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::DVec3>, y: f64| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_z",
                |_self: Val<bevy::math::DVec3>, z: f64| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec3::with_z(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::DVec4>::new(world)
            .register(
                "abs",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::abs(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "abs_diff_eq",
                |
                    _self: Val<bevy::math::DVec4>,
                    rhs: Val<bevy::math::DVec4>,
                    max_abs_diff: f64|
                {
                    let output: bool = bevy::math::DVec4::abs_diff_eq(
                            _self.into_inner(),
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Add<
                        bevy::math::DVec4,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::DVec4>, rhs: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Add<
                        &bevy::math::DVec4,
                    >>::add(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::DVec4>, rhs: f64| {
                    let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Add<
                        f64,
                    >>::add(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "as_i64vec4",
                |_self: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::I64Vec4> = bevy::math::DVec4::as_i64vec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_ivec4",
                |_self: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::IVec4> = bevy::math::DVec4::as_ivec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_u64vec4",
                |_self: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::U64Vec4> = bevy::math::DVec4::as_u64vec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_uvec4",
                |_self: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::UVec4> = bevy::math::DVec4::as_uvec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_vec4",
                |_self: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::DVec4::as_vec4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "ceil",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::ceil(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp",
                |
                    _self: Val<bevy::math::DVec4>,
                    min: Val<bevy::math::DVec4>,
                    max: Val<bevy::math::DVec4>|
                {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::clamp(
                            _self.into_inner(),
                            min.into_inner(),
                            max.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length",
                |_self: Val<bevy::math::DVec4>, min: f64, max: f64| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::clamp_length(
                            _self.into_inner(),
                            min,
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length_max",
                |_self: Val<bevy::math::DVec4>, max: f64| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::clamp_length_max(
                            _self.into_inner(),
                            max,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clamp_length_min",
                |_self: Val<bevy::math::DVec4>, min: f64| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::clamp_length_min(
                            _self.into_inner(),
                            min,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpeq",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmpeq(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpge",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmpge(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpgt",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmpgt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmple",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmple(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmplt",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmplt(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "cmpne",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmpne(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "copysign",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::copysign(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: f64 = bevy::math::DVec4::distance(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "distance_squared",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: f64 = bevy::math::DVec4::distance_squared(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::DVec4>, rhs: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Div<
                        &bevy::math::DVec4,
                    >>::div(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Div<
                        bevy::math::DVec4,
                    >>::div(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::DVec4>, rhs: f64| {
                    let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Div<
                        f64,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div_euclid",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::div_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: f64 = bevy::math::DVec4::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "dot_into_vec",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::dot_into_vec(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_product",
                |_self: Val<bevy::math::DVec4>| {
                    let output: f64 = bevy::math::DVec4::element_product(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "element_sum",
                |_self: Val<bevy::math::DVec4>| {
                    let output: f64 = bevy::math::DVec4::element_sum(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::DVec4>, other: Ref<bevy::math::DVec4>| {
                    let output: bool = <bevy::math::DVec4 as std::cmp::PartialEq<
                        bevy::math::DVec4,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "exp",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::exp(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "floor",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::floor(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "fract",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::fract(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "fract_gl",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::fract_gl(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [f64; 4]| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::from_array(a)
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Val<bevy::math::DVec4>| {
                    let output: bool = bevy::math::DVec4::is_finite(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_finite_mask",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::DVec4::is_finite_mask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Val<bevy::math::DVec4>| {
                    let output: bool = bevy::math::DVec4::is_nan(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_nan_mask",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::BVec4> = bevy::math::DVec4::is_nan_mask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_negative_bitmask",
                |_self: Val<bevy::math::DVec4>| {
                    let output: u32 = bevy::math::DVec4::is_negative_bitmask(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_normalized",
                |_self: Val<bevy::math::DVec4>| {
                    let output: bool = bevy::math::DVec4::is_normalized(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "length",
                |_self: Val<bevy::math::DVec4>| {
                    let output: f64 = bevy::math::DVec4::length(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_recip",
                |_self: Val<bevy::math::DVec4>| {
                    let output: f64 = bevy::math::DVec4::length_recip(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::DVec4>| {
                    let output: f64 = bevy::math::DVec4::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "lerp",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>, s: f64| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::lerp(
                            _self.into_inner(),
                            rhs.into_inner(),
                            s,
                        )
                        .into();
                    output
                },
            )
            .register(
                "max",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::max(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "max_element",
                |_self: Val<bevy::math::DVec4>| {
                    let output: f64 = bevy::math::DVec4::max_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "midpoint",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::midpoint(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::min(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "min_element",
                |_self: Val<bevy::math::DVec4>| {
                    let output: f64 = bevy::math::DVec4::min_element(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "move_towards",
                |_self: Ref<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>, d: f64| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::move_towards(
                            &_self,
                            rhs.into_inner(),
                            d,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DVec4>, rhs: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Mul<
                        &bevy::math::DVec4,
                    >>::mul(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DVec4>, rhs: f64| {
                    let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Mul<
                        f64,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Mul<
                        bevy::math::DVec4,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul_add",
                |
                    _self: Val<bevy::math::DVec4>,
                    a: Val<bevy::math::DVec4>,
                    b: Val<bevy::math::DVec4>|
                {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::mul_add(
                            _self.into_inner(),
                            a.into_inner(),
                            b.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: f64, y: f64, z: f64, w: f64| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::new(
                            x,
                            y,
                            z,
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "normalize",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::normalize(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "normalize_or",
                |_self: Val<bevy::math::DVec4>, fallback: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::normalize_or(
                            _self.into_inner(),
                            fallback.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "normalize_or_zero",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::normalize_or_zero(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "powf",
                |_self: Val<bevy::math::DVec4>, n: f64| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::powf(
                            _self.into_inner(),
                            n,
                        )
                        .into();
                    output
                },
            )
            .register(
                "project_onto",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::project_onto(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "project_onto_normalized",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::project_onto_normalized(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "recip",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::recip(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "reflect",
                |_self: Val<bevy::math::DVec4>, normal: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::reflect(
                            _self.into_inner(),
                            normal.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "refract",
                |
                    _self: Val<bevy::math::DVec4>,
                    normal: Val<bevy::math::DVec4>,
                    eta: f64|
                {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::refract(
                            _self.into_inner(),
                            normal.into_inner(),
                            eta,
                        )
                        .into();
                    output
                },
            )
            .register(
                "reject_from",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::reject_from(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "reject_from_normalized",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::reject_from_normalized(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Rem<
                        bevy::math::DVec4,
                    >>::rem(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::DVec4>, rhs: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Rem<
                        &bevy::math::DVec4,
                    >>::rem(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem",
                |_self: Val<bevy::math::DVec4>, rhs: f64| {
                    let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Rem<
                        f64,
                    >>::rem(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "rem_euclid",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::rem_euclid(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "round",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::round(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "select",
                |
                    mask: Val<bevy::math::BVec4>,
                    if_true: Val<bevy::math::DVec4>,
                    if_false: Val<bevy::math::DVec4>|
                {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::select(
                            mask.into_inner(),
                            if_true.into_inner(),
                            if_false.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "signum",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::signum(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: f64| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::DVec4>, rhs: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Sub<
                        &bevy::math::DVec4,
                    >>::sub(_self.into_inner(), &rhs)
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Sub<
                        bevy::math::DVec4,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::DVec4>, rhs: f64| {
                    let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Sub<
                        f64,
                    >>::sub(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::DVec4>| {
                    let output: [f64; 4] = bevy::math::DVec4::to_array(&_self).into();
                    output
                },
            )
            .register(
                "trunc",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::trunc(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "truncate",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DVec4::truncate(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_w",
                |_self: Val<bevy::math::DVec4>, w: f64| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::with_w(
                            _self.into_inner(),
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_x",
                |_self: Val<bevy::math::DVec4>, x: f64| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::with_x(
                            _self.into_inner(),
                            x,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_y",
                |_self: Val<bevy::math::DVec4>, y: f64| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::with_y(
                            _self.into_inner(),
                            y,
                        )
                        .into();
                    output
                },
            )
            .register(
                "with_z",
                |_self: Val<bevy::math::DVec4>, z: f64| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DVec4::with_z(
                            _self.into_inner(),
                            z,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::Mat2>::new(world)
            .register(
                "abs",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = bevy::math::Mat2::abs(&_self)
                        .into();
                    output
                },
            )
            .register(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::Mat2>,
                    rhs: Val<bevy::math::Mat2>,
                    max_abs_diff: f32|
                {
                    let output: bool = bevy::math::Mat2::abs_diff_eq(
                            &_self,
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::Mat2>, rhs: Val<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as std::ops::Add<
                        bevy::math::Mat2,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add_mat2",
                |_self: Ref<bevy::math::Mat2>, rhs: Ref<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = bevy::math::Mat2::add_mat2(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_dmat2",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: Val<bevy::math::DMat2> = bevy::math::Mat2::as_dmat2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "col",
                |_self: Ref<bevy::math::Mat2>, index: usize| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Mat2::col(
                            &_self,
                            index,
                        )
                        .into();
                    output
                },
            )
            .register(
                "determinant",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: f32 = bevy::math::Mat2::determinant(&_self).into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::Mat2>, rhs: f32| {
                    let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as std::ops::Div<
                        f32,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div_scalar",
                |_self: Ref<bevy::math::Mat2>, rhs: f32| {
                    let output: Val<bevy::math::Mat2> = bevy::math::Mat2::div_scalar(
                            &_self,
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::Mat2>, rhs: Ref<bevy::math::Mat2>| {
                    let output: bool = <bevy::math::Mat2 as std::cmp::PartialEq<
                        bevy::math::Mat2,
                    >>::eq(&_self, &rhs)
                        .into();
                    output
                },
            )
            .register(
                "from_angle",
                |angle: f32| {
                    let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_angle(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_cols",
                |x_axis: Val<bevy::math::Vec2>, y_axis: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_cols(
                            x_axis.into_inner(),
                            y_axis.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_diagonal",
                |diagonal: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_diagonal(
                            diagonal.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat3",
                |m: Val<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_mat3(
                            m.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat3_minor",
                |m: Val<bevy::math::Mat3>, i: usize, j: usize| {
                    let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_mat3_minor(
                            m.into_inner(),
                            i,
                            j,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat3a",
                |m: Val<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_mat3a(
                            m.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat3a_minor",
                |m: Val<bevy::math::Mat3A>, i: usize, j: usize| {
                    let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_mat3a_minor(
                            m.into_inner(),
                            i,
                            j,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale_angle",
                |scale: Val<bevy::math::Vec2>, angle: f32| {
                    let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_scale_angle(
                            scale.into_inner(),
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "inverse",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = bevy::math::Mat2::inverse(&_self)
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: bool = bevy::math::Mat2::is_finite(&_self).into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: bool = bevy::math::Mat2::is_nan(&_self).into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Mat2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = <bevy::math::Mat2 as std::ops::Mul<
                        bevy::math::Vec2,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Mat2>, rhs: f32| {
                    let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as std::ops::Mul<
                        f32,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Mat2>, rhs: Val<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as std::ops::Mul<
                        bevy::math::Mat2,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul_mat2",
                |_self: Ref<bevy::math::Mat2>, rhs: Ref<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = bevy::math::Mat2::mul_mat2(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_scalar",
                |_self: Ref<bevy::math::Mat2>, rhs: f32| {
                    let output: Val<bevy::math::Mat2> = bevy::math::Mat2::mul_scalar(
                            &_self,
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_vec2",
                |_self: Ref<bevy::math::Mat2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Mat2::mul_vec2(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "row",
                |_self: Ref<bevy::math::Mat2>, index: usize| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Mat2::row(
                            &_self,
                            index,
                        )
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::Mat2>, rhs: Val<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as std::ops::Sub<
                        bevy::math::Mat2,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub_mat2",
                |_self: Ref<bevy::math::Mat2>, rhs: Ref<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = bevy::math::Mat2::sub_mat2(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: [f32; 4] = bevy::math::Mat2::to_cols_array(&_self)
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: [[f32; 2]; 2] = bevy::math::Mat2::to_cols_array_2d(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "transpose",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = bevy::math::Mat2::transpose(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::Mat3>::new(world)
            .register(
                "abs",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::abs(&_self)
                        .into();
                    output
                },
            )
            .register(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::Mat3>,
                    rhs: Val<bevy::math::Mat3>,
                    max_abs_diff: f32|
                {
                    let output: bool = bevy::math::Mat3::abs_diff_eq(
                            &_self,
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::Mat3>, rhs: Val<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Add<
                        bevy::math::Mat3,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add_mat3",
                |_self: Ref<bevy::math::Mat3>, rhs: Ref<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::add_mat3(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_dmat3",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: Val<bevy::math::DMat3> = bevy::math::Mat3::as_dmat3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "col",
                |_self: Ref<bevy::math::Mat3>, index: usize| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Mat3::col(
                            &_self,
                            index,
                        )
                        .into();
                    output
                },
            )
            .register(
                "determinant",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: f32 = bevy::math::Mat3::determinant(&_self).into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::Mat3>, rhs: f32| {
                    let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Div<
                        f32,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div_scalar",
                |_self: Ref<bevy::math::Mat3>, rhs: f32| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::div_scalar(
                            &_self,
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::Mat3>, rhs: Ref<bevy::math::Mat3>| {
                    let output: bool = <bevy::math::Mat3 as std::cmp::PartialEq<
                        bevy::math::Mat3,
                    >>::eq(&_self, &rhs)
                        .into();
                    output
                },
            )
            .register(
                "from_angle",
                |angle: f32| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_angle(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_axis_angle",
                |axis: Val<bevy::math::Vec3>, angle: f32| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_axis_angle(
                            axis.into_inner(),
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_cols",
                |
                    x_axis: Val<bevy::math::Vec3>,
                    y_axis: Val<bevy::math::Vec3>,
                    z_axis: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_cols(
                            x_axis.into_inner(),
                            y_axis.into_inner(),
                            z_axis.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_diagonal",
                |diagonal: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_diagonal(
                            diagonal.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_euler",
                |order: Val<bevy::math::EulerRot>, a: f32, b: f32, c: f32| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_euler(
                            order.into_inner(),
                            a,
                            b,
                            c,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat2",
                |m: Val<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_mat2(
                            m.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat4",
                |m: Val<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_mat4(
                            m.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat4_minor",
                |m: Val<bevy::math::Mat4>, i: usize, j: usize| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_mat4_minor(
                            m.into_inner(),
                            i,
                            j,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_quat",
                |rotation: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_quat(
                            rotation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_x",
                |angle: f32| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_rotation_x(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_y",
                |angle: f32| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_rotation_y(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_z",
                |angle: f32| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_rotation_z(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale",
                |scale: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_scale(
                            scale.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale_angle_translation",
                |
                    scale: Val<bevy::math::Vec2>,
                    angle: f32,
                    translation: Val<bevy::math::Vec2>|
                {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_scale_angle_translation(
                            scale.into_inner(),
                            angle,
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_translation",
                |translation: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_translation(
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "inverse",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::inverse(&_self)
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: bool = bevy::math::Mat3::is_finite(&_self).into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: bool = bevy::math::Mat3::is_nan(&_self).into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Mat3>, rhs: f32| {
                    let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Mul<
                        f32,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Mat3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Mat3 as std::ops::Mul<
                        bevy::math::Vec3,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Mat3>, rhs: Val<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Mul<
                        bevy::math::Mat3,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Mat3>, rhs: Val<bevy::math::Affine2>| {
                    let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Mul<
                        bevy::math::Affine2,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Mat3>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Mat3 as std::ops::Mul<
                        bevy::math::Vec3A,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul_mat3",
                |_self: Ref<bevy::math::Mat3>, rhs: Ref<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::mul_mat3(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_scalar",
                |_self: Ref<bevy::math::Mat3>, rhs: f32| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::mul_scalar(
                            &_self,
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_vec3",
                |_self: Ref<bevy::math::Mat3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Mat3::mul_vec3(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_vec3a",
                |_self: Ref<bevy::math::Mat3>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Mat3::mul_vec3a(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "row",
                |_self: Ref<bevy::math::Mat3>, index: usize| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Mat3::row(
                            &_self,
                            index,
                        )
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::Mat3>, rhs: Val<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Sub<
                        bevy::math::Mat3,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub_mat3",
                |_self: Ref<bevy::math::Mat3>, rhs: Ref<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::sub_mat3(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: [f32; 9] = bevy::math::Mat3::to_cols_array(&_self)
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: [[f32; 3]; 3] = bevy::math::Mat3::to_cols_array_2d(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "to_euler",
                |_self: Ref<bevy::math::Mat3>, order: Val<bevy::math::EulerRot>| {
                    let output: (f32, f32, f32) = bevy::math::Mat3::to_euler(
                            &_self,
                            order.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_point2",
                |_self: Ref<bevy::math::Mat3>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Mat3::transform_point2(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_vector2",
                |_self: Ref<bevy::math::Mat3>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Mat3::transform_vector2(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transpose",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = bevy::math::Mat3::transpose(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::Mat3A>::new(world)
            .register(
                "abs",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::abs(&_self)
                        .into();
                    output
                },
            )
            .register(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::Mat3A>,
                    rhs: Val<bevy::math::Mat3A>,
                    max_abs_diff: f32|
                {
                    let output: bool = bevy::math::Mat3A::abs_diff_eq(
                            &_self,
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::Mat3A>, rhs: Val<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Add<
                        bevy::math::Mat3A,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add_mat3",
                |_self: Ref<bevy::math::Mat3A>, rhs: Ref<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::add_mat3(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_dmat3",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::DMat3> = bevy::math::Mat3A::as_dmat3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "col",
                |_self: Ref<bevy::math::Mat3A>, index: usize| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Mat3A::col(
                            &_self,
                            index,
                        )
                        .into();
                    output
                },
            )
            .register(
                "determinant",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: f32 = bevy::math::Mat3A::determinant(&_self).into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::Mat3A>, rhs: f32| {
                    let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Div<
                        f32,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div_scalar",
                |_self: Ref<bevy::math::Mat3A>, rhs: f32| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::div_scalar(
                            &_self,
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::Mat3A>, rhs: Ref<bevy::math::Mat3A>| {
                    let output: bool = <bevy::math::Mat3A as std::cmp::PartialEq<
                        bevy::math::Mat3A,
                    >>::eq(&_self, &rhs)
                        .into();
                    output
                },
            )
            .register(
                "from_angle",
                |angle: f32| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_angle(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_axis_angle",
                |axis: Val<bevy::math::Vec3>, angle: f32| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_axis_angle(
                            axis.into_inner(),
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_cols",
                |
                    x_axis: Val<bevy::math::Vec3A>,
                    y_axis: Val<bevy::math::Vec3A>,
                    z_axis: Val<bevy::math::Vec3A>|
                {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_cols(
                            x_axis.into_inner(),
                            y_axis.into_inner(),
                            z_axis.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_diagonal",
                |diagonal: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_diagonal(
                            diagonal.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_euler",
                |order: Val<bevy::math::EulerRot>, a: f32, b: f32, c: f32| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_euler(
                            order.into_inner(),
                            a,
                            b,
                            c,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat2",
                |m: Val<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_mat2(
                            m.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat4",
                |m: Val<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_mat4(
                            m.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat4_minor",
                |m: Val<bevy::math::Mat4>, i: usize, j: usize| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_mat4_minor(
                            m.into_inner(),
                            i,
                            j,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_quat",
                |rotation: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_quat(
                            rotation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_x",
                |angle: f32| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_rotation_x(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_y",
                |angle: f32| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_rotation_y(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_z",
                |angle: f32| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_rotation_z(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale",
                |scale: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_scale(
                            scale.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale_angle_translation",
                |
                    scale: Val<bevy::math::Vec2>,
                    angle: f32,
                    translation: Val<bevy::math::Vec2>|
                {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_scale_angle_translation(
                            scale.into_inner(),
                            angle,
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_translation",
                |translation: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_translation(
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "inverse",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::inverse(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: bool = bevy::math::Mat3A::is_finite(&_self).into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: bool = bevy::math::Mat3A::is_nan(&_self).into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Mat3A>, rhs: f32| {
                    let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Mul<
                        f32,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Mat3A>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = <bevy::math::Mat3A as std::ops::Mul<
                        bevy::math::Vec3,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Mat3A>, rhs: Val<bevy::math::Affine2>| {
                    let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Mul<
                        bevy::math::Affine2,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Mat3A>, rhs: Val<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Mul<
                        bevy::math::Mat3A,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Mat3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = <bevy::math::Mat3A as std::ops::Mul<
                        bevy::math::Vec3A,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul_mat3",
                |_self: Ref<bevy::math::Mat3A>, rhs: Ref<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::mul_mat3(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_scalar",
                |_self: Ref<bevy::math::Mat3A>, rhs: f32| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::mul_scalar(
                            &_self,
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_vec3",
                |_self: Ref<bevy::math::Mat3A>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Mat3A::mul_vec3(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_vec3a",
                |_self: Ref<bevy::math::Mat3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Mat3A::mul_vec3a(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "row",
                |_self: Ref<bevy::math::Mat3A>, index: usize| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Mat3A::row(
                            &_self,
                            index,
                        )
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::Mat3A>, rhs: Val<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Sub<
                        bevy::math::Mat3A,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub_mat3",
                |_self: Ref<bevy::math::Mat3A>, rhs: Ref<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::sub_mat3(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: [f32; 9] = bevy::math::Mat3A::to_cols_array(&_self)
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: [[f32; 3]; 3] = bevy::math::Mat3A::to_cols_array_2d(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "to_euler",
                |_self: Ref<bevy::math::Mat3A>, order: Val<bevy::math::EulerRot>| {
                    let output: (f32, f32, f32) = bevy::math::Mat3A::to_euler(
                            &_self,
                            order.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_point2",
                |_self: Ref<bevy::math::Mat3A>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Mat3A::transform_point2(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_vector2",
                |_self: Ref<bevy::math::Mat3A>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Mat3A::transform_vector2(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transpose",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::transpose(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::Mat4>::new(world)
            .register(
                "abs",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::abs(&_self)
                        .into();
                    output
                },
            )
            .register(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::Mat4>,
                    rhs: Val<bevy::math::Mat4>,
                    max_abs_diff: f32|
                {
                    let output: bool = bevy::math::Mat4::abs_diff_eq(
                            &_self,
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::Mat4>, rhs: Val<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Add<
                        bevy::math::Mat4,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add_mat4",
                |_self: Ref<bevy::math::Mat4>, rhs: Ref<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::add_mat4(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_dmat4",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: Val<bevy::math::DMat4> = bevy::math::Mat4::as_dmat4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "col",
                |_self: Ref<bevy::math::Mat4>, index: usize| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Mat4::col(
                            &_self,
                            index,
                        )
                        .into();
                    output
                },
            )
            .register(
                "determinant",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: f32 = bevy::math::Mat4::determinant(&_self).into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::Mat4>, rhs: f32| {
                    let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Div<
                        f32,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div_scalar",
                |_self: Ref<bevy::math::Mat4>, rhs: f32| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::div_scalar(
                            &_self,
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::Mat4>, rhs: Ref<bevy::math::Mat4>| {
                    let output: bool = <bevy::math::Mat4 as std::cmp::PartialEq<
                        bevy::math::Mat4,
                    >>::eq(&_self, &rhs)
                        .into();
                    output
                },
            )
            .register(
                "from_axis_angle",
                |axis: Val<bevy::math::Vec3>, angle: f32| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_axis_angle(
                            axis.into_inner(),
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_cols",
                |
                    x_axis: Val<bevy::math::Vec4>,
                    y_axis: Val<bevy::math::Vec4>,
                    z_axis: Val<bevy::math::Vec4>,
                    w_axis: Val<bevy::math::Vec4>|
                {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_cols(
                            x_axis.into_inner(),
                            y_axis.into_inner(),
                            z_axis.into_inner(),
                            w_axis.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_diagonal",
                |diagonal: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_diagonal(
                            diagonal.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_euler",
                |order: Val<bevy::math::EulerRot>, a: f32, b: f32, c: f32| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_euler(
                            order.into_inner(),
                            a,
                            b,
                            c,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat3",
                |m: Val<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_mat3(
                            m.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat3a",
                |m: Val<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_mat3a(
                            m.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_quat",
                |rotation: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_quat(
                            rotation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_translation",
                |rotation: Val<bevy::math::Quat>, translation: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_rotation_translation(
                            rotation.into_inner(),
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_x",
                |angle: f32| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_rotation_x(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_y",
                |angle: f32| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_rotation_y(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_z",
                |angle: f32| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_rotation_z(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale",
                |scale: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_scale(
                            scale.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale_rotation_translation",
                |
                    scale: Val<bevy::math::Vec3>,
                    rotation: Val<bevy::math::Quat>,
                    translation: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_scale_rotation_translation(
                            scale.into_inner(),
                            rotation.into_inner(),
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_translation",
                |translation: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_translation(
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "inverse",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::inverse(&_self)
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: bool = bevy::math::Mat4::is_finite(&_self).into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: bool = bevy::math::Mat4::is_nan(&_self).into();
                    output
                },
            )
            .register(
                "look_at_lh",
                |
                    eye: Val<bevy::math::Vec3>,
                    center: Val<bevy::math::Vec3>,
                    up: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::look_at_lh(
                            eye.into_inner(),
                            center.into_inner(),
                            up.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "look_at_rh",
                |
                    eye: Val<bevy::math::Vec3>,
                    center: Val<bevy::math::Vec3>,
                    up: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::look_at_rh(
                            eye.into_inner(),
                            center.into_inner(),
                            up.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "look_to_lh",
                |
                    eye: Val<bevy::math::Vec3>,
                    dir: Val<bevy::math::Vec3>,
                    up: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::look_to_lh(
                            eye.into_inner(),
                            dir.into_inner(),
                            up.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "look_to_rh",
                |
                    eye: Val<bevy::math::Vec3>,
                    dir: Val<bevy::math::Vec3>,
                    up: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::look_to_rh(
                            eye.into_inner(),
                            dir.into_inner(),
                            up.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Mat4>, rhs: Val<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Mul<
                        bevy::math::Mat4,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Mat4>, rhs: Val<bevy::math::Affine3A>| {
                    let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Mul<
                        bevy::math::Affine3A,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Mat4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = <bevy::math::Mat4 as std::ops::Mul<
                        bevy::math::Vec4,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Mat4>, rhs: f32| {
                    let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Mul<
                        f32,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul_mat4",
                |_self: Ref<bevy::math::Mat4>, rhs: Ref<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::mul_mat4(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_scalar",
                |_self: Ref<bevy::math::Mat4>, rhs: f32| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::mul_scalar(
                            &_self,
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_vec4",
                |_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Mat4::mul_vec4(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "orthographic_lh",
                |left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::orthographic_lh(
                            left,
                            right,
                            bottom,
                            top,
                            near,
                            far,
                        )
                        .into();
                    output
                },
            )
            .register(
                "orthographic_rh",
                |left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::orthographic_rh(
                            left,
                            right,
                            bottom,
                            top,
                            near,
                            far,
                        )
                        .into();
                    output
                },
            )
            .register(
                "orthographic_rh_gl",
                |left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::orthographic_rh_gl(
                            left,
                            right,
                            bottom,
                            top,
                            near,
                            far,
                        )
                        .into();
                    output
                },
            )
            .register(
                "perspective_infinite_lh",
                |fov_y_radians: f32, aspect_ratio: f32, z_near: f32| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_infinite_lh(
                            fov_y_radians,
                            aspect_ratio,
                            z_near,
                        )
                        .into();
                    output
                },
            )
            .register(
                "perspective_infinite_reverse_lh",
                |fov_y_radians: f32, aspect_ratio: f32, z_near: f32| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_infinite_reverse_lh(
                            fov_y_radians,
                            aspect_ratio,
                            z_near,
                        )
                        .into();
                    output
                },
            )
            .register(
                "perspective_infinite_reverse_rh",
                |fov_y_radians: f32, aspect_ratio: f32, z_near: f32| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_infinite_reverse_rh(
                            fov_y_radians,
                            aspect_ratio,
                            z_near,
                        )
                        .into();
                    output
                },
            )
            .register(
                "perspective_infinite_rh",
                |fov_y_radians: f32, aspect_ratio: f32, z_near: f32| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_infinite_rh(
                            fov_y_radians,
                            aspect_ratio,
                            z_near,
                        )
                        .into();
                    output
                },
            )
            .register(
                "perspective_lh",
                |fov_y_radians: f32, aspect_ratio: f32, z_near: f32, z_far: f32| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_lh(
                            fov_y_radians,
                            aspect_ratio,
                            z_near,
                            z_far,
                        )
                        .into();
                    output
                },
            )
            .register(
                "perspective_rh",
                |fov_y_radians: f32, aspect_ratio: f32, z_near: f32, z_far: f32| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_rh(
                            fov_y_radians,
                            aspect_ratio,
                            z_near,
                            z_far,
                        )
                        .into();
                    output
                },
            )
            .register(
                "perspective_rh_gl",
                |fov_y_radians: f32, aspect_ratio: f32, z_near: f32, z_far: f32| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_rh_gl(
                            fov_y_radians,
                            aspect_ratio,
                            z_near,
                            z_far,
                        )
                        .into();
                    output
                },
            )
            .register(
                "project_point3",
                |_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Mat4::project_point3(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "project_point3a",
                |_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Mat4::project_point3a(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "row",
                |_self: Ref<bevy::math::Mat4>, index: usize| {
                    let output: Val<bevy::math::Vec4> = bevy::math::Mat4::row(
                            &_self,
                            index,
                        )
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::Mat4>, rhs: Val<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Sub<
                        bevy::math::Mat4,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub_mat4",
                |_self: Ref<bevy::math::Mat4>, rhs: Ref<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::sub_mat4(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: [f32; 16] = bevy::math::Mat4::to_cols_array(&_self)
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: [[f32; 4]; 4] = bevy::math::Mat4::to_cols_array_2d(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "to_euler",
                |_self: Ref<bevy::math::Mat4>, order: Val<bevy::math::EulerRot>| {
                    let output: (f32, f32, f32) = bevy::math::Mat4::to_euler(
                            &_self,
                            order.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_point3",
                |_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Mat4::transform_point3(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_point3a",
                |_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Mat4::transform_point3a(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_vector3",
                |_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Mat4::transform_vector3(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_vector3a",
                |_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Mat4::transform_vector3a(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transpose",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = bevy::math::Mat4::transpose(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::DMat2>::new(world)
            .register(
                "abs",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = bevy::math::DMat2::abs(&_self)
                        .into();
                    output
                },
            )
            .register(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::DMat2>,
                    rhs: Val<bevy::math::DMat2>,
                    max_abs_diff: f64|
                {
                    let output: bool = bevy::math::DMat2::abs_diff_eq(
                            &_self,
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::DMat2>, rhs: Val<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as std::ops::Add<
                        bevy::math::DMat2,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add_mat2",
                |_self: Ref<bevy::math::DMat2>, rhs: Ref<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = bevy::math::DMat2::add_mat2(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_mat2",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: Val<bevy::math::Mat2> = bevy::math::DMat2::as_mat2(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "col",
                |_self: Ref<bevy::math::DMat2>, index: usize| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DMat2::col(
                            &_self,
                            index,
                        )
                        .into();
                    output
                },
            )
            .register(
                "determinant",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: f64 = bevy::math::DMat2::determinant(&_self).into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::DMat2>, rhs: f64| {
                    let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as std::ops::Div<
                        f64,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div_scalar",
                |_self: Ref<bevy::math::DMat2>, rhs: f64| {
                    let output: Val<bevy::math::DMat2> = bevy::math::DMat2::div_scalar(
                            &_self,
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::DMat2>, rhs: Ref<bevy::math::DMat2>| {
                    let output: bool = <bevy::math::DMat2 as std::cmp::PartialEq<
                        bevy::math::DMat2,
                    >>::eq(&_self, &rhs)
                        .into();
                    output
                },
            )
            .register(
                "from_angle",
                |angle: f64| {
                    let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_angle(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_cols",
                |x_axis: Val<bevy::math::DVec2>, y_axis: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_cols(
                            x_axis.into_inner(),
                            y_axis.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_diagonal",
                |diagonal: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_diagonal(
                            diagonal.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat3",
                |m: Val<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_mat3(
                            m.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat3_minor",
                |m: Val<bevy::math::DMat3>, i: usize, j: usize| {
                    let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_mat3_minor(
                            m.into_inner(),
                            i,
                            j,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale_angle",
                |scale: Val<bevy::math::DVec2>, angle: f64| {
                    let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_scale_angle(
                            scale.into_inner(),
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "inverse",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = bevy::math::DMat2::inverse(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: bool = bevy::math::DMat2::is_finite(&_self).into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: bool = bevy::math::DMat2::is_nan(&_self).into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DMat2>, rhs: Val<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as std::ops::Mul<
                        bevy::math::DMat2,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DMat2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = <bevy::math::DMat2 as std::ops::Mul<
                        bevy::math::DVec2,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DMat2>, rhs: f64| {
                    let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as std::ops::Mul<
                        f64,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul_mat2",
                |_self: Ref<bevy::math::DMat2>, rhs: Ref<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = bevy::math::DMat2::mul_mat2(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_scalar",
                |_self: Ref<bevy::math::DMat2>, rhs: f64| {
                    let output: Val<bevy::math::DMat2> = bevy::math::DMat2::mul_scalar(
                            &_self,
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_vec2",
                |_self: Ref<bevy::math::DMat2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DMat2::mul_vec2(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "row",
                |_self: Ref<bevy::math::DMat2>, index: usize| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DMat2::row(
                            &_self,
                            index,
                        )
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::DMat2>, rhs: Val<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as std::ops::Sub<
                        bevy::math::DMat2,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub_mat2",
                |_self: Ref<bevy::math::DMat2>, rhs: Ref<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = bevy::math::DMat2::sub_mat2(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: [f64; 4] = bevy::math::DMat2::to_cols_array(&_self)
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: [[f64; 2]; 2] = bevy::math::DMat2::to_cols_array_2d(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "transpose",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = bevy::math::DMat2::transpose(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::DMat3>::new(world)
            .register(
                "abs",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::abs(&_self)
                        .into();
                    output
                },
            )
            .register(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::DMat3>,
                    rhs: Val<bevy::math::DMat3>,
                    max_abs_diff: f64|
                {
                    let output: bool = bevy::math::DMat3::abs_diff_eq(
                            &_self,
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::DMat3>, rhs: Val<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Add<
                        bevy::math::DMat3,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add_mat3",
                |_self: Ref<bevy::math::DMat3>, rhs: Ref<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::add_mat3(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_mat3",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: Val<bevy::math::Mat3> = bevy::math::DMat3::as_mat3(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "col",
                |_self: Ref<bevy::math::DMat3>, index: usize| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DMat3::col(
                            &_self,
                            index,
                        )
                        .into();
                    output
                },
            )
            .register(
                "determinant",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: f64 = bevy::math::DMat3::determinant(&_self).into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::DMat3>, rhs: f64| {
                    let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Div<
                        f64,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div_scalar",
                |_self: Ref<bevy::math::DMat3>, rhs: f64| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::div_scalar(
                            &_self,
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::DMat3>, rhs: Ref<bevy::math::DMat3>| {
                    let output: bool = <bevy::math::DMat3 as std::cmp::PartialEq<
                        bevy::math::DMat3,
                    >>::eq(&_self, &rhs)
                        .into();
                    output
                },
            )
            .register(
                "from_angle",
                |angle: f64| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_angle(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_axis_angle",
                |axis: Val<bevy::math::DVec3>, angle: f64| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_axis_angle(
                            axis.into_inner(),
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_cols",
                |
                    x_axis: Val<bevy::math::DVec3>,
                    y_axis: Val<bevy::math::DVec3>,
                    z_axis: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_cols(
                            x_axis.into_inner(),
                            y_axis.into_inner(),
                            z_axis.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_diagonal",
                |diagonal: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_diagonal(
                            diagonal.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_euler",
                |order: Val<bevy::math::EulerRot>, a: f64, b: f64, c: f64| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_euler(
                            order.into_inner(),
                            a,
                            b,
                            c,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat2",
                |m: Val<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_mat2(
                            m.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat4",
                |m: Val<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_mat4(
                            m.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat4_minor",
                |m: Val<bevy::math::DMat4>, i: usize, j: usize| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_mat4_minor(
                            m.into_inner(),
                            i,
                            j,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_quat",
                |rotation: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_quat(
                            rotation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_x",
                |angle: f64| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_rotation_x(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_y",
                |angle: f64| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_rotation_y(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_z",
                |angle: f64| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_rotation_z(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale",
                |scale: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_scale(
                            scale.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale_angle_translation",
                |
                    scale: Val<bevy::math::DVec2>,
                    angle: f64,
                    translation: Val<bevy::math::DVec2>|
                {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_scale_angle_translation(
                            scale.into_inner(),
                            angle,
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_translation",
                |translation: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_translation(
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "inverse",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::inverse(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: bool = bevy::math::DMat3::is_finite(&_self).into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: bool = bevy::math::DMat3::is_nan(&_self).into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DMat3>, rhs: Val<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Mul<
                        bevy::math::DMat3,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DMat3>, rhs: Val<bevy::math::DAffine2>| {
                    let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Mul<
                        bevy::math::DAffine2,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DMat3>, rhs: f64| {
                    let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Mul<
                        f64,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DMat3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DMat3 as std::ops::Mul<
                        bevy::math::DVec3,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul_mat3",
                |_self: Ref<bevy::math::DMat3>, rhs: Ref<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::mul_mat3(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_scalar",
                |_self: Ref<bevy::math::DMat3>, rhs: f64| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::mul_scalar(
                            &_self,
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_vec3",
                |_self: Ref<bevy::math::DMat3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DMat3::mul_vec3(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "row",
                |_self: Ref<bevy::math::DMat3>, index: usize| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DMat3::row(
                            &_self,
                            index,
                        )
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::DMat3>, rhs: Val<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Sub<
                        bevy::math::DMat3,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub_mat3",
                |_self: Ref<bevy::math::DMat3>, rhs: Ref<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::sub_mat3(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: [f64; 9] = bevy::math::DMat3::to_cols_array(&_self)
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: [[f64; 3]; 3] = bevy::math::DMat3::to_cols_array_2d(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "to_euler",
                |_self: Ref<bevy::math::DMat3>, order: Val<bevy::math::EulerRot>| {
                    let output: (f64, f64, f64) = bevy::math::DMat3::to_euler(
                            &_self,
                            order.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_point2",
                |_self: Ref<bevy::math::DMat3>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DMat3::transform_point2(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_vector2",
                |_self: Ref<bevy::math::DMat3>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DMat3::transform_vector2(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transpose",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = bevy::math::DMat3::transpose(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::DMat4>::new(world)
            .register(
                "abs",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::abs(&_self)
                        .into();
                    output
                },
            )
            .register(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::DMat4>,
                    rhs: Val<bevy::math::DMat4>,
                    max_abs_diff: f64|
                {
                    let output: bool = bevy::math::DMat4::abs_diff_eq(
                            &_self,
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::DMat4>, rhs: Val<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Add<
                        bevy::math::DMat4,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "add_mat4",
                |_self: Ref<bevy::math::DMat4>, rhs: Ref<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::add_mat4(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_mat4",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: Val<bevy::math::Mat4> = bevy::math::DMat4::as_mat4(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "col",
                |_self: Ref<bevy::math::DMat4>, index: usize| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DMat4::col(
                            &_self,
                            index,
                        )
                        .into();
                    output
                },
            )
            .register(
                "determinant",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: f64 = bevy::math::DMat4::determinant(&_self).into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::DMat4>, rhs: f64| {
                    let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Div<
                        f64,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "div_scalar",
                |_self: Ref<bevy::math::DMat4>, rhs: f64| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::div_scalar(
                            &_self,
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::DMat4>, rhs: Ref<bevy::math::DMat4>| {
                    let output: bool = <bevy::math::DMat4 as std::cmp::PartialEq<
                        bevy::math::DMat4,
                    >>::eq(&_self, &rhs)
                        .into();
                    output
                },
            )
            .register(
                "from_axis_angle",
                |axis: Val<bevy::math::DVec3>, angle: f64| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_axis_angle(
                            axis.into_inner(),
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_cols",
                |
                    x_axis: Val<bevy::math::DVec4>,
                    y_axis: Val<bevy::math::DVec4>,
                    z_axis: Val<bevy::math::DVec4>,
                    w_axis: Val<bevy::math::DVec4>|
                {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_cols(
                            x_axis.into_inner(),
                            y_axis.into_inner(),
                            z_axis.into_inner(),
                            w_axis.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_diagonal",
                |diagonal: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_diagonal(
                            diagonal.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_euler",
                |order: Val<bevy::math::EulerRot>, a: f64, b: f64, c: f64| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_euler(
                            order.into_inner(),
                            a,
                            b,
                            c,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat3",
                |m: Val<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_mat3(
                            m.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_quat",
                |rotation: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_quat(
                            rotation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_translation",
                |rotation: Val<bevy::math::DQuat>, translation: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_rotation_translation(
                            rotation.into_inner(),
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_x",
                |angle: f64| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_rotation_x(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_y",
                |angle: f64| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_rotation_y(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_z",
                |angle: f64| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_rotation_z(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale",
                |scale: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_scale(
                            scale.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale_rotation_translation",
                |
                    scale: Val<bevy::math::DVec3>,
                    rotation: Val<bevy::math::DQuat>,
                    translation: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_scale_rotation_translation(
                            scale.into_inner(),
                            rotation.into_inner(),
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_translation",
                |translation: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_translation(
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "inverse",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::inverse(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: bool = bevy::math::DMat4::is_finite(&_self).into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: bool = bevy::math::DMat4::is_nan(&_self).into();
                    output
                },
            )
            .register(
                "look_at_lh",
                |
                    eye: Val<bevy::math::DVec3>,
                    center: Val<bevy::math::DVec3>,
                    up: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::look_at_lh(
                            eye.into_inner(),
                            center.into_inner(),
                            up.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "look_at_rh",
                |
                    eye: Val<bevy::math::DVec3>,
                    center: Val<bevy::math::DVec3>,
                    up: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::look_at_rh(
                            eye.into_inner(),
                            center.into_inner(),
                            up.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "look_to_lh",
                |
                    eye: Val<bevy::math::DVec3>,
                    dir: Val<bevy::math::DVec3>,
                    up: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::look_to_lh(
                            eye.into_inner(),
                            dir.into_inner(),
                            up.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "look_to_rh",
                |
                    eye: Val<bevy::math::DVec3>,
                    dir: Val<bevy::math::DVec3>,
                    up: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::look_to_rh(
                            eye.into_inner(),
                            dir.into_inner(),
                            up.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DMat4>, rhs: Val<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Mul<
                        bevy::math::DMat4,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DMat4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = <bevy::math::DMat4 as std::ops::Mul<
                        bevy::math::DVec4,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DMat4>, rhs: Val<bevy::math::DAffine3>| {
                    let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Mul<
                        bevy::math::DAffine3,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DMat4>, rhs: f64| {
                    let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Mul<
                        f64,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul_mat4",
                |_self: Ref<bevy::math::DMat4>, rhs: Ref<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::mul_mat4(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_scalar",
                |_self: Ref<bevy::math::DMat4>, rhs: f64| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::mul_scalar(
                            &_self,
                            rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_vec4",
                |_self: Ref<bevy::math::DMat4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DMat4::mul_vec4(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "orthographic_lh",
                |left: f64, right: f64, bottom: f64, top: f64, near: f64, far: f64| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::orthographic_lh(
                            left,
                            right,
                            bottom,
                            top,
                            near,
                            far,
                        )
                        .into();
                    output
                },
            )
            .register(
                "orthographic_rh",
                |left: f64, right: f64, bottom: f64, top: f64, near: f64, far: f64| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::orthographic_rh(
                            left,
                            right,
                            bottom,
                            top,
                            near,
                            far,
                        )
                        .into();
                    output
                },
            )
            .register(
                "orthographic_rh_gl",
                |left: f64, right: f64, bottom: f64, top: f64, near: f64, far: f64| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::orthographic_rh_gl(
                            left,
                            right,
                            bottom,
                            top,
                            near,
                            far,
                        )
                        .into();
                    output
                },
            )
            .register(
                "perspective_infinite_lh",
                |fov_y_radians: f64, aspect_ratio: f64, z_near: f64| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_infinite_lh(
                            fov_y_radians,
                            aspect_ratio,
                            z_near,
                        )
                        .into();
                    output
                },
            )
            .register(
                "perspective_infinite_reverse_lh",
                |fov_y_radians: f64, aspect_ratio: f64, z_near: f64| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_infinite_reverse_lh(
                            fov_y_radians,
                            aspect_ratio,
                            z_near,
                        )
                        .into();
                    output
                },
            )
            .register(
                "perspective_infinite_reverse_rh",
                |fov_y_radians: f64, aspect_ratio: f64, z_near: f64| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_infinite_reverse_rh(
                            fov_y_radians,
                            aspect_ratio,
                            z_near,
                        )
                        .into();
                    output
                },
            )
            .register(
                "perspective_infinite_rh",
                |fov_y_radians: f64, aspect_ratio: f64, z_near: f64| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_infinite_rh(
                            fov_y_radians,
                            aspect_ratio,
                            z_near,
                        )
                        .into();
                    output
                },
            )
            .register(
                "perspective_lh",
                |fov_y_radians: f64, aspect_ratio: f64, z_near: f64, z_far: f64| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_lh(
                            fov_y_radians,
                            aspect_ratio,
                            z_near,
                            z_far,
                        )
                        .into();
                    output
                },
            )
            .register(
                "perspective_rh",
                |fov_y_radians: f64, aspect_ratio: f64, z_near: f64, z_far: f64| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_rh(
                            fov_y_radians,
                            aspect_ratio,
                            z_near,
                            z_far,
                        )
                        .into();
                    output
                },
            )
            .register(
                "perspective_rh_gl",
                |fov_y_radians: f64, aspect_ratio: f64, z_near: f64, z_far: f64| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_rh_gl(
                            fov_y_radians,
                            aspect_ratio,
                            z_near,
                            z_far,
                        )
                        .into();
                    output
                },
            )
            .register(
                "project_point3",
                |_self: Ref<bevy::math::DMat4>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DMat4::project_point3(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "row",
                |_self: Ref<bevy::math::DMat4>, index: usize| {
                    let output: Val<bevy::math::DVec4> = bevy::math::DMat4::row(
                            &_self,
                            index,
                        )
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::DMat4>, rhs: Val<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Sub<
                        bevy::math::DMat4,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "sub_mat4",
                |_self: Ref<bevy::math::DMat4>, rhs: Ref<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::sub_mat4(
                            &_self,
                            &rhs,
                        )
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: [f64; 16] = bevy::math::DMat4::to_cols_array(&_self)
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: [[f64; 4]; 4] = bevy::math::DMat4::to_cols_array_2d(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "to_euler",
                |_self: Ref<bevy::math::DMat4>, order: Val<bevy::math::EulerRot>| {
                    let output: (f64, f64, f64) = bevy::math::DMat4::to_euler(
                            &_self,
                            order.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_point3",
                |_self: Ref<bevy::math::DMat4>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DMat4::transform_point3(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_vector3",
                |_self: Ref<bevy::math::DMat4>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DMat4::transform_vector3(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transpose",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = bevy::math::DMat4::transpose(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::Affine2>::new(world)
            .register(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::Affine2>,
                    rhs: Val<bevy::math::Affine2>,
                    max_abs_diff: f32|
                {
                    let output: bool = bevy::math::Affine2::abs_diff_eq(
                            &_self,
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::Affine2>| {
                    let output: Val<bevy::math::Affine2> = <bevy::math::Affine2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::Affine2>, rhs: Ref<bevy::math::Affine2>| {
                    let output: bool = <bevy::math::Affine2 as std::cmp::PartialEq<
                        bevy::math::Affine2,
                    >>::eq(&_self, &rhs)
                        .into();
                    output
                },
            )
            .register(
                "from_angle",
                |angle: f32| {
                    let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_angle(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_angle_translation",
                |angle: f32, translation: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_angle_translation(
                            angle,
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_cols",
                |
                    x_axis: Val<bevy::math::Vec2>,
                    y_axis: Val<bevy::math::Vec2>,
                    z_axis: Val<bevy::math::Vec2>|
                {
                    let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_cols(
                            x_axis.into_inner(),
                            y_axis.into_inner(),
                            z_axis.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat2",
                |matrix2: Val<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_mat2(
                            matrix2.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat2_translation",
                |matrix2: Val<bevy::math::Mat2>, translation: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_mat2_translation(
                            matrix2.into_inner(),
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat3",
                |m: Val<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_mat3(
                            m.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat3a",
                |m: Val<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_mat3a(
                            m.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale",
                |scale: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_scale(
                            scale.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale_angle_translation",
                |
                    scale: Val<bevy::math::Vec2>,
                    angle: f32,
                    translation: Val<bevy::math::Vec2>|
                {
                    let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_scale_angle_translation(
                            scale.into_inner(),
                            angle,
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_translation",
                |translation: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_translation(
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "inverse",
                |_self: Ref<bevy::math::Affine2>| {
                    let output: Val<bevy::math::Affine2> = bevy::math::Affine2::inverse(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Ref<bevy::math::Affine2>| {
                    let output: bool = bevy::math::Affine2::is_finite(&_self).into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Ref<bevy::math::Affine2>| {
                    let output: bool = bevy::math::Affine2::is_nan(&_self).into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Affine2>, rhs: Val<bevy::math::Affine2>| {
                    let output: Val<bevy::math::Affine2> = <bevy::math::Affine2 as std::ops::Mul<
                        bevy::math::Affine2,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Affine2>, rhs: Val<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = <bevy::math::Affine2 as std::ops::Mul<
                        bevy::math::Mat3,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Affine2>, rhs: Val<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = <bevy::math::Affine2 as std::ops::Mul<
                        bevy::math::Mat3A,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array",
                |_self: Ref<bevy::math::Affine2>| {
                    let output: [f32; 6] = bevy::math::Affine2::to_cols_array(&_self)
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::Affine2>| {
                    let output: [[f32; 2]; 3] = bevy::math::Affine2::to_cols_array_2d(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_point2",
                |_self: Ref<bevy::math::Affine2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Affine2::transform_point2(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_vector2",
                |_self: Ref<bevy::math::Affine2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = bevy::math::Affine2::transform_vector2(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::Affine3A>::new(world)
            .register(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::Affine3A>,
                    rhs: Val<bevy::math::Affine3A>,
                    max_abs_diff: f32|
                {
                    let output: bool = bevy::math::Affine3A::abs_diff_eq(
                            &_self,
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::Affine3A>| {
                    let output: Val<bevy::math::Affine3A> = <bevy::math::Affine3A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::Affine3A>, rhs: Ref<bevy::math::Affine3A>| {
                    let output: bool = <bevy::math::Affine3A as std::cmp::PartialEq<
                        bevy::math::Affine3A,
                    >>::eq(&_self, &rhs)
                        .into();
                    output
                },
            )
            .register(
                "from_axis_angle",
                |axis: Val<bevy::math::Vec3>, angle: f32| {
                    let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_axis_angle(
                            axis.into_inner(),
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_cols",
                |
                    x_axis: Val<bevy::math::Vec3A>,
                    y_axis: Val<bevy::math::Vec3A>,
                    z_axis: Val<bevy::math::Vec3A>,
                    w_axis: Val<bevy::math::Vec3A>|
                {
                    let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_cols(
                            x_axis.into_inner(),
                            y_axis.into_inner(),
                            z_axis.into_inner(),
                            w_axis.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat3",
                |mat3: Val<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_mat3(
                            mat3.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat3_translation",
                |mat3: Val<bevy::math::Mat3>, translation: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_mat3_translation(
                            mat3.into_inner(),
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat4",
                |m: Val<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_mat4(
                            m.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_quat",
                |rotation: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_quat(
                            rotation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_translation",
                |rotation: Val<bevy::math::Quat>, translation: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_rotation_translation(
                            rotation.into_inner(),
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_x",
                |angle: f32| {
                    let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_rotation_x(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_y",
                |angle: f32| {
                    let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_rotation_y(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_z",
                |angle: f32| {
                    let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_rotation_z(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale",
                |scale: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_scale(
                            scale.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale_rotation_translation",
                |
                    scale: Val<bevy::math::Vec3>,
                    rotation: Val<bevy::math::Quat>,
                    translation: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_scale_rotation_translation(
                            scale.into_inner(),
                            rotation.into_inner(),
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_translation",
                |translation: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_translation(
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "inverse",
                |_self: Ref<bevy::math::Affine3A>| {
                    let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::inverse(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Ref<bevy::math::Affine3A>| {
                    let output: bool = bevy::math::Affine3A::is_finite(&_self).into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Ref<bevy::math::Affine3A>| {
                    let output: bool = bevy::math::Affine3A::is_nan(&_self).into();
                    output
                },
            )
            .register(
                "look_at_lh",
                |
                    eye: Val<bevy::math::Vec3>,
                    center: Val<bevy::math::Vec3>,
                    up: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::look_at_lh(
                            eye.into_inner(),
                            center.into_inner(),
                            up.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "look_at_rh",
                |
                    eye: Val<bevy::math::Vec3>,
                    center: Val<bevy::math::Vec3>,
                    up: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::look_at_rh(
                            eye.into_inner(),
                            center.into_inner(),
                            up.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "look_to_lh",
                |
                    eye: Val<bevy::math::Vec3>,
                    dir: Val<bevy::math::Vec3>,
                    up: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::look_to_lh(
                            eye.into_inner(),
                            dir.into_inner(),
                            up.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "look_to_rh",
                |
                    eye: Val<bevy::math::Vec3>,
                    dir: Val<bevy::math::Vec3>,
                    up: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::look_to_rh(
                            eye.into_inner(),
                            dir.into_inner(),
                            up.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Affine3A>, rhs: Val<bevy::math::Affine3A>| {
                    let output: Val<bevy::math::Affine3A> = <bevy::math::Affine3A as std::ops::Mul<
                        bevy::math::Affine3A,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::Affine3A>, rhs: Val<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = <bevy::math::Affine3A as std::ops::Mul<
                        bevy::math::Mat4,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array",
                |_self: Ref<bevy::math::Affine3A>| {
                    let output: [f32; 12] = bevy::math::Affine3A::to_cols_array(&_self)
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::Affine3A>| {
                    let output: [[f32; 3]; 4] = bevy::math::Affine3A::to_cols_array_2d(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_point3",
                |_self: Ref<bevy::math::Affine3A>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Affine3A::transform_point3(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_point3a",
                |_self: Ref<bevy::math::Affine3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Affine3A::transform_point3a(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_vector3",
                |_self: Ref<bevy::math::Affine3A>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = bevy::math::Affine3A::transform_vector3(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_vector3a",
                |_self: Ref<bevy::math::Affine3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = bevy::math::Affine3A::transform_vector3a(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::DAffine2>::new(world)
            .register(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::DAffine2>,
                    rhs: Val<bevy::math::DAffine2>,
                    max_abs_diff: f64|
                {
                    let output: bool = bevy::math::DAffine2::abs_diff_eq(
                            &_self,
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::DAffine2>| {
                    let output: Val<bevy::math::DAffine2> = <bevy::math::DAffine2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::DAffine2>, rhs: Ref<bevy::math::DAffine2>| {
                    let output: bool = <bevy::math::DAffine2 as std::cmp::PartialEq<
                        bevy::math::DAffine2,
                    >>::eq(&_self, &rhs)
                        .into();
                    output
                },
            )
            .register(
                "from_angle",
                |angle: f64| {
                    let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_angle(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_angle_translation",
                |angle: f64, translation: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_angle_translation(
                            angle,
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_cols",
                |
                    x_axis: Val<bevy::math::DVec2>,
                    y_axis: Val<bevy::math::DVec2>,
                    z_axis: Val<bevy::math::DVec2>|
                {
                    let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_cols(
                            x_axis.into_inner(),
                            y_axis.into_inner(),
                            z_axis.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat2",
                |matrix2: Val<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_mat2(
                            matrix2.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat2_translation",
                |matrix2: Val<bevy::math::DMat2>, translation: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_mat2_translation(
                            matrix2.into_inner(),
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat3",
                |m: Val<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_mat3(
                            m.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale",
                |scale: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_scale(
                            scale.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale_angle_translation",
                |
                    scale: Val<bevy::math::DVec2>,
                    angle: f64,
                    translation: Val<bevy::math::DVec2>|
                {
                    let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_scale_angle_translation(
                            scale.into_inner(),
                            angle,
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_translation",
                |translation: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_translation(
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "inverse",
                |_self: Ref<bevy::math::DAffine2>| {
                    let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::inverse(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Ref<bevy::math::DAffine2>| {
                    let output: bool = bevy::math::DAffine2::is_finite(&_self).into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Ref<bevy::math::DAffine2>| {
                    let output: bool = bevy::math::DAffine2::is_nan(&_self).into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DAffine2>, rhs: Val<bevy::math::DAffine2>| {
                    let output: Val<bevy::math::DAffine2> = <bevy::math::DAffine2 as std::ops::Mul<
                        bevy::math::DAffine2,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DAffine2>, rhs: Val<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = <bevy::math::DAffine2 as std::ops::Mul<
                        bevy::math::DMat3,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array",
                |_self: Ref<bevy::math::DAffine2>| {
                    let output: [f64; 6] = bevy::math::DAffine2::to_cols_array(&_self)
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::DAffine2>| {
                    let output: [[f64; 2]; 3] = bevy::math::DAffine2::to_cols_array_2d(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_point2",
                |_self: Ref<bevy::math::DAffine2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DAffine2::transform_point2(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_vector2",
                |_self: Ref<bevy::math::DAffine2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = bevy::math::DAffine2::transform_vector2(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::DAffine3>::new(world)
            .register(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::DAffine3>,
                    rhs: Val<bevy::math::DAffine3>,
                    max_abs_diff: f64|
                {
                    let output: bool = bevy::math::DAffine3::abs_diff_eq(
                            &_self,
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::DAffine3>| {
                    let output: Val<bevy::math::DAffine3> = <bevy::math::DAffine3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::DAffine3>, rhs: Ref<bevy::math::DAffine3>| {
                    let output: bool = <bevy::math::DAffine3 as std::cmp::PartialEq<
                        bevy::math::DAffine3,
                    >>::eq(&_self, &rhs)
                        .into();
                    output
                },
            )
            .register(
                "from_axis_angle",
                |axis: Val<bevy::math::DVec3>, angle: f64| {
                    let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_axis_angle(
                            axis.into_inner(),
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_cols",
                |
                    x_axis: Val<bevy::math::DVec3>,
                    y_axis: Val<bevy::math::DVec3>,
                    z_axis: Val<bevy::math::DVec3>,
                    w_axis: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_cols(
                            x_axis.into_inner(),
                            y_axis.into_inner(),
                            z_axis.into_inner(),
                            w_axis.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat3",
                |mat3: Val<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_mat3(
                            mat3.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat3_translation",
                |mat3: Val<bevy::math::DMat3>, translation: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_mat3_translation(
                            mat3.into_inner(),
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat4",
                |m: Val<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_mat4(
                            m.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_quat",
                |rotation: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_quat(
                            rotation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_translation",
                |rotation: Val<bevy::math::DQuat>, translation: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_rotation_translation(
                            rotation.into_inner(),
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_x",
                |angle: f64| {
                    let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_rotation_x(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_y",
                |angle: f64| {
                    let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_rotation_y(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_z",
                |angle: f64| {
                    let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_rotation_z(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale",
                |scale: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_scale(
                            scale.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scale_rotation_translation",
                |
                    scale: Val<bevy::math::DVec3>,
                    rotation: Val<bevy::math::DQuat>,
                    translation: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_scale_rotation_translation(
                            scale.into_inner(),
                            rotation.into_inner(),
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_translation",
                |translation: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_translation(
                            translation.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "inverse",
                |_self: Ref<bevy::math::DAffine3>| {
                    let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::inverse(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Ref<bevy::math::DAffine3>| {
                    let output: bool = bevy::math::DAffine3::is_finite(&_self).into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Ref<bevy::math::DAffine3>| {
                    let output: bool = bevy::math::DAffine3::is_nan(&_self).into();
                    output
                },
            )
            .register(
                "look_at_lh",
                |
                    eye: Val<bevy::math::DVec3>,
                    center: Val<bevy::math::DVec3>,
                    up: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::look_at_lh(
                            eye.into_inner(),
                            center.into_inner(),
                            up.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "look_at_rh",
                |
                    eye: Val<bevy::math::DVec3>,
                    center: Val<bevy::math::DVec3>,
                    up: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::look_at_rh(
                            eye.into_inner(),
                            center.into_inner(),
                            up.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "look_to_lh",
                |
                    eye: Val<bevy::math::DVec3>,
                    dir: Val<bevy::math::DVec3>,
                    up: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::look_to_lh(
                            eye.into_inner(),
                            dir.into_inner(),
                            up.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "look_to_rh",
                |
                    eye: Val<bevy::math::DVec3>,
                    dir: Val<bevy::math::DVec3>,
                    up: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::look_to_rh(
                            eye.into_inner(),
                            dir.into_inner(),
                            up.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DAffine3>, rhs: Val<bevy::math::DAffine3>| {
                    let output: Val<bevy::math::DAffine3> = <bevy::math::DAffine3 as std::ops::Mul<
                        bevy::math::DAffine3,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DAffine3>, rhs: Val<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = <bevy::math::DAffine3 as std::ops::Mul<
                        bevy::math::DMat4,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array",
                |_self: Ref<bevy::math::DAffine3>| {
                    let output: [f64; 12] = bevy::math::DAffine3::to_cols_array(&_self)
                        .into();
                    output
                },
            )
            .register(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::DAffine3>| {
                    let output: [[f64; 3]; 4] = bevy::math::DAffine3::to_cols_array_2d(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_point3",
                |_self: Ref<bevy::math::DAffine3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DAffine3::transform_point3(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "transform_vector3",
                |_self: Ref<bevy::math::DAffine3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DAffine3::transform_vector3(
                            &_self,
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::DQuat>::new(world)
            .register(
                "abs_diff_eq",
                |
                    _self: Val<bevy::math::DQuat>,
                    rhs: Val<bevy::math::DQuat>,
                    max_abs_diff: f64|
                {
                    let output: bool = bevy::math::DQuat::abs_diff_eq(
                            _self.into_inner(),
                            rhs.into_inner(),
                            max_abs_diff,
                        )
                        .into();
                    output
                },
            )
            .register(
                "add",
                |_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as std::ops::Add<
                        bevy::math::DQuat,
                    >>::add(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "angle_between",
                |_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>| {
                    let output: f64 = bevy::math::DQuat::angle_between(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "as_quat",
                |_self: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::Quat> = bevy::math::DQuat::as_quat(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "conjugate",
                |_self: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::conjugate(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "div",
                |_self: Val<bevy::math::DQuat>, rhs: f64| {
                    let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as std::ops::Div<
                        f64,
                    >>::div(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "dot",
                |_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>| {
                    let output: f64 = bevy::math::DQuat::dot(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::DQuat>, rhs: Ref<bevy::math::DQuat>| {
                    let output: bool = <bevy::math::DQuat as std::cmp::PartialEq<
                        bevy::math::DQuat,
                    >>::eq(&_self, &rhs)
                        .into();
                    output
                },
            )
            .register(
                "from_affine3",
                |a: Ref<bevy::math::DAffine3>| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_affine3(
                            &a,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [f64; 4]| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_array(a)
                        .into();
                    output
                },
            )
            .register(
                "from_axis_angle",
                |axis: Val<bevy::math::DVec3>, angle: f64| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_axis_angle(
                            axis.into_inner(),
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_euler",
                |euler: Val<bevy::math::EulerRot>, a: f64, b: f64, c: f64| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_euler(
                            euler.into_inner(),
                            a,
                            b,
                            c,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat3",
                |mat: Ref<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_mat3(
                            &mat,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_mat4",
                |mat: Ref<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_mat4(
                            &mat,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_arc",
                |from: Val<bevy::math::DVec3>, to: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_arc(
                            from.into_inner(),
                            to.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_arc_2d",
                |from: Val<bevy::math::DVec2>, to: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_arc_2d(
                            from.into_inner(),
                            to.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_arc_colinear",
                |from: Val<bevy::math::DVec3>, to: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_arc_colinear(
                            from.into_inner(),
                            to.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_x",
                |angle: f64| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_x(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_y",
                |angle: f64| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_y(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_rotation_z",
                |angle: f64| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_z(
                            angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_scaled_axis",
                |v: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_scaled_axis(
                            v.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_vec4",
                |v: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_vec4(
                            v.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "from_xyzw",
                |x: f64, y: f64, z: f64, w: f64| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_xyzw(
                            x,
                            y,
                            z,
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "inverse",
                |_self: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::inverse(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_finite",
                |_self: Val<bevy::math::DQuat>| {
                    let output: bool = bevy::math::DQuat::is_finite(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_nan",
                |_self: Val<bevy::math::DQuat>| {
                    let output: bool = bevy::math::DQuat::is_nan(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_near_identity",
                |_self: Val<bevy::math::DQuat>| {
                    let output: bool = bevy::math::DQuat::is_near_identity(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "is_normalized",
                |_self: Val<bevy::math::DQuat>| {
                    let output: bool = bevy::math::DQuat::is_normalized(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "length",
                |_self: Val<bevy::math::DQuat>| {
                    let output: f64 = bevy::math::DQuat::length(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_recip",
                |_self: Val<bevy::math::DQuat>| {
                    let output: f64 = bevy::math::DQuat::length_recip(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "length_squared",
                |_self: Val<bevy::math::DQuat>| {
                    let output: f64 = bevy::math::DQuat::length_squared(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "lerp",
                |_self: Val<bevy::math::DQuat>, end: Val<bevy::math::DQuat>, s: f64| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::lerp(
                            _self.into_inner(),
                            end.into_inner(),
                            s,
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = <bevy::math::DQuat as std::ops::Mul<
                        bevy::math::DVec3,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as std::ops::Mul<
                        bevy::math::DQuat,
                    >>::mul(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "mul",
                |_self: Val<bevy::math::DQuat>, rhs: f64| {
                    let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as std::ops::Mul<
                        f64,
                    >>::mul(_self.into_inner(), rhs)
                        .into();
                    output
                },
            )
            .register(
                "mul_quat",
                |_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::mul_quat(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "mul_vec3",
                |_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DQuat::mul_vec3(
                            _self.into_inner(),
                            rhs.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "neg",
                |_self: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as std::ops::Neg>::neg(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "normalize",
                |_self: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::normalize(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "rotate_towards",
                |
                    _self: Ref<bevy::math::DQuat>,
                    rhs: Val<bevy::math::DQuat>,
                    max_angle: f64|
                {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::rotate_towards(
                            &_self,
                            rhs.into_inner(),
                            max_angle,
                        )
                        .into();
                    output
                },
            )
            .register(
                "slerp",
                |_self: Val<bevy::math::DQuat>, end: Val<bevy::math::DQuat>, s: f64| {
                    let output: Val<bevy::math::DQuat> = bevy::math::DQuat::slerp(
                            _self.into_inner(),
                            end.into_inner(),
                            s,
                        )
                        .into();
                    output
                },
            )
            .register(
                "sub",
                |_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as std::ops::Sub<
                        bevy::math::DQuat,
                    >>::sub(_self.into_inner(), rhs.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "to_array",
                |_self: Ref<bevy::math::DQuat>| {
                    let output: [f64; 4] = bevy::math::DQuat::to_array(&_self).into();
                    output
                },
            )
            .register(
                "to_euler",
                |_self: Val<bevy::math::DQuat>, order: Val<bevy::math::EulerRot>| {
                    let output: (f64, f64, f64) = bevy::math::DQuat::to_euler(
                            _self.into_inner(),
                            order.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "to_scaled_axis",
                |_self: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DQuat::to_scaled_axis(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            )
            .register(
                "xyz",
                |_self: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DVec3> = bevy::math::DQuat::xyz(
                            _self.into_inner(),
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::EulerRot>::new(world)
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::EulerRot>| {
                    let output: () = <bevy::math::EulerRot as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::EulerRot>| {
                    let output: Val<bevy::math::EulerRot> = <bevy::math::EulerRot as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::EulerRot>, other: Ref<bevy::math::EulerRot>| {
                    let output: bool = <bevy::math::EulerRot as std::cmp::PartialEq<
                        bevy::math::EulerRot,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::BVec3A>::new(world)
            .register(
                "all",
                |_self: Val<bevy::math::BVec3A>| {
                    let output: bool = bevy::math::BVec3A::all(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "any",
                |_self: Val<bevy::math::BVec3A>| {
                    let output: bool = bevy::math::BVec3A::any(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "bitmask",
                |_self: Val<bevy::math::BVec3A>| {
                    let output: u32 = bevy::math::BVec3A::bitmask(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::BVec3A>| {
                    let output: Val<bevy::math::BVec3A> = <bevy::math::BVec3A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::BVec3A>, rhs: Ref<bevy::math::BVec3A>| {
                    let output: bool = <bevy::math::BVec3A as std::cmp::PartialEq<
                        bevy::math::BVec3A,
                    >>::eq(&_self, &rhs)
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [bool; 3]| {
                    let output: Val<bevy::math::BVec3A> = bevy::math::BVec3A::from_array(
                            a,
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: bool, y: bool, z: bool| {
                    let output: Val<bevy::math::BVec3A> = bevy::math::BVec3A::new(
                            x,
                            y,
                            z,
                        )
                        .into();
                    output
                },
            )
            .register(
                "set",
                |mut _self: Mut<bevy::math::BVec3A>, index: usize, value: bool| {
                    let output: () = bevy::math::BVec3A::set(&mut _self, index, value)
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: bool| {
                    let output: Val<bevy::math::BVec3A> = bevy::math::BVec3A::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "test",
                |_self: Ref<bevy::math::BVec3A>, index: usize| {
                    let output: bool = bevy::math::BVec3A::test(&_self, index).into();
                    output
                },
            );
        NamespaceBuilder::<::bevy::math::BVec4A>::new(world)
            .register(
                "all",
                |_self: Val<bevy::math::BVec4A>| {
                    let output: bool = bevy::math::BVec4A::all(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "any",
                |_self: Val<bevy::math::BVec4A>| {
                    let output: bool = bevy::math::BVec4A::any(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "bitmask",
                |_self: Val<bevy::math::BVec4A>| {
                    let output: u32 = bevy::math::BVec4A::bitmask(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<bevy::math::BVec4A>| {
                    let output: Val<bevy::math::BVec4A> = <bevy::math::BVec4A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<bevy::math::BVec4A>, rhs: Ref<bevy::math::BVec4A>| {
                    let output: bool = <bevy::math::BVec4A as std::cmp::PartialEq<
                        bevy::math::BVec4A,
                    >>::eq(&_self, &rhs)
                        .into();
                    output
                },
            )
            .register(
                "from_array",
                |a: [bool; 4]| {
                    let output: Val<bevy::math::BVec4A> = bevy::math::BVec4A::from_array(
                            a,
                        )
                        .into();
                    output
                },
            )
            .register(
                "new",
                |x: bool, y: bool, z: bool, w: bool| {
                    let output: Val<bevy::math::BVec4A> = bevy::math::BVec4A::new(
                            x,
                            y,
                            z,
                            w,
                        )
                        .into();
                    output
                },
            )
            .register(
                "set",
                |mut _self: Mut<bevy::math::BVec4A>, index: usize, value: bool| {
                    let output: () = bevy::math::BVec4A::set(&mut _self, index, value)
                        .into();
                    output
                },
            )
            .register(
                "splat",
                |v: bool| {
                    let output: Val<bevy::math::BVec4A> = bevy::math::BVec4A::splat(v)
                        .into();
                    output
                },
            )
            .register(
                "test",
                |_self: Ref<bevy::math::BVec4A>, index: usize| {
                    let output: bool = bevy::math::BVec4A::test(&_self, index).into();
                    output
                },
            );
        NamespaceBuilder::<::smol_str::SmolStr>::new(world)
            .register(
                "clone",
                |_self: Ref<smol_str::SmolStr>| {
                    let output: Val<smol_str::SmolStr> = <smol_str::SmolStr as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<smol_str::SmolStr>, other: Ref<smol_str::SmolStr>| {
                    let output: bool = <smol_str::SmolStr as std::cmp::PartialEq<
                        smol_str::SmolStr,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "is_empty",
                |_self: Ref<smol_str::SmolStr>| {
                    let output: bool = smol_str::SmolStr::is_empty(&_self).into();
                    output
                },
            )
            .register(
                "is_heap_allocated",
                |_self: Ref<smol_str::SmolStr>| {
                    let output: bool = smol_str::SmolStr::is_heap_allocated(&_self)
                        .into();
                    output
                },
            )
            .register(
                "len",
                |_self: Ref<smol_str::SmolStr>| {
                    let output: usize = smol_str::SmolStr::len(&_self).into();
                    output
                },
            )
            .register(
                "to_string",
                |_self: Ref<smol_str::SmolStr>| {
                    let output: std::string::String = smol_str::SmolStr::to_string(
                            &_self,
                        )
                        .into();
                    output
                },
            );
        NamespaceBuilder::<::uuid::Uuid>::new(world)
            .register(
                "as_u128",
                |_self: Ref<uuid::Uuid>| {
                    let output: u128 = uuid::Uuid::as_u128(&_self).into();
                    output
                },
            )
            .register(
                "as_u64_pair",
                |_self: Ref<uuid::Uuid>| {
                    let output: (u64, u64) = uuid::Uuid::as_u64_pair(&_self).into();
                    output
                },
            )
            .register(
                "assert_receiver_is_total_eq",
                |_self: Ref<uuid::Uuid>| {
                    let output: () = <uuid::Uuid as std::cmp::Eq>::assert_receiver_is_total_eq(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "clone",
                |_self: Ref<uuid::Uuid>| {
                    let output: Val<uuid::Uuid> = <uuid::Uuid as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                            &_self,
                        )
                        .into();
                    output
                },
            )
            .register(
                "encode_buffer",
                || {
                    let output: [u8; 45] = uuid::Uuid::encode_buffer().into();
                    output
                },
            )
            .register(
                "eq",
                |_self: Ref<uuid::Uuid>, other: Ref<uuid::Uuid>| {
                    let output: bool = <uuid::Uuid as std::cmp::PartialEq<
                        uuid::Uuid,
                    >>::eq(&_self, &other)
                        .into();
                    output
                },
            )
            .register(
                "from_bytes",
                |bytes: [u8; 16]| {
                    let output: Val<uuid::Uuid> = uuid::Uuid::from_bytes(bytes).into();
                    output
                },
            )
            .register(
                "from_bytes_le",
                |b: [u8; 16]| {
                    let output: Val<uuid::Uuid> = uuid::Uuid::from_bytes_le(b).into();
                    output
                },
            )
            .register(
                "from_u128",
                |v: u128| {
                    let output: Val<uuid::Uuid> = uuid::Uuid::from_u128(v).into();
                    output
                },
            )
            .register(
                "from_u128_le",
                |v: u128| {
                    let output: Val<uuid::Uuid> = uuid::Uuid::from_u128_le(v).into();
                    output
                },
            )
            .register(
                "from_u64_pair",
                |high_bits: u64, low_bits: u64| {
                    let output: Val<uuid::Uuid> = uuid::Uuid::from_u64_pair(
                            high_bits,
                            low_bits,
                        )
                        .into();
                    output
                },
            )
            .register(
                "get_node_id",
                |_self: Ref<uuid::Uuid>| {
                    let output: bevy::reflect::erased_serde::__private::serde::__private::Option<
                        [u8; 6],
                    > = uuid::Uuid::get_node_id(&_self).into();
                    output
                },
            )
            .register(
                "get_version_num",
                |_self: Ref<uuid::Uuid>| {
                    let output: usize = uuid::Uuid::get_version_num(&_self).into();
                    output
                },
            )
            .register(
                "into_bytes",
                |_self: Val<uuid::Uuid>| {
                    let output: [u8; 16] = uuid::Uuid::into_bytes(_self.into_inner())
                        .into();
                    output
                },
            )
            .register(
                "is_max",
                |_self: Ref<uuid::Uuid>| {
                    let output: bool = uuid::Uuid::is_max(&_self).into();
                    output
                },
            )
            .register(
                "is_nil",
                |_self: Ref<uuid::Uuid>| {
                    let output: bool = uuid::Uuid::is_nil(&_self).into();
                    output
                },
            )
            .register(
                "max",
                || {
                    let output: Val<uuid::Uuid> = uuid::Uuid::max().into();
                    output
                },
            )
            .register(
                "new_v4",
                || {
                    let output: Val<uuid::Uuid> = uuid::Uuid::new_v4().into();
                    output
                },
            )
            .register(
                "nil",
                || {
                    let output: Val<uuid::Uuid> = uuid::Uuid::nil().into();
                    output
                },
            )
            .register(
                "to_bytes_le",
                |_self: Ref<uuid::Uuid>| {
                    let output: [u8; 16] = uuid::Uuid::to_bytes_le(&_self).into();
                    output
                },
            )
            .register(
                "to_u128_le",
                |_self: Ref<uuid::Uuid>| {
                    let output: u128 = uuid::Uuid::to_u128_le(&_self).into();
                    output
                },
            );
    }
}
