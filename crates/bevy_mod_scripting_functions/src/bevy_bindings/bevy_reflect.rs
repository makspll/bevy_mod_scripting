// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use bevy_mod_scripting_core::bindings::{
    ReflectReference,
    function::{
        from::{Ref, Mut, Val},
        namespace::NamespaceBuilder,
    },
};
use bevy_mod_scripting_derive::script_bindings;
use crate::*;
pub struct BevyReflectScriptingPlugin;
#[script_bindings(remote, name = "atomic_bool")]
impl std::sync::atomic::AtomicBool {
    fn into_inner(_self: Val<std::sync::atomic::AtomicBool>) {
        let output: bool = std::sync::atomic::AtomicBool::into_inner(_self.into_inner())
            .into();
        output
    }
    fn new(v: bool) {
        let output: Val<std::sync::atomic::AtomicBool> = std::sync::atomic::AtomicBool::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "atomic_i_16")]
impl std::sync::atomic::AtomicI16 {
    fn into_inner(_self: Val<std::sync::atomic::AtomicI16>) {
        let output: i16 = std::sync::atomic::AtomicI16::into_inner(_self.into_inner())
            .into();
        output
    }
    fn new(v: i16) {
        let output: Val<std::sync::atomic::AtomicI16> = std::sync::atomic::AtomicI16::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "atomic_i_32")]
impl std::sync::atomic::AtomicI32 {
    fn into_inner(_self: Val<std::sync::atomic::AtomicI32>) {
        let output: i32 = std::sync::atomic::AtomicI32::into_inner(_self.into_inner())
            .into();
        output
    }
    fn new(v: i32) {
        let output: Val<std::sync::atomic::AtomicI32> = std::sync::atomic::AtomicI32::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "atomic_i_64")]
impl std::sync::atomic::AtomicI64 {
    fn into_inner(_self: Val<std::sync::atomic::AtomicI64>) {
        let output: i64 = std::sync::atomic::AtomicI64::into_inner(_self.into_inner())
            .into();
        output
    }
    fn new(v: i64) {
        let output: Val<std::sync::atomic::AtomicI64> = std::sync::atomic::AtomicI64::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "atomic_i_8")]
impl std::sync::atomic::AtomicI8 {
    fn into_inner(_self: Val<std::sync::atomic::AtomicI8>) {
        let output: i8 = std::sync::atomic::AtomicI8::into_inner(_self.into_inner())
            .into();
        output
    }
    fn new(v: i8) {
        let output: Val<std::sync::atomic::AtomicI8> = std::sync::atomic::AtomicI8::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "atomic_isize")]
impl std::sync::atomic::AtomicIsize {
    fn into_inner(_self: Val<std::sync::atomic::AtomicIsize>) {
        let output: isize = std::sync::atomic::AtomicIsize::into_inner(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn new(v: isize) {
        let output: Val<std::sync::atomic::AtomicIsize> = std::sync::atomic::AtomicIsize::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "atomic_u_16")]
impl std::sync::atomic::AtomicU16 {
    fn into_inner(_self: Val<std::sync::atomic::AtomicU16>) {
        let output: u16 = std::sync::atomic::AtomicU16::into_inner(_self.into_inner())
            .into();
        output
    }
    fn new(v: u16) {
        let output: Val<std::sync::atomic::AtomicU16> = std::sync::atomic::AtomicU16::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "atomic_u_32")]
impl std::sync::atomic::AtomicU32 {
    fn into_inner(_self: Val<std::sync::atomic::AtomicU32>) {
        let output: u32 = std::sync::atomic::AtomicU32::into_inner(_self.into_inner())
            .into();
        output
    }
    fn new(v: u32) {
        let output: Val<std::sync::atomic::AtomicU32> = std::sync::atomic::AtomicU32::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "atomic_u_64")]
impl std::sync::atomic::AtomicU64 {
    fn into_inner(_self: Val<std::sync::atomic::AtomicU64>) {
        let output: u64 = std::sync::atomic::AtomicU64::into_inner(_self.into_inner())
            .into();
        output
    }
    fn new(v: u64) {
        let output: Val<std::sync::atomic::AtomicU64> = std::sync::atomic::AtomicU64::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "atomic_u_8")]
impl std::sync::atomic::AtomicU8 {
    fn into_inner(_self: Val<std::sync::atomic::AtomicU8>) {
        let output: u8 = std::sync::atomic::AtomicU8::into_inner(_self.into_inner())
            .into();
        output
    }
    fn new(v: u8) {
        let output: Val<std::sync::atomic::AtomicU8> = std::sync::atomic::AtomicU8::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "atomic_usize")]
impl std::sync::atomic::AtomicUsize {
    fn into_inner(_self: Val<std::sync::atomic::AtomicUsize>) {
        let output: usize = std::sync::atomic::AtomicUsize::into_inner(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn new(v: usize) {
        let output: Val<std::sync::atomic::AtomicUsize> = std::sync::atomic::AtomicUsize::new(
                v,
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "duration")]
impl bevy::utils::Duration {
    fn abs_diff(_self: Val<bevy::utils::Duration>, other: Val<bevy::utils::Duration>) {
        let output: Val<bevy::utils::Duration> = bevy::utils::Duration::abs_diff(
                _self.into_inner(),
                other.into_inner(),
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::utils::Duration>, rhs: Val<bevy::utils::Duration>) {
        let output: Val<bevy::utils::Duration> = <bevy::utils::Duration as std::ops::Add<
            bevy::utils::Duration,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn as_micros(_self: Ref<bevy::utils::Duration>) {
        let output: u128 = bevy::utils::Duration::as_micros(&_self).into();
        output
    }
    fn as_millis(_self: Ref<bevy::utils::Duration>) {
        let output: u128 = bevy::utils::Duration::as_millis(&_self).into();
        output
    }
    fn as_nanos(_self: Ref<bevy::utils::Duration>) {
        let output: u128 = bevy::utils::Duration::as_nanos(&_self).into();
        output
    }
    fn as_secs(_self: Ref<bevy::utils::Duration>) {
        let output: u64 = bevy::utils::Duration::as_secs(&_self).into();
        output
    }
    fn as_secs_f32(_self: Ref<bevy::utils::Duration>) {
        let output: f32 = bevy::utils::Duration::as_secs_f32(&_self).into();
        output
    }
    fn as_secs_f64(_self: Ref<bevy::utils::Duration>) {
        let output: f64 = bevy::utils::Duration::as_secs_f64(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::utils::Duration>) {
        let output: () = <bevy::utils::Duration as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::utils::Duration>) {
        let output: Val<bevy::utils::Duration> = <bevy::utils::Duration as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::utils::Duration>, rhs: u32) {
        let output: Val<bevy::utils::Duration> = <bevy::utils::Duration as std::ops::Div<
            u32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_duration_f32(
        _self: Val<bevy::utils::Duration>,
        rhs: Val<bevy::utils::Duration>,
    ) {
        let output: f32 = bevy::utils::Duration::div_duration_f32(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div_duration_f64(
        _self: Val<bevy::utils::Duration>,
        rhs: Val<bevy::utils::Duration>,
    ) {
        let output: f64 = bevy::utils::Duration::div_duration_f64(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div_f32(_self: Val<bevy::utils::Duration>, rhs: f32) {
        let output: Val<bevy::utils::Duration> = bevy::utils::Duration::div_f32(
                _self.into_inner(),
                rhs,
            )
            .into();
        output
    }
    fn div_f64(_self: Val<bevy::utils::Duration>, rhs: f64) {
        let output: Val<bevy::utils::Duration> = bevy::utils::Duration::div_f64(
                _self.into_inner(),
                rhs,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::utils::Duration>, other: Ref<bevy::utils::Duration>) {
        let output: bool = <bevy::utils::Duration as std::cmp::PartialEq<
            bevy::utils::Duration,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn from_micros(micros: u64) {
        let output: Val<bevy::utils::Duration> = bevy::utils::Duration::from_micros(
                micros,
            )
            .into();
        output
    }
    fn from_millis(millis: u64) {
        let output: Val<bevy::utils::Duration> = bevy::utils::Duration::from_millis(
                millis,
            )
            .into();
        output
    }
    fn from_nanos(nanos: u64) {
        let output: Val<bevy::utils::Duration> = bevy::utils::Duration::from_nanos(nanos)
            .into();
        output
    }
    fn from_secs(secs: u64) {
        let output: Val<bevy::utils::Duration> = bevy::utils::Duration::from_secs(secs)
            .into();
        output
    }
    fn from_secs_f32(secs: f32) {
        let output: Val<bevy::utils::Duration> = bevy::utils::Duration::from_secs_f32(
                secs,
            )
            .into();
        output
    }
    fn from_secs_f64(secs: f64) {
        let output: Val<bevy::utils::Duration> = bevy::utils::Duration::from_secs_f64(
                secs,
            )
            .into();
        output
    }
    fn is_zero(_self: Ref<bevy::utils::Duration>) {
        let output: bool = bevy::utils::Duration::is_zero(&_self).into();
        output
    }
    fn mul(_self: Val<bevy::utils::Duration>, rhs: u32) {
        let output: Val<bevy::utils::Duration> = <bevy::utils::Duration as std::ops::Mul<
            u32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn mul_f32(_self: Val<bevy::utils::Duration>, rhs: f32) {
        let output: Val<bevy::utils::Duration> = bevy::utils::Duration::mul_f32(
                _self.into_inner(),
                rhs,
            )
            .into();
        output
    }
    fn mul_f64(_self: Val<bevy::utils::Duration>, rhs: f64) {
        let output: Val<bevy::utils::Duration> = bevy::utils::Duration::mul_f64(
                _self.into_inner(),
                rhs,
            )
            .into();
        output
    }
    fn new(secs: u64, nanos: u32) {
        let output: Val<bevy::utils::Duration> = bevy::utils::Duration::new(secs, nanos)
            .into();
        output
    }
    fn saturating_add(
        _self: Val<bevy::utils::Duration>,
        rhs: Val<bevy::utils::Duration>,
    ) {
        let output: Val<bevy::utils::Duration> = bevy::utils::Duration::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_mul(_self: Val<bevy::utils::Duration>, rhs: u32) {
        let output: Val<bevy::utils::Duration> = bevy::utils::Duration::saturating_mul(
                _self.into_inner(),
                rhs,
            )
            .into();
        output
    }
    fn saturating_sub(
        _self: Val<bevy::utils::Duration>,
        rhs: Val<bevy::utils::Duration>,
    ) {
        let output: Val<bevy::utils::Duration> = bevy::utils::Duration::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn sub(_self: Val<bevy::utils::Duration>, rhs: Val<bevy::utils::Duration>) {
        let output: Val<bevy::utils::Duration> = <bevy::utils::Duration as std::ops::Sub<
            bevy::utils::Duration,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn subsec_micros(_self: Ref<bevy::utils::Duration>) {
        let output: u32 = bevy::utils::Duration::subsec_micros(&_self).into();
        output
    }
    fn subsec_millis(_self: Ref<bevy::utils::Duration>) {
        let output: u32 = bevy::utils::Duration::subsec_millis(&_self).into();
        output
    }
    fn subsec_nanos(_self: Ref<bevy::utils::Duration>) {
        let output: u32 = bevy::utils::Duration::subsec_nanos(&_self).into();
        output
    }
}
#[script_bindings(remote, name = "instant")]
impl bevy::utils::Instant {
    fn add(_self: Val<bevy::utils::Instant>, other: Val<bevy::utils::Duration>) {
        let output: Val<bevy::utils::Instant> = <bevy::utils::Instant as std::ops::Add<
            bevy::utils::Duration,
        >>::add(_self.into_inner(), other.into_inner())
            .into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::utils::Instant>) {
        let output: () = <bevy::utils::Instant as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::utils::Instant>) {
        let output: Val<bevy::utils::Instant> = <bevy::utils::Instant as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn duration_since(
        _self: Ref<bevy::utils::Instant>,
        earlier: Val<bevy::utils::Instant>,
    ) {
        let output: Val<bevy::utils::Duration> = bevy::utils::Instant::duration_since(
                &_self,
                earlier.into_inner(),
            )
            .into();
        output
    }
    fn elapsed(_self: Ref<bevy::utils::Instant>) {
        let output: Val<bevy::utils::Duration> = bevy::utils::Instant::elapsed(&_self)
            .into();
        output
    }
    fn eq(_self: Ref<bevy::utils::Instant>, other: Ref<bevy::utils::Instant>) {
        let output: bool = <bevy::utils::Instant as std::cmp::PartialEq<
            bevy::utils::Instant,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn now() {
        let output: Val<bevy::utils::Instant> = bevy::utils::Instant::now().into();
        output
    }
    fn saturating_duration_since(
        _self: Ref<bevy::utils::Instant>,
        earlier: Val<bevy::utils::Instant>,
    ) {
        let output: Val<bevy::utils::Duration> = bevy::utils::Instant::saturating_duration_since(
                &_self,
                earlier.into_inner(),
            )
            .into();
        output
    }
    fn sub(_self: Val<bevy::utils::Instant>, other: Val<bevy::utils::Duration>) {
        let output: Val<bevy::utils::Instant> = <bevy::utils::Instant as std::ops::Sub<
            bevy::utils::Duration,
        >>::sub(_self.into_inner(), other.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::utils::Instant>, other: Val<bevy::utils::Instant>) {
        let output: Val<bevy::utils::Duration> = <bevy::utils::Instant as std::ops::Sub<
            bevy::utils::Instant,
        >>::sub(_self.into_inner(), other.into_inner())
            .into();
        output
    }
}
#[script_bindings(remote, name = "range_full")]
impl std::ops::RangeFull {
    fn assert_receiver_is_total_eq(_self: Ref<std::ops::RangeFull>) {
        let output: () = <std::ops::RangeFull as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(_self: Ref<std::ops::RangeFull>) {
        let output: Val<std::ops::RangeFull> = <std::ops::RangeFull as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<std::ops::RangeFull>, other: Ref<std::ops::RangeFull>) {
        let output: bool = <std::ops::RangeFull as std::cmp::PartialEq<
            std::ops::RangeFull,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(remote, name = "quat")]
impl bevy::math::Quat {
    fn abs_diff_eq(
        _self: Val<bevy::math::Quat>,
        rhs: Val<bevy::math::Quat>,
        max_abs_diff: f32,
    ) {
        let output: bool = bevy::math::Quat::abs_diff_eq(
                _self.into_inner(),
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>) {
        let output: Val<bevy::math::Quat> = <bevy::math::Quat as std::ops::Add<
            bevy::math::Quat,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn angle_between(_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>) {
        let output: f32 = bevy::math::Quat::angle_between(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn as_dquat(_self: Val<bevy::math::Quat>) {
        let output: Val<bevy::math::DQuat> = bevy::math::Quat::as_dquat(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::Quat>) {
        let output: Val<bevy::math::Quat> = <bevy::math::Quat as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn conjugate(_self: Val<bevy::math::Quat>) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::conjugate(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::Quat>, rhs: f32) {
        let output: Val<bevy::math::Quat> = <bevy::math::Quat as std::ops::Div<
            f32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>) {
        let output: f32 = bevy::math::Quat::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::Quat>, rhs: Ref<bevy::math::Quat>) {
        let output: bool = <bevy::math::Quat as std::cmp::PartialEq<
            bevy::math::Quat,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    fn from_affine3(a: Ref<bevy::math::Affine3A>) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_affine3(&a).into();
        output
    }
    fn from_array(a: [f32; 4]) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_array(a).into();
        output
    }
    fn from_axis_angle(axis: Val<bevy::math::Vec3>, angle: f32) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_axis_angle(
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    fn from_euler(euler: Val<bevy::math::EulerRot>, a: f32, b: f32, c: f32) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_euler(
                euler.into_inner(),
                a,
                b,
                c,
            )
            .into();
        output
    }
    fn from_mat3(mat: Ref<bevy::math::Mat3>) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_mat3(&mat).into();
        output
    }
    fn from_mat3a(mat: Ref<bevy::math::Mat3A>) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_mat3a(&mat).into();
        output
    }
    fn from_mat4(mat: Ref<bevy::math::Mat4>) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_mat4(&mat).into();
        output
    }
    fn from_rotation_arc(from: Val<bevy::math::Vec3>, to: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_arc(
                from.into_inner(),
                to.into_inner(),
            )
            .into();
        output
    }
    fn from_rotation_arc_2d(from: Val<bevy::math::Vec2>, to: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_arc_2d(
                from.into_inner(),
                to.into_inner(),
            )
            .into();
        output
    }
    fn from_rotation_arc_colinear(
        from: Val<bevy::math::Vec3>,
        to: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_arc_colinear(
                from.into_inner(),
                to.into_inner(),
            )
            .into();
        output
    }
    fn from_rotation_x(angle: f32) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_x(angle)
            .into();
        output
    }
    fn from_rotation_y(angle: f32) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_y(angle)
            .into();
        output
    }
    fn from_rotation_z(angle: f32) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_z(angle)
            .into();
        output
    }
    fn from_scaled_axis(v: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_scaled_axis(
                v.into_inner(),
            )
            .into();
        output
    }
    fn from_vec4(v: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_vec4(v.into_inner())
            .into();
        output
    }
    fn from_xyzw(x: f32, y: f32, z: f32, w: f32) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::from_xyzw(x, y, z, w)
            .into();
        output
    }
    fn inverse(_self: Val<bevy::math::Quat>) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::inverse(_self.into_inner())
            .into();
        output
    }
    fn is_finite(_self: Val<bevy::math::Quat>) {
        let output: bool = bevy::math::Quat::is_finite(_self.into_inner()).into();
        output
    }
    fn is_nan(_self: Val<bevy::math::Quat>) {
        let output: bool = bevy::math::Quat::is_nan(_self.into_inner()).into();
        output
    }
    fn is_near_identity(_self: Val<bevy::math::Quat>) {
        let output: bool = bevy::math::Quat::is_near_identity(_self.into_inner()).into();
        output
    }
    fn is_normalized(_self: Val<bevy::math::Quat>) {
        let output: bool = bevy::math::Quat::is_normalized(_self.into_inner()).into();
        output
    }
    fn length(_self: Val<bevy::math::Quat>) {
        let output: f32 = bevy::math::Quat::length(_self.into_inner()).into();
        output
    }
    fn length_recip(_self: Val<bevy::math::Quat>) {
        let output: f32 = bevy::math::Quat::length_recip(_self.into_inner()).into();
        output
    }
    fn length_squared(_self: Val<bevy::math::Quat>) {
        let output: f32 = bevy::math::Quat::length_squared(_self.into_inner()).into();
        output
    }
    fn lerp(_self: Val<bevy::math::Quat>, end: Val<bevy::math::Quat>, s: f32) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::lerp(
                _self.into_inner(),
                end.into_inner(),
                s,
            )
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>) {
        let output: Val<bevy::math::Quat> = <bevy::math::Quat as std::ops::Mul<
            bevy::math::Quat,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Quat as std::ops::Mul<
            bevy::math::Vec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Quat as std::ops::Mul<
            bevy::math::Vec3A,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Quat>, rhs: f32) {
        let output: Val<bevy::math::Quat> = <bevy::math::Quat as std::ops::Mul<
            f32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn mul_quat(_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::mul_quat(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn mul_vec3(_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Quat::mul_vec3(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn mul_vec3a(_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Quat::mul_vec3a(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::Quat>) {
        let output: Val<bevy::math::Quat> = <bevy::math::Quat as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn normalize(_self: Val<bevy::math::Quat>) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::normalize(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn rotate_towards(
        _self: Ref<bevy::math::Quat>,
        rhs: Val<bevy::math::Quat>,
        max_angle: f32,
    ) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::rotate_towards(
                &_self,
                rhs.into_inner(),
                max_angle,
            )
            .into();
        output
    }
    fn slerp(_self: Val<bevy::math::Quat>, end: Val<bevy::math::Quat>, s: f32) {
        let output: Val<bevy::math::Quat> = bevy::math::Quat::slerp(
                _self.into_inner(),
                end.into_inner(),
                s,
            )
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>) {
        let output: Val<bevy::math::Quat> = <bevy::math::Quat as std::ops::Sub<
            bevy::math::Quat,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::Quat>) {
        let output: [f32; 4] = bevy::math::Quat::to_array(&_self).into();
        output
    }
    fn to_euler(_self: Val<bevy::math::Quat>, order: Val<bevy::math::EulerRot>) {
        let output: (f32, f32, f32) = bevy::math::Quat::to_euler(
                _self.into_inner(),
                order.into_inner(),
            )
            .into();
        output
    }
    fn to_scaled_axis(_self: Val<bevy::math::Quat>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Quat::to_scaled_axis(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn xyz(_self: Val<bevy::math::Quat>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Quat::xyz(_self.into_inner())
            .into();
        output
    }
}
#[script_bindings(remote, name = "vec_3")]
impl bevy::math::Vec3 {
    fn abs(_self: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::abs(_self.into_inner())
            .into();
        output
    }
    fn abs_diff_eq(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
        max_abs_diff: f32,
    ) {
        let output: bool = bevy::math::Vec3::abs_diff_eq(
                _self.into_inner(),
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Vec3>, rhs: Ref<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Add<
            &bevy::math::Vec3,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Add<
            bevy::math::Vec3,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Vec3>, rhs: f32) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Add<
            f32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn angle_between(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: f32 = bevy::math::Vec3::angle_between(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn any_orthogonal_vector(_self: Ref<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::any_orthogonal_vector(
                &_self,
            )
            .into();
        output
    }
    fn any_orthonormal_vector(_self: Ref<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::any_orthonormal_vector(
                &_self,
            )
            .into();
        output
    }
    fn as_dvec3(_self: Ref<bevy::math::Vec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::Vec3::as_dvec3(&_self).into();
        output
    }
    fn as_i64vec3(_self: Ref<bevy::math::Vec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::Vec3::as_i64vec3(&_self)
            .into();
        output
    }
    fn as_ivec3(_self: Ref<bevy::math::Vec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::Vec3::as_ivec3(&_self).into();
        output
    }
    fn as_u64vec3(_self: Ref<bevy::math::Vec3>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::Vec3::as_u64vec3(&_self)
            .into();
        output
    }
    fn as_uvec3(_self: Ref<bevy::math::Vec3>) {
        let output: Val<bevy::math::UVec3> = bevy::math::Vec3::as_uvec3(&_self).into();
        output
    }
    fn ceil(_self: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::ceil(_self.into_inner())
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::Vec3>,
        min: Val<bevy::math::Vec3>,
        max: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clamp_length(_self: Val<bevy::math::Vec3>, min: f32, max: f32) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::clamp_length(
                _self.into_inner(),
                min,
                max,
            )
            .into();
        output
    }
    fn clamp_length_max(_self: Val<bevy::math::Vec3>, max: f32) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::clamp_length_max(
                _self.into_inner(),
                max,
            )
            .into();
        output
    }
    fn clamp_length_min(_self: Val<bevy::math::Vec3>, min: f32) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::clamp_length_min(
                _self.into_inner(),
                min,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn copysign(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::copysign(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cross(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::cross(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: f32 = bevy::math::Vec3::distance(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance_squared(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: f32 = bevy::math::Vec3::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::Vec3>, rhs: Ref<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Div<
            &bevy::math::Vec3,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Div<
            bevy::math::Vec3,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::Vec3>, rhs: f32) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Div<
            f32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_euclid(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: f32 = bevy::math::Vec3::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::Vec3>) {
        let output: f32 = bevy::math::Vec3::element_product(_self.into_inner()).into();
        output
    }
    fn element_sum(_self: Val<bevy::math::Vec3>) {
        let output: f32 = bevy::math::Vec3::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::Vec3>, other: Ref<bevy::math::Vec3>) {
        let output: bool = <bevy::math::Vec3 as std::cmp::PartialEq<
            bevy::math::Vec3,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn exp(_self: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::exp(_self.into_inner())
            .into();
        output
    }
    fn extend(_self: Val<bevy::math::Vec3>, w: f32) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec3::extend(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    fn floor(_self: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::floor(_self.into_inner())
            .into();
        output
    }
    fn fract(_self: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::fract(_self.into_inner())
            .into();
        output
    }
    fn fract_gl(_self: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::fract_gl(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn from_array(a: [f32; 3]) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::from_array(a).into();
        output
    }
    fn is_finite(_self: Val<bevy::math::Vec3>) {
        let output: bool = bevy::math::Vec3::is_finite(_self.into_inner()).into();
        output
    }
    fn is_finite_mask(_self: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::Vec3::is_finite_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn is_nan(_self: Val<bevy::math::Vec3>) {
        let output: bool = bevy::math::Vec3::is_nan(_self.into_inner()).into();
        output
    }
    fn is_nan_mask(_self: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::Vec3::is_nan_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn is_negative_bitmask(_self: Val<bevy::math::Vec3>) {
        let output: u32 = bevy::math::Vec3::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    fn is_normalized(_self: Val<bevy::math::Vec3>) {
        let output: bool = bevy::math::Vec3::is_normalized(_self.into_inner()).into();
        output
    }
    fn length(_self: Val<bevy::math::Vec3>) {
        let output: f32 = bevy::math::Vec3::length(_self.into_inner()).into();
        output
    }
    fn length_recip(_self: Val<bevy::math::Vec3>) {
        let output: f32 = bevy::math::Vec3::length_recip(_self.into_inner()).into();
        output
    }
    fn length_squared(_self: Val<bevy::math::Vec3>) {
        let output: f32 = bevy::math::Vec3::length_squared(_self.into_inner()).into();
        output
    }
    fn lerp(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>, s: f32) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::lerp(
                _self.into_inner(),
                rhs.into_inner(),
                s,
            )
            .into();
        output
    }
    fn max(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::Vec3>) {
        let output: f32 = bevy::math::Vec3::max_element(_self.into_inner()).into();
        output
    }
    fn midpoint(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::midpoint(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::Vec3>) {
        let output: f32 = bevy::math::Vec3::min_element(_self.into_inner()).into();
        output
    }
    fn move_towards(_self: Ref<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>, d: f32) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::move_towards(
                &_self,
                rhs.into_inner(),
                d,
            )
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Vec3>, rhs: Ref<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Mul<
            &bevy::math::Vec3,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Mul<
            bevy::math::Vec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Vec3>, rhs: f32) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Mul<
            f32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn mul_add(
        _self: Val<bevy::math::Vec3>,
        a: Val<bevy::math::Vec3>,
        b: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::mul_add(
                _self.into_inner(),
                a.into_inner(),
                b.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn new(x: f32, y: f32, z: f32) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::new(x, y, z).into();
        output
    }
    fn normalize(_self: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::normalize(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn normalize_or(_self: Val<bevy::math::Vec3>, fallback: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::normalize_or(
                _self.into_inner(),
                fallback.into_inner(),
            )
            .into();
        output
    }
    fn normalize_or_zero(_self: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::normalize_or_zero(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn powf(_self: Val<bevy::math::Vec3>, n: f32) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::powf(_self.into_inner(), n)
            .into();
        output
    }
    fn project_onto(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::project_onto(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn project_onto_normalized(
        _self: Val<bevy::math::Vec3>,
        rhs: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::project_onto_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn recip(_self: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::recip(_self.into_inner())
            .into();
        output
    }
    fn reflect(_self: Val<bevy::math::Vec3>, normal: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::reflect(
                _self.into_inner(),
                normal.into_inner(),
            )
            .into();
        output
    }
    fn refract(_self: Val<bevy::math::Vec3>, normal: Val<bevy::math::Vec3>, eta: f32) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::refract(
                _self.into_inner(),
                normal.into_inner(),
                eta,
            )
            .into();
        output
    }
    fn reject_from(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::reject_from(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn reject_from_normalized(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::reject_from_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::Vec3>, rhs: Ref<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Rem<
            &bevy::math::Vec3,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Rem<
            bevy::math::Vec3,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::Vec3>, rhs: f32) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Rem<
            f32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn rem_euclid(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn round(_self: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::round(_self.into_inner())
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec3>,
        if_true: Val<bevy::math::Vec3>,
        if_false: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn signum(_self: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::signum(_self.into_inner())
            .into();
        output
    }
    fn splat(v: f32) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::Vec3>, rhs: Ref<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Sub<
            &bevy::math::Vec3,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Sub<
            bevy::math::Vec3,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::Vec3>, rhs: f32) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as std::ops::Sub<
            f32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::Vec3>) {
        let output: [f32; 3] = bevy::math::Vec3::to_array(&_self).into();
        output
    }
    fn trunc(_self: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::trunc(_self.into_inner())
            .into();
        output
    }
    fn truncate(_self: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec3::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn with_x(_self: Val<bevy::math::Vec3>, x: f32) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::Vec3>, y: f32) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    fn with_z(_self: Val<bevy::math::Vec3>, z: f32) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec3::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "i_vec_2")]
impl bevy::math::IVec2 {
    fn abs(_self: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::abs(_self.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::IVec2>, rhs: Ref<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Add<
            &bevy::math::IVec2,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Add<
            bevy::math::IVec2,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::IVec2>, rhs: i32) {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Add<
            i32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn as_dvec2(_self: Ref<bevy::math::IVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::IVec2::as_dvec2(&_self).into();
        output
    }
    fn as_i64vec2(_self: Ref<bevy::math::IVec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::IVec2::as_i64vec2(&_self)
            .into();
        output
    }
    fn as_u64vec2(_self: Ref<bevy::math::IVec2>) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::IVec2::as_u64vec2(&_self)
            .into();
        output
    }
    fn as_uvec2(_self: Ref<bevy::math::IVec2>) {
        let output: Val<bevy::math::UVec2> = bevy::math::IVec2::as_uvec2(&_self).into();
        output
    }
    fn as_vec2(_self: Ref<bevy::math::IVec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::IVec2::as_vec2(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::IVec2>) {
        let output: () = <bevy::math::IVec2 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::IVec2>,
        min: Val<bevy::math::IVec2>,
        max: Val<bevy::math::IVec2>,
    ) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance_squared(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: i32 = bevy::math::IVec2::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::IVec2>, rhs: Ref<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Div<
            &bevy::math::IVec2,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Div<
            bevy::math::IVec2,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::IVec2>, rhs: i32) {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Div<
            i32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_euclid(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: i32 = bevy::math::IVec2::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::IVec2>) {
        let output: i32 = bevy::math::IVec2::element_product(_self.into_inner()).into();
        output
    }
    fn element_sum(_self: Val<bevy::math::IVec2>) {
        let output: i32 = bevy::math::IVec2::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::IVec2>, other: Ref<bevy::math::IVec2>) {
        let output: bool = <bevy::math::IVec2 as std::cmp::PartialEq<
            bevy::math::IVec2,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn extend(_self: Val<bevy::math::IVec2>, z: i32) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec2::extend(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    fn from_array(a: [i32; 2]) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::from_array(a).into();
        output
    }
    fn is_negative_bitmask(_self: Val<bevy::math::IVec2>) {
        let output: u32 = bevy::math::IVec2::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    fn length_squared(_self: Val<bevy::math::IVec2>) {
        let output: i32 = bevy::math::IVec2::length_squared(_self.into_inner()).into();
        output
    }
    fn max(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::IVec2>) {
        let output: i32 = bevy::math::IVec2::max_element(_self.into_inner()).into();
        output
    }
    fn min(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::IVec2>) {
        let output: i32 = bevy::math::IVec2::min_element(_self.into_inner()).into();
        output
    }
    fn mul(_self: Val<bevy::math::IVec2>, rhs: Ref<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Mul<
            &bevy::math::IVec2,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Mul<
            bevy::math::IVec2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::IVec2>, rhs: i32) {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Mul<
            i32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn new(x: i32, y: i32) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::new(x, y).into();
        output
    }
    fn perp(_self: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::perp(_self.into_inner())
            .into();
        output
    }
    fn perp_dot(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: i32 = bevy::math::IVec2::perp_dot(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::IVec2>, rhs: Ref<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Rem<
            &bevy::math::IVec2,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Rem<
            bevy::math::IVec2,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::IVec2>, rhs: i32) {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Rem<
            i32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn rem_euclid(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rotate(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::rotate(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_add(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_add_unsigned(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_div(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_mul(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_sub(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_sub_unsigned(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec2>,
        if_true: Val<bevy::math::IVec2>,
        if_false: Val<bevy::math::IVec2>,
    ) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn signum(_self: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn splat(v: i32) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::IVec2>, rhs: Ref<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Sub<
            &bevy::math::IVec2,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Sub<
            bevy::math::IVec2,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::IVec2>, rhs: i32) {
        let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as std::ops::Sub<
            i32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::IVec2>) {
        let output: [i32; 2] = bevy::math::IVec2::to_array(&_self).into();
        output
    }
    fn with_x(_self: Val<bevy::math::IVec2>, x: i32) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::IVec2>, y: i32) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    fn wrapping_add(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_add_unsigned(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_div(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_mul(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_sub(_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_sub_unsigned(
        _self: Val<bevy::math::IVec2>,
        rhs: Val<bevy::math::UVec2>,
    ) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "i_vec_3")]
impl bevy::math::IVec3 {
    fn abs(_self: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::abs(_self.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::IVec3>, rhs: Ref<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Add<
            &bevy::math::IVec3,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Add<
            bevy::math::IVec3,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::IVec3>, rhs: i32) {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Add<
            i32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn as_dvec3(_self: Ref<bevy::math::IVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::IVec3::as_dvec3(&_self).into();
        output
    }
    fn as_i64vec3(_self: Ref<bevy::math::IVec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::IVec3::as_i64vec3(&_self)
            .into();
        output
    }
    fn as_u64vec3(_self: Ref<bevy::math::IVec3>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::IVec3::as_u64vec3(&_self)
            .into();
        output
    }
    fn as_uvec3(_self: Ref<bevy::math::IVec3>) {
        let output: Val<bevy::math::UVec3> = bevy::math::IVec3::as_uvec3(&_self).into();
        output
    }
    fn as_vec3(_self: Ref<bevy::math::IVec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::IVec3::as_vec3(&_self).into();
        output
    }
    fn as_vec3a(_self: Ref<bevy::math::IVec3>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::IVec3::as_vec3a(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::IVec3>) {
        let output: () = <bevy::math::IVec3 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::IVec3>,
        min: Val<bevy::math::IVec3>,
        max: Val<bevy::math::IVec3>,
    ) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cross(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::cross(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance_squared(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: i32 = bevy::math::IVec3::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::IVec3>, rhs: Ref<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Div<
            &bevy::math::IVec3,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Div<
            bevy::math::IVec3,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::IVec3>, rhs: i32) {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Div<
            i32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_euclid(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: i32 = bevy::math::IVec3::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::IVec3>) {
        let output: i32 = bevy::math::IVec3::element_product(_self.into_inner()).into();
        output
    }
    fn element_sum(_self: Val<bevy::math::IVec3>) {
        let output: i32 = bevy::math::IVec3::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::IVec3>, other: Ref<bevy::math::IVec3>) {
        let output: bool = <bevy::math::IVec3 as std::cmp::PartialEq<
            bevy::math::IVec3,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn extend(_self: Val<bevy::math::IVec3>, w: i32) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec3::extend(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    fn from_array(a: [i32; 3]) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::from_array(a).into();
        output
    }
    fn is_negative_bitmask(_self: Val<bevy::math::IVec3>) {
        let output: u32 = bevy::math::IVec3::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    fn length_squared(_self: Val<bevy::math::IVec3>) {
        let output: i32 = bevy::math::IVec3::length_squared(_self.into_inner()).into();
        output
    }
    fn max(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::IVec3>) {
        let output: i32 = bevy::math::IVec3::max_element(_self.into_inner()).into();
        output
    }
    fn min(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::IVec3>) {
        let output: i32 = bevy::math::IVec3::min_element(_self.into_inner()).into();
        output
    }
    fn mul(_self: Val<bevy::math::IVec3>, rhs: Ref<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Mul<
            &bevy::math::IVec3,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Mul<
            bevy::math::IVec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::IVec3>, rhs: i32) {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Mul<
            i32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn new(x: i32, y: i32, z: i32) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::new(x, y, z).into();
        output
    }
    fn rem(_self: Val<bevy::math::IVec3>, rhs: Ref<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Rem<
            &bevy::math::IVec3,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Rem<
            bevy::math::IVec3,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::IVec3>, rhs: i32) {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Rem<
            i32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn rem_euclid(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_add(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_add_unsigned(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_div(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_mul(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_sub(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_sub_unsigned(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec3>,
        if_true: Val<bevy::math::IVec3>,
        if_false: Val<bevy::math::IVec3>,
    ) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn signum(_self: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn splat(v: i32) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::IVec3>, rhs: Ref<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Sub<
            &bevy::math::IVec3,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Sub<
            bevy::math::IVec3,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::IVec3>, rhs: i32) {
        let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as std::ops::Sub<
            i32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::IVec3>) {
        let output: [i32; 3] = bevy::math::IVec3::to_array(&_self).into();
        output
    }
    fn truncate(_self: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec2> = bevy::math::IVec3::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn with_x(_self: Val<bevy::math::IVec3>, x: i32) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::IVec3>, y: i32) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    fn with_z(_self: Val<bevy::math::IVec3>, z: i32) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    fn wrapping_add(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_add_unsigned(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_div(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_mul(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_sub(_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_sub_unsigned(
        _self: Val<bevy::math::IVec3>,
        rhs: Val<bevy::math::UVec3>,
    ) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "i_vec_4")]
impl bevy::math::IVec4 {
    fn abs(_self: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::abs(_self.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::IVec4>, rhs: Ref<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Add<
            &bevy::math::IVec4,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Add<
            bevy::math::IVec4,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::IVec4>, rhs: i32) {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Add<
            i32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn as_dvec4(_self: Ref<bevy::math::IVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::IVec4::as_dvec4(&_self).into();
        output
    }
    fn as_i64vec4(_self: Ref<bevy::math::IVec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::IVec4::as_i64vec4(&_self)
            .into();
        output
    }
    fn as_u64vec4(_self: Ref<bevy::math::IVec4>) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::IVec4::as_u64vec4(&_self)
            .into();
        output
    }
    fn as_uvec4(_self: Ref<bevy::math::IVec4>) {
        let output: Val<bevy::math::UVec4> = bevy::math::IVec4::as_uvec4(&_self).into();
        output
    }
    fn as_vec4(_self: Ref<bevy::math::IVec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::IVec4::as_vec4(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::IVec4>) {
        let output: () = <bevy::math::IVec4 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::IVec4>,
        min: Val<bevy::math::IVec4>,
        max: Val<bevy::math::IVec4>,
    ) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance_squared(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: i32 = bevy::math::IVec4::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::IVec4>, rhs: Ref<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Div<
            &bevy::math::IVec4,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Div<
            bevy::math::IVec4,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::IVec4>, rhs: i32) {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Div<
            i32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_euclid(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: i32 = bevy::math::IVec4::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::IVec4>) {
        let output: i32 = bevy::math::IVec4::element_product(_self.into_inner()).into();
        output
    }
    fn element_sum(_self: Val<bevy::math::IVec4>) {
        let output: i32 = bevy::math::IVec4::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::IVec4>, other: Ref<bevy::math::IVec4>) {
        let output: bool = <bevy::math::IVec4 as std::cmp::PartialEq<
            bevy::math::IVec4,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn from_array(a: [i32; 4]) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::from_array(a).into();
        output
    }
    fn is_negative_bitmask(_self: Val<bevy::math::IVec4>) {
        let output: u32 = bevy::math::IVec4::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    fn length_squared(_self: Val<bevy::math::IVec4>) {
        let output: i32 = bevy::math::IVec4::length_squared(_self.into_inner()).into();
        output
    }
    fn max(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::IVec4>) {
        let output: i32 = bevy::math::IVec4::max_element(_self.into_inner()).into();
        output
    }
    fn min(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::IVec4>) {
        let output: i32 = bevy::math::IVec4::min_element(_self.into_inner()).into();
        output
    }
    fn mul(_self: Val<bevy::math::IVec4>, rhs: Ref<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Mul<
            &bevy::math::IVec4,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Mul<
            bevy::math::IVec4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::IVec4>, rhs: i32) {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Mul<
            i32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn new(x: i32, y: i32, z: i32, w: i32) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::new(x, y, z, w).into();
        output
    }
    fn rem(_self: Val<bevy::math::IVec4>, rhs: Ref<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Rem<
            &bevy::math::IVec4,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Rem<
            bevy::math::IVec4,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::IVec4>, rhs: i32) {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Rem<
            i32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn rem_euclid(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_add(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_add_unsigned(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_div(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_mul(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_sub(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_sub_unsigned(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec4>,
        if_true: Val<bevy::math::IVec4>,
        if_false: Val<bevy::math::IVec4>,
    ) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn signum(_self: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn splat(v: i32) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::IVec4>, rhs: Ref<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Sub<
            &bevy::math::IVec4,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Sub<
            bevy::math::IVec4,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::IVec4>, rhs: i32) {
        let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as std::ops::Sub<
            i32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::IVec4>) {
        let output: [i32; 4] = bevy::math::IVec4::to_array(&_self).into();
        output
    }
    fn truncate(_self: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec3> = bevy::math::IVec4::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn with_w(_self: Val<bevy::math::IVec4>, w: i32) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::with_w(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    fn with_x(_self: Val<bevy::math::IVec4>, x: i32) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::IVec4>, y: i32) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    fn with_z(_self: Val<bevy::math::IVec4>, z: i32) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    fn wrapping_add(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_add_unsigned(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_div(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_mul(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_sub(_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_sub_unsigned(
        _self: Val<bevy::math::IVec4>,
        rhs: Val<bevy::math::UVec4>,
    ) {
        let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "i_64_vec_2")]
impl bevy::math::I64Vec2 {
    fn abs(_self: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::abs(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::I64Vec2>, rhs: Ref<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Add<
            &bevy::math::I64Vec2,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Add<
            bevy::math::I64Vec2,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::I64Vec2>, rhs: i64) {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Add<
            i64,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn as_dvec2(_self: Ref<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::I64Vec2::as_dvec2(&_self)
            .into();
        output
    }
    fn as_ivec2(_self: Ref<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::I64Vec2::as_ivec2(&_self)
            .into();
        output
    }
    fn as_u64vec2(_self: Ref<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::I64Vec2::as_u64vec2(&_self)
            .into();
        output
    }
    fn as_uvec2(_self: Ref<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::UVec2> = bevy::math::I64Vec2::as_uvec2(&_self)
            .into();
        output
    }
    fn as_vec2(_self: Ref<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::I64Vec2::as_vec2(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::I64Vec2>) {
        let output: () = <bevy::math::I64Vec2 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::I64Vec2>,
        min: Val<bevy::math::I64Vec2>,
        max: Val<bevy::math::I64Vec2>,
    ) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance_squared(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: i64 = bevy::math::I64Vec2::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::I64Vec2>, rhs: Ref<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Div<
            &bevy::math::I64Vec2,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Div<
            bevy::math::I64Vec2,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::I64Vec2>, rhs: i64) {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Div<
            i64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_euclid(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: i64 = bevy::math::I64Vec2::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::I64Vec2>) {
        let output: i64 = bevy::math::I64Vec2::element_product(_self.into_inner())
            .into();
        output
    }
    fn element_sum(_self: Val<bevy::math::I64Vec2>) {
        let output: i64 = bevy::math::I64Vec2::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::I64Vec2>, other: Ref<bevy::math::I64Vec2>) {
        let output: bool = <bevy::math::I64Vec2 as std::cmp::PartialEq<
            bevy::math::I64Vec2,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn extend(_self: Val<bevy::math::I64Vec2>, z: i64) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec2::extend(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    fn from_array(a: [i64; 2]) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::from_array(a).into();
        output
    }
    fn is_negative_bitmask(_self: Val<bevy::math::I64Vec2>) {
        let output: u32 = bevy::math::I64Vec2::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    fn length_squared(_self: Val<bevy::math::I64Vec2>) {
        let output: i64 = bevy::math::I64Vec2::length_squared(_self.into_inner()).into();
        output
    }
    fn max(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::I64Vec2>) {
        let output: i64 = bevy::math::I64Vec2::max_element(_self.into_inner()).into();
        output
    }
    fn min(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::I64Vec2>) {
        let output: i64 = bevy::math::I64Vec2::min_element(_self.into_inner()).into();
        output
    }
    fn mul(_self: Val<bevy::math::I64Vec2>, rhs: Ref<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Mul<
            &bevy::math::I64Vec2,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Mul<
            bevy::math::I64Vec2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::I64Vec2>, rhs: i64) {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Mul<
            i64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn new(x: i64, y: i64) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::new(x, y).into();
        output
    }
    fn perp(_self: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::perp(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn perp_dot(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: i64 = bevy::math::I64Vec2::perp_dot(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::I64Vec2>, rhs: Ref<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Rem<
            &bevy::math::I64Vec2,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Rem<
            bevy::math::I64Vec2,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::I64Vec2>, rhs: i64) {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Rem<
            i64,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn rem_euclid(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rotate(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::rotate(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_add(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_add_unsigned(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_div(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_mul(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_sub(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_sub_unsigned(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec2>,
        if_true: Val<bevy::math::I64Vec2>,
        if_false: Val<bevy::math::I64Vec2>,
    ) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn signum(_self: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn splat(v: i64) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::I64Vec2>, rhs: Ref<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Sub<
            &bevy::math::I64Vec2,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Sub<
            bevy::math::I64Vec2,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::I64Vec2>, rhs: i64) {
        let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as std::ops::Sub<
            i64,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::I64Vec2>) {
        let output: [i64; 2] = bevy::math::I64Vec2::to_array(&_self).into();
        output
    }
    fn with_x(_self: Val<bevy::math::I64Vec2>, x: i64) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::I64Vec2>, y: i64) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    fn wrapping_add(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_add_unsigned(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_div(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_mul(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_sub(_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_sub_unsigned(
        _self: Val<bevy::math::I64Vec2>,
        rhs: Val<bevy::math::U64Vec2>,
    ) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "i_64_vec_3")]
impl bevy::math::I64Vec3 {
    fn abs(_self: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::abs(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::I64Vec3>, rhs: Ref<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Add<
            &bevy::math::I64Vec3,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Add<
            bevy::math::I64Vec3,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::I64Vec3>, rhs: i64) {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Add<
            i64,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn as_dvec3(_self: Ref<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::I64Vec3::as_dvec3(&_self)
            .into();
        output
    }
    fn as_ivec3(_self: Ref<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::I64Vec3::as_ivec3(&_self)
            .into();
        output
    }
    fn as_u64vec3(_self: Ref<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::I64Vec3::as_u64vec3(&_self)
            .into();
        output
    }
    fn as_uvec3(_self: Ref<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::UVec3> = bevy::math::I64Vec3::as_uvec3(&_self)
            .into();
        output
    }
    fn as_vec3(_self: Ref<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::I64Vec3::as_vec3(&_self).into();
        output
    }
    fn as_vec3a(_self: Ref<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::I64Vec3::as_vec3a(&_self)
            .into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::I64Vec3>) {
        let output: () = <bevy::math::I64Vec3 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::I64Vec3>,
        min: Val<bevy::math::I64Vec3>,
        max: Val<bevy::math::I64Vec3>,
    ) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cross(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::cross(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance_squared(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: i64 = bevy::math::I64Vec3::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::I64Vec3>, rhs: Ref<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Div<
            &bevy::math::I64Vec3,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Div<
            bevy::math::I64Vec3,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::I64Vec3>, rhs: i64) {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Div<
            i64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_euclid(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: i64 = bevy::math::I64Vec3::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::I64Vec3>) {
        let output: i64 = bevy::math::I64Vec3::element_product(_self.into_inner())
            .into();
        output
    }
    fn element_sum(_self: Val<bevy::math::I64Vec3>) {
        let output: i64 = bevy::math::I64Vec3::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::I64Vec3>, other: Ref<bevy::math::I64Vec3>) {
        let output: bool = <bevy::math::I64Vec3 as std::cmp::PartialEq<
            bevy::math::I64Vec3,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn extend(_self: Val<bevy::math::I64Vec3>, w: i64) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec3::extend(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    fn from_array(a: [i64; 3]) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::from_array(a).into();
        output
    }
    fn is_negative_bitmask(_self: Val<bevy::math::I64Vec3>) {
        let output: u32 = bevy::math::I64Vec3::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    fn length_squared(_self: Val<bevy::math::I64Vec3>) {
        let output: i64 = bevy::math::I64Vec3::length_squared(_self.into_inner()).into();
        output
    }
    fn max(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::I64Vec3>) {
        let output: i64 = bevy::math::I64Vec3::max_element(_self.into_inner()).into();
        output
    }
    fn min(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::I64Vec3>) {
        let output: i64 = bevy::math::I64Vec3::min_element(_self.into_inner()).into();
        output
    }
    fn mul(_self: Val<bevy::math::I64Vec3>, rhs: Ref<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Mul<
            &bevy::math::I64Vec3,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Mul<
            bevy::math::I64Vec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::I64Vec3>, rhs: i64) {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Mul<
            i64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn new(x: i64, y: i64, z: i64) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::new(x, y, z).into();
        output
    }
    fn rem(_self: Val<bevy::math::I64Vec3>, rhs: Ref<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Rem<
            &bevy::math::I64Vec3,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Rem<
            bevy::math::I64Vec3,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::I64Vec3>, rhs: i64) {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Rem<
            i64,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn rem_euclid(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_add(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_add_unsigned(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_div(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_mul(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_sub(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_sub_unsigned(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec3>,
        if_true: Val<bevy::math::I64Vec3>,
        if_false: Val<bevy::math::I64Vec3>,
    ) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn signum(_self: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn splat(v: i64) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::I64Vec3>, rhs: Ref<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Sub<
            &bevy::math::I64Vec3,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Sub<
            bevy::math::I64Vec3,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::I64Vec3>, rhs: i64) {
        let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as std::ops::Sub<
            i64,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::I64Vec3>) {
        let output: [i64; 3] = bevy::math::I64Vec3::to_array(&_self).into();
        output
    }
    fn truncate(_self: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec3::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn with_x(_self: Val<bevy::math::I64Vec3>, x: i64) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::I64Vec3>, y: i64) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    fn with_z(_self: Val<bevy::math::I64Vec3>, z: i64) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    fn wrapping_add(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_add_unsigned(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_div(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_mul(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_sub(_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_sub_unsigned(
        _self: Val<bevy::math::I64Vec3>,
        rhs: Val<bevy::math::U64Vec3>,
    ) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "i_64_vec_4")]
impl bevy::math::I64Vec4 {
    fn abs(_self: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::abs(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::I64Vec4>, rhs: Ref<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Add<
            &bevy::math::I64Vec4,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Add<
            bevy::math::I64Vec4,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::I64Vec4>, rhs: i64) {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Add<
            i64,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn as_dvec4(_self: Ref<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::I64Vec4::as_dvec4(&_self)
            .into();
        output
    }
    fn as_ivec4(_self: Ref<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::I64Vec4::as_ivec4(&_self)
            .into();
        output
    }
    fn as_u64vec4(_self: Ref<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::I64Vec4::as_u64vec4(&_self)
            .into();
        output
    }
    fn as_uvec4(_self: Ref<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::UVec4> = bevy::math::I64Vec4::as_uvec4(&_self)
            .into();
        output
    }
    fn as_vec4(_self: Ref<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::I64Vec4::as_vec4(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::I64Vec4>) {
        let output: () = <bevy::math::I64Vec4 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::I64Vec4>,
        min: Val<bevy::math::I64Vec4>,
        max: Val<bevy::math::I64Vec4>,
    ) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance_squared(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: i64 = bevy::math::I64Vec4::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::I64Vec4>, rhs: Ref<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Div<
            &bevy::math::I64Vec4,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Div<
            bevy::math::I64Vec4,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::I64Vec4>, rhs: i64) {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Div<
            i64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_euclid(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: i64 = bevy::math::I64Vec4::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::I64Vec4>) {
        let output: i64 = bevy::math::I64Vec4::element_product(_self.into_inner())
            .into();
        output
    }
    fn element_sum(_self: Val<bevy::math::I64Vec4>) {
        let output: i64 = bevy::math::I64Vec4::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::I64Vec4>, other: Ref<bevy::math::I64Vec4>) {
        let output: bool = <bevy::math::I64Vec4 as std::cmp::PartialEq<
            bevy::math::I64Vec4,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn from_array(a: [i64; 4]) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::from_array(a).into();
        output
    }
    fn is_negative_bitmask(_self: Val<bevy::math::I64Vec4>) {
        let output: u32 = bevy::math::I64Vec4::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    fn length_squared(_self: Val<bevy::math::I64Vec4>) {
        let output: i64 = bevy::math::I64Vec4::length_squared(_self.into_inner()).into();
        output
    }
    fn max(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::I64Vec4>) {
        let output: i64 = bevy::math::I64Vec4::max_element(_self.into_inner()).into();
        output
    }
    fn min(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::I64Vec4>) {
        let output: i64 = bevy::math::I64Vec4::min_element(_self.into_inner()).into();
        output
    }
    fn mul(_self: Val<bevy::math::I64Vec4>, rhs: Ref<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Mul<
            &bevy::math::I64Vec4,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Mul<
            bevy::math::I64Vec4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::I64Vec4>, rhs: i64) {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Mul<
            i64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn new(x: i64, y: i64, z: i64, w: i64) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::new(x, y, z, w)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::I64Vec4>, rhs: Ref<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Rem<
            &bevy::math::I64Vec4,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Rem<
            bevy::math::I64Vec4,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::I64Vec4>, rhs: i64) {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Rem<
            i64,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn rem_euclid(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_add(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_add_unsigned(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_div(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_mul(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_sub(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_sub_unsigned(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec4>,
        if_true: Val<bevy::math::I64Vec4>,
        if_false: Val<bevy::math::I64Vec4>,
    ) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn signum(_self: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn splat(v: i64) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::I64Vec4>, rhs: Ref<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Sub<
            &bevy::math::I64Vec4,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Sub<
            bevy::math::I64Vec4,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::I64Vec4>, rhs: i64) {
        let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as std::ops::Sub<
            i64,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::I64Vec4>) {
        let output: [i64; 4] = bevy::math::I64Vec4::to_array(&_self).into();
        output
    }
    fn truncate(_self: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec4::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn with_w(_self: Val<bevy::math::I64Vec4>, w: i64) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::with_w(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    fn with_x(_self: Val<bevy::math::I64Vec4>, x: i64) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::I64Vec4>, y: i64) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    fn with_z(_self: Val<bevy::math::I64Vec4>, z: i64) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    fn wrapping_add(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_add_unsigned(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_add_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_div(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_mul(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_sub(_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_sub_unsigned(
        _self: Val<bevy::math::I64Vec4>,
        rhs: Val<bevy::math::U64Vec4>,
    ) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_sub_unsigned(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "u_vec_2")]
impl bevy::math::UVec2 {
    fn add(_self: Val<bevy::math::UVec2>, rhs: Ref<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Add<
            &bevy::math::UVec2,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Add<
            bevy::math::UVec2,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::UVec2>, rhs: u32) {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Add<
            u32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn as_dvec2(_self: Ref<bevy::math::UVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::UVec2::as_dvec2(&_self).into();
        output
    }
    fn as_i64vec2(_self: Ref<bevy::math::UVec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::UVec2::as_i64vec2(&_self)
            .into();
        output
    }
    fn as_ivec2(_self: Ref<bevy::math::UVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::UVec2::as_ivec2(&_self).into();
        output
    }
    fn as_u64vec2(_self: Ref<bevy::math::UVec2>) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::UVec2::as_u64vec2(&_self)
            .into();
        output
    }
    fn as_vec2(_self: Ref<bevy::math::UVec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::UVec2::as_vec2(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::UVec2>) {
        let output: () = <bevy::math::UVec2 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::UVec2>,
        min: Val<bevy::math::UVec2>,
        max: Val<bevy::math::UVec2>,
    ) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::UVec2>, rhs: Ref<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Div<
            &bevy::math::UVec2,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Div<
            bevy::math::UVec2,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::UVec2>, rhs: u32) {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Div<
            u32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: u32 = bevy::math::UVec2::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::UVec2>) {
        let output: u32 = bevy::math::UVec2::element_product(_self.into_inner()).into();
        output
    }
    fn element_sum(_self: Val<bevy::math::UVec2>) {
        let output: u32 = bevy::math::UVec2::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::UVec2>, other: Ref<bevy::math::UVec2>) {
        let output: bool = <bevy::math::UVec2 as std::cmp::PartialEq<
            bevy::math::UVec2,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn extend(_self: Val<bevy::math::UVec2>, z: u32) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec2::extend(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    fn from_array(a: [u32; 2]) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::from_array(a).into();
        output
    }
    fn length_squared(_self: Val<bevy::math::UVec2>) {
        let output: u32 = bevy::math::UVec2::length_squared(_self.into_inner()).into();
        output
    }
    fn max(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::UVec2>) {
        let output: u32 = bevy::math::UVec2::max_element(_self.into_inner()).into();
        output
    }
    fn min(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::UVec2>) {
        let output: u32 = bevy::math::UVec2::min_element(_self.into_inner()).into();
        output
    }
    fn mul(_self: Val<bevy::math::UVec2>, rhs: Ref<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Mul<
            &bevy::math::UVec2,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Mul<
            bevy::math::UVec2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::UVec2>, rhs: u32) {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Mul<
            u32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn new(x: u32, y: u32) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::new(x, y).into();
        output
    }
    fn rem(_self: Val<bevy::math::UVec2>, rhs: Ref<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Rem<
            &bevy::math::UVec2,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Rem<
            bevy::math::UVec2,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::UVec2>, rhs: u32) {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Rem<
            u32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn saturating_add(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_add_signed(
        _self: Val<bevy::math::UVec2>,
        rhs: Val<bevy::math::IVec2>,
    ) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_div(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_mul(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_sub(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec2>,
        if_true: Val<bevy::math::UVec2>,
        if_false: Val<bevy::math::UVec2>,
    ) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn splat(v: u32) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::UVec2>, rhs: Ref<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Sub<
            &bevy::math::UVec2,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Sub<
            bevy::math::UVec2,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::UVec2>, rhs: u32) {
        let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as std::ops::Sub<
            u32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::UVec2>) {
        let output: [u32; 2] = bevy::math::UVec2::to_array(&_self).into();
        output
    }
    fn with_x(_self: Val<bevy::math::UVec2>, x: u32) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::UVec2>, y: u32) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    fn wrapping_add(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_add_signed(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::IVec2>) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_div(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_mul(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_sub(_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "u_vec_3")]
impl bevy::math::UVec3 {
    fn add(_self: Val<bevy::math::UVec3>, rhs: Ref<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Add<
            &bevy::math::UVec3,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Add<
            bevy::math::UVec3,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::UVec3>, rhs: u32) {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Add<
            u32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn as_dvec3(_self: Ref<bevy::math::UVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::UVec3::as_dvec3(&_self).into();
        output
    }
    fn as_i64vec3(_self: Ref<bevy::math::UVec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::UVec3::as_i64vec3(&_self)
            .into();
        output
    }
    fn as_ivec3(_self: Ref<bevy::math::UVec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::UVec3::as_ivec3(&_self).into();
        output
    }
    fn as_u64vec3(_self: Ref<bevy::math::UVec3>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::UVec3::as_u64vec3(&_self)
            .into();
        output
    }
    fn as_vec3(_self: Ref<bevy::math::UVec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::UVec3::as_vec3(&_self).into();
        output
    }
    fn as_vec3a(_self: Ref<bevy::math::UVec3>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::UVec3::as_vec3a(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::UVec3>) {
        let output: () = <bevy::math::UVec3 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::UVec3>,
        min: Val<bevy::math::UVec3>,
        max: Val<bevy::math::UVec3>,
    ) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cross(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::cross(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::UVec3>, rhs: Ref<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Div<
            &bevy::math::UVec3,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Div<
            bevy::math::UVec3,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::UVec3>, rhs: u32) {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Div<
            u32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: u32 = bevy::math::UVec3::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::UVec3>) {
        let output: u32 = bevy::math::UVec3::element_product(_self.into_inner()).into();
        output
    }
    fn element_sum(_self: Val<bevy::math::UVec3>) {
        let output: u32 = bevy::math::UVec3::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::UVec3>, other: Ref<bevy::math::UVec3>) {
        let output: bool = <bevy::math::UVec3 as std::cmp::PartialEq<
            bevy::math::UVec3,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn extend(_self: Val<bevy::math::UVec3>, w: u32) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec3::extend(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    fn from_array(a: [u32; 3]) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::from_array(a).into();
        output
    }
    fn length_squared(_self: Val<bevy::math::UVec3>) {
        let output: u32 = bevy::math::UVec3::length_squared(_self.into_inner()).into();
        output
    }
    fn max(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::UVec3>) {
        let output: u32 = bevy::math::UVec3::max_element(_self.into_inner()).into();
        output
    }
    fn min(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::UVec3>) {
        let output: u32 = bevy::math::UVec3::min_element(_self.into_inner()).into();
        output
    }
    fn mul(_self: Val<bevy::math::UVec3>, rhs: Ref<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Mul<
            &bevy::math::UVec3,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Mul<
            bevy::math::UVec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::UVec3>, rhs: u32) {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Mul<
            u32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn new(x: u32, y: u32, z: u32) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::new(x, y, z).into();
        output
    }
    fn rem(_self: Val<bevy::math::UVec3>, rhs: Ref<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Rem<
            &bevy::math::UVec3,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Rem<
            bevy::math::UVec3,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::UVec3>, rhs: u32) {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Rem<
            u32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn saturating_add(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_add_signed(
        _self: Val<bevy::math::UVec3>,
        rhs: Val<bevy::math::IVec3>,
    ) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_div(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_mul(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_sub(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec3>,
        if_true: Val<bevy::math::UVec3>,
        if_false: Val<bevy::math::UVec3>,
    ) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn splat(v: u32) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::UVec3>, rhs: Ref<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Sub<
            &bevy::math::UVec3,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Sub<
            bevy::math::UVec3,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::UVec3>, rhs: u32) {
        let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as std::ops::Sub<
            u32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::UVec3>) {
        let output: [u32; 3] = bevy::math::UVec3::to_array(&_self).into();
        output
    }
    fn truncate(_self: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec2> = bevy::math::UVec3::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn with_x(_self: Val<bevy::math::UVec3>, x: u32) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::UVec3>, y: u32) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    fn with_z(_self: Val<bevy::math::UVec3>, z: u32) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    fn wrapping_add(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_add_signed(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::IVec3>) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_div(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_mul(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_sub(_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "u_vec_4")]
impl bevy::math::UVec4 {
    fn add(_self: Val<bevy::math::UVec4>, rhs: Ref<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Add<
            &bevy::math::UVec4,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Add<
            bevy::math::UVec4,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::UVec4>, rhs: u32) {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Add<
            u32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn as_dvec4(_self: Ref<bevy::math::UVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::UVec4::as_dvec4(&_self).into();
        output
    }
    fn as_i64vec4(_self: Ref<bevy::math::UVec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::UVec4::as_i64vec4(&_self)
            .into();
        output
    }
    fn as_ivec4(_self: Ref<bevy::math::UVec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::UVec4::as_ivec4(&_self).into();
        output
    }
    fn as_u64vec4(_self: Ref<bevy::math::UVec4>) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::UVec4::as_u64vec4(&_self)
            .into();
        output
    }
    fn as_vec4(_self: Ref<bevy::math::UVec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::UVec4::as_vec4(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::UVec4>) {
        let output: () = <bevy::math::UVec4 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::UVec4>,
        min: Val<bevy::math::UVec4>,
        max: Val<bevy::math::UVec4>,
    ) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::UVec4>, rhs: Ref<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Div<
            &bevy::math::UVec4,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Div<
            bevy::math::UVec4,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::UVec4>, rhs: u32) {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Div<
            u32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: u32 = bevy::math::UVec4::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::UVec4>) {
        let output: u32 = bevy::math::UVec4::element_product(_self.into_inner()).into();
        output
    }
    fn element_sum(_self: Val<bevy::math::UVec4>) {
        let output: u32 = bevy::math::UVec4::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::UVec4>, other: Ref<bevy::math::UVec4>) {
        let output: bool = <bevy::math::UVec4 as std::cmp::PartialEq<
            bevy::math::UVec4,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn from_array(a: [u32; 4]) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::from_array(a).into();
        output
    }
    fn length_squared(_self: Val<bevy::math::UVec4>) {
        let output: u32 = bevy::math::UVec4::length_squared(_self.into_inner()).into();
        output
    }
    fn max(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::UVec4>) {
        let output: u32 = bevy::math::UVec4::max_element(_self.into_inner()).into();
        output
    }
    fn min(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::UVec4>) {
        let output: u32 = bevy::math::UVec4::min_element(_self.into_inner()).into();
        output
    }
    fn mul(_self: Val<bevy::math::UVec4>, rhs: Ref<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Mul<
            &bevy::math::UVec4,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Mul<
            bevy::math::UVec4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::UVec4>, rhs: u32) {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Mul<
            u32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn new(x: u32, y: u32, z: u32, w: u32) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::new(x, y, z, w).into();
        output
    }
    fn rem(_self: Val<bevy::math::UVec4>, rhs: Ref<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Rem<
            &bevy::math::UVec4,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Rem<
            bevy::math::UVec4,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::UVec4>, rhs: u32) {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Rem<
            u32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn saturating_add(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_add_signed(
        _self: Val<bevy::math::UVec4>,
        rhs: Val<bevy::math::IVec4>,
    ) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_div(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_mul(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_sub(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec4>,
        if_true: Val<bevy::math::UVec4>,
        if_false: Val<bevy::math::UVec4>,
    ) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn splat(v: u32) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::UVec4>, rhs: Ref<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Sub<
            &bevy::math::UVec4,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Sub<
            bevy::math::UVec4,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::UVec4>, rhs: u32) {
        let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as std::ops::Sub<
            u32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::UVec4>) {
        let output: [u32; 4] = bevy::math::UVec4::to_array(&_self).into();
        output
    }
    fn truncate(_self: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec3> = bevy::math::UVec4::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn with_w(_self: Val<bevy::math::UVec4>, w: u32) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::with_w(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    fn with_x(_self: Val<bevy::math::UVec4>, x: u32) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::UVec4>, y: u32) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    fn with_z(_self: Val<bevy::math::UVec4>, z: u32) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    fn wrapping_add(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_add_signed(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::IVec4>) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_div(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_mul(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_sub(_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>) {
        let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "u_64_vec_2")]
impl bevy::math::U64Vec2 {
    fn add(_self: Val<bevy::math::U64Vec2>, rhs: Ref<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Add<
            &bevy::math::U64Vec2,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Add<
            bevy::math::U64Vec2,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::U64Vec2>, rhs: u64) {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Add<
            u64,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn as_dvec2(_self: Ref<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::U64Vec2::as_dvec2(&_self)
            .into();
        output
    }
    fn as_i64vec2(_self: Ref<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::U64Vec2::as_i64vec2(&_self)
            .into();
        output
    }
    fn as_ivec2(_self: Ref<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::U64Vec2::as_ivec2(&_self)
            .into();
        output
    }
    fn as_uvec2(_self: Ref<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::UVec2> = bevy::math::U64Vec2::as_uvec2(&_self)
            .into();
        output
    }
    fn as_vec2(_self: Ref<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::U64Vec2::as_vec2(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::U64Vec2>) {
        let output: () = <bevy::math::U64Vec2 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::U64Vec2>,
        min: Val<bevy::math::U64Vec2>,
        max: Val<bevy::math::U64Vec2>,
    ) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::U64Vec2>, rhs: Ref<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Div<
            &bevy::math::U64Vec2,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Div<
            bevy::math::U64Vec2,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::U64Vec2>, rhs: u64) {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Div<
            u64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: u64 = bevy::math::U64Vec2::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::U64Vec2>) {
        let output: u64 = bevy::math::U64Vec2::element_product(_self.into_inner())
            .into();
        output
    }
    fn element_sum(_self: Val<bevy::math::U64Vec2>) {
        let output: u64 = bevy::math::U64Vec2::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::U64Vec2>, other: Ref<bevy::math::U64Vec2>) {
        let output: bool = <bevy::math::U64Vec2 as std::cmp::PartialEq<
            bevy::math::U64Vec2,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn extend(_self: Val<bevy::math::U64Vec2>, z: u64) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec2::extend(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    fn from_array(a: [u64; 2]) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::from_array(a).into();
        output
    }
    fn length_squared(_self: Val<bevy::math::U64Vec2>) {
        let output: u64 = bevy::math::U64Vec2::length_squared(_self.into_inner()).into();
        output
    }
    fn max(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::U64Vec2>) {
        let output: u64 = bevy::math::U64Vec2::max_element(_self.into_inner()).into();
        output
    }
    fn min(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::U64Vec2>) {
        let output: u64 = bevy::math::U64Vec2::min_element(_self.into_inner()).into();
        output
    }
    fn mul(_self: Val<bevy::math::U64Vec2>, rhs: Ref<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Mul<
            &bevy::math::U64Vec2,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Mul<
            bevy::math::U64Vec2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::U64Vec2>, rhs: u64) {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Mul<
            u64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn new(x: u64, y: u64) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::new(x, y).into();
        output
    }
    fn rem(_self: Val<bevy::math::U64Vec2>, rhs: Ref<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Rem<
            &bevy::math::U64Vec2,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Rem<
            bevy::math::U64Vec2,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::U64Vec2>, rhs: u64) {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Rem<
            u64,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn saturating_add(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_add_signed(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_div(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_mul(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_sub(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec2>,
        if_true: Val<bevy::math::U64Vec2>,
        if_false: Val<bevy::math::U64Vec2>,
    ) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn splat(v: u64) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::U64Vec2>, rhs: Ref<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Sub<
            &bevy::math::U64Vec2,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Sub<
            bevy::math::U64Vec2,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::U64Vec2>, rhs: u64) {
        let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as std::ops::Sub<
            u64,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::U64Vec2>) {
        let output: [u64; 2] = bevy::math::U64Vec2::to_array(&_self).into();
        output
    }
    fn with_x(_self: Val<bevy::math::U64Vec2>, x: u64) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::U64Vec2>, y: u64) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    fn wrapping_add(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_add_signed(
        _self: Val<bevy::math::U64Vec2>,
        rhs: Val<bevy::math::I64Vec2>,
    ) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_div(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_mul(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_sub(_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "u_64_vec_3")]
impl bevy::math::U64Vec3 {
    fn add(_self: Val<bevy::math::U64Vec3>, rhs: Ref<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Add<
            &bevy::math::U64Vec3,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Add<
            bevy::math::U64Vec3,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::U64Vec3>, rhs: u64) {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Add<
            u64,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn as_dvec3(_self: Ref<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::U64Vec3::as_dvec3(&_self)
            .into();
        output
    }
    fn as_i64vec3(_self: Ref<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::U64Vec3::as_i64vec3(&_self)
            .into();
        output
    }
    fn as_ivec3(_self: Ref<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::U64Vec3::as_ivec3(&_self)
            .into();
        output
    }
    fn as_uvec3(_self: Ref<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::UVec3> = bevy::math::U64Vec3::as_uvec3(&_self)
            .into();
        output
    }
    fn as_vec3(_self: Ref<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::U64Vec3::as_vec3(&_self).into();
        output
    }
    fn as_vec3a(_self: Ref<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::U64Vec3::as_vec3a(&_self)
            .into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::U64Vec3>) {
        let output: () = <bevy::math::U64Vec3 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::U64Vec3>,
        min: Val<bevy::math::U64Vec3>,
        max: Val<bevy::math::U64Vec3>,
    ) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cross(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::cross(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::U64Vec3>, rhs: Ref<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Div<
            &bevy::math::U64Vec3,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Div<
            bevy::math::U64Vec3,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::U64Vec3>, rhs: u64) {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Div<
            u64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: u64 = bevy::math::U64Vec3::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::U64Vec3>) {
        let output: u64 = bevy::math::U64Vec3::element_product(_self.into_inner())
            .into();
        output
    }
    fn element_sum(_self: Val<bevy::math::U64Vec3>) {
        let output: u64 = bevy::math::U64Vec3::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::U64Vec3>, other: Ref<bevy::math::U64Vec3>) {
        let output: bool = <bevy::math::U64Vec3 as std::cmp::PartialEq<
            bevy::math::U64Vec3,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn extend(_self: Val<bevy::math::U64Vec3>, w: u64) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec3::extend(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    fn from_array(a: [u64; 3]) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::from_array(a).into();
        output
    }
    fn length_squared(_self: Val<bevy::math::U64Vec3>) {
        let output: u64 = bevy::math::U64Vec3::length_squared(_self.into_inner()).into();
        output
    }
    fn max(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::U64Vec3>) {
        let output: u64 = bevy::math::U64Vec3::max_element(_self.into_inner()).into();
        output
    }
    fn min(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::U64Vec3>) {
        let output: u64 = bevy::math::U64Vec3::min_element(_self.into_inner()).into();
        output
    }
    fn mul(_self: Val<bevy::math::U64Vec3>, rhs: Ref<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Mul<
            &bevy::math::U64Vec3,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Mul<
            bevy::math::U64Vec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::U64Vec3>, rhs: u64) {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Mul<
            u64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn new(x: u64, y: u64, z: u64) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::new(x, y, z).into();
        output
    }
    fn rem(_self: Val<bevy::math::U64Vec3>, rhs: Ref<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Rem<
            &bevy::math::U64Vec3,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Rem<
            bevy::math::U64Vec3,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::U64Vec3>, rhs: u64) {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Rem<
            u64,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn saturating_add(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_add_signed(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_div(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_mul(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_sub(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec3>,
        if_true: Val<bevy::math::U64Vec3>,
        if_false: Val<bevy::math::U64Vec3>,
    ) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn splat(v: u64) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::U64Vec3>, rhs: Ref<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Sub<
            &bevy::math::U64Vec3,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Sub<
            bevy::math::U64Vec3,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::U64Vec3>, rhs: u64) {
        let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as std::ops::Sub<
            u64,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::U64Vec3>) {
        let output: [u64; 3] = bevy::math::U64Vec3::to_array(&_self).into();
        output
    }
    fn truncate(_self: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec3::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn with_x(_self: Val<bevy::math::U64Vec3>, x: u64) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::U64Vec3>, y: u64) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    fn with_z(_self: Val<bevy::math::U64Vec3>, z: u64) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    fn wrapping_add(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_add_signed(
        _self: Val<bevy::math::U64Vec3>,
        rhs: Val<bevy::math::I64Vec3>,
    ) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_div(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_mul(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_sub(_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "u_64_vec_4")]
impl bevy::math::U64Vec4 {
    fn add(_self: Val<bevy::math::U64Vec4>, rhs: Ref<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Add<
            &bevy::math::U64Vec4,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Add<
            bevy::math::U64Vec4,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::U64Vec4>, rhs: u64) {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Add<
            u64,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn as_dvec4(_self: Ref<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::U64Vec4::as_dvec4(&_self)
            .into();
        output
    }
    fn as_i64vec4(_self: Ref<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::U64Vec4::as_i64vec4(&_self)
            .into();
        output
    }
    fn as_ivec4(_self: Ref<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::U64Vec4::as_ivec4(&_self)
            .into();
        output
    }
    fn as_uvec4(_self: Ref<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::UVec4> = bevy::math::U64Vec4::as_uvec4(&_self)
            .into();
        output
    }
    fn as_vec4(_self: Ref<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::U64Vec4::as_vec4(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::U64Vec4>) {
        let output: () = <bevy::math::U64Vec4 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::U64Vec4>,
        min: Val<bevy::math::U64Vec4>,
        max: Val<bevy::math::U64Vec4>,
    ) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::U64Vec4>, rhs: Ref<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Div<
            &bevy::math::U64Vec4,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Div<
            bevy::math::U64Vec4,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::U64Vec4>, rhs: u64) {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Div<
            u64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: u64 = bevy::math::U64Vec4::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::U64Vec4>) {
        let output: u64 = bevy::math::U64Vec4::element_product(_self.into_inner())
            .into();
        output
    }
    fn element_sum(_self: Val<bevy::math::U64Vec4>) {
        let output: u64 = bevy::math::U64Vec4::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::U64Vec4>, other: Ref<bevy::math::U64Vec4>) {
        let output: bool = <bevy::math::U64Vec4 as std::cmp::PartialEq<
            bevy::math::U64Vec4,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn from_array(a: [u64; 4]) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::from_array(a).into();
        output
    }
    fn length_squared(_self: Val<bevy::math::U64Vec4>) {
        let output: u64 = bevy::math::U64Vec4::length_squared(_self.into_inner()).into();
        output
    }
    fn max(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::U64Vec4>) {
        let output: u64 = bevy::math::U64Vec4::max_element(_self.into_inner()).into();
        output
    }
    fn min(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::U64Vec4>) {
        let output: u64 = bevy::math::U64Vec4::min_element(_self.into_inner()).into();
        output
    }
    fn mul(_self: Val<bevy::math::U64Vec4>, rhs: Ref<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Mul<
            &bevy::math::U64Vec4,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Mul<
            bevy::math::U64Vec4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::U64Vec4>, rhs: u64) {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Mul<
            u64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn new(x: u64, y: u64, z: u64, w: u64) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::new(x, y, z, w)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::U64Vec4>, rhs: Ref<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Rem<
            &bevy::math::U64Vec4,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Rem<
            bevy::math::U64Vec4,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::U64Vec4>, rhs: u64) {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Rem<
            u64,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn saturating_add(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_add_signed(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_div(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_mul(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn saturating_sub(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec4>,
        if_true: Val<bevy::math::U64Vec4>,
        if_false: Val<bevy::math::U64Vec4>,
    ) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn splat(v: u64) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::U64Vec4>, rhs: Ref<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Sub<
            &bevy::math::U64Vec4,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Sub<
            bevy::math::U64Vec4,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::U64Vec4>, rhs: u64) {
        let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as std::ops::Sub<
            u64,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::U64Vec4>) {
        let output: [u64; 4] = bevy::math::U64Vec4::to_array(&_self).into();
        output
    }
    fn truncate(_self: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec4::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn with_w(_self: Val<bevy::math::U64Vec4>, w: u64) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::with_w(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    fn with_x(_self: Val<bevy::math::U64Vec4>, x: u64) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::U64Vec4>, y: u64) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    fn with_z(_self: Val<bevy::math::U64Vec4>, z: u64) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    fn wrapping_add(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_add(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_add_signed(
        _self: Val<bevy::math::U64Vec4>,
        rhs: Val<bevy::math::I64Vec4>,
    ) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_add_signed(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_div(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_div(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_mul(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_mul(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn wrapping_sub(_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_sub(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "vec_2")]
impl bevy::math::Vec2 {
    fn abs(_self: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::abs(_self.into_inner())
            .into();
        output
    }
    fn abs_diff_eq(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
        max_abs_diff: f32,
    ) {
        let output: bool = bevy::math::Vec2::abs_diff_eq(
                _self.into_inner(),
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Vec2>, rhs: Ref<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Add<
            &bevy::math::Vec2,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Add<
            bevy::math::Vec2,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Vec2>, rhs: f32) {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Add<
            f32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn angle_between(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: f32 = bevy::math::Vec2::angle_between(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn angle_to(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: f32 = bevy::math::Vec2::angle_to(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn as_dvec2(_self: Ref<bevy::math::Vec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::Vec2::as_dvec2(&_self).into();
        output
    }
    fn as_i64vec2(_self: Ref<bevy::math::Vec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::Vec2::as_i64vec2(&_self)
            .into();
        output
    }
    fn as_ivec2(_self: Ref<bevy::math::Vec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::Vec2::as_ivec2(&_self).into();
        output
    }
    fn as_u64vec2(_self: Ref<bevy::math::Vec2>) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::Vec2::as_u64vec2(&_self)
            .into();
        output
    }
    fn as_uvec2(_self: Ref<bevy::math::Vec2>) {
        let output: Val<bevy::math::UVec2> = bevy::math::Vec2::as_uvec2(&_self).into();
        output
    }
    fn ceil(_self: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::ceil(_self.into_inner())
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::Vec2>,
        min: Val<bevy::math::Vec2>,
        max: Val<bevy::math::Vec2>,
    ) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clamp_length(_self: Val<bevy::math::Vec2>, min: f32, max: f32) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::clamp_length(
                _self.into_inner(),
                min,
                max,
            )
            .into();
        output
    }
    fn clamp_length_max(_self: Val<bevy::math::Vec2>, max: f32) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::clamp_length_max(
                _self.into_inner(),
                max,
            )
            .into();
        output
    }
    fn clamp_length_min(_self: Val<bevy::math::Vec2>, min: f32) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::clamp_length_min(
                _self.into_inner(),
                min,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn copysign(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::copysign(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: f32 = bevy::math::Vec2::distance(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance_squared(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: f32 = bevy::math::Vec2::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::Vec2>, rhs: Ref<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Div<
            &bevy::math::Vec2,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Div<
            bevy::math::Vec2,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::Vec2>, rhs: f32) {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Div<
            f32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_euclid(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: f32 = bevy::math::Vec2::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::Vec2>) {
        let output: f32 = bevy::math::Vec2::element_product(_self.into_inner()).into();
        output
    }
    fn element_sum(_self: Val<bevy::math::Vec2>) {
        let output: f32 = bevy::math::Vec2::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::Vec2>, other: Ref<bevy::math::Vec2>) {
        let output: bool = <bevy::math::Vec2 as std::cmp::PartialEq<
            bevy::math::Vec2,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn exp(_self: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::exp(_self.into_inner())
            .into();
        output
    }
    fn extend(_self: Val<bevy::math::Vec2>, z: f32) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec2::extend(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    fn floor(_self: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::floor(_self.into_inner())
            .into();
        output
    }
    fn fract(_self: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::fract(_self.into_inner())
            .into();
        output
    }
    fn fract_gl(_self: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::fract_gl(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn from_angle(angle: f32) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::from_angle(angle).into();
        output
    }
    fn from_array(a: [f32; 2]) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::from_array(a).into();
        output
    }
    fn is_finite(_self: Val<bevy::math::Vec2>) {
        let output: bool = bevy::math::Vec2::is_finite(_self.into_inner()).into();
        output
    }
    fn is_finite_mask(_self: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::Vec2::is_finite_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn is_nan(_self: Val<bevy::math::Vec2>) {
        let output: bool = bevy::math::Vec2::is_nan(_self.into_inner()).into();
        output
    }
    fn is_nan_mask(_self: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::Vec2::is_nan_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn is_negative_bitmask(_self: Val<bevy::math::Vec2>) {
        let output: u32 = bevy::math::Vec2::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    fn is_normalized(_self: Val<bevy::math::Vec2>) {
        let output: bool = bevy::math::Vec2::is_normalized(_self.into_inner()).into();
        output
    }
    fn length(_self: Val<bevy::math::Vec2>) {
        let output: f32 = bevy::math::Vec2::length(_self.into_inner()).into();
        output
    }
    fn length_recip(_self: Val<bevy::math::Vec2>) {
        let output: f32 = bevy::math::Vec2::length_recip(_self.into_inner()).into();
        output
    }
    fn length_squared(_self: Val<bevy::math::Vec2>) {
        let output: f32 = bevy::math::Vec2::length_squared(_self.into_inner()).into();
        output
    }
    fn lerp(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>, s: f32) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::lerp(
                _self.into_inner(),
                rhs.into_inner(),
                s,
            )
            .into();
        output
    }
    fn max(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::Vec2>) {
        let output: f32 = bevy::math::Vec2::max_element(_self.into_inner()).into();
        output
    }
    fn midpoint(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::midpoint(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::Vec2>) {
        let output: f32 = bevy::math::Vec2::min_element(_self.into_inner()).into();
        output
    }
    fn move_towards(_self: Ref<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>, d: f32) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::move_towards(
                &_self,
                rhs.into_inner(),
                d,
            )
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Vec2>, rhs: Ref<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Mul<
            &bevy::math::Vec2,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Mul<
            bevy::math::Vec2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Vec2>, rhs: f32) {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Mul<
            f32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn mul_add(
        _self: Val<bevy::math::Vec2>,
        a: Val<bevy::math::Vec2>,
        b: Val<bevy::math::Vec2>,
    ) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::mul_add(
                _self.into_inner(),
                a.into_inner(),
                b.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn new(x: f32, y: f32) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::new(x, y).into();
        output
    }
    fn normalize(_self: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::normalize(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn normalize_or(_self: Val<bevy::math::Vec2>, fallback: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::normalize_or(
                _self.into_inner(),
                fallback.into_inner(),
            )
            .into();
        output
    }
    fn normalize_or_zero(_self: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::normalize_or_zero(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn perp(_self: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::perp(_self.into_inner())
            .into();
        output
    }
    fn perp_dot(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: f32 = bevy::math::Vec2::perp_dot(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn powf(_self: Val<bevy::math::Vec2>, n: f32) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::powf(_self.into_inner(), n)
            .into();
        output
    }
    fn project_onto(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::project_onto(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn project_onto_normalized(
        _self: Val<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
    ) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::project_onto_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn recip(_self: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::recip(_self.into_inner())
            .into();
        output
    }
    fn reflect(_self: Val<bevy::math::Vec2>, normal: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::reflect(
                _self.into_inner(),
                normal.into_inner(),
            )
            .into();
        output
    }
    fn refract(_self: Val<bevy::math::Vec2>, normal: Val<bevy::math::Vec2>, eta: f32) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::refract(
                _self.into_inner(),
                normal.into_inner(),
                eta,
            )
            .into();
        output
    }
    fn reject_from(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::reject_from(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn reject_from_normalized(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::reject_from_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::Vec2>, rhs: Ref<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Rem<
            &bevy::math::Vec2,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Rem<
            bevy::math::Vec2,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::Vec2>, rhs: f32) {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Rem<
            f32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn rem_euclid(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rotate(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::rotate(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rotate_towards(
        _self: Ref<bevy::math::Vec2>,
        rhs: Val<bevy::math::Vec2>,
        max_angle: f32,
    ) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::rotate_towards(
                &_self,
                rhs.into_inner(),
                max_angle,
            )
            .into();
        output
    }
    fn round(_self: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::round(_self.into_inner())
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec2>,
        if_true: Val<bevy::math::Vec2>,
        if_false: Val<bevy::math::Vec2>,
    ) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn signum(_self: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::signum(_self.into_inner())
            .into();
        output
    }
    fn splat(v: f32) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::Vec2>, rhs: Ref<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Sub<
            &bevy::math::Vec2,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Sub<
            bevy::math::Vec2,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::Vec2>, rhs: f32) {
        let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as std::ops::Sub<
            f32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_angle(_self: Val<bevy::math::Vec2>) {
        let output: f32 = bevy::math::Vec2::to_angle(_self.into_inner()).into();
        output
    }
    fn to_array(_self: Ref<bevy::math::Vec2>) {
        let output: [f32; 2] = bevy::math::Vec2::to_array(&_self).into();
        output
    }
    fn trunc(_self: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::trunc(_self.into_inner())
            .into();
        output
    }
    fn with_x(_self: Val<bevy::math::Vec2>, x: f32) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::Vec2>, y: f32) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec2::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "vec_3_a")]
impl bevy::math::Vec3A {
    fn abs(_self: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::abs(_self.into_inner())
            .into();
        output
    }
    fn abs_diff_eq(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
        max_abs_diff: f32,
    ) {
        let output: bool = bevy::math::Vec3A::abs_diff_eq(
                _self.into_inner(),
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Add<
            &bevy::math::Vec3A,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Add<
            bevy::math::Vec3A,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Vec3A>, rhs: f32) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Add<
            f32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn angle_between(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: f32 = bevy::math::Vec3A::angle_between(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn any_orthogonal_vector(_self: Ref<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::any_orthogonal_vector(
                &_self,
            )
            .into();
        output
    }
    fn any_orthonormal_vector(_self: Ref<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::any_orthonormal_vector(
                &_self,
            )
            .into();
        output
    }
    fn as_dvec3(_self: Ref<bevy::math::Vec3A>) {
        let output: Val<bevy::math::DVec3> = bevy::math::Vec3A::as_dvec3(&_self).into();
        output
    }
    fn as_i64vec3(_self: Ref<bevy::math::Vec3A>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::Vec3A::as_i64vec3(&_self)
            .into();
        output
    }
    fn as_ivec3(_self: Ref<bevy::math::Vec3A>) {
        let output: Val<bevy::math::IVec3> = bevy::math::Vec3A::as_ivec3(&_self).into();
        output
    }
    fn as_u64vec3(_self: Ref<bevy::math::Vec3A>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::Vec3A::as_u64vec3(&_self)
            .into();
        output
    }
    fn as_uvec3(_self: Ref<bevy::math::Vec3A>) {
        let output: Val<bevy::math::UVec3> = bevy::math::Vec3A::as_uvec3(&_self).into();
        output
    }
    fn ceil(_self: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::ceil(_self.into_inner())
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::Vec3A>,
        min: Val<bevy::math::Vec3A>,
        max: Val<bevy::math::Vec3A>,
    ) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clamp_length(_self: Val<bevy::math::Vec3A>, min: f32, max: f32) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::clamp_length(
                _self.into_inner(),
                min,
                max,
            )
            .into();
        output
    }
    fn clamp_length_max(_self: Val<bevy::math::Vec3A>, max: f32) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::clamp_length_max(
                _self.into_inner(),
                max,
            )
            .into();
        output
    }
    fn clamp_length_min(_self: Val<bevy::math::Vec3A>, min: f32) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::clamp_length_min(
                _self.into_inner(),
                min,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn copysign(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::copysign(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cross(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::cross(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: f32 = bevy::math::Vec3A::distance(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance_squared(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: f32 = bevy::math::Vec3A::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Div<
            &bevy::math::Vec3A,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Div<
            bevy::math::Vec3A,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::Vec3A>, rhs: f32) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Div<
            f32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_euclid(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: f32 = bevy::math::Vec3A::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::Vec3A>) {
        let output: f32 = bevy::math::Vec3A::element_product(_self.into_inner()).into();
        output
    }
    fn element_sum(_self: Val<bevy::math::Vec3A>) {
        let output: f32 = bevy::math::Vec3A::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>) {
        let output: bool = <bevy::math::Vec3A as std::cmp::PartialEq<
            bevy::math::Vec3A,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    fn exp(_self: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::exp(_self.into_inner())
            .into();
        output
    }
    fn extend(_self: Val<bevy::math::Vec3A>, w: f32) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec3A::extend(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    fn floor(_self: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::floor(_self.into_inner())
            .into();
        output
    }
    fn fract(_self: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::fract(_self.into_inner())
            .into();
        output
    }
    fn fract_gl(_self: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::fract_gl(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn from_array(a: [f32; 3]) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::from_array(a).into();
        output
    }
    fn from_vec4(v: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::from_vec4(v.into_inner())
            .into();
        output
    }
    fn is_finite(_self: Val<bevy::math::Vec3A>) {
        let output: bool = bevy::math::Vec3A::is_finite(_self.into_inner()).into();
        output
    }
    fn is_finite_mask(_self: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::is_finite_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn is_nan(_self: Val<bevy::math::Vec3A>) {
        let output: bool = bevy::math::Vec3A::is_nan(_self.into_inner()).into();
        output
    }
    fn is_nan_mask(_self: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::is_nan_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn is_negative_bitmask(_self: Val<bevy::math::Vec3A>) {
        let output: u32 = bevy::math::Vec3A::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    fn is_normalized(_self: Val<bevy::math::Vec3A>) {
        let output: bool = bevy::math::Vec3A::is_normalized(_self.into_inner()).into();
        output
    }
    fn length(_self: Val<bevy::math::Vec3A>) {
        let output: f32 = bevy::math::Vec3A::length(_self.into_inner()).into();
        output
    }
    fn length_recip(_self: Val<bevy::math::Vec3A>) {
        let output: f32 = bevy::math::Vec3A::length_recip(_self.into_inner()).into();
        output
    }
    fn length_squared(_self: Val<bevy::math::Vec3A>) {
        let output: f32 = bevy::math::Vec3A::length_squared(_self.into_inner()).into();
        output
    }
    fn lerp(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>, s: f32) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::lerp(
                _self.into_inner(),
                rhs.into_inner(),
                s,
            )
            .into();
        output
    }
    fn max(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::Vec3A>) {
        let output: f32 = bevy::math::Vec3A::max_element(_self.into_inner()).into();
        output
    }
    fn midpoint(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::midpoint(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::Vec3A>) {
        let output: f32 = bevy::math::Vec3A::min_element(_self.into_inner()).into();
        output
    }
    fn move_towards(_self: Ref<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>, d: f32) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::move_towards(
                &_self,
                rhs.into_inner(),
                d,
            )
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Mul<
            &bevy::math::Vec3A,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Mul<
            bevy::math::Vec3A,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Vec3A>, rhs: f32) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Mul<
            f32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn mul_add(
        _self: Val<bevy::math::Vec3A>,
        a: Val<bevy::math::Vec3A>,
        b: Val<bevy::math::Vec3A>,
    ) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::mul_add(
                _self.into_inner(),
                a.into_inner(),
                b.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn new(x: f32, y: f32, z: f32) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::new(x, y, z).into();
        output
    }
    fn normalize(_self: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::normalize(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn normalize_or(_self: Val<bevy::math::Vec3A>, fallback: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::normalize_or(
                _self.into_inner(),
                fallback.into_inner(),
            )
            .into();
        output
    }
    fn normalize_or_zero(_self: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::normalize_or_zero(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn powf(_self: Val<bevy::math::Vec3A>, n: f32) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::powf(
                _self.into_inner(),
                n,
            )
            .into();
        output
    }
    fn project_onto(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::project_onto(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn project_onto_normalized(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::project_onto_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn recip(_self: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::recip(_self.into_inner())
            .into();
        output
    }
    fn reflect(_self: Val<bevy::math::Vec3A>, normal: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::reflect(
                _self.into_inner(),
                normal.into_inner(),
            )
            .into();
        output
    }
    fn refract(_self: Val<bevy::math::Vec3A>, normal: Val<bevy::math::Vec3A>, eta: f32) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::refract(
                _self.into_inner(),
                normal.into_inner(),
                eta,
            )
            .into();
        output
    }
    fn reject_from(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::reject_from(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn reject_from_normalized(
        _self: Val<bevy::math::Vec3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::reject_from_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Rem<
            &bevy::math::Vec3A,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Rem<
            bevy::math::Vec3A,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::Vec3A>, rhs: f32) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Rem<
            f32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn rem_euclid(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn round(_self: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::round(_self.into_inner())
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec3A>,
        if_true: Val<bevy::math::Vec3A>,
        if_false: Val<bevy::math::Vec3A>,
    ) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn signum(_self: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn splat(v: f32) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Sub<
            &bevy::math::Vec3A,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Sub<
            bevy::math::Vec3A,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::Vec3A>, rhs: f32) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as std::ops::Sub<
            f32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::Vec3A>) {
        let output: [f32; 3] = bevy::math::Vec3A::to_array(&_self).into();
        output
    }
    fn trunc(_self: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::trunc(_self.into_inner())
            .into();
        output
    }
    fn truncate(_self: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Vec3A::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn with_x(_self: Val<bevy::math::Vec3A>, x: f32) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::Vec3A>, y: f32) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    fn with_z(_self: Val<bevy::math::Vec3A>, z: f32) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "vec_4")]
impl bevy::math::Vec4 {
    fn abs(_self: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::abs(_self.into_inner())
            .into();
        output
    }
    fn abs_diff_eq(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
        max_abs_diff: f32,
    ) {
        let output: bool = bevy::math::Vec4::abs_diff_eq(
                _self.into_inner(),
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Add<
            &bevy::math::Vec4,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Add<
            bevy::math::Vec4,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Vec4>, rhs: f32) {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Add<
            f32,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn as_dvec4(_self: Ref<bevy::math::Vec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::Vec4::as_dvec4(&_self).into();
        output
    }
    fn as_i64vec4(_self: Ref<bevy::math::Vec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::Vec4::as_i64vec4(&_self)
            .into();
        output
    }
    fn as_ivec4(_self: Ref<bevy::math::Vec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::Vec4::as_ivec4(&_self).into();
        output
    }
    fn as_u64vec4(_self: Ref<bevy::math::Vec4>) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::Vec4::as_u64vec4(&_self)
            .into();
        output
    }
    fn as_uvec4(_self: Ref<bevy::math::Vec4>) {
        let output: Val<bevy::math::UVec4> = bevy::math::Vec4::as_uvec4(&_self).into();
        output
    }
    fn ceil(_self: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::ceil(_self.into_inner())
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::Vec4>,
        min: Val<bevy::math::Vec4>,
        max: Val<bevy::math::Vec4>,
    ) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clamp_length(_self: Val<bevy::math::Vec4>, min: f32, max: f32) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::clamp_length(
                _self.into_inner(),
                min,
                max,
            )
            .into();
        output
    }
    fn clamp_length_max(_self: Val<bevy::math::Vec4>, max: f32) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::clamp_length_max(
                _self.into_inner(),
                max,
            )
            .into();
        output
    }
    fn clamp_length_min(_self: Val<bevy::math::Vec4>, min: f32) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::clamp_length_min(
                _self.into_inner(),
                min,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn copysign(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::copysign(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: f32 = bevy::math::Vec4::distance(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance_squared(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: f32 = bevy::math::Vec4::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Div<
            &bevy::math::Vec4,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Div<
            bevy::math::Vec4,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::Vec4>, rhs: f32) {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Div<
            f32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_euclid(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: f32 = bevy::math::Vec4::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::Vec4>) {
        let output: f32 = bevy::math::Vec4::element_product(_self.into_inner()).into();
        output
    }
    fn element_sum(_self: Val<bevy::math::Vec4>) {
        let output: f32 = bevy::math::Vec4::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>) {
        let output: bool = <bevy::math::Vec4 as std::cmp::PartialEq<
            bevy::math::Vec4,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    fn exp(_self: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::exp(_self.into_inner())
            .into();
        output
    }
    fn floor(_self: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::floor(_self.into_inner())
            .into();
        output
    }
    fn fract(_self: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::fract(_self.into_inner())
            .into();
        output
    }
    fn fract_gl(_self: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::fract_gl(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn from_array(a: [f32; 4]) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::from_array(a).into();
        output
    }
    fn is_finite(_self: Val<bevy::math::Vec4>) {
        let output: bool = bevy::math::Vec4::is_finite(_self.into_inner()).into();
        output
    }
    fn is_finite_mask(_self: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::is_finite_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn is_nan(_self: Val<bevy::math::Vec4>) {
        let output: bool = bevy::math::Vec4::is_nan(_self.into_inner()).into();
        output
    }
    fn is_nan_mask(_self: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::is_nan_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn is_negative_bitmask(_self: Val<bevy::math::Vec4>) {
        let output: u32 = bevy::math::Vec4::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    fn is_normalized(_self: Val<bevy::math::Vec4>) {
        let output: bool = bevy::math::Vec4::is_normalized(_self.into_inner()).into();
        output
    }
    fn length(_self: Val<bevy::math::Vec4>) {
        let output: f32 = bevy::math::Vec4::length(_self.into_inner()).into();
        output
    }
    fn length_recip(_self: Val<bevy::math::Vec4>) {
        let output: f32 = bevy::math::Vec4::length_recip(_self.into_inner()).into();
        output
    }
    fn length_squared(_self: Val<bevy::math::Vec4>) {
        let output: f32 = bevy::math::Vec4::length_squared(_self.into_inner()).into();
        output
    }
    fn lerp(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>, s: f32) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::lerp(
                _self.into_inner(),
                rhs.into_inner(),
                s,
            )
            .into();
        output
    }
    fn max(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::Vec4>) {
        let output: f32 = bevy::math::Vec4::max_element(_self.into_inner()).into();
        output
    }
    fn midpoint(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::midpoint(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::Vec4>) {
        let output: f32 = bevy::math::Vec4::min_element(_self.into_inner()).into();
        output
    }
    fn move_towards(_self: Ref<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>, d: f32) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::move_towards(
                &_self,
                rhs.into_inner(),
                d,
            )
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Mul<
            &bevy::math::Vec4,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Mul<
            bevy::math::Vec4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Vec4>, rhs: f32) {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Mul<
            f32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn mul_add(
        _self: Val<bevy::math::Vec4>,
        a: Val<bevy::math::Vec4>,
        b: Val<bevy::math::Vec4>,
    ) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::mul_add(
                _self.into_inner(),
                a.into_inner(),
                b.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn new(x: f32, y: f32, z: f32, w: f32) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::new(x, y, z, w).into();
        output
    }
    fn normalize(_self: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::normalize(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn normalize_or(_self: Val<bevy::math::Vec4>, fallback: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::normalize_or(
                _self.into_inner(),
                fallback.into_inner(),
            )
            .into();
        output
    }
    fn normalize_or_zero(_self: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::normalize_or_zero(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn powf(_self: Val<bevy::math::Vec4>, n: f32) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::powf(_self.into_inner(), n)
            .into();
        output
    }
    fn project_onto(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::project_onto(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn project_onto_normalized(
        _self: Val<bevy::math::Vec4>,
        rhs: Val<bevy::math::Vec4>,
    ) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::project_onto_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn recip(_self: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::recip(_self.into_inner())
            .into();
        output
    }
    fn reflect(_self: Val<bevy::math::Vec4>, normal: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::reflect(
                _self.into_inner(),
                normal.into_inner(),
            )
            .into();
        output
    }
    fn refract(_self: Val<bevy::math::Vec4>, normal: Val<bevy::math::Vec4>, eta: f32) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::refract(
                _self.into_inner(),
                normal.into_inner(),
                eta,
            )
            .into();
        output
    }
    fn reject_from(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::reject_from(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn reject_from_normalized(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::reject_from_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Rem<
            &bevy::math::Vec4,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Rem<
            bevy::math::Vec4,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::Vec4>, rhs: f32) {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Rem<
            f32,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn rem_euclid(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn round(_self: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::round(_self.into_inner())
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec4A>,
        if_true: Val<bevy::math::Vec4>,
        if_false: Val<bevy::math::Vec4>,
    ) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn signum(_self: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::signum(_self.into_inner())
            .into();
        output
    }
    fn splat(v: f32) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Sub<
            &bevy::math::Vec4,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Sub<
            bevy::math::Vec4,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::Vec4>, rhs: f32) {
        let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as std::ops::Sub<
            f32,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::Vec4>) {
        let output: [f32; 4] = bevy::math::Vec4::to_array(&_self).into();
        output
    }
    fn trunc(_self: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::trunc(_self.into_inner())
            .into();
        output
    }
    fn truncate(_self: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Vec4::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn with_w(_self: Val<bevy::math::Vec4>, w: f32) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::with_w(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    fn with_x(_self: Val<bevy::math::Vec4>, x: f32) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::Vec4>, y: f32) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    fn with_z(_self: Val<bevy::math::Vec4>, z: f32) {
        let output: Val<bevy::math::Vec4> = bevy::math::Vec4::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "b_vec_2")]
impl bevy::math::BVec2 {
    fn all(_self: Val<bevy::math::BVec2>) {
        let output: bool = bevy::math::BVec2::all(_self.into_inner()).into();
        output
    }
    fn any(_self: Val<bevy::math::BVec2>) {
        let output: bool = bevy::math::BVec2::any(_self.into_inner()).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::BVec2>) {
        let output: () = <bevy::math::BVec2 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn bitmask(_self: Val<bevy::math::BVec2>) {
        let output: u32 = bevy::math::BVec2::bitmask(_self.into_inner()).into();
        output
    }
    fn clone(_self: Ref<bevy::math::BVec2>) {
        let output: Val<bevy::math::BVec2> = <bevy::math::BVec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::BVec2>, other: Ref<bevy::math::BVec2>) {
        let output: bool = <bevy::math::BVec2 as std::cmp::PartialEq<
            bevy::math::BVec2,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn from_array(a: [bool; 2]) {
        let output: Val<bevy::math::BVec2> = bevy::math::BVec2::from_array(a).into();
        output
    }
    fn new(x: bool, y: bool) {
        let output: Val<bevy::math::BVec2> = bevy::math::BVec2::new(x, y).into();
        output
    }
    fn set(mut _self: Mut<bevy::math::BVec2>, index: usize, value: bool) {
        let output: () = bevy::math::BVec2::set(&mut _self, index, value).into();
        output
    }
    fn splat(v: bool) {
        let output: Val<bevy::math::BVec2> = bevy::math::BVec2::splat(v).into();
        output
    }
    fn test(_self: Ref<bevy::math::BVec2>, index: usize) {
        let output: bool = bevy::math::BVec2::test(&_self, index).into();
        output
    }
}
#[script_bindings(remote, name = "b_vec_3")]
impl bevy::math::BVec3 {
    fn all(_self: Val<bevy::math::BVec3>) {
        let output: bool = bevy::math::BVec3::all(_self.into_inner()).into();
        output
    }
    fn any(_self: Val<bevy::math::BVec3>) {
        let output: bool = bevy::math::BVec3::any(_self.into_inner()).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::BVec3>) {
        let output: () = <bevy::math::BVec3 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn bitmask(_self: Val<bevy::math::BVec3>) {
        let output: u32 = bevy::math::BVec3::bitmask(_self.into_inner()).into();
        output
    }
    fn clone(_self: Ref<bevy::math::BVec3>) {
        let output: Val<bevy::math::BVec3> = <bevy::math::BVec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::BVec3>, other: Ref<bevy::math::BVec3>) {
        let output: bool = <bevy::math::BVec3 as std::cmp::PartialEq<
            bevy::math::BVec3,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn from_array(a: [bool; 3]) {
        let output: Val<bevy::math::BVec3> = bevy::math::BVec3::from_array(a).into();
        output
    }
    fn new(x: bool, y: bool, z: bool) {
        let output: Val<bevy::math::BVec3> = bevy::math::BVec3::new(x, y, z).into();
        output
    }
    fn set(mut _self: Mut<bevy::math::BVec3>, index: usize, value: bool) {
        let output: () = bevy::math::BVec3::set(&mut _self, index, value).into();
        output
    }
    fn splat(v: bool) {
        let output: Val<bevy::math::BVec3> = bevy::math::BVec3::splat(v).into();
        output
    }
    fn test(_self: Ref<bevy::math::BVec3>, index: usize) {
        let output: bool = bevy::math::BVec3::test(&_self, index).into();
        output
    }
}
#[script_bindings(remote, name = "b_vec_4")]
impl bevy::math::BVec4 {
    fn all(_self: Val<bevy::math::BVec4>) {
        let output: bool = bevy::math::BVec4::all(_self.into_inner()).into();
        output
    }
    fn any(_self: Val<bevy::math::BVec4>) {
        let output: bool = bevy::math::BVec4::any(_self.into_inner()).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::BVec4>) {
        let output: () = <bevy::math::BVec4 as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn bitmask(_self: Val<bevy::math::BVec4>) {
        let output: u32 = bevy::math::BVec4::bitmask(_self.into_inner()).into();
        output
    }
    fn clone(_self: Ref<bevy::math::BVec4>) {
        let output: Val<bevy::math::BVec4> = <bevy::math::BVec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::BVec4>, other: Ref<bevy::math::BVec4>) {
        let output: bool = <bevy::math::BVec4 as std::cmp::PartialEq<
            bevy::math::BVec4,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn from_array(a: [bool; 4]) {
        let output: Val<bevy::math::BVec4> = bevy::math::BVec4::from_array(a).into();
        output
    }
    fn new(x: bool, y: bool, z: bool, w: bool) {
        let output: Val<bevy::math::BVec4> = bevy::math::BVec4::new(x, y, z, w).into();
        output
    }
    fn set(mut _self: Mut<bevy::math::BVec4>, index: usize, value: bool) {
        let output: () = bevy::math::BVec4::set(&mut _self, index, value).into();
        output
    }
    fn splat(v: bool) {
        let output: Val<bevy::math::BVec4> = bevy::math::BVec4::splat(v).into();
        output
    }
    fn test(_self: Ref<bevy::math::BVec4>, index: usize) {
        let output: bool = bevy::math::BVec4::test(&_self, index).into();
        output
    }
}
#[script_bindings(remote, name = "d_vec_2")]
impl bevy::math::DVec2 {
    fn abs(_self: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::abs(_self.into_inner())
            .into();
        output
    }
    fn abs_diff_eq(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
        max_abs_diff: f64,
    ) {
        let output: bool = bevy::math::DVec2::abs_diff_eq(
                _self.into_inner(),
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::DVec2>, rhs: Ref<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Add<
            &bevy::math::DVec2,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Add<
            bevy::math::DVec2,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::DVec2>, rhs: f64) {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Add<
            f64,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn angle_between(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: f64 = bevy::math::DVec2::angle_between(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn angle_to(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: f64 = bevy::math::DVec2::angle_to(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn as_i64vec2(_self: Ref<bevy::math::DVec2>) {
        let output: Val<bevy::math::I64Vec2> = bevy::math::DVec2::as_i64vec2(&_self)
            .into();
        output
    }
    fn as_ivec2(_self: Ref<bevy::math::DVec2>) {
        let output: Val<bevy::math::IVec2> = bevy::math::DVec2::as_ivec2(&_self).into();
        output
    }
    fn as_u64vec2(_self: Ref<bevy::math::DVec2>) {
        let output: Val<bevy::math::U64Vec2> = bevy::math::DVec2::as_u64vec2(&_self)
            .into();
        output
    }
    fn as_uvec2(_self: Ref<bevy::math::DVec2>) {
        let output: Val<bevy::math::UVec2> = bevy::math::DVec2::as_uvec2(&_self).into();
        output
    }
    fn as_vec2(_self: Ref<bevy::math::DVec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::DVec2::as_vec2(&_self).into();
        output
    }
    fn ceil(_self: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::ceil(_self.into_inner())
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::DVec2>,
        min: Val<bevy::math::DVec2>,
        max: Val<bevy::math::DVec2>,
    ) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clamp_length(_self: Val<bevy::math::DVec2>, min: f64, max: f64) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::clamp_length(
                _self.into_inner(),
                min,
                max,
            )
            .into();
        output
    }
    fn clamp_length_max(_self: Val<bevy::math::DVec2>, max: f64) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::clamp_length_max(
                _self.into_inner(),
                max,
            )
            .into();
        output
    }
    fn clamp_length_min(_self: Val<bevy::math::DVec2>, min: f64) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::clamp_length_min(
                _self.into_inner(),
                min,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn copysign(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::copysign(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: f64 = bevy::math::DVec2::distance(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance_squared(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: f64 = bevy::math::DVec2::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::DVec2>, rhs: Ref<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Div<
            &bevy::math::DVec2,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Div<
            bevy::math::DVec2,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::DVec2>, rhs: f64) {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Div<
            f64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_euclid(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: f64 = bevy::math::DVec2::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::DVec2>) {
        let output: f64 = bevy::math::DVec2::element_product(_self.into_inner()).into();
        output
    }
    fn element_sum(_self: Val<bevy::math::DVec2>) {
        let output: f64 = bevy::math::DVec2::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::DVec2>, other: Ref<bevy::math::DVec2>) {
        let output: bool = <bevy::math::DVec2 as std::cmp::PartialEq<
            bevy::math::DVec2,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn exp(_self: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::exp(_self.into_inner())
            .into();
        output
    }
    fn extend(_self: Val<bevy::math::DVec2>, z: f64) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec2::extend(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
    fn floor(_self: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::floor(_self.into_inner())
            .into();
        output
    }
    fn fract(_self: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::fract(_self.into_inner())
            .into();
        output
    }
    fn fract_gl(_self: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::fract_gl(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn from_angle(angle: f64) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::from_angle(angle).into();
        output
    }
    fn from_array(a: [f64; 2]) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::from_array(a).into();
        output
    }
    fn is_finite(_self: Val<bevy::math::DVec2>) {
        let output: bool = bevy::math::DVec2::is_finite(_self.into_inner()).into();
        output
    }
    fn is_finite_mask(_self: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::DVec2::is_finite_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn is_nan(_self: Val<bevy::math::DVec2>) {
        let output: bool = bevy::math::DVec2::is_nan(_self.into_inner()).into();
        output
    }
    fn is_nan_mask(_self: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::BVec2> = bevy::math::DVec2::is_nan_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn is_negative_bitmask(_self: Val<bevy::math::DVec2>) {
        let output: u32 = bevy::math::DVec2::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    fn is_normalized(_self: Val<bevy::math::DVec2>) {
        let output: bool = bevy::math::DVec2::is_normalized(_self.into_inner()).into();
        output
    }
    fn length(_self: Val<bevy::math::DVec2>) {
        let output: f64 = bevy::math::DVec2::length(_self.into_inner()).into();
        output
    }
    fn length_recip(_self: Val<bevy::math::DVec2>) {
        let output: f64 = bevy::math::DVec2::length_recip(_self.into_inner()).into();
        output
    }
    fn length_squared(_self: Val<bevy::math::DVec2>) {
        let output: f64 = bevy::math::DVec2::length_squared(_self.into_inner()).into();
        output
    }
    fn lerp(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>, s: f64) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::lerp(
                _self.into_inner(),
                rhs.into_inner(),
                s,
            )
            .into();
        output
    }
    fn max(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::DVec2>) {
        let output: f64 = bevy::math::DVec2::max_element(_self.into_inner()).into();
        output
    }
    fn midpoint(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::midpoint(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::DVec2>) {
        let output: f64 = bevy::math::DVec2::min_element(_self.into_inner()).into();
        output
    }
    fn move_towards(_self: Ref<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>, d: f64) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::move_towards(
                &_self,
                rhs.into_inner(),
                d,
            )
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DVec2>, rhs: Ref<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Mul<
            &bevy::math::DVec2,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Mul<
            bevy::math::DVec2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DVec2>, rhs: f64) {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Mul<
            f64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn mul_add(
        _self: Val<bevy::math::DVec2>,
        a: Val<bevy::math::DVec2>,
        b: Val<bevy::math::DVec2>,
    ) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::mul_add(
                _self.into_inner(),
                a.into_inner(),
                b.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn new(x: f64, y: f64) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::new(x, y).into();
        output
    }
    fn normalize(_self: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::normalize(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn normalize_or(_self: Val<bevy::math::DVec2>, fallback: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::normalize_or(
                _self.into_inner(),
                fallback.into_inner(),
            )
            .into();
        output
    }
    fn normalize_or_zero(_self: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::normalize_or_zero(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn perp(_self: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::perp(_self.into_inner())
            .into();
        output
    }
    fn perp_dot(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: f64 = bevy::math::DVec2::perp_dot(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn powf(_self: Val<bevy::math::DVec2>, n: f64) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::powf(
                _self.into_inner(),
                n,
            )
            .into();
        output
    }
    fn project_onto(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::project_onto(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn project_onto_normalized(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::project_onto_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn recip(_self: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::recip(_self.into_inner())
            .into();
        output
    }
    fn reflect(_self: Val<bevy::math::DVec2>, normal: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::reflect(
                _self.into_inner(),
                normal.into_inner(),
            )
            .into();
        output
    }
    fn refract(_self: Val<bevy::math::DVec2>, normal: Val<bevy::math::DVec2>, eta: f64) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::refract(
                _self.into_inner(),
                normal.into_inner(),
                eta,
            )
            .into();
        output
    }
    fn reject_from(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::reject_from(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn reject_from_normalized(
        _self: Val<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
    ) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::reject_from_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::DVec2>, rhs: Ref<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Rem<
            &bevy::math::DVec2,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Rem<
            bevy::math::DVec2,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::DVec2>, rhs: f64) {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Rem<
            f64,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn rem_euclid(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rotate(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::rotate(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rotate_towards(
        _self: Ref<bevy::math::DVec2>,
        rhs: Val<bevy::math::DVec2>,
        max_angle: f64,
    ) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::rotate_towards(
                &_self,
                rhs.into_inner(),
                max_angle,
            )
            .into();
        output
    }
    fn round(_self: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::round(_self.into_inner())
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec2>,
        if_true: Val<bevy::math::DVec2>,
        if_false: Val<bevy::math::DVec2>,
    ) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn signum(_self: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn splat(v: f64) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::DVec2>, rhs: Ref<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Sub<
            &bevy::math::DVec2,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Sub<
            bevy::math::DVec2,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::DVec2>, rhs: f64) {
        let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as std::ops::Sub<
            f64,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_angle(_self: Val<bevy::math::DVec2>) {
        let output: f64 = bevy::math::DVec2::to_angle(_self.into_inner()).into();
        output
    }
    fn to_array(_self: Ref<bevy::math::DVec2>) {
        let output: [f64; 2] = bevy::math::DVec2::to_array(&_self).into();
        output
    }
    fn trunc(_self: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::trunc(_self.into_inner())
            .into();
        output
    }
    fn with_x(_self: Val<bevy::math::DVec2>, x: f64) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::DVec2>, y: f64) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec2::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "d_vec_3")]
impl bevy::math::DVec3 {
    fn abs(_self: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::abs(_self.into_inner())
            .into();
        output
    }
    fn abs_diff_eq(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
        max_abs_diff: f64,
    ) {
        let output: bool = bevy::math::DVec3::abs_diff_eq(
                _self.into_inner(),
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::DVec3>, rhs: Ref<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Add<
            &bevy::math::DVec3,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Add<
            bevy::math::DVec3,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::DVec3>, rhs: f64) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Add<
            f64,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn angle_between(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: f64 = bevy::math::DVec3::angle_between(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn any_orthogonal_vector(_self: Ref<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::any_orthogonal_vector(
                &_self,
            )
            .into();
        output
    }
    fn any_orthonormal_vector(_self: Ref<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::any_orthonormal_vector(
                &_self,
            )
            .into();
        output
    }
    fn as_i64vec3(_self: Ref<bevy::math::DVec3>) {
        let output: Val<bevy::math::I64Vec3> = bevy::math::DVec3::as_i64vec3(&_self)
            .into();
        output
    }
    fn as_ivec3(_self: Ref<bevy::math::DVec3>) {
        let output: Val<bevy::math::IVec3> = bevy::math::DVec3::as_ivec3(&_self).into();
        output
    }
    fn as_u64vec3(_self: Ref<bevy::math::DVec3>) {
        let output: Val<bevy::math::U64Vec3> = bevy::math::DVec3::as_u64vec3(&_self)
            .into();
        output
    }
    fn as_uvec3(_self: Ref<bevy::math::DVec3>) {
        let output: Val<bevy::math::UVec3> = bevy::math::DVec3::as_uvec3(&_self).into();
        output
    }
    fn as_vec3(_self: Ref<bevy::math::DVec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::DVec3::as_vec3(&_self).into();
        output
    }
    fn as_vec3a(_self: Ref<bevy::math::DVec3>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::DVec3::as_vec3a(&_self).into();
        output
    }
    fn ceil(_self: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::ceil(_self.into_inner())
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::DVec3>,
        min: Val<bevy::math::DVec3>,
        max: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clamp_length(_self: Val<bevy::math::DVec3>, min: f64, max: f64) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::clamp_length(
                _self.into_inner(),
                min,
                max,
            )
            .into();
        output
    }
    fn clamp_length_max(_self: Val<bevy::math::DVec3>, max: f64) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::clamp_length_max(
                _self.into_inner(),
                max,
            )
            .into();
        output
    }
    fn clamp_length_min(_self: Val<bevy::math::DVec3>, min: f64) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::clamp_length_min(
                _self.into_inner(),
                min,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn copysign(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::copysign(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cross(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::cross(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: f64 = bevy::math::DVec3::distance(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance_squared(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: f64 = bevy::math::DVec3::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::DVec3>, rhs: Ref<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Div<
            &bevy::math::DVec3,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Div<
            bevy::math::DVec3,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::DVec3>, rhs: f64) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Div<
            f64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_euclid(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: f64 = bevy::math::DVec3::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::DVec3>) {
        let output: f64 = bevy::math::DVec3::element_product(_self.into_inner()).into();
        output
    }
    fn element_sum(_self: Val<bevy::math::DVec3>) {
        let output: f64 = bevy::math::DVec3::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::DVec3>, other: Ref<bevy::math::DVec3>) {
        let output: bool = <bevy::math::DVec3 as std::cmp::PartialEq<
            bevy::math::DVec3,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn exp(_self: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::exp(_self.into_inner())
            .into();
        output
    }
    fn extend(_self: Val<bevy::math::DVec3>, w: f64) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec3::extend(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    fn floor(_self: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::floor(_self.into_inner())
            .into();
        output
    }
    fn fract(_self: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::fract(_self.into_inner())
            .into();
        output
    }
    fn fract_gl(_self: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::fract_gl(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn from_array(a: [f64; 3]) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::from_array(a).into();
        output
    }
    fn is_finite(_self: Val<bevy::math::DVec3>) {
        let output: bool = bevy::math::DVec3::is_finite(_self.into_inner()).into();
        output
    }
    fn is_finite_mask(_self: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::DVec3::is_finite_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn is_nan(_self: Val<bevy::math::DVec3>) {
        let output: bool = bevy::math::DVec3::is_nan(_self.into_inner()).into();
        output
    }
    fn is_nan_mask(_self: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::BVec3> = bevy::math::DVec3::is_nan_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn is_negative_bitmask(_self: Val<bevy::math::DVec3>) {
        let output: u32 = bevy::math::DVec3::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    fn is_normalized(_self: Val<bevy::math::DVec3>) {
        let output: bool = bevy::math::DVec3::is_normalized(_self.into_inner()).into();
        output
    }
    fn length(_self: Val<bevy::math::DVec3>) {
        let output: f64 = bevy::math::DVec3::length(_self.into_inner()).into();
        output
    }
    fn length_recip(_self: Val<bevy::math::DVec3>) {
        let output: f64 = bevy::math::DVec3::length_recip(_self.into_inner()).into();
        output
    }
    fn length_squared(_self: Val<bevy::math::DVec3>) {
        let output: f64 = bevy::math::DVec3::length_squared(_self.into_inner()).into();
        output
    }
    fn lerp(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>, s: f64) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::lerp(
                _self.into_inner(),
                rhs.into_inner(),
                s,
            )
            .into();
        output
    }
    fn max(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::DVec3>) {
        let output: f64 = bevy::math::DVec3::max_element(_self.into_inner()).into();
        output
    }
    fn midpoint(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::midpoint(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::DVec3>) {
        let output: f64 = bevy::math::DVec3::min_element(_self.into_inner()).into();
        output
    }
    fn move_towards(_self: Ref<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>, d: f64) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::move_towards(
                &_self,
                rhs.into_inner(),
                d,
            )
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DVec3>, rhs: Ref<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Mul<
            &bevy::math::DVec3,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Mul<
            bevy::math::DVec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DVec3>, rhs: f64) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Mul<
            f64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn mul_add(
        _self: Val<bevy::math::DVec3>,
        a: Val<bevy::math::DVec3>,
        b: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::mul_add(
                _self.into_inner(),
                a.into_inner(),
                b.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn new(x: f64, y: f64, z: f64) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::new(x, y, z).into();
        output
    }
    fn normalize(_self: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::normalize(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn normalize_or(_self: Val<bevy::math::DVec3>, fallback: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::normalize_or(
                _self.into_inner(),
                fallback.into_inner(),
            )
            .into();
        output
    }
    fn normalize_or_zero(_self: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::normalize_or_zero(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn powf(_self: Val<bevy::math::DVec3>, n: f64) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::powf(
                _self.into_inner(),
                n,
            )
            .into();
        output
    }
    fn project_onto(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::project_onto(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn project_onto_normalized(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::project_onto_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn recip(_self: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::recip(_self.into_inner())
            .into();
        output
    }
    fn reflect(_self: Val<bevy::math::DVec3>, normal: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::reflect(
                _self.into_inner(),
                normal.into_inner(),
            )
            .into();
        output
    }
    fn refract(_self: Val<bevy::math::DVec3>, normal: Val<bevy::math::DVec3>, eta: f64) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::refract(
                _self.into_inner(),
                normal.into_inner(),
                eta,
            )
            .into();
        output
    }
    fn reject_from(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::reject_from(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn reject_from_normalized(
        _self: Val<bevy::math::DVec3>,
        rhs: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::reject_from_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::DVec3>, rhs: Ref<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Rem<
            &bevy::math::DVec3,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Rem<
            bevy::math::DVec3,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::DVec3>, rhs: f64) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Rem<
            f64,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn rem_euclid(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn round(_self: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::round(_self.into_inner())
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec3>,
        if_true: Val<bevy::math::DVec3>,
        if_false: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn signum(_self: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn splat(v: f64) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::DVec3>, rhs: Ref<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Sub<
            &bevy::math::DVec3,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Sub<
            bevy::math::DVec3,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::DVec3>, rhs: f64) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as std::ops::Sub<
            f64,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::DVec3>) {
        let output: [f64; 3] = bevy::math::DVec3::to_array(&_self).into();
        output
    }
    fn trunc(_self: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::trunc(_self.into_inner())
            .into();
        output
    }
    fn truncate(_self: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DVec3::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn with_x(_self: Val<bevy::math::DVec3>, x: f64) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::DVec3>, y: f64) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    fn with_z(_self: Val<bevy::math::DVec3>, z: f64) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec3::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "d_vec_4")]
impl bevy::math::DVec4 {
    fn abs(_self: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::abs(_self.into_inner())
            .into();
        output
    }
    fn abs_diff_eq(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
        max_abs_diff: f64,
    ) {
        let output: bool = bevy::math::DVec4::abs_diff_eq(
                _self.into_inner(),
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::DVec4>, rhs: Ref<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Add<
            &bevy::math::DVec4,
        >>::add(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn add(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Add<
            bevy::math::DVec4,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add(_self: Val<bevy::math::DVec4>, rhs: f64) {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Add<
            f64,
        >>::add(_self.into_inner(), rhs)
            .into();
        output
    }
    fn as_i64vec4(_self: Ref<bevy::math::DVec4>) {
        let output: Val<bevy::math::I64Vec4> = bevy::math::DVec4::as_i64vec4(&_self)
            .into();
        output
    }
    fn as_ivec4(_self: Ref<bevy::math::DVec4>) {
        let output: Val<bevy::math::IVec4> = bevy::math::DVec4::as_ivec4(&_self).into();
        output
    }
    fn as_u64vec4(_self: Ref<bevy::math::DVec4>) {
        let output: Val<bevy::math::U64Vec4> = bevy::math::DVec4::as_u64vec4(&_self)
            .into();
        output
    }
    fn as_uvec4(_self: Ref<bevy::math::DVec4>) {
        let output: Val<bevy::math::UVec4> = bevy::math::DVec4::as_uvec4(&_self).into();
        output
    }
    fn as_vec4(_self: Ref<bevy::math::DVec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::DVec4::as_vec4(&_self).into();
        output
    }
    fn ceil(_self: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::ceil(_self.into_inner())
            .into();
        output
    }
    fn clamp(
        _self: Val<bevy::math::DVec4>,
        min: Val<bevy::math::DVec4>,
        max: Val<bevy::math::DVec4>,
    ) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::clamp(
                _self.into_inner(),
                min.into_inner(),
                max.into_inner(),
            )
            .into();
        output
    }
    fn clamp_length(_self: Val<bevy::math::DVec4>, min: f64, max: f64) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::clamp_length(
                _self.into_inner(),
                min,
                max,
            )
            .into();
        output
    }
    fn clamp_length_max(_self: Val<bevy::math::DVec4>, max: f64) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::clamp_length_max(
                _self.into_inner(),
                max,
            )
            .into();
        output
    }
    fn clamp_length_min(_self: Val<bevy::math::DVec4>, min: f64) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::clamp_length_min(
                _self.into_inner(),
                min,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn cmpeq(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmpeq(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpge(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmpge(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpgt(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmpgt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmple(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmple(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmplt(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmplt(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn cmpne(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmpne(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn copysign(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::copysign(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: f64 = bevy::math::DVec4::distance(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn distance_squared(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: f64 = bevy::math::DVec4::distance_squared(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::DVec4>, rhs: Ref<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Div<
            &bevy::math::DVec4,
        >>::div(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn div(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Div<
            bevy::math::DVec4,
        >>::div(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn div(_self: Val<bevy::math::DVec4>, rhs: f64) {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Div<
            f64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_euclid(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::div_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: f64 = bevy::math::DVec4::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn dot_into_vec(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::dot_into_vec(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn element_product(_self: Val<bevy::math::DVec4>) {
        let output: f64 = bevy::math::DVec4::element_product(_self.into_inner()).into();
        output
    }
    fn element_sum(_self: Val<bevy::math::DVec4>) {
        let output: f64 = bevy::math::DVec4::element_sum(_self.into_inner()).into();
        output
    }
    fn eq(_self: Ref<bevy::math::DVec4>, other: Ref<bevy::math::DVec4>) {
        let output: bool = <bevy::math::DVec4 as std::cmp::PartialEq<
            bevy::math::DVec4,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn exp(_self: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::exp(_self.into_inner())
            .into();
        output
    }
    fn floor(_self: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::floor(_self.into_inner())
            .into();
        output
    }
    fn fract(_self: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::fract(_self.into_inner())
            .into();
        output
    }
    fn fract_gl(_self: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::fract_gl(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn from_array(a: [f64; 4]) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::from_array(a).into();
        output
    }
    fn is_finite(_self: Val<bevy::math::DVec4>) {
        let output: bool = bevy::math::DVec4::is_finite(_self.into_inner()).into();
        output
    }
    fn is_finite_mask(_self: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::DVec4::is_finite_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn is_nan(_self: Val<bevy::math::DVec4>) {
        let output: bool = bevy::math::DVec4::is_nan(_self.into_inner()).into();
        output
    }
    fn is_nan_mask(_self: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::BVec4> = bevy::math::DVec4::is_nan_mask(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn is_negative_bitmask(_self: Val<bevy::math::DVec4>) {
        let output: u32 = bevy::math::DVec4::is_negative_bitmask(_self.into_inner())
            .into();
        output
    }
    fn is_normalized(_self: Val<bevy::math::DVec4>) {
        let output: bool = bevy::math::DVec4::is_normalized(_self.into_inner()).into();
        output
    }
    fn length(_self: Val<bevy::math::DVec4>) {
        let output: f64 = bevy::math::DVec4::length(_self.into_inner()).into();
        output
    }
    fn length_recip(_self: Val<bevy::math::DVec4>) {
        let output: f64 = bevy::math::DVec4::length_recip(_self.into_inner()).into();
        output
    }
    fn length_squared(_self: Val<bevy::math::DVec4>) {
        let output: f64 = bevy::math::DVec4::length_squared(_self.into_inner()).into();
        output
    }
    fn lerp(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>, s: f64) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::lerp(
                _self.into_inner(),
                rhs.into_inner(),
                s,
            )
            .into();
        output
    }
    fn max(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::max(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn max_element(_self: Val<bevy::math::DVec4>) {
        let output: f64 = bevy::math::DVec4::max_element(_self.into_inner()).into();
        output
    }
    fn midpoint(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::midpoint(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::min(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn min_element(_self: Val<bevy::math::DVec4>) {
        let output: f64 = bevy::math::DVec4::min_element(_self.into_inner()).into();
        output
    }
    fn move_towards(_self: Ref<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>, d: f64) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::move_towards(
                &_self,
                rhs.into_inner(),
                d,
            )
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DVec4>, rhs: Ref<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Mul<
            &bevy::math::DVec4,
        >>::mul(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Mul<
            bevy::math::DVec4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DVec4>, rhs: f64) {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Mul<
            f64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn mul_add(
        _self: Val<bevy::math::DVec4>,
        a: Val<bevy::math::DVec4>,
        b: Val<bevy::math::DVec4>,
    ) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::mul_add(
                _self.into_inner(),
                a.into_inner(),
                b.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn new(x: f64, y: f64, z: f64, w: f64) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::new(x, y, z, w).into();
        output
    }
    fn normalize(_self: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::normalize(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn normalize_or(_self: Val<bevy::math::DVec4>, fallback: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::normalize_or(
                _self.into_inner(),
                fallback.into_inner(),
            )
            .into();
        output
    }
    fn normalize_or_zero(_self: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::normalize_or_zero(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn powf(_self: Val<bevy::math::DVec4>, n: f64) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::powf(
                _self.into_inner(),
                n,
            )
            .into();
        output
    }
    fn project_onto(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::project_onto(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn project_onto_normalized(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::project_onto_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn recip(_self: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::recip(_self.into_inner())
            .into();
        output
    }
    fn reflect(_self: Val<bevy::math::DVec4>, normal: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::reflect(
                _self.into_inner(),
                normal.into_inner(),
            )
            .into();
        output
    }
    fn refract(_self: Val<bevy::math::DVec4>, normal: Val<bevy::math::DVec4>, eta: f64) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::refract(
                _self.into_inner(),
                normal.into_inner(),
                eta,
            )
            .into();
        output
    }
    fn reject_from(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::reject_from(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn reject_from_normalized(
        _self: Val<bevy::math::DVec4>,
        rhs: Val<bevy::math::DVec4>,
    ) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::reject_from_normalized(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::DVec4>, rhs: Ref<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Rem<
            &bevy::math::DVec4,
        >>::rem(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Rem<
            bevy::math::DVec4,
        >>::rem(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn rem(_self: Val<bevy::math::DVec4>, rhs: f64) {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Rem<
            f64,
        >>::rem(_self.into_inner(), rhs)
            .into();
        output
    }
    fn rem_euclid(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::rem_euclid(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn round(_self: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::round(_self.into_inner())
            .into();
        output
    }
    fn select(
        mask: Val<bevy::math::BVec4>,
        if_true: Val<bevy::math::DVec4>,
        if_false: Val<bevy::math::DVec4>,
    ) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::select(
                mask.into_inner(),
                if_true.into_inner(),
                if_false.into_inner(),
            )
            .into();
        output
    }
    fn signum(_self: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::signum(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn splat(v: f64) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::splat(v).into();
        output
    }
    fn sub(_self: Val<bevy::math::DVec4>, rhs: Ref<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Sub<
            &bevy::math::DVec4,
        >>::sub(_self.into_inner(), &rhs)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Sub<
            bevy::math::DVec4,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::DVec4>, rhs: f64) {
        let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as std::ops::Sub<
            f64,
        >>::sub(_self.into_inner(), rhs)
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::DVec4>) {
        let output: [f64; 4] = bevy::math::DVec4::to_array(&_self).into();
        output
    }
    fn trunc(_self: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::trunc(_self.into_inner())
            .into();
        output
    }
    fn truncate(_self: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DVec4::truncate(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn with_w(_self: Val<bevy::math::DVec4>, w: f64) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::with_w(
                _self.into_inner(),
                w,
            )
            .into();
        output
    }
    fn with_x(_self: Val<bevy::math::DVec4>, x: f64) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::with_x(
                _self.into_inner(),
                x,
            )
            .into();
        output
    }
    fn with_y(_self: Val<bevy::math::DVec4>, y: f64) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::with_y(
                _self.into_inner(),
                y,
            )
            .into();
        output
    }
    fn with_z(_self: Val<bevy::math::DVec4>, z: f64) {
        let output: Val<bevy::math::DVec4> = bevy::math::DVec4::with_z(
                _self.into_inner(),
                z,
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "mat_2")]
impl bevy::math::Mat2 {
    fn abs(_self: Ref<bevy::math::Mat2>) {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::abs(&_self).into();
        output
    }
    fn abs_diff_eq(
        _self: Ref<bevy::math::Mat2>,
        rhs: Val<bevy::math::Mat2>,
        max_abs_diff: f32,
    ) {
        let output: bool = bevy::math::Mat2::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Mat2>, rhs: Val<bevy::math::Mat2>) {
        let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as std::ops::Add<
            bevy::math::Mat2,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add_mat2(_self: Ref<bevy::math::Mat2>, rhs: Ref<bevy::math::Mat2>) {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::add_mat2(&_self, &rhs)
            .into();
        output
    }
    fn as_dmat2(_self: Ref<bevy::math::Mat2>) {
        let output: Val<bevy::math::DMat2> = bevy::math::Mat2::as_dmat2(&_self).into();
        output
    }
    fn clone(_self: Ref<bevy::math::Mat2>) {
        let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn col(_self: Ref<bevy::math::Mat2>, index: usize) {
        let output: Val<bevy::math::Vec2> = bevy::math::Mat2::col(&_self, index).into();
        output
    }
    fn determinant(_self: Ref<bevy::math::Mat2>) {
        let output: f32 = bevy::math::Mat2::determinant(&_self).into();
        output
    }
    fn div(_self: Val<bevy::math::Mat2>, rhs: f32) {
        let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as std::ops::Div<
            f32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_scalar(_self: Ref<bevy::math::Mat2>, rhs: f32) {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::div_scalar(&_self, rhs)
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::Mat2>, rhs: Ref<bevy::math::Mat2>) {
        let output: bool = <bevy::math::Mat2 as std::cmp::PartialEq<
            bevy::math::Mat2,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    fn from_angle(angle: f32) {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_angle(angle).into();
        output
    }
    fn from_cols(x_axis: Val<bevy::math::Vec2>, y_axis: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
            )
            .into();
        output
    }
    fn from_diagonal(diagonal: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_diagonal(
                diagonal.into_inner(),
            )
            .into();
        output
    }
    fn from_mat3(m: Val<bevy::math::Mat3>) {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_mat3(m.into_inner())
            .into();
        output
    }
    fn from_mat3_minor(m: Val<bevy::math::Mat3>, i: usize, j: usize) {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_mat3_minor(
                m.into_inner(),
                i,
                j,
            )
            .into();
        output
    }
    fn from_mat3a(m: Val<bevy::math::Mat3A>) {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_mat3a(m.into_inner())
            .into();
        output
    }
    fn from_mat3a_minor(m: Val<bevy::math::Mat3A>, i: usize, j: usize) {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_mat3a_minor(
                m.into_inner(),
                i,
                j,
            )
            .into();
        output
    }
    fn from_scale_angle(scale: Val<bevy::math::Vec2>, angle: f32) {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_scale_angle(
                scale.into_inner(),
                angle,
            )
            .into();
        output
    }
    fn inverse(_self: Ref<bevy::math::Mat2>) {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::inverse(&_self).into();
        output
    }
    fn is_finite(_self: Ref<bevy::math::Mat2>) {
        let output: bool = bevy::math::Mat2::is_finite(&_self).into();
        output
    }
    fn is_nan(_self: Ref<bevy::math::Mat2>) {
        let output: bool = bevy::math::Mat2::is_nan(&_self).into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat2>, rhs: Val<bevy::math::Mat2>) {
        let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as std::ops::Mul<
            bevy::math::Mat2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = <bevy::math::Mat2 as std::ops::Mul<
            bevy::math::Vec2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat2>, rhs: f32) {
        let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as std::ops::Mul<
            f32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn mul_mat2(_self: Ref<bevy::math::Mat2>, rhs: Ref<bevy::math::Mat2>) {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::mul_mat2(&_self, &rhs)
            .into();
        output
    }
    fn mul_scalar(_self: Ref<bevy::math::Mat2>, rhs: f32) {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::mul_scalar(&_self, rhs)
            .into();
        output
    }
    fn mul_vec2(_self: Ref<bevy::math::Mat2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Mat2::mul_vec2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::Mat2>) {
        let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn row(_self: Ref<bevy::math::Mat2>, index: usize) {
        let output: Val<bevy::math::Vec2> = bevy::math::Mat2::row(&_self, index).into();
        output
    }
    fn sub(_self: Val<bevy::math::Mat2>, rhs: Val<bevy::math::Mat2>) {
        let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as std::ops::Sub<
            bevy::math::Mat2,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub_mat2(_self: Ref<bevy::math::Mat2>, rhs: Ref<bevy::math::Mat2>) {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::sub_mat2(&_self, &rhs)
            .into();
        output
    }
    fn to_cols_array(_self: Ref<bevy::math::Mat2>) {
        let output: [f32; 4] = bevy::math::Mat2::to_cols_array(&_self).into();
        output
    }
    fn to_cols_array_2d(_self: Ref<bevy::math::Mat2>) {
        let output: [[f32; 2]; 2] = bevy::math::Mat2::to_cols_array_2d(&_self).into();
        output
    }
    fn transpose(_self: Ref<bevy::math::Mat2>) {
        let output: Val<bevy::math::Mat2> = bevy::math::Mat2::transpose(&_self).into();
        output
    }
}
#[script_bindings(remote, name = "mat_3")]
impl bevy::math::Mat3 {
    fn abs(_self: Ref<bevy::math::Mat3>) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::abs(&_self).into();
        output
    }
    fn abs_diff_eq(
        _self: Ref<bevy::math::Mat3>,
        rhs: Val<bevy::math::Mat3>,
        max_abs_diff: f32,
    ) {
        let output: bool = bevy::math::Mat3::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Mat3>, rhs: Val<bevy::math::Mat3>) {
        let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Add<
            bevy::math::Mat3,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add_mat3(_self: Ref<bevy::math::Mat3>, rhs: Ref<bevy::math::Mat3>) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::add_mat3(&_self, &rhs)
            .into();
        output
    }
    fn as_dmat3(_self: Ref<bevy::math::Mat3>) {
        let output: Val<bevy::math::DMat3> = bevy::math::Mat3::as_dmat3(&_self).into();
        output
    }
    fn clone(_self: Ref<bevy::math::Mat3>) {
        let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn col(_self: Ref<bevy::math::Mat3>, index: usize) {
        let output: Val<bevy::math::Vec3> = bevy::math::Mat3::col(&_self, index).into();
        output
    }
    fn determinant(_self: Ref<bevy::math::Mat3>) {
        let output: f32 = bevy::math::Mat3::determinant(&_self).into();
        output
    }
    fn div(_self: Val<bevy::math::Mat3>, rhs: f32) {
        let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Div<
            f32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_scalar(_self: Ref<bevy::math::Mat3>, rhs: f32) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::div_scalar(&_self, rhs)
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::Mat3>, rhs: Ref<bevy::math::Mat3>) {
        let output: bool = <bevy::math::Mat3 as std::cmp::PartialEq<
            bevy::math::Mat3,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    fn from_angle(angle: f32) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_angle(angle).into();
        output
    }
    fn from_axis_angle(axis: Val<bevy::math::Vec3>, angle: f32) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_axis_angle(
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    fn from_cols(
        x_axis: Val<bevy::math::Vec3>,
        y_axis: Val<bevy::math::Vec3>,
        z_axis: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
                z_axis.into_inner(),
            )
            .into();
        output
    }
    fn from_diagonal(diagonal: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_diagonal(
                diagonal.into_inner(),
            )
            .into();
        output
    }
    fn from_euler(order: Val<bevy::math::EulerRot>, a: f32, b: f32, c: f32) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_euler(
                order.into_inner(),
                a,
                b,
                c,
            )
            .into();
        output
    }
    fn from_mat2(m: Val<bevy::math::Mat2>) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_mat2(m.into_inner())
            .into();
        output
    }
    fn from_mat4(m: Val<bevy::math::Mat4>) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_mat4(m.into_inner())
            .into();
        output
    }
    fn from_mat4_minor(m: Val<bevy::math::Mat4>, i: usize, j: usize) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_mat4_minor(
                m.into_inner(),
                i,
                j,
            )
            .into();
        output
    }
    fn from_quat(rotation: Val<bevy::math::Quat>) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_quat(
                rotation.into_inner(),
            )
            .into();
        output
    }
    fn from_rotation_x(angle: f32) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_rotation_x(angle)
            .into();
        output
    }
    fn from_rotation_y(angle: f32) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_rotation_y(angle)
            .into();
        output
    }
    fn from_rotation_z(angle: f32) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_rotation_z(angle)
            .into();
        output
    }
    fn from_scale(scale: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    fn from_scale_angle_translation(
        scale: Val<bevy::math::Vec2>,
        angle: f32,
        translation: Val<bevy::math::Vec2>,
    ) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_scale_angle_translation(
                scale.into_inner(),
                angle,
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_translation(translation: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    fn inverse(_self: Ref<bevy::math::Mat3>) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::inverse(&_self).into();
        output
    }
    fn is_finite(_self: Ref<bevy::math::Mat3>) {
        let output: bool = bevy::math::Mat3::is_finite(&_self).into();
        output
    }
    fn is_nan(_self: Ref<bevy::math::Mat3>) {
        let output: bool = bevy::math::Mat3::is_nan(&_self).into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat3>, rhs: Val<bevy::math::Affine2>) {
        let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Mul<
            bevy::math::Affine2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat3>, rhs: Val<bevy::math::Mat3>) {
        let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Mul<
            bevy::math::Mat3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Mat3 as std::ops::Mul<
            bevy::math::Vec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat3>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Mat3 as std::ops::Mul<
            bevy::math::Vec3A,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat3>, rhs: f32) {
        let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Mul<
            f32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn mul_mat3(_self: Ref<bevy::math::Mat3>, rhs: Ref<bevy::math::Mat3>) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::mul_mat3(&_self, &rhs)
            .into();
        output
    }
    fn mul_scalar(_self: Ref<bevy::math::Mat3>, rhs: f32) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::mul_scalar(&_self, rhs)
            .into();
        output
    }
    fn mul_vec3(_self: Ref<bevy::math::Mat3>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Mat3::mul_vec3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn mul_vec3a(_self: Ref<bevy::math::Mat3>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Mat3::mul_vec3a(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::Mat3>) {
        let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn row(_self: Ref<bevy::math::Mat3>, index: usize) {
        let output: Val<bevy::math::Vec3> = bevy::math::Mat3::row(&_self, index).into();
        output
    }
    fn sub(_self: Val<bevy::math::Mat3>, rhs: Val<bevy::math::Mat3>) {
        let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as std::ops::Sub<
            bevy::math::Mat3,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub_mat3(_self: Ref<bevy::math::Mat3>, rhs: Ref<bevy::math::Mat3>) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::sub_mat3(&_self, &rhs)
            .into();
        output
    }
    fn to_cols_array(_self: Ref<bevy::math::Mat3>) {
        let output: [f32; 9] = bevy::math::Mat3::to_cols_array(&_self).into();
        output
    }
    fn to_cols_array_2d(_self: Ref<bevy::math::Mat3>) {
        let output: [[f32; 3]; 3] = bevy::math::Mat3::to_cols_array_2d(&_self).into();
        output
    }
    fn to_euler(_self: Ref<bevy::math::Mat3>, order: Val<bevy::math::EulerRot>) {
        let output: (f32, f32, f32) = bevy::math::Mat3::to_euler(
                &_self,
                order.into_inner(),
            )
            .into();
        output
    }
    fn transform_point2(_self: Ref<bevy::math::Mat3>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Mat3::transform_point2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn transform_vector2(_self: Ref<bevy::math::Mat3>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Mat3::transform_vector2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn transpose(_self: Ref<bevy::math::Mat3>) {
        let output: Val<bevy::math::Mat3> = bevy::math::Mat3::transpose(&_self).into();
        output
    }
}
#[script_bindings(remote, name = "mat_3_a")]
impl bevy::math::Mat3A {
    fn abs(_self: Ref<bevy::math::Mat3A>) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::abs(&_self).into();
        output
    }
    fn abs_diff_eq(
        _self: Ref<bevy::math::Mat3A>,
        rhs: Val<bevy::math::Mat3A>,
        max_abs_diff: f32,
    ) {
        let output: bool = bevy::math::Mat3A::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Mat3A>, rhs: Val<bevy::math::Mat3A>) {
        let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Add<
            bevy::math::Mat3A,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add_mat3(_self: Ref<bevy::math::Mat3A>, rhs: Ref<bevy::math::Mat3A>) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::add_mat3(&_self, &rhs)
            .into();
        output
    }
    fn as_dmat3(_self: Ref<bevy::math::Mat3A>) {
        let output: Val<bevy::math::DMat3> = bevy::math::Mat3A::as_dmat3(&_self).into();
        output
    }
    fn clone(_self: Ref<bevy::math::Mat3A>) {
        let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn col(_self: Ref<bevy::math::Mat3A>, index: usize) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Mat3A::col(&_self, index)
            .into();
        output
    }
    fn determinant(_self: Ref<bevy::math::Mat3A>) {
        let output: f32 = bevy::math::Mat3A::determinant(&_self).into();
        output
    }
    fn div(_self: Val<bevy::math::Mat3A>, rhs: f32) {
        let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Div<
            f32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_scalar(_self: Ref<bevy::math::Mat3A>, rhs: f32) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::div_scalar(&_self, rhs)
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::Mat3A>, rhs: Ref<bevy::math::Mat3A>) {
        let output: bool = <bevy::math::Mat3A as std::cmp::PartialEq<
            bevy::math::Mat3A,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    fn from_angle(angle: f32) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_angle(angle).into();
        output
    }
    fn from_axis_angle(axis: Val<bevy::math::Vec3>, angle: f32) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_axis_angle(
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    fn from_cols(
        x_axis: Val<bevy::math::Vec3A>,
        y_axis: Val<bevy::math::Vec3A>,
        z_axis: Val<bevy::math::Vec3A>,
    ) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
                z_axis.into_inner(),
            )
            .into();
        output
    }
    fn from_diagonal(diagonal: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_diagonal(
                diagonal.into_inner(),
            )
            .into();
        output
    }
    fn from_euler(order: Val<bevy::math::EulerRot>, a: f32, b: f32, c: f32) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_euler(
                order.into_inner(),
                a,
                b,
                c,
            )
            .into();
        output
    }
    fn from_mat2(m: Val<bevy::math::Mat2>) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_mat2(m.into_inner())
            .into();
        output
    }
    fn from_mat4(m: Val<bevy::math::Mat4>) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_mat4(m.into_inner())
            .into();
        output
    }
    fn from_mat4_minor(m: Val<bevy::math::Mat4>, i: usize, j: usize) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_mat4_minor(
                m.into_inner(),
                i,
                j,
            )
            .into();
        output
    }
    fn from_quat(rotation: Val<bevy::math::Quat>) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_quat(
                rotation.into_inner(),
            )
            .into();
        output
    }
    fn from_rotation_x(angle: f32) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_rotation_x(angle)
            .into();
        output
    }
    fn from_rotation_y(angle: f32) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_rotation_y(angle)
            .into();
        output
    }
    fn from_rotation_z(angle: f32) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_rotation_z(angle)
            .into();
        output
    }
    fn from_scale(scale: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    fn from_scale_angle_translation(
        scale: Val<bevy::math::Vec2>,
        angle: f32,
        translation: Val<bevy::math::Vec2>,
    ) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_scale_angle_translation(
                scale.into_inner(),
                angle,
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_translation(translation: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    fn inverse(_self: Ref<bevy::math::Mat3A>) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::inverse(&_self).into();
        output
    }
    fn is_finite(_self: Ref<bevy::math::Mat3A>) {
        let output: bool = bevy::math::Mat3A::is_finite(&_self).into();
        output
    }
    fn is_nan(_self: Ref<bevy::math::Mat3A>) {
        let output: bool = bevy::math::Mat3A::is_nan(&_self).into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat3A>, rhs: Val<bevy::math::Affine2>) {
        let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Mul<
            bevy::math::Affine2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat3A>, rhs: Val<bevy::math::Mat3A>) {
        let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Mul<
            bevy::math::Mat3A,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat3A>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = <bevy::math::Mat3A as std::ops::Mul<
            bevy::math::Vec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = <bevy::math::Mat3A as std::ops::Mul<
            bevy::math::Vec3A,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat3A>, rhs: f32) {
        let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Mul<
            f32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn mul_mat3(_self: Ref<bevy::math::Mat3A>, rhs: Ref<bevy::math::Mat3A>) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::mul_mat3(&_self, &rhs)
            .into();
        output
    }
    fn mul_scalar(_self: Ref<bevy::math::Mat3A>, rhs: f32) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::mul_scalar(&_self, rhs)
            .into();
        output
    }
    fn mul_vec3(_self: Ref<bevy::math::Mat3A>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Mat3A::mul_vec3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn mul_vec3a(_self: Ref<bevy::math::Mat3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Mat3A::mul_vec3a(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::Mat3A>) {
        let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn row(_self: Ref<bevy::math::Mat3A>, index: usize) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Mat3A::row(&_self, index)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::Mat3A>, rhs: Val<bevy::math::Mat3A>) {
        let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as std::ops::Sub<
            bevy::math::Mat3A,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub_mat3(_self: Ref<bevy::math::Mat3A>, rhs: Ref<bevy::math::Mat3A>) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::sub_mat3(&_self, &rhs)
            .into();
        output
    }
    fn to_cols_array(_self: Ref<bevy::math::Mat3A>) {
        let output: [f32; 9] = bevy::math::Mat3A::to_cols_array(&_self).into();
        output
    }
    fn to_cols_array_2d(_self: Ref<bevy::math::Mat3A>) {
        let output: [[f32; 3]; 3] = bevy::math::Mat3A::to_cols_array_2d(&_self).into();
        output
    }
    fn to_euler(_self: Ref<bevy::math::Mat3A>, order: Val<bevy::math::EulerRot>) {
        let output: (f32, f32, f32) = bevy::math::Mat3A::to_euler(
                &_self,
                order.into_inner(),
            )
            .into();
        output
    }
    fn transform_point2(_self: Ref<bevy::math::Mat3A>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Mat3A::transform_point2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn transform_vector2(_self: Ref<bevy::math::Mat3A>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Mat3A::transform_vector2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn transpose(_self: Ref<bevy::math::Mat3A>) {
        let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::transpose(&_self).into();
        output
    }
}
#[script_bindings(remote, name = "mat_4")]
impl bevy::math::Mat4 {
    fn abs(_self: Ref<bevy::math::Mat4>) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::abs(&_self).into();
        output
    }
    fn abs_diff_eq(
        _self: Ref<bevy::math::Mat4>,
        rhs: Val<bevy::math::Mat4>,
        max_abs_diff: f32,
    ) {
        let output: bool = bevy::math::Mat4::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::Mat4>, rhs: Val<bevy::math::Mat4>) {
        let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Add<
            bevy::math::Mat4,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add_mat4(_self: Ref<bevy::math::Mat4>, rhs: Ref<bevy::math::Mat4>) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::add_mat4(&_self, &rhs)
            .into();
        output
    }
    fn as_dmat4(_self: Ref<bevy::math::Mat4>) {
        let output: Val<bevy::math::DMat4> = bevy::math::Mat4::as_dmat4(&_self).into();
        output
    }
    fn clone(_self: Ref<bevy::math::Mat4>) {
        let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn col(_self: Ref<bevy::math::Mat4>, index: usize) {
        let output: Val<bevy::math::Vec4> = bevy::math::Mat4::col(&_self, index).into();
        output
    }
    fn determinant(_self: Ref<bevy::math::Mat4>) {
        let output: f32 = bevy::math::Mat4::determinant(&_self).into();
        output
    }
    fn div(_self: Val<bevy::math::Mat4>, rhs: f32) {
        let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Div<
            f32,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_scalar(_self: Ref<bevy::math::Mat4>, rhs: f32) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::div_scalar(&_self, rhs)
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::Mat4>, rhs: Ref<bevy::math::Mat4>) {
        let output: bool = <bevy::math::Mat4 as std::cmp::PartialEq<
            bevy::math::Mat4,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    fn from_axis_angle(axis: Val<bevy::math::Vec3>, angle: f32) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_axis_angle(
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    fn from_cols(
        x_axis: Val<bevy::math::Vec4>,
        y_axis: Val<bevy::math::Vec4>,
        z_axis: Val<bevy::math::Vec4>,
        w_axis: Val<bevy::math::Vec4>,
    ) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
                z_axis.into_inner(),
                w_axis.into_inner(),
            )
            .into();
        output
    }
    fn from_diagonal(diagonal: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_diagonal(
                diagonal.into_inner(),
            )
            .into();
        output
    }
    fn from_euler(order: Val<bevy::math::EulerRot>, a: f32, b: f32, c: f32) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_euler(
                order.into_inner(),
                a,
                b,
                c,
            )
            .into();
        output
    }
    fn from_mat3(m: Val<bevy::math::Mat3>) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_mat3(m.into_inner())
            .into();
        output
    }
    fn from_mat3a(m: Val<bevy::math::Mat3A>) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_mat3a(m.into_inner())
            .into();
        output
    }
    fn from_quat(rotation: Val<bevy::math::Quat>) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_quat(
                rotation.into_inner(),
            )
            .into();
        output
    }
    fn from_rotation_translation(
        rotation: Val<bevy::math::Quat>,
        translation: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_rotation_translation(
                rotation.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_rotation_x(angle: f32) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_rotation_x(angle)
            .into();
        output
    }
    fn from_rotation_y(angle: f32) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_rotation_y(angle)
            .into();
        output
    }
    fn from_rotation_z(angle: f32) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_rotation_z(angle)
            .into();
        output
    }
    fn from_scale(scale: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    fn from_scale_rotation_translation(
        scale: Val<bevy::math::Vec3>,
        rotation: Val<bevy::math::Quat>,
        translation: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_scale_rotation_translation(
                scale.into_inner(),
                rotation.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_translation(translation: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    fn inverse(_self: Ref<bevy::math::Mat4>) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::inverse(&_self).into();
        output
    }
    fn is_finite(_self: Ref<bevy::math::Mat4>) {
        let output: bool = bevy::math::Mat4::is_finite(&_self).into();
        output
    }
    fn is_nan(_self: Ref<bevy::math::Mat4>) {
        let output: bool = bevy::math::Mat4::is_nan(&_self).into();
        output
    }
    fn look_at_lh(
        eye: Val<bevy::math::Vec3>,
        center: Val<bevy::math::Vec3>,
        up: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::look_at_lh(
                eye.into_inner(),
                center.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn look_at_rh(
        eye: Val<bevy::math::Vec3>,
        center: Val<bevy::math::Vec3>,
        up: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::look_at_rh(
                eye.into_inner(),
                center.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn look_to_lh(
        eye: Val<bevy::math::Vec3>,
        dir: Val<bevy::math::Vec3>,
        up: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::look_to_lh(
                eye.into_inner(),
                dir.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn look_to_rh(
        eye: Val<bevy::math::Vec3>,
        dir: Val<bevy::math::Vec3>,
        up: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::look_to_rh(
                eye.into_inner(),
                dir.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat4>, rhs: Val<bevy::math::Affine3A>) {
        let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Mul<
            bevy::math::Affine3A,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat4>, rhs: Val<bevy::math::Mat4>) {
        let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Mul<
            bevy::math::Mat4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = <bevy::math::Mat4 as std::ops::Mul<
            bevy::math::Vec4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Mat4>, rhs: f32) {
        let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Mul<
            f32,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn mul_mat4(_self: Ref<bevy::math::Mat4>, rhs: Ref<bevy::math::Mat4>) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::mul_mat4(&_self, &rhs)
            .into();
        output
    }
    fn mul_scalar(_self: Ref<bevy::math::Mat4>, rhs: f32) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::mul_scalar(&_self, rhs)
            .into();
        output
    }
    fn mul_vec4(_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec4>) {
        let output: Val<bevy::math::Vec4> = bevy::math::Mat4::mul_vec4(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::Mat4>) {
        let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn orthographic_lh(
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
    ) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::orthographic_lh(
                left,
                right,
                bottom,
                top,
                near,
                far,
            )
            .into();
        output
    }
    fn orthographic_rh(
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
    ) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::orthographic_rh(
                left,
                right,
                bottom,
                top,
                near,
                far,
            )
            .into();
        output
    }
    fn orthographic_rh_gl(
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
    ) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::orthographic_rh_gl(
                left,
                right,
                bottom,
                top,
                near,
                far,
            )
            .into();
        output
    }
    fn perspective_infinite_lh(fov_y_radians: f32, aspect_ratio: f32, z_near: f32) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_infinite_lh(
                fov_y_radians,
                aspect_ratio,
                z_near,
            )
            .into();
        output
    }
    fn perspective_infinite_reverse_lh(
        fov_y_radians: f32,
        aspect_ratio: f32,
        z_near: f32,
    ) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_infinite_reverse_lh(
                fov_y_radians,
                aspect_ratio,
                z_near,
            )
            .into();
        output
    }
    fn perspective_infinite_reverse_rh(
        fov_y_radians: f32,
        aspect_ratio: f32,
        z_near: f32,
    ) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_infinite_reverse_rh(
                fov_y_radians,
                aspect_ratio,
                z_near,
            )
            .into();
        output
    }
    fn perspective_infinite_rh(fov_y_radians: f32, aspect_ratio: f32, z_near: f32) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_infinite_rh(
                fov_y_radians,
                aspect_ratio,
                z_near,
            )
            .into();
        output
    }
    fn perspective_lh(fov_y_radians: f32, aspect_ratio: f32, z_near: f32, z_far: f32) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_lh(
                fov_y_radians,
                aspect_ratio,
                z_near,
                z_far,
            )
            .into();
        output
    }
    fn perspective_rh(fov_y_radians: f32, aspect_ratio: f32, z_near: f32, z_far: f32) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_rh(
                fov_y_radians,
                aspect_ratio,
                z_near,
                z_far,
            )
            .into();
        output
    }
    fn perspective_rh_gl(
        fov_y_radians: f32,
        aspect_ratio: f32,
        z_near: f32,
        z_far: f32,
    ) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_rh_gl(
                fov_y_radians,
                aspect_ratio,
                z_near,
                z_far,
            )
            .into();
        output
    }
    fn project_point3(_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Mat4::project_point3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn project_point3a(_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Mat4::project_point3a(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn row(_self: Ref<bevy::math::Mat4>, index: usize) {
        let output: Val<bevy::math::Vec4> = bevy::math::Mat4::row(&_self, index).into();
        output
    }
    fn sub(_self: Val<bevy::math::Mat4>, rhs: Val<bevy::math::Mat4>) {
        let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as std::ops::Sub<
            bevy::math::Mat4,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub_mat4(_self: Ref<bevy::math::Mat4>, rhs: Ref<bevy::math::Mat4>) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::sub_mat4(&_self, &rhs)
            .into();
        output
    }
    fn to_cols_array(_self: Ref<bevy::math::Mat4>) {
        let output: [f32; 16] = bevy::math::Mat4::to_cols_array(&_self).into();
        output
    }
    fn to_cols_array_2d(_self: Ref<bevy::math::Mat4>) {
        let output: [[f32; 4]; 4] = bevy::math::Mat4::to_cols_array_2d(&_self).into();
        output
    }
    fn to_euler(_self: Ref<bevy::math::Mat4>, order: Val<bevy::math::EulerRot>) {
        let output: (f32, f32, f32) = bevy::math::Mat4::to_euler(
                &_self,
                order.into_inner(),
            )
            .into();
        output
    }
    fn transform_point3(_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Mat4::transform_point3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn transform_point3a(_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Mat4::transform_point3a(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn transform_vector3(_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Mat4::transform_vector3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn transform_vector3a(_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Mat4::transform_vector3a(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn transpose(_self: Ref<bevy::math::Mat4>) {
        let output: Val<bevy::math::Mat4> = bevy::math::Mat4::transpose(&_self).into();
        output
    }
}
#[script_bindings(remote, name = "d_mat_2")]
impl bevy::math::DMat2 {
    fn abs(_self: Ref<bevy::math::DMat2>) {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::abs(&_self).into();
        output
    }
    fn abs_diff_eq(
        _self: Ref<bevy::math::DMat2>,
        rhs: Val<bevy::math::DMat2>,
        max_abs_diff: f64,
    ) {
        let output: bool = bevy::math::DMat2::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::DMat2>, rhs: Val<bevy::math::DMat2>) {
        let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as std::ops::Add<
            bevy::math::DMat2,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add_mat2(_self: Ref<bevy::math::DMat2>, rhs: Ref<bevy::math::DMat2>) {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::add_mat2(&_self, &rhs)
            .into();
        output
    }
    fn as_mat2(_self: Ref<bevy::math::DMat2>) {
        let output: Val<bevy::math::Mat2> = bevy::math::DMat2::as_mat2(&_self).into();
        output
    }
    fn clone(_self: Ref<bevy::math::DMat2>) {
        let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn col(_self: Ref<bevy::math::DMat2>, index: usize) {
        let output: Val<bevy::math::DVec2> = bevy::math::DMat2::col(&_self, index)
            .into();
        output
    }
    fn determinant(_self: Ref<bevy::math::DMat2>) {
        let output: f64 = bevy::math::DMat2::determinant(&_self).into();
        output
    }
    fn div(_self: Val<bevy::math::DMat2>, rhs: f64) {
        let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as std::ops::Div<
            f64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_scalar(_self: Ref<bevy::math::DMat2>, rhs: f64) {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::div_scalar(&_self, rhs)
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::DMat2>, rhs: Ref<bevy::math::DMat2>) {
        let output: bool = <bevy::math::DMat2 as std::cmp::PartialEq<
            bevy::math::DMat2,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    fn from_angle(angle: f64) {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_angle(angle).into();
        output
    }
    fn from_cols(x_axis: Val<bevy::math::DVec2>, y_axis: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
            )
            .into();
        output
    }
    fn from_diagonal(diagonal: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_diagonal(
                diagonal.into_inner(),
            )
            .into();
        output
    }
    fn from_mat3(m: Val<bevy::math::DMat3>) {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_mat3(m.into_inner())
            .into();
        output
    }
    fn from_mat3_minor(m: Val<bevy::math::DMat3>, i: usize, j: usize) {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_mat3_minor(
                m.into_inner(),
                i,
                j,
            )
            .into();
        output
    }
    fn from_scale_angle(scale: Val<bevy::math::DVec2>, angle: f64) {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_scale_angle(
                scale.into_inner(),
                angle,
            )
            .into();
        output
    }
    fn inverse(_self: Ref<bevy::math::DMat2>) {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::inverse(&_self).into();
        output
    }
    fn is_finite(_self: Ref<bevy::math::DMat2>) {
        let output: bool = bevy::math::DMat2::is_finite(&_self).into();
        output
    }
    fn is_nan(_self: Ref<bevy::math::DMat2>) {
        let output: bool = bevy::math::DMat2::is_nan(&_self).into();
        output
    }
    fn mul(_self: Val<bevy::math::DMat2>, rhs: Val<bevy::math::DMat2>) {
        let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as std::ops::Mul<
            bevy::math::DMat2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DMat2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = <bevy::math::DMat2 as std::ops::Mul<
            bevy::math::DVec2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DMat2>, rhs: f64) {
        let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as std::ops::Mul<
            f64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn mul_mat2(_self: Ref<bevy::math::DMat2>, rhs: Ref<bevy::math::DMat2>) {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::mul_mat2(&_self, &rhs)
            .into();
        output
    }
    fn mul_scalar(_self: Ref<bevy::math::DMat2>, rhs: f64) {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::mul_scalar(&_self, rhs)
            .into();
        output
    }
    fn mul_vec2(_self: Ref<bevy::math::DMat2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DMat2::mul_vec2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::DMat2>) {
        let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn row(_self: Ref<bevy::math::DMat2>, index: usize) {
        let output: Val<bevy::math::DVec2> = bevy::math::DMat2::row(&_self, index)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::DMat2>, rhs: Val<bevy::math::DMat2>) {
        let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as std::ops::Sub<
            bevy::math::DMat2,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub_mat2(_self: Ref<bevy::math::DMat2>, rhs: Ref<bevy::math::DMat2>) {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::sub_mat2(&_self, &rhs)
            .into();
        output
    }
    fn to_cols_array(_self: Ref<bevy::math::DMat2>) {
        let output: [f64; 4] = bevy::math::DMat2::to_cols_array(&_self).into();
        output
    }
    fn to_cols_array_2d(_self: Ref<bevy::math::DMat2>) {
        let output: [[f64; 2]; 2] = bevy::math::DMat2::to_cols_array_2d(&_self).into();
        output
    }
    fn transpose(_self: Ref<bevy::math::DMat2>) {
        let output: Val<bevy::math::DMat2> = bevy::math::DMat2::transpose(&_self).into();
        output
    }
}
#[script_bindings(remote, name = "d_mat_3")]
impl bevy::math::DMat3 {
    fn abs(_self: Ref<bevy::math::DMat3>) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::abs(&_self).into();
        output
    }
    fn abs_diff_eq(
        _self: Ref<bevy::math::DMat3>,
        rhs: Val<bevy::math::DMat3>,
        max_abs_diff: f64,
    ) {
        let output: bool = bevy::math::DMat3::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::DMat3>, rhs: Val<bevy::math::DMat3>) {
        let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Add<
            bevy::math::DMat3,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add_mat3(_self: Ref<bevy::math::DMat3>, rhs: Ref<bevy::math::DMat3>) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::add_mat3(&_self, &rhs)
            .into();
        output
    }
    fn as_mat3(_self: Ref<bevy::math::DMat3>) {
        let output: Val<bevy::math::Mat3> = bevy::math::DMat3::as_mat3(&_self).into();
        output
    }
    fn clone(_self: Ref<bevy::math::DMat3>) {
        let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn col(_self: Ref<bevy::math::DMat3>, index: usize) {
        let output: Val<bevy::math::DVec3> = bevy::math::DMat3::col(&_self, index)
            .into();
        output
    }
    fn determinant(_self: Ref<bevy::math::DMat3>) {
        let output: f64 = bevy::math::DMat3::determinant(&_self).into();
        output
    }
    fn div(_self: Val<bevy::math::DMat3>, rhs: f64) {
        let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Div<
            f64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_scalar(_self: Ref<bevy::math::DMat3>, rhs: f64) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::div_scalar(&_self, rhs)
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::DMat3>, rhs: Ref<bevy::math::DMat3>) {
        let output: bool = <bevy::math::DMat3 as std::cmp::PartialEq<
            bevy::math::DMat3,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    fn from_angle(angle: f64) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_angle(angle).into();
        output
    }
    fn from_axis_angle(axis: Val<bevy::math::DVec3>, angle: f64) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_axis_angle(
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    fn from_cols(
        x_axis: Val<bevy::math::DVec3>,
        y_axis: Val<bevy::math::DVec3>,
        z_axis: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
                z_axis.into_inner(),
            )
            .into();
        output
    }
    fn from_diagonal(diagonal: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_diagonal(
                diagonal.into_inner(),
            )
            .into();
        output
    }
    fn from_euler(order: Val<bevy::math::EulerRot>, a: f64, b: f64, c: f64) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_euler(
                order.into_inner(),
                a,
                b,
                c,
            )
            .into();
        output
    }
    fn from_mat2(m: Val<bevy::math::DMat2>) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_mat2(m.into_inner())
            .into();
        output
    }
    fn from_mat4(m: Val<bevy::math::DMat4>) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_mat4(m.into_inner())
            .into();
        output
    }
    fn from_mat4_minor(m: Val<bevy::math::DMat4>, i: usize, j: usize) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_mat4_minor(
                m.into_inner(),
                i,
                j,
            )
            .into();
        output
    }
    fn from_quat(rotation: Val<bevy::math::DQuat>) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_quat(
                rotation.into_inner(),
            )
            .into();
        output
    }
    fn from_rotation_x(angle: f64) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_rotation_x(angle)
            .into();
        output
    }
    fn from_rotation_y(angle: f64) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_rotation_y(angle)
            .into();
        output
    }
    fn from_rotation_z(angle: f64) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_rotation_z(angle)
            .into();
        output
    }
    fn from_scale(scale: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    fn from_scale_angle_translation(
        scale: Val<bevy::math::DVec2>,
        angle: f64,
        translation: Val<bevy::math::DVec2>,
    ) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_scale_angle_translation(
                scale.into_inner(),
                angle,
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_translation(translation: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    fn inverse(_self: Ref<bevy::math::DMat3>) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::inverse(&_self).into();
        output
    }
    fn is_finite(_self: Ref<bevy::math::DMat3>) {
        let output: bool = bevy::math::DMat3::is_finite(&_self).into();
        output
    }
    fn is_nan(_self: Ref<bevy::math::DMat3>) {
        let output: bool = bevy::math::DMat3::is_nan(&_self).into();
        output
    }
    fn mul(_self: Val<bevy::math::DMat3>, rhs: Val<bevy::math::DAffine2>) {
        let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Mul<
            bevy::math::DAffine2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DMat3>, rhs: Val<bevy::math::DMat3>) {
        let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Mul<
            bevy::math::DMat3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DMat3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DMat3 as std::ops::Mul<
            bevy::math::DVec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DMat3>, rhs: f64) {
        let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Mul<
            f64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn mul_mat3(_self: Ref<bevy::math::DMat3>, rhs: Ref<bevy::math::DMat3>) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::mul_mat3(&_self, &rhs)
            .into();
        output
    }
    fn mul_scalar(_self: Ref<bevy::math::DMat3>, rhs: f64) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::mul_scalar(&_self, rhs)
            .into();
        output
    }
    fn mul_vec3(_self: Ref<bevy::math::DMat3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DMat3::mul_vec3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::DMat3>) {
        let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn row(_self: Ref<bevy::math::DMat3>, index: usize) {
        let output: Val<bevy::math::DVec3> = bevy::math::DMat3::row(&_self, index)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::DMat3>, rhs: Val<bevy::math::DMat3>) {
        let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as std::ops::Sub<
            bevy::math::DMat3,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub_mat3(_self: Ref<bevy::math::DMat3>, rhs: Ref<bevy::math::DMat3>) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::sub_mat3(&_self, &rhs)
            .into();
        output
    }
    fn to_cols_array(_self: Ref<bevy::math::DMat3>) {
        let output: [f64; 9] = bevy::math::DMat3::to_cols_array(&_self).into();
        output
    }
    fn to_cols_array_2d(_self: Ref<bevy::math::DMat3>) {
        let output: [[f64; 3]; 3] = bevy::math::DMat3::to_cols_array_2d(&_self).into();
        output
    }
    fn to_euler(_self: Ref<bevy::math::DMat3>, order: Val<bevy::math::EulerRot>) {
        let output: (f64, f64, f64) = bevy::math::DMat3::to_euler(
                &_self,
                order.into_inner(),
            )
            .into();
        output
    }
    fn transform_point2(_self: Ref<bevy::math::DMat3>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DMat3::transform_point2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn transform_vector2(_self: Ref<bevy::math::DMat3>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DMat3::transform_vector2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn transpose(_self: Ref<bevy::math::DMat3>) {
        let output: Val<bevy::math::DMat3> = bevy::math::DMat3::transpose(&_self).into();
        output
    }
}
#[script_bindings(remote, name = "d_mat_4")]
impl bevy::math::DMat4 {
    fn abs(_self: Ref<bevy::math::DMat4>) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::abs(&_self).into();
        output
    }
    fn abs_diff_eq(
        _self: Ref<bevy::math::DMat4>,
        rhs: Val<bevy::math::DMat4>,
        max_abs_diff: f64,
    ) {
        let output: bool = bevy::math::DMat4::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::DMat4>, rhs: Val<bevy::math::DMat4>) {
        let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Add<
            bevy::math::DMat4,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn add_mat4(_self: Ref<bevy::math::DMat4>, rhs: Ref<bevy::math::DMat4>) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::add_mat4(&_self, &rhs)
            .into();
        output
    }
    fn as_mat4(_self: Ref<bevy::math::DMat4>) {
        let output: Val<bevy::math::Mat4> = bevy::math::DMat4::as_mat4(&_self).into();
        output
    }
    fn clone(_self: Ref<bevy::math::DMat4>) {
        let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn col(_self: Ref<bevy::math::DMat4>, index: usize) {
        let output: Val<bevy::math::DVec4> = bevy::math::DMat4::col(&_self, index)
            .into();
        output
    }
    fn determinant(_self: Ref<bevy::math::DMat4>) {
        let output: f64 = bevy::math::DMat4::determinant(&_self).into();
        output
    }
    fn div(_self: Val<bevy::math::DMat4>, rhs: f64) {
        let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Div<
            f64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn div_scalar(_self: Ref<bevy::math::DMat4>, rhs: f64) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::div_scalar(&_self, rhs)
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::DMat4>, rhs: Ref<bevy::math::DMat4>) {
        let output: bool = <bevy::math::DMat4 as std::cmp::PartialEq<
            bevy::math::DMat4,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    fn from_axis_angle(axis: Val<bevy::math::DVec3>, angle: f64) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_axis_angle(
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    fn from_cols(
        x_axis: Val<bevy::math::DVec4>,
        y_axis: Val<bevy::math::DVec4>,
        z_axis: Val<bevy::math::DVec4>,
        w_axis: Val<bevy::math::DVec4>,
    ) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
                z_axis.into_inner(),
                w_axis.into_inner(),
            )
            .into();
        output
    }
    fn from_diagonal(diagonal: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_diagonal(
                diagonal.into_inner(),
            )
            .into();
        output
    }
    fn from_euler(order: Val<bevy::math::EulerRot>, a: f64, b: f64, c: f64) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_euler(
                order.into_inner(),
                a,
                b,
                c,
            )
            .into();
        output
    }
    fn from_mat3(m: Val<bevy::math::DMat3>) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_mat3(m.into_inner())
            .into();
        output
    }
    fn from_quat(rotation: Val<bevy::math::DQuat>) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_quat(
                rotation.into_inner(),
            )
            .into();
        output
    }
    fn from_rotation_translation(
        rotation: Val<bevy::math::DQuat>,
        translation: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_rotation_translation(
                rotation.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_rotation_x(angle: f64) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_rotation_x(angle)
            .into();
        output
    }
    fn from_rotation_y(angle: f64) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_rotation_y(angle)
            .into();
        output
    }
    fn from_rotation_z(angle: f64) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_rotation_z(angle)
            .into();
        output
    }
    fn from_scale(scale: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    fn from_scale_rotation_translation(
        scale: Val<bevy::math::DVec3>,
        rotation: Val<bevy::math::DQuat>,
        translation: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_scale_rotation_translation(
                scale.into_inner(),
                rotation.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_translation(translation: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    fn inverse(_self: Ref<bevy::math::DMat4>) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::inverse(&_self).into();
        output
    }
    fn is_finite(_self: Ref<bevy::math::DMat4>) {
        let output: bool = bevy::math::DMat4::is_finite(&_self).into();
        output
    }
    fn is_nan(_self: Ref<bevy::math::DMat4>) {
        let output: bool = bevy::math::DMat4::is_nan(&_self).into();
        output
    }
    fn look_at_lh(
        eye: Val<bevy::math::DVec3>,
        center: Val<bevy::math::DVec3>,
        up: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::look_at_lh(
                eye.into_inner(),
                center.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn look_at_rh(
        eye: Val<bevy::math::DVec3>,
        center: Val<bevy::math::DVec3>,
        up: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::look_at_rh(
                eye.into_inner(),
                center.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn look_to_lh(
        eye: Val<bevy::math::DVec3>,
        dir: Val<bevy::math::DVec3>,
        up: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::look_to_lh(
                eye.into_inner(),
                dir.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn look_to_rh(
        eye: Val<bevy::math::DVec3>,
        dir: Val<bevy::math::DVec3>,
        up: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::look_to_rh(
                eye.into_inner(),
                dir.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DMat4>, rhs: Val<bevy::math::DAffine3>) {
        let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Mul<
            bevy::math::DAffine3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DMat4>, rhs: Val<bevy::math::DMat4>) {
        let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Mul<
            bevy::math::DMat4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DMat4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = <bevy::math::DMat4 as std::ops::Mul<
            bevy::math::DVec4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DMat4>, rhs: f64) {
        let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Mul<
            f64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn mul_mat4(_self: Ref<bevy::math::DMat4>, rhs: Ref<bevy::math::DMat4>) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::mul_mat4(&_self, &rhs)
            .into();
        output
    }
    fn mul_scalar(_self: Ref<bevy::math::DMat4>, rhs: f64) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::mul_scalar(&_self, rhs)
            .into();
        output
    }
    fn mul_vec4(_self: Ref<bevy::math::DMat4>, rhs: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DVec4> = bevy::math::DMat4::mul_vec4(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::DMat4>) {
        let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn orthographic_lh(
        left: f64,
        right: f64,
        bottom: f64,
        top: f64,
        near: f64,
        far: f64,
    ) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::orthographic_lh(
                left,
                right,
                bottom,
                top,
                near,
                far,
            )
            .into();
        output
    }
    fn orthographic_rh(
        left: f64,
        right: f64,
        bottom: f64,
        top: f64,
        near: f64,
        far: f64,
    ) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::orthographic_rh(
                left,
                right,
                bottom,
                top,
                near,
                far,
            )
            .into();
        output
    }
    fn orthographic_rh_gl(
        left: f64,
        right: f64,
        bottom: f64,
        top: f64,
        near: f64,
        far: f64,
    ) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::orthographic_rh_gl(
                left,
                right,
                bottom,
                top,
                near,
                far,
            )
            .into();
        output
    }
    fn perspective_infinite_lh(fov_y_radians: f64, aspect_ratio: f64, z_near: f64) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_infinite_lh(
                fov_y_radians,
                aspect_ratio,
                z_near,
            )
            .into();
        output
    }
    fn perspective_infinite_reverse_lh(
        fov_y_radians: f64,
        aspect_ratio: f64,
        z_near: f64,
    ) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_infinite_reverse_lh(
                fov_y_radians,
                aspect_ratio,
                z_near,
            )
            .into();
        output
    }
    fn perspective_infinite_reverse_rh(
        fov_y_radians: f64,
        aspect_ratio: f64,
        z_near: f64,
    ) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_infinite_reverse_rh(
                fov_y_radians,
                aspect_ratio,
                z_near,
            )
            .into();
        output
    }
    fn perspective_infinite_rh(fov_y_radians: f64, aspect_ratio: f64, z_near: f64) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_infinite_rh(
                fov_y_radians,
                aspect_ratio,
                z_near,
            )
            .into();
        output
    }
    fn perspective_lh(fov_y_radians: f64, aspect_ratio: f64, z_near: f64, z_far: f64) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_lh(
                fov_y_radians,
                aspect_ratio,
                z_near,
                z_far,
            )
            .into();
        output
    }
    fn perspective_rh(fov_y_radians: f64, aspect_ratio: f64, z_near: f64, z_far: f64) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_rh(
                fov_y_radians,
                aspect_ratio,
                z_near,
                z_far,
            )
            .into();
        output
    }
    fn perspective_rh_gl(
        fov_y_radians: f64,
        aspect_ratio: f64,
        z_near: f64,
        z_far: f64,
    ) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_rh_gl(
                fov_y_radians,
                aspect_ratio,
                z_near,
                z_far,
            )
            .into();
        output
    }
    fn project_point3(_self: Ref<bevy::math::DMat4>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DMat4::project_point3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn row(_self: Ref<bevy::math::DMat4>, index: usize) {
        let output: Val<bevy::math::DVec4> = bevy::math::DMat4::row(&_self, index)
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::DMat4>, rhs: Val<bevy::math::DMat4>) {
        let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as std::ops::Sub<
            bevy::math::DMat4,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn sub_mat4(_self: Ref<bevy::math::DMat4>, rhs: Ref<bevy::math::DMat4>) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::sub_mat4(&_self, &rhs)
            .into();
        output
    }
    fn to_cols_array(_self: Ref<bevy::math::DMat4>) {
        let output: [f64; 16] = bevy::math::DMat4::to_cols_array(&_self).into();
        output
    }
    fn to_cols_array_2d(_self: Ref<bevy::math::DMat4>) {
        let output: [[f64; 4]; 4] = bevy::math::DMat4::to_cols_array_2d(&_self).into();
        output
    }
    fn to_euler(_self: Ref<bevy::math::DMat4>, order: Val<bevy::math::EulerRot>) {
        let output: (f64, f64, f64) = bevy::math::DMat4::to_euler(
                &_self,
                order.into_inner(),
            )
            .into();
        output
    }
    fn transform_point3(_self: Ref<bevy::math::DMat4>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DMat4::transform_point3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn transform_vector3(_self: Ref<bevy::math::DMat4>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DMat4::transform_vector3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn transpose(_self: Ref<bevy::math::DMat4>) {
        let output: Val<bevy::math::DMat4> = bevy::math::DMat4::transpose(&_self).into();
        output
    }
}
#[script_bindings(remote, name = "affine_2")]
impl bevy::math::Affine2 {
    fn abs_diff_eq(
        _self: Ref<bevy::math::Affine2>,
        rhs: Val<bevy::math::Affine2>,
        max_abs_diff: f32,
    ) {
        let output: bool = bevy::math::Affine2::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::Affine2>) {
        let output: Val<bevy::math::Affine2> = <bevy::math::Affine2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::Affine2>, rhs: Ref<bevy::math::Affine2>) {
        let output: bool = <bevy::math::Affine2 as std::cmp::PartialEq<
            bevy::math::Affine2,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    fn from_angle(angle: f32) {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_angle(angle)
            .into();
        output
    }
    fn from_angle_translation(angle: f32, translation: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_angle_translation(
                angle,
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_cols(
        x_axis: Val<bevy::math::Vec2>,
        y_axis: Val<bevy::math::Vec2>,
        z_axis: Val<bevy::math::Vec2>,
    ) {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
                z_axis.into_inner(),
            )
            .into();
        output
    }
    fn from_mat2(matrix2: Val<bevy::math::Mat2>) {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_mat2(
                matrix2.into_inner(),
            )
            .into();
        output
    }
    fn from_mat2_translation(
        matrix2: Val<bevy::math::Mat2>,
        translation: Val<bevy::math::Vec2>,
    ) {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_mat2_translation(
                matrix2.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_mat3(m: Val<bevy::math::Mat3>) {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_mat3(
                m.into_inner(),
            )
            .into();
        output
    }
    fn from_mat3a(m: Val<bevy::math::Mat3A>) {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_mat3a(
                m.into_inner(),
            )
            .into();
        output
    }
    fn from_scale(scale: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    fn from_scale_angle_translation(
        scale: Val<bevy::math::Vec2>,
        angle: f32,
        translation: Val<bevy::math::Vec2>,
    ) {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_scale_angle_translation(
                scale.into_inner(),
                angle,
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_translation(translation: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    fn inverse(_self: Ref<bevy::math::Affine2>) {
        let output: Val<bevy::math::Affine2> = bevy::math::Affine2::inverse(&_self)
            .into();
        output
    }
    fn is_finite(_self: Ref<bevy::math::Affine2>) {
        let output: bool = bevy::math::Affine2::is_finite(&_self).into();
        output
    }
    fn is_nan(_self: Ref<bevy::math::Affine2>) {
        let output: bool = bevy::math::Affine2::is_nan(&_self).into();
        output
    }
    fn mul(_self: Val<bevy::math::Affine2>, rhs: Val<bevy::math::Affine2>) {
        let output: Val<bevy::math::Affine2> = <bevy::math::Affine2 as std::ops::Mul<
            bevy::math::Affine2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Affine2>, rhs: Val<bevy::math::Mat3>) {
        let output: Val<bevy::math::Mat3> = <bevy::math::Affine2 as std::ops::Mul<
            bevy::math::Mat3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Affine2>, rhs: Val<bevy::math::Mat3A>) {
        let output: Val<bevy::math::Mat3A> = <bevy::math::Affine2 as std::ops::Mul<
            bevy::math::Mat3A,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn to_cols_array(_self: Ref<bevy::math::Affine2>) {
        let output: [f32; 6] = bevy::math::Affine2::to_cols_array(&_self).into();
        output
    }
    fn to_cols_array_2d(_self: Ref<bevy::math::Affine2>) {
        let output: [[f32; 2]; 3] = bevy::math::Affine2::to_cols_array_2d(&_self).into();
        output
    }
    fn transform_point2(_self: Ref<bevy::math::Affine2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Affine2::transform_point2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn transform_vector2(_self: Ref<bevy::math::Affine2>, rhs: Val<bevy::math::Vec2>) {
        let output: Val<bevy::math::Vec2> = bevy::math::Affine2::transform_vector2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "affine_3_a")]
impl bevy::math::Affine3A {
    fn abs_diff_eq(
        _self: Ref<bevy::math::Affine3A>,
        rhs: Val<bevy::math::Affine3A>,
        max_abs_diff: f32,
    ) {
        let output: bool = bevy::math::Affine3A::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::Affine3A>) {
        let output: Val<bevy::math::Affine3A> = <bevy::math::Affine3A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::Affine3A>, rhs: Ref<bevy::math::Affine3A>) {
        let output: bool = <bevy::math::Affine3A as std::cmp::PartialEq<
            bevy::math::Affine3A,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    fn from_axis_angle(axis: Val<bevy::math::Vec3>, angle: f32) {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_axis_angle(
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    fn from_cols(
        x_axis: Val<bevy::math::Vec3A>,
        y_axis: Val<bevy::math::Vec3A>,
        z_axis: Val<bevy::math::Vec3A>,
        w_axis: Val<bevy::math::Vec3A>,
    ) {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
                z_axis.into_inner(),
                w_axis.into_inner(),
            )
            .into();
        output
    }
    fn from_mat3(mat3: Val<bevy::math::Mat3>) {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_mat3(
                mat3.into_inner(),
            )
            .into();
        output
    }
    fn from_mat3_translation(
        mat3: Val<bevy::math::Mat3>,
        translation: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_mat3_translation(
                mat3.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_mat4(m: Val<bevy::math::Mat4>) {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_mat4(
                m.into_inner(),
            )
            .into();
        output
    }
    fn from_quat(rotation: Val<bevy::math::Quat>) {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_quat(
                rotation.into_inner(),
            )
            .into();
        output
    }
    fn from_rotation_translation(
        rotation: Val<bevy::math::Quat>,
        translation: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_rotation_translation(
                rotation.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_rotation_x(angle: f32) {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_rotation_x(
                angle,
            )
            .into();
        output
    }
    fn from_rotation_y(angle: f32) {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_rotation_y(
                angle,
            )
            .into();
        output
    }
    fn from_rotation_z(angle: f32) {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_rotation_z(
                angle,
            )
            .into();
        output
    }
    fn from_scale(scale: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    fn from_scale_rotation_translation(
        scale: Val<bevy::math::Vec3>,
        rotation: Val<bevy::math::Quat>,
        translation: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_scale_rotation_translation(
                scale.into_inner(),
                rotation.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_translation(translation: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    fn inverse(_self: Ref<bevy::math::Affine3A>) {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::inverse(&_self)
            .into();
        output
    }
    fn is_finite(_self: Ref<bevy::math::Affine3A>) {
        let output: bool = bevy::math::Affine3A::is_finite(&_self).into();
        output
    }
    fn is_nan(_self: Ref<bevy::math::Affine3A>) {
        let output: bool = bevy::math::Affine3A::is_nan(&_self).into();
        output
    }
    fn look_at_lh(
        eye: Val<bevy::math::Vec3>,
        center: Val<bevy::math::Vec3>,
        up: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::look_at_lh(
                eye.into_inner(),
                center.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn look_at_rh(
        eye: Val<bevy::math::Vec3>,
        center: Val<bevy::math::Vec3>,
        up: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::look_at_rh(
                eye.into_inner(),
                center.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn look_to_lh(
        eye: Val<bevy::math::Vec3>,
        dir: Val<bevy::math::Vec3>,
        up: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::look_to_lh(
                eye.into_inner(),
                dir.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn look_to_rh(
        eye: Val<bevy::math::Vec3>,
        dir: Val<bevy::math::Vec3>,
        up: Val<bevy::math::Vec3>,
    ) {
        let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::look_to_rh(
                eye.into_inner(),
                dir.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Affine3A>, rhs: Val<bevy::math::Affine3A>) {
        let output: Val<bevy::math::Affine3A> = <bevy::math::Affine3A as std::ops::Mul<
            bevy::math::Affine3A,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::Affine3A>, rhs: Val<bevy::math::Mat4>) {
        let output: Val<bevy::math::Mat4> = <bevy::math::Affine3A as std::ops::Mul<
            bevy::math::Mat4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn to_cols_array(_self: Ref<bevy::math::Affine3A>) {
        let output: [f32; 12] = bevy::math::Affine3A::to_cols_array(&_self).into();
        output
    }
    fn to_cols_array_2d(_self: Ref<bevy::math::Affine3A>) {
        let output: [[f32; 3]; 4] = bevy::math::Affine3A::to_cols_array_2d(&_self)
            .into();
        output
    }
    fn transform_point3(_self: Ref<bevy::math::Affine3A>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Affine3A::transform_point3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn transform_point3a(_self: Ref<bevy::math::Affine3A>, rhs: Val<bevy::math::Vec3A>) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Affine3A::transform_point3a(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn transform_vector3(_self: Ref<bevy::math::Affine3A>, rhs: Val<bevy::math::Vec3>) {
        let output: Val<bevy::math::Vec3> = bevy::math::Affine3A::transform_vector3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn transform_vector3a(
        _self: Ref<bevy::math::Affine3A>,
        rhs: Val<bevy::math::Vec3A>,
    ) {
        let output: Val<bevy::math::Vec3A> = bevy::math::Affine3A::transform_vector3a(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "d_affine_2")]
impl bevy::math::DAffine2 {
    fn abs_diff_eq(
        _self: Ref<bevy::math::DAffine2>,
        rhs: Val<bevy::math::DAffine2>,
        max_abs_diff: f64,
    ) {
        let output: bool = bevy::math::DAffine2::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::DAffine2>) {
        let output: Val<bevy::math::DAffine2> = <bevy::math::DAffine2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::DAffine2>, rhs: Ref<bevy::math::DAffine2>) {
        let output: bool = <bevy::math::DAffine2 as std::cmp::PartialEq<
            bevy::math::DAffine2,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    fn from_angle(angle: f64) {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_angle(angle)
            .into();
        output
    }
    fn from_angle_translation(angle: f64, translation: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_angle_translation(
                angle,
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_cols(
        x_axis: Val<bevy::math::DVec2>,
        y_axis: Val<bevy::math::DVec2>,
        z_axis: Val<bevy::math::DVec2>,
    ) {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
                z_axis.into_inner(),
            )
            .into();
        output
    }
    fn from_mat2(matrix2: Val<bevy::math::DMat2>) {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_mat2(
                matrix2.into_inner(),
            )
            .into();
        output
    }
    fn from_mat2_translation(
        matrix2: Val<bevy::math::DMat2>,
        translation: Val<bevy::math::DVec2>,
    ) {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_mat2_translation(
                matrix2.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_mat3(m: Val<bevy::math::DMat3>) {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_mat3(
                m.into_inner(),
            )
            .into();
        output
    }
    fn from_scale(scale: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    fn from_scale_angle_translation(
        scale: Val<bevy::math::DVec2>,
        angle: f64,
        translation: Val<bevy::math::DVec2>,
    ) {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_scale_angle_translation(
                scale.into_inner(),
                angle,
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_translation(translation: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    fn inverse(_self: Ref<bevy::math::DAffine2>) {
        let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::inverse(&_self)
            .into();
        output
    }
    fn is_finite(_self: Ref<bevy::math::DAffine2>) {
        let output: bool = bevy::math::DAffine2::is_finite(&_self).into();
        output
    }
    fn is_nan(_self: Ref<bevy::math::DAffine2>) {
        let output: bool = bevy::math::DAffine2::is_nan(&_self).into();
        output
    }
    fn mul(_self: Val<bevy::math::DAffine2>, rhs: Val<bevy::math::DAffine2>) {
        let output: Val<bevy::math::DAffine2> = <bevy::math::DAffine2 as std::ops::Mul<
            bevy::math::DAffine2,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DAffine2>, rhs: Val<bevy::math::DMat3>) {
        let output: Val<bevy::math::DMat3> = <bevy::math::DAffine2 as std::ops::Mul<
            bevy::math::DMat3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn to_cols_array(_self: Ref<bevy::math::DAffine2>) {
        let output: [f64; 6] = bevy::math::DAffine2::to_cols_array(&_self).into();
        output
    }
    fn to_cols_array_2d(_self: Ref<bevy::math::DAffine2>) {
        let output: [[f64; 2]; 3] = bevy::math::DAffine2::to_cols_array_2d(&_self)
            .into();
        output
    }
    fn transform_point2(_self: Ref<bevy::math::DAffine2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DAffine2::transform_point2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn transform_vector2(_self: Ref<bevy::math::DAffine2>, rhs: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DVec2> = bevy::math::DAffine2::transform_vector2(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "d_affine_3")]
impl bevy::math::DAffine3 {
    fn abs_diff_eq(
        _self: Ref<bevy::math::DAffine3>,
        rhs: Val<bevy::math::DAffine3>,
        max_abs_diff: f64,
    ) {
        let output: bool = bevy::math::DAffine3::abs_diff_eq(
                &_self,
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::DAffine3>) {
        let output: Val<bevy::math::DAffine3> = <bevy::math::DAffine3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::DAffine3>, rhs: Ref<bevy::math::DAffine3>) {
        let output: bool = <bevy::math::DAffine3 as std::cmp::PartialEq<
            bevy::math::DAffine3,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    fn from_axis_angle(axis: Val<bevy::math::DVec3>, angle: f64) {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_axis_angle(
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    fn from_cols(
        x_axis: Val<bevy::math::DVec3>,
        y_axis: Val<bevy::math::DVec3>,
        z_axis: Val<bevy::math::DVec3>,
        w_axis: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_cols(
                x_axis.into_inner(),
                y_axis.into_inner(),
                z_axis.into_inner(),
                w_axis.into_inner(),
            )
            .into();
        output
    }
    fn from_mat3(mat3: Val<bevy::math::DMat3>) {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_mat3(
                mat3.into_inner(),
            )
            .into();
        output
    }
    fn from_mat3_translation(
        mat3: Val<bevy::math::DMat3>,
        translation: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_mat3_translation(
                mat3.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_mat4(m: Val<bevy::math::DMat4>) {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_mat4(
                m.into_inner(),
            )
            .into();
        output
    }
    fn from_quat(rotation: Val<bevy::math::DQuat>) {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_quat(
                rotation.into_inner(),
            )
            .into();
        output
    }
    fn from_rotation_translation(
        rotation: Val<bevy::math::DQuat>,
        translation: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_rotation_translation(
                rotation.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_rotation_x(angle: f64) {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_rotation_x(
                angle,
            )
            .into();
        output
    }
    fn from_rotation_y(angle: f64) {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_rotation_y(
                angle,
            )
            .into();
        output
    }
    fn from_rotation_z(angle: f64) {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_rotation_z(
                angle,
            )
            .into();
        output
    }
    fn from_scale(scale: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_scale(
                scale.into_inner(),
            )
            .into();
        output
    }
    fn from_scale_rotation_translation(
        scale: Val<bevy::math::DVec3>,
        rotation: Val<bevy::math::DQuat>,
        translation: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_scale_rotation_translation(
                scale.into_inner(),
                rotation.into_inner(),
                translation.into_inner(),
            )
            .into();
        output
    }
    fn from_translation(translation: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_translation(
                translation.into_inner(),
            )
            .into();
        output
    }
    fn inverse(_self: Ref<bevy::math::DAffine3>) {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::inverse(&_self)
            .into();
        output
    }
    fn is_finite(_self: Ref<bevy::math::DAffine3>) {
        let output: bool = bevy::math::DAffine3::is_finite(&_self).into();
        output
    }
    fn is_nan(_self: Ref<bevy::math::DAffine3>) {
        let output: bool = bevy::math::DAffine3::is_nan(&_self).into();
        output
    }
    fn look_at_lh(
        eye: Val<bevy::math::DVec3>,
        center: Val<bevy::math::DVec3>,
        up: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::look_at_lh(
                eye.into_inner(),
                center.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn look_at_rh(
        eye: Val<bevy::math::DVec3>,
        center: Val<bevy::math::DVec3>,
        up: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::look_at_rh(
                eye.into_inner(),
                center.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn look_to_lh(
        eye: Val<bevy::math::DVec3>,
        dir: Val<bevy::math::DVec3>,
        up: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::look_to_lh(
                eye.into_inner(),
                dir.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn look_to_rh(
        eye: Val<bevy::math::DVec3>,
        dir: Val<bevy::math::DVec3>,
        up: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::look_to_rh(
                eye.into_inner(),
                dir.into_inner(),
                up.into_inner(),
            )
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DAffine3>, rhs: Val<bevy::math::DAffine3>) {
        let output: Val<bevy::math::DAffine3> = <bevy::math::DAffine3 as std::ops::Mul<
            bevy::math::DAffine3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DAffine3>, rhs: Val<bevy::math::DMat4>) {
        let output: Val<bevy::math::DMat4> = <bevy::math::DAffine3 as std::ops::Mul<
            bevy::math::DMat4,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn to_cols_array(_self: Ref<bevy::math::DAffine3>) {
        let output: [f64; 12] = bevy::math::DAffine3::to_cols_array(&_self).into();
        output
    }
    fn to_cols_array_2d(_self: Ref<bevy::math::DAffine3>) {
        let output: [[f64; 3]; 4] = bevy::math::DAffine3::to_cols_array_2d(&_self)
            .into();
        output
    }
    fn transform_point3(_self: Ref<bevy::math::DAffine3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DAffine3::transform_point3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn transform_vector3(_self: Ref<bevy::math::DAffine3>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DAffine3::transform_vector3(
                &_self,
                rhs.into_inner(),
            )
            .into();
        output
    }
}
#[script_bindings(remote, name = "d_quat")]
impl bevy::math::DQuat {
    fn abs_diff_eq(
        _self: Val<bevy::math::DQuat>,
        rhs: Val<bevy::math::DQuat>,
        max_abs_diff: f64,
    ) {
        let output: bool = bevy::math::DQuat::abs_diff_eq(
                _self.into_inner(),
                rhs.into_inner(),
                max_abs_diff,
            )
            .into();
        output
    }
    fn add(_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>) {
        let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as std::ops::Add<
            bevy::math::DQuat,
        >>::add(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn angle_between(_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>) {
        let output: f64 = bevy::math::DQuat::angle_between(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn as_quat(_self: Val<bevy::math::DQuat>) {
        let output: Val<bevy::math::Quat> = bevy::math::DQuat::as_quat(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::DQuat>) {
        let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn conjugate(_self: Val<bevy::math::DQuat>) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::conjugate(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn div(_self: Val<bevy::math::DQuat>, rhs: f64) {
        let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as std::ops::Div<
            f64,
        >>::div(_self.into_inner(), rhs)
            .into();
        output
    }
    fn dot(_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>) {
        let output: f64 = bevy::math::DQuat::dot(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::DQuat>, rhs: Ref<bevy::math::DQuat>) {
        let output: bool = <bevy::math::DQuat as std::cmp::PartialEq<
            bevy::math::DQuat,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    fn from_affine3(a: Ref<bevy::math::DAffine3>) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_affine3(&a).into();
        output
    }
    fn from_array(a: [f64; 4]) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_array(a).into();
        output
    }
    fn from_axis_angle(axis: Val<bevy::math::DVec3>, angle: f64) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_axis_angle(
                axis.into_inner(),
                angle,
            )
            .into();
        output
    }
    fn from_euler(euler: Val<bevy::math::EulerRot>, a: f64, b: f64, c: f64) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_euler(
                euler.into_inner(),
                a,
                b,
                c,
            )
            .into();
        output
    }
    fn from_mat3(mat: Ref<bevy::math::DMat3>) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_mat3(&mat).into();
        output
    }
    fn from_mat4(mat: Ref<bevy::math::DMat4>) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_mat4(&mat).into();
        output
    }
    fn from_rotation_arc(from: Val<bevy::math::DVec3>, to: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_arc(
                from.into_inner(),
                to.into_inner(),
            )
            .into();
        output
    }
    fn from_rotation_arc_2d(from: Val<bevy::math::DVec2>, to: Val<bevy::math::DVec2>) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_arc_2d(
                from.into_inner(),
                to.into_inner(),
            )
            .into();
        output
    }
    fn from_rotation_arc_colinear(
        from: Val<bevy::math::DVec3>,
        to: Val<bevy::math::DVec3>,
    ) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_arc_colinear(
                from.into_inner(),
                to.into_inner(),
            )
            .into();
        output
    }
    fn from_rotation_x(angle: f64) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_x(angle)
            .into();
        output
    }
    fn from_rotation_y(angle: f64) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_y(angle)
            .into();
        output
    }
    fn from_rotation_z(angle: f64) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_z(angle)
            .into();
        output
    }
    fn from_scaled_axis(v: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_scaled_axis(
                v.into_inner(),
            )
            .into();
        output
    }
    fn from_vec4(v: Val<bevy::math::DVec4>) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_vec4(v.into_inner())
            .into();
        output
    }
    fn from_xyzw(x: f64, y: f64, z: f64, w: f64) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_xyzw(x, y, z, w)
            .into();
        output
    }
    fn inverse(_self: Val<bevy::math::DQuat>) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::inverse(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn is_finite(_self: Val<bevy::math::DQuat>) {
        let output: bool = bevy::math::DQuat::is_finite(_self.into_inner()).into();
        output
    }
    fn is_nan(_self: Val<bevy::math::DQuat>) {
        let output: bool = bevy::math::DQuat::is_nan(_self.into_inner()).into();
        output
    }
    fn is_near_identity(_self: Val<bevy::math::DQuat>) {
        let output: bool = bevy::math::DQuat::is_near_identity(_self.into_inner())
            .into();
        output
    }
    fn is_normalized(_self: Val<bevy::math::DQuat>) {
        let output: bool = bevy::math::DQuat::is_normalized(_self.into_inner()).into();
        output
    }
    fn length(_self: Val<bevy::math::DQuat>) {
        let output: f64 = bevy::math::DQuat::length(_self.into_inner()).into();
        output
    }
    fn length_recip(_self: Val<bevy::math::DQuat>) {
        let output: f64 = bevy::math::DQuat::length_recip(_self.into_inner()).into();
        output
    }
    fn length_squared(_self: Val<bevy::math::DQuat>) {
        let output: f64 = bevy::math::DQuat::length_squared(_self.into_inner()).into();
        output
    }
    fn lerp(_self: Val<bevy::math::DQuat>, end: Val<bevy::math::DQuat>, s: f64) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::lerp(
                _self.into_inner(),
                end.into_inner(),
                s,
            )
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>) {
        let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as std::ops::Mul<
            bevy::math::DQuat,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = <bevy::math::DQuat as std::ops::Mul<
            bevy::math::DVec3,
        >>::mul(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn mul(_self: Val<bevy::math::DQuat>, rhs: f64) {
        let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as std::ops::Mul<
            f64,
        >>::mul(_self.into_inner(), rhs)
            .into();
        output
    }
    fn mul_quat(_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::mul_quat(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn mul_vec3(_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DVec3>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DQuat::mul_vec3(
                _self.into_inner(),
                rhs.into_inner(),
            )
            .into();
        output
    }
    fn neg(_self: Val<bevy::math::DQuat>) {
        let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as std::ops::Neg>::neg(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn normalize(_self: Val<bevy::math::DQuat>) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::normalize(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn rotate_towards(
        _self: Ref<bevy::math::DQuat>,
        rhs: Val<bevy::math::DQuat>,
        max_angle: f64,
    ) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::rotate_towards(
                &_self,
                rhs.into_inner(),
                max_angle,
            )
            .into();
        output
    }
    fn slerp(_self: Val<bevy::math::DQuat>, end: Val<bevy::math::DQuat>, s: f64) {
        let output: Val<bevy::math::DQuat> = bevy::math::DQuat::slerp(
                _self.into_inner(),
                end.into_inner(),
                s,
            )
            .into();
        output
    }
    fn sub(_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>) {
        let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as std::ops::Sub<
            bevy::math::DQuat,
        >>::sub(_self.into_inner(), rhs.into_inner())
            .into();
        output
    }
    fn to_array(_self: Ref<bevy::math::DQuat>) {
        let output: [f64; 4] = bevy::math::DQuat::to_array(&_self).into();
        output
    }
    fn to_euler(_self: Val<bevy::math::DQuat>, order: Val<bevy::math::EulerRot>) {
        let output: (f64, f64, f64) = bevy::math::DQuat::to_euler(
                _self.into_inner(),
                order.into_inner(),
            )
            .into();
        output
    }
    fn to_scaled_axis(_self: Val<bevy::math::DQuat>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DQuat::to_scaled_axis(
                _self.into_inner(),
            )
            .into();
        output
    }
    fn xyz(_self: Val<bevy::math::DQuat>) {
        let output: Val<bevy::math::DVec3> = bevy::math::DQuat::xyz(_self.into_inner())
            .into();
        output
    }
}
#[script_bindings(remote, name = "euler_rot")]
impl bevy::math::EulerRot {
    fn assert_receiver_is_total_eq(_self: Ref<bevy::math::EulerRot>) {
        let output: () = <bevy::math::EulerRot as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(_self: Ref<bevy::math::EulerRot>) {
        let output: Val<bevy::math::EulerRot> = <bevy::math::EulerRot as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::EulerRot>, other: Ref<bevy::math::EulerRot>) {
        let output: bool = <bevy::math::EulerRot as std::cmp::PartialEq<
            bevy::math::EulerRot,
        >>::eq(&_self, &other)
            .into();
        output
    }
}
#[script_bindings(remote, name = "b_vec_3_a")]
impl bevy::math::BVec3A {
    fn all(_self: Val<bevy::math::BVec3A>) {
        let output: bool = bevy::math::BVec3A::all(_self.into_inner()).into();
        output
    }
    fn any(_self: Val<bevy::math::BVec3A>) {
        let output: bool = bevy::math::BVec3A::any(_self.into_inner()).into();
        output
    }
    fn bitmask(_self: Val<bevy::math::BVec3A>) {
        let output: u32 = bevy::math::BVec3A::bitmask(_self.into_inner()).into();
        output
    }
    fn clone(_self: Ref<bevy::math::BVec3A>) {
        let output: Val<bevy::math::BVec3A> = <bevy::math::BVec3A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::BVec3A>, rhs: Ref<bevy::math::BVec3A>) {
        let output: bool = <bevy::math::BVec3A as std::cmp::PartialEq<
            bevy::math::BVec3A,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    fn from_array(a: [bool; 3]) {
        let output: Val<bevy::math::BVec3A> = bevy::math::BVec3A::from_array(a).into();
        output
    }
    fn new(x: bool, y: bool, z: bool) {
        let output: Val<bevy::math::BVec3A> = bevy::math::BVec3A::new(x, y, z).into();
        output
    }
    fn set(mut _self: Mut<bevy::math::BVec3A>, index: usize, value: bool) {
        let output: () = bevy::math::BVec3A::set(&mut _self, index, value).into();
        output
    }
    fn splat(v: bool) {
        let output: Val<bevy::math::BVec3A> = bevy::math::BVec3A::splat(v).into();
        output
    }
    fn test(_self: Ref<bevy::math::BVec3A>, index: usize) {
        let output: bool = bevy::math::BVec3A::test(&_self, index).into();
        output
    }
}
#[script_bindings(remote, name = "b_vec_4_a")]
impl bevy::math::BVec4A {
    fn all(_self: Val<bevy::math::BVec4A>) {
        let output: bool = bevy::math::BVec4A::all(_self.into_inner()).into();
        output
    }
    fn any(_self: Val<bevy::math::BVec4A>) {
        let output: bool = bevy::math::BVec4A::any(_self.into_inner()).into();
        output
    }
    fn bitmask(_self: Val<bevy::math::BVec4A>) {
        let output: u32 = bevy::math::BVec4A::bitmask(_self.into_inner()).into();
        output
    }
    fn clone(_self: Ref<bevy::math::BVec4A>) {
        let output: Val<bevy::math::BVec4A> = <bevy::math::BVec4A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<bevy::math::BVec4A>, rhs: Ref<bevy::math::BVec4A>) {
        let output: bool = <bevy::math::BVec4A as std::cmp::PartialEq<
            bevy::math::BVec4A,
        >>::eq(&_self, &rhs)
            .into();
        output
    }
    fn from_array(a: [bool; 4]) {
        let output: Val<bevy::math::BVec4A> = bevy::math::BVec4A::from_array(a).into();
        output
    }
    fn new(x: bool, y: bool, z: bool, w: bool) {
        let output: Val<bevy::math::BVec4A> = bevy::math::BVec4A::new(x, y, z, w).into();
        output
    }
    fn set(mut _self: Mut<bevy::math::BVec4A>, index: usize, value: bool) {
        let output: () = bevy::math::BVec4A::set(&mut _self, index, value).into();
        output
    }
    fn splat(v: bool) {
        let output: Val<bevy::math::BVec4A> = bevy::math::BVec4A::splat(v).into();
        output
    }
    fn test(_self: Ref<bevy::math::BVec4A>, index: usize) {
        let output: bool = bevy::math::BVec4A::test(&_self, index).into();
        output
    }
}
#[script_bindings(remote, name = "smol_str")]
impl smol_str::SmolStr {
    fn clone(_self: Ref<smol_str::SmolStr>) {
        let output: Val<smol_str::SmolStr> = <smol_str::SmolStr as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn eq(_self: Ref<smol_str::SmolStr>, other: Ref<smol_str::SmolStr>) {
        let output: bool = <smol_str::SmolStr as std::cmp::PartialEq<
            smol_str::SmolStr,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn is_empty(_self: Ref<smol_str::SmolStr>) {
        let output: bool = smol_str::SmolStr::is_empty(&_self).into();
        output
    }
    fn is_heap_allocated(_self: Ref<smol_str::SmolStr>) {
        let output: bool = smol_str::SmolStr::is_heap_allocated(&_self).into();
        output
    }
    fn len(_self: Ref<smol_str::SmolStr>) {
        let output: usize = smol_str::SmolStr::len(&_self).into();
        output
    }
    fn to_string(_self: Ref<smol_str::SmolStr>) {
        let output: std::string::String = smol_str::SmolStr::to_string(&_self).into();
        output
    }
}
#[script_bindings(remote, name = "uuid")]
impl uuid::Uuid {
    fn as_u128(_self: Ref<uuid::Uuid>) {
        let output: u128 = uuid::Uuid::as_u128(&_self).into();
        output
    }
    fn as_u64_pair(_self: Ref<uuid::Uuid>) {
        let output: (u64, u64) = uuid::Uuid::as_u64_pair(&_self).into();
        output
    }
    fn assert_receiver_is_total_eq(_self: Ref<uuid::Uuid>) {
        let output: () = <uuid::Uuid as std::cmp::Eq>::assert_receiver_is_total_eq(
                &_self,
            )
            .into();
        output
    }
    fn clone(_self: Ref<uuid::Uuid>) {
        let output: Val<uuid::Uuid> = <uuid::Uuid as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                &_self,
            )
            .into();
        output
    }
    fn encode_buffer() {
        let output: [u8; 45] = uuid::Uuid::encode_buffer().into();
        output
    }
    fn eq(_self: Ref<uuid::Uuid>, other: Ref<uuid::Uuid>) {
        let output: bool = <uuid::Uuid as std::cmp::PartialEq<
            uuid::Uuid,
        >>::eq(&_self, &other)
            .into();
        output
    }
    fn from_bytes(bytes: [u8; 16]) {
        let output: Val<uuid::Uuid> = uuid::Uuid::from_bytes(bytes).into();
        output
    }
    fn from_bytes_le(b: [u8; 16]) {
        let output: Val<uuid::Uuid> = uuid::Uuid::from_bytes_le(b).into();
        output
    }
    fn from_u128(v: u128) {
        let output: Val<uuid::Uuid> = uuid::Uuid::from_u128(v).into();
        output
    }
    fn from_u128_le(v: u128) {
        let output: Val<uuid::Uuid> = uuid::Uuid::from_u128_le(v).into();
        output
    }
    fn from_u64_pair(high_bits: u64, low_bits: u64) {
        let output: Val<uuid::Uuid> = uuid::Uuid::from_u64_pair(high_bits, low_bits)
            .into();
        output
    }
    fn get_node_id(_self: Ref<uuid::Uuid>) {
        let output: bevy::reflect::erased_serde::__private::serde::__private::Option<
            [u8; 6],
        > = uuid::Uuid::get_node_id(&_self).into();
        output
    }
    fn get_version_num(_self: Ref<uuid::Uuid>) {
        let output: usize = uuid::Uuid::get_version_num(&_self).into();
        output
    }
    fn into_bytes(_self: Val<uuid::Uuid>) {
        let output: [u8; 16] = uuid::Uuid::into_bytes(_self.into_inner()).into();
        output
    }
    fn is_max(_self: Ref<uuid::Uuid>) {
        let output: bool = uuid::Uuid::is_max(&_self).into();
        output
    }
    fn is_nil(_self: Ref<uuid::Uuid>) {
        let output: bool = uuid::Uuid::is_nil(&_self).into();
        output
    }
    fn max() {
        let output: Val<uuid::Uuid> = uuid::Uuid::max().into();
        output
    }
    fn new_v4() {
        let output: Val<uuid::Uuid> = uuid::Uuid::new_v4().into();
        output
    }
    fn nil() {
        let output: Val<uuid::Uuid> = uuid::Uuid::nil().into();
        output
    }
    fn to_bytes_le(_self: Ref<uuid::Uuid>) {
        let output: [u8; 16] = uuid::Uuid::to_bytes_le(&_self).into();
        output
    }
    fn to_u128_le(_self: Ref<uuid::Uuid>) {
        let output: u128 = uuid::Uuid::to_u128_le(&_self).into();
        output
    }
}
impl ::bevy::app::Plugin for BevyReflectScriptingPlugin {
    fn build(&self, app: &mut ::bevy::prelude::App) {
        let mut world = app.world_mut();
        register_atomic_bool(&mut world);
        register_atomic_i_16(&mut world);
        register_atomic_i_32(&mut world);
        register_atomic_i_64(&mut world);
        register_atomic_i_8(&mut world);
        register_atomic_isize(&mut world);
        register_atomic_u_16(&mut world);
        register_atomic_u_32(&mut world);
        register_atomic_u_64(&mut world);
        register_atomic_u_8(&mut world);
        register_atomic_usize(&mut world);
        register_duration(&mut world);
        register_instant(&mut world);
        register_range_full(&mut world);
        register_quat(&mut world);
        register_vec_3(&mut world);
        register_i_vec_2(&mut world);
        register_i_vec_3(&mut world);
        register_i_vec_4(&mut world);
        register_i_64_vec_2(&mut world);
        register_i_64_vec_3(&mut world);
        register_i_64_vec_4(&mut world);
        register_u_vec_2(&mut world);
        register_u_vec_3(&mut world);
        register_u_vec_4(&mut world);
        register_u_64_vec_2(&mut world);
        register_u_64_vec_3(&mut world);
        register_u_64_vec_4(&mut world);
        register_vec_2(&mut world);
        register_vec_3_a(&mut world);
        register_vec_4(&mut world);
        register_b_vec_2(&mut world);
        register_b_vec_3(&mut world);
        register_b_vec_4(&mut world);
        register_d_vec_2(&mut world);
        register_d_vec_3(&mut world);
        register_d_vec_4(&mut world);
        register_mat_2(&mut world);
        register_mat_3(&mut world);
        register_mat_3_a(&mut world);
        register_mat_4(&mut world);
        register_d_mat_2(&mut world);
        register_d_mat_3(&mut world);
        register_d_mat_4(&mut world);
        register_affine_2(&mut world);
        register_affine_3_a(&mut world);
        register_d_affine_2(&mut world);
        register_d_affine_3(&mut world);
        register_d_quat(&mut world);
        register_euler_rot(&mut world);
        register_b_vec_3_a(&mut world);
        register_b_vec_4_a(&mut world);
        register_smol_str(&mut world);
        register_uuid(&mut world);
    }
}
