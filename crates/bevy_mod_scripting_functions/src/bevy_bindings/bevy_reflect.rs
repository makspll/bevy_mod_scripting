    #![allow(clippy::all)]
    #![allow(unused, deprecated, dead_code)]
    use bevy_mod_scripting_core::bindings::{
        ReflectReference,
        function::{
            from::{Ref, Mut, Val},
            namespace::NamespaceBuilder,
        },
    };
    use bevy_mod_scripting_derive::script_bindings;
    use crate::*;
    pub struct BevyReflectScriptingPlugin;
    pub(crate) fn register_atomic_bool_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            ::core::sync::atomic::AtomicBool,
        >::new(world)
            .register_documented(
                "into_inner",
                |_self: Val<::core::sync::atomic::AtomicBool>| {
                    let output: bool = {
                        {
                            let output: bool = ::core::sync::atomic::AtomicBool::into_inner(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Consumes the atomic and returns the contained value.\n This is safe because passing `self` by value guarantees that no other threads are\n concurrently accessing the atomic data.\n # Examples\n ```\n use std::sync::atomic::AtomicBool;\n let some_bool = AtomicBool::new(true);\n assert_eq!(some_bool.into_inner(), true);\n ```",
                &["_self"],
            )
            .register_documented(
                "new",
                |v: bool| {
                    let output: Val<::core::sync::atomic::AtomicBool> = {
                        {
                            let output: Val<::core::sync::atomic::AtomicBool> = ::core::sync::atomic::AtomicBool::new(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new `AtomicBool`.\n # Examples\n ```\n use std::sync::atomic::AtomicBool;\n let atomic_true = AtomicBool::new(true);\n let atomic_false = AtomicBool::new(false);\n ```",
                &["v"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                ::core::sync::atomic::AtomicBool,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_atomic_i_16_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            ::core::sync::atomic::AtomicI16,
        >::new(world)
            .register_documented(
                "into_inner",
                |_self: Val<::core::sync::atomic::AtomicI16>| {
                    let output: i16 = {
                        {
                            let output: i16 = ::core::sync::atomic::AtomicI16::into_inner(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Consumes the atomic and returns the contained value.\n This is safe because passing `self` by value guarantees that no other threads are\n concurrently accessing the atomic data.\n # Examples\n ```\nuse std::sync::atomic::AtomicI16;\nlet some_var = AtomicI16::new(5);\n assert_eq!(some_var.into_inner(), 5);\n ```",
                &["_self"],
            )
            .register_documented(
                "new",
                |v: i16| {
                    let output: Val<::core::sync::atomic::AtomicI16> = {
                        {
                            let output: Val<::core::sync::atomic::AtomicI16> = ::core::sync::atomic::AtomicI16::new(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new atomic integer.\n # Examples\n ```\nuse std::sync::atomic::AtomicI16;\nlet atomic_forty_two = AtomicI16::new(42);\n ```",
                &["v"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                ::core::sync::atomic::AtomicI16,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_atomic_i_32_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            ::core::sync::atomic::AtomicI32,
        >::new(world)
            .register_documented(
                "into_inner",
                |_self: Val<::core::sync::atomic::AtomicI32>| {
                    let output: i32 = {
                        {
                            let output: i32 = ::core::sync::atomic::AtomicI32::into_inner(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Consumes the atomic and returns the contained value.\n This is safe because passing `self` by value guarantees that no other threads are\n concurrently accessing the atomic data.\n # Examples\n ```\nuse std::sync::atomic::AtomicI32;\nlet some_var = AtomicI32::new(5);\n assert_eq!(some_var.into_inner(), 5);\n ```",
                &["_self"],
            )
            .register_documented(
                "new",
                |v: i32| {
                    let output: Val<::core::sync::atomic::AtomicI32> = {
                        {
                            let output: Val<::core::sync::atomic::AtomicI32> = ::core::sync::atomic::AtomicI32::new(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new atomic integer.\n # Examples\n ```\nuse std::sync::atomic::AtomicI32;\nlet atomic_forty_two = AtomicI32::new(42);\n ```",
                &["v"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                ::core::sync::atomic::AtomicI32,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_atomic_i_64_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            ::core::sync::atomic::AtomicI64,
        >::new(world)
            .register_documented(
                "into_inner",
                |_self: Val<::core::sync::atomic::AtomicI64>| {
                    let output: i64 = {
                        {
                            let output: i64 = ::core::sync::atomic::AtomicI64::into_inner(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Consumes the atomic and returns the contained value.\n This is safe because passing `self` by value guarantees that no other threads are\n concurrently accessing the atomic data.\n # Examples\n ```\nuse std::sync::atomic::AtomicI64;\nlet some_var = AtomicI64::new(5);\n assert_eq!(some_var.into_inner(), 5);\n ```",
                &["_self"],
            )
            .register_documented(
                "new",
                |v: i64| {
                    let output: Val<::core::sync::atomic::AtomicI64> = {
                        {
                            let output: Val<::core::sync::atomic::AtomicI64> = ::core::sync::atomic::AtomicI64::new(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new atomic integer.\n # Examples\n ```\nuse std::sync::atomic::AtomicI64;\nlet atomic_forty_two = AtomicI64::new(42);\n ```",
                &["v"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                ::core::sync::atomic::AtomicI64,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_atomic_i_8_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            ::core::sync::atomic::AtomicI8,
        >::new(world)
            .register_documented(
                "into_inner",
                |_self: Val<::core::sync::atomic::AtomicI8>| {
                    let output: i8 = {
                        {
                            let output: i8 = ::core::sync::atomic::AtomicI8::into_inner(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Consumes the atomic and returns the contained value.\n This is safe because passing `self` by value guarantees that no other threads are\n concurrently accessing the atomic data.\n # Examples\n ```\nuse std::sync::atomic::AtomicI8;\nlet some_var = AtomicI8::new(5);\n assert_eq!(some_var.into_inner(), 5);\n ```",
                &["_self"],
            )
            .register_documented(
                "new",
                |v: i8| {
                    let output: Val<::core::sync::atomic::AtomicI8> = {
                        {
                            let output: Val<::core::sync::atomic::AtomicI8> = ::core::sync::atomic::AtomicI8::new(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new atomic integer.\n # Examples\n ```\nuse std::sync::atomic::AtomicI8;\nlet atomic_forty_two = AtomicI8::new(42);\n ```",
                &["v"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                ::core::sync::atomic::AtomicI8,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_atomic_isize_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            ::core::sync::atomic::AtomicIsize,
        >::new(world)
            .register_documented(
                "into_inner",
                |_self: Val<::core::sync::atomic::AtomicIsize>| {
                    let output: isize = {
                        {
                            let output: isize = ::core::sync::atomic::AtomicIsize::into_inner(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Consumes the atomic and returns the contained value.\n This is safe because passing `self` by value guarantees that no other threads are\n concurrently accessing the atomic data.\n # Examples\n ```\nuse std::sync::atomic::AtomicIsize;\nlet some_var = AtomicIsize::new(5);\n assert_eq!(some_var.into_inner(), 5);\n ```",
                &["_self"],
            )
            .register_documented(
                "new",
                |v: isize| {
                    let output: Val<::core::sync::atomic::AtomicIsize> = {
                        {
                            let output: Val<::core::sync::atomic::AtomicIsize> = ::core::sync::atomic::AtomicIsize::new(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new atomic integer.\n # Examples\n ```\nuse std::sync::atomic::AtomicIsize;\nlet atomic_forty_two = AtomicIsize::new(42);\n ```",
                &["v"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                ::core::sync::atomic::AtomicIsize,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_atomic_u_16_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            ::core::sync::atomic::AtomicU16,
        >::new(world)
            .register_documented(
                "into_inner",
                |_self: Val<::core::sync::atomic::AtomicU16>| {
                    let output: u16 = {
                        {
                            let output: u16 = ::core::sync::atomic::AtomicU16::into_inner(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Consumes the atomic and returns the contained value.\n This is safe because passing `self` by value guarantees that no other threads are\n concurrently accessing the atomic data.\n # Examples\n ```\nuse std::sync::atomic::AtomicU16;\nlet some_var = AtomicU16::new(5);\n assert_eq!(some_var.into_inner(), 5);\n ```",
                &["_self"],
            )
            .register_documented(
                "new",
                |v: u16| {
                    let output: Val<::core::sync::atomic::AtomicU16> = {
                        {
                            let output: Val<::core::sync::atomic::AtomicU16> = ::core::sync::atomic::AtomicU16::new(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new atomic integer.\n # Examples\n ```\nuse std::sync::atomic::AtomicU16;\nlet atomic_forty_two = AtomicU16::new(42);\n ```",
                &["v"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                ::core::sync::atomic::AtomicU16,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_atomic_u_32_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            ::core::sync::atomic::AtomicU32,
        >::new(world)
            .register_documented(
                "into_inner",
                |_self: Val<::core::sync::atomic::AtomicU32>| {
                    let output: u32 = {
                        {
                            let output: u32 = ::core::sync::atomic::AtomicU32::into_inner(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Consumes the atomic and returns the contained value.\n This is safe because passing `self` by value guarantees that no other threads are\n concurrently accessing the atomic data.\n # Examples\n ```\nuse std::sync::atomic::AtomicU32;\nlet some_var = AtomicU32::new(5);\n assert_eq!(some_var.into_inner(), 5);\n ```",
                &["_self"],
            )
            .register_documented(
                "new",
                |v: u32| {
                    let output: Val<::core::sync::atomic::AtomicU32> = {
                        {
                            let output: Val<::core::sync::atomic::AtomicU32> = ::core::sync::atomic::AtomicU32::new(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new atomic integer.\n # Examples\n ```\nuse std::sync::atomic::AtomicU32;\nlet atomic_forty_two = AtomicU32::new(42);\n ```",
                &["v"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                ::core::sync::atomic::AtomicU32,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_atomic_u_64_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            ::core::sync::atomic::AtomicU64,
        >::new(world)
            .register_documented(
                "into_inner",
                |_self: Val<::core::sync::atomic::AtomicU64>| {
                    let output: u64 = {
                        {
                            let output: u64 = ::core::sync::atomic::AtomicU64::into_inner(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Consumes the atomic and returns the contained value.\n This is safe because passing `self` by value guarantees that no other threads are\n concurrently accessing the atomic data.\n # Examples\n ```\nuse std::sync::atomic::AtomicU64;\nlet some_var = AtomicU64::new(5);\n assert_eq!(some_var.into_inner(), 5);\n ```",
                &["_self"],
            )
            .register_documented(
                "new",
                |v: u64| {
                    let output: Val<::core::sync::atomic::AtomicU64> = {
                        {
                            let output: Val<::core::sync::atomic::AtomicU64> = ::core::sync::atomic::AtomicU64::new(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new atomic integer.\n # Examples\n ```\nuse std::sync::atomic::AtomicU64;\nlet atomic_forty_two = AtomicU64::new(42);\n ```",
                &["v"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                ::core::sync::atomic::AtomicU64,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_atomic_u_8_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            ::core::sync::atomic::AtomicU8,
        >::new(world)
            .register_documented(
                "into_inner",
                |_self: Val<::core::sync::atomic::AtomicU8>| {
                    let output: u8 = {
                        {
                            let output: u8 = ::core::sync::atomic::AtomicU8::into_inner(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Consumes the atomic and returns the contained value.\n This is safe because passing `self` by value guarantees that no other threads are\n concurrently accessing the atomic data.\n # Examples\n ```\nuse std::sync::atomic::AtomicU8;\nlet some_var = AtomicU8::new(5);\n assert_eq!(some_var.into_inner(), 5);\n ```",
                &["_self"],
            )
            .register_documented(
                "new",
                |v: u8| {
                    let output: Val<::core::sync::atomic::AtomicU8> = {
                        {
                            let output: Val<::core::sync::atomic::AtomicU8> = ::core::sync::atomic::AtomicU8::new(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new atomic integer.\n # Examples\n ```\nuse std::sync::atomic::AtomicU8;\nlet atomic_forty_two = AtomicU8::new(42);\n ```",
                &["v"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                ::core::sync::atomic::AtomicU8,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_atomic_usize_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            ::core::sync::atomic::AtomicUsize,
        >::new(world)
            .register_documented(
                "into_inner",
                |_self: Val<::core::sync::atomic::AtomicUsize>| {
                    let output: usize = {
                        {
                            let output: usize = ::core::sync::atomic::AtomicUsize::into_inner(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Consumes the atomic and returns the contained value.\n This is safe because passing `self` by value guarantees that no other threads are\n concurrently accessing the atomic data.\n # Examples\n ```\nuse std::sync::atomic::AtomicUsize;\nlet some_var = AtomicUsize::new(5);\n assert_eq!(some_var.into_inner(), 5);\n ```",
                &["_self"],
            )
            .register_documented(
                "new",
                |v: usize| {
                    let output: Val<::core::sync::atomic::AtomicUsize> = {
                        {
                            let output: Val<::core::sync::atomic::AtomicUsize> = ::core::sync::atomic::AtomicUsize::new(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new atomic integer.\n # Examples\n ```\nuse std::sync::atomic::AtomicUsize;\nlet atomic_forty_two = AtomicUsize::new(42);\n ```",
                &["v"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                ::core::sync::atomic::AtomicUsize,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_duration_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            ::core::time::Duration,
        >::new(world)
            .register_documented(
                "abs_diff",
                |_self: Val<::core::time::Duration>, other: Val<::core::time::Duration>| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = ::core::time::Duration::abs_diff(
                                    _self.into_inner(),
                                    other.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the absolute difference between `self` and `other`.\n # Examples\n ```\n use std::time::Duration;\n assert_eq!(Duration::new(100, 0).abs_diff(Duration::new(80, 0)), Duration::new(20, 0));\n assert_eq!(Duration::new(100, 400_000_000).abs_diff(Duration::new(110, 0)), Duration::new(9, 600_000_000));\n ```",
                &["_self", "other"],
            )
            .register_documented(
                "add",
                |_self: Val<::core::time::Duration>, rhs: Val<::core::time::Duration>| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = <::core::time::Duration as ::core::ops::Add<
                                ::core::time::Duration,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_micros",
                |_self: Ref<::core::time::Duration>| {
                    let output: u128 = {
                        {
                            let output: u128 = ::core::time::Duration::as_micros(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the total number of whole microseconds contained by this `Duration`.\n # Examples\n ```\n use std::time::Duration;\n let duration = Duration::new(5, 730_023_852);\n assert_eq!(duration.as_micros(), 5_730_023);\n ```",
                &["_self"],
            )
            .register_documented(
                "as_millis",
                |_self: Ref<::core::time::Duration>| {
                    let output: u128 = {
                        {
                            let output: u128 = ::core::time::Duration::as_millis(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the total number of whole milliseconds contained by this `Duration`.\n # Examples\n ```\n use std::time::Duration;\n let duration = Duration::new(5, 730_023_852);\n assert_eq!(duration.as_millis(), 5_730);\n ```",
                &["_self"],
            )
            .register_documented(
                "as_nanos",
                |_self: Ref<::core::time::Duration>| {
                    let output: u128 = {
                        {
                            let output: u128 = ::core::time::Duration::as_nanos(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the total number of nanoseconds contained by this `Duration`.\n # Examples\n ```\n use std::time::Duration;\n let duration = Duration::new(5, 730_023_852);\n assert_eq!(duration.as_nanos(), 5_730_023_852);\n ```",
                &["_self"],
            )
            .register_documented(
                "as_secs",
                |_self: Ref<::core::time::Duration>| {
                    let output: u64 = {
                        {
                            let output: u64 = ::core::time::Duration::as_secs(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the number of _whole_ seconds contained by this `Duration`.\n The returned value does not include the fractional (nanosecond) part of the\n duration, which can be obtained using [`subsec_nanos`].\n # Examples\n ```\n use std::time::Duration;\n let duration = Duration::new(5, 730_023_852);\n assert_eq!(duration.as_secs(), 5);\n ```\n To determine the total number of seconds represented by the `Duration`\n including the fractional part, use [`as_secs_f64`] or [`as_secs_f32`]\n [`as_secs_f64`]: Duration::as_secs_f64\n [`as_secs_f32`]: Duration::as_secs_f32\n [`subsec_nanos`]: Duration::subsec_nanos",
                &["_self"],
            )
            .register_documented(
                "as_secs_f32",
                |_self: Ref<::core::time::Duration>| {
                    let output: f32 = {
                        {
                            let output: f32 = ::core::time::Duration::as_secs_f32(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the number of seconds contained by this `Duration` as `f32`.\n The returned value includes the fractional (nanosecond) part of the duration.\n # Examples\n ```\n use std::time::Duration;\n let dur = Duration::new(2, 700_000_000);\n assert_eq!(dur.as_secs_f32(), 2.7);\n ```",
                &["_self"],
            )
            .register_documented(
                "as_secs_f64",
                |_self: Ref<::core::time::Duration>| {
                    let output: f64 = {
                        {
                            let output: f64 = ::core::time::Duration::as_secs_f64(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the number of seconds contained by this `Duration` as `f64`.\n The returned value includes the fractional (nanosecond) part of the duration.\n # Examples\n ```\n use std::time::Duration;\n let dur = Duration::new(2, 700_000_000);\n assert_eq!(dur.as_secs_f64(), 2.7);\n ```",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<::core::time::Duration>| {
                    let output: () = {
                        {
                            let output: () = <::core::time::Duration as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<::core::time::Duration>| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = <::core::time::Duration as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "div",
                |_self: Val<::core::time::Duration>, rhs: u32| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = <::core::time::Duration as ::core::ops::Div<
                                u32,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_duration_f32",
                |_self: Val<::core::time::Duration>, rhs: Val<::core::time::Duration>| {
                    let output: f32 = {
                        {
                            let output: f32 = ::core::time::Duration::div_duration_f32(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Divides `Duration` by `Duration` and returns `f32`.\n # Examples\n ```\n use std::time::Duration;\n let dur1 = Duration::new(2, 700_000_000);\n let dur2 = Duration::new(5, 400_000_000);\n assert_eq!(dur1.div_duration_f32(dur2), 0.5);\n ```",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_duration_f64",
                |_self: Val<::core::time::Duration>, rhs: Val<::core::time::Duration>| {
                    let output: f64 = {
                        {
                            let output: f64 = ::core::time::Duration::div_duration_f64(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Divides `Duration` by `Duration` and returns `f64`.\n # Examples\n ```\n use std::time::Duration;\n let dur1 = Duration::new(2, 700_000_000);\n let dur2 = Duration::new(5, 400_000_000);\n assert_eq!(dur1.div_duration_f64(dur2), 0.5);\n ```",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_f32",
                |_self: Val<::core::time::Duration>, rhs: f32| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = ::core::time::Duration::div_f32(
                                    _self.into_inner(),
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Divides `Duration` by `f32`.\n # Panics\n This method will panic if result is negative, overflows `Duration` or not finite.\n # Examples\n ```\n use std::time::Duration;\n let dur = Duration::new(2, 700_000_000);\n // note that due to rounding errors result is slightly\n // different from 0.859_872_611\n assert_eq!(dur.div_f32(3.14), Duration::new(0, 859_872_580));\n assert_eq!(dur.div_f32(3.14e5), Duration::new(0, 8_599));\n ```",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_f64",
                |_self: Val<::core::time::Duration>, rhs: f64| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = ::core::time::Duration::div_f64(
                                    _self.into_inner(),
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Divides `Duration` by `f64`.\n # Panics\n This method will panic if result is negative, overflows `Duration` or not finite.\n # Examples\n ```\n use std::time::Duration;\n let dur = Duration::new(2, 700_000_000);\n assert_eq!(dur.div_f64(3.14), Duration::new(0, 859_872_611));\n assert_eq!(dur.div_f64(3.14e5), Duration::new(0, 8_599));\n ```",
                &["_self", "rhs"],
            )
            .register_documented(
                "eq",
                |_self: Ref<::core::time::Duration>, other: Ref<::core::time::Duration>| {
                    let output: bool = {
                        {
                            let output: bool = <::core::time::Duration as ::core::cmp::PartialEq<
                                ::core::time::Duration,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "from_micros",
                |micros: u64| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = ::core::time::Duration::from_micros(
                                    micros,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new `Duration` from the specified number of microseconds.\n # Examples\n ```\n use std::time::Duration;\n let duration = Duration::from_micros(1_000_002);\n assert_eq!(1, duration.as_secs());\n assert_eq!(2_000, duration.subsec_nanos());\n ```",
                &["micros"],
            )
            .register_documented(
                "from_millis",
                |millis: u64| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = ::core::time::Duration::from_millis(
                                    millis,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new `Duration` from the specified number of milliseconds.\n # Examples\n ```\n use std::time::Duration;\n let duration = Duration::from_millis(2_569);\n assert_eq!(2, duration.as_secs());\n assert_eq!(569_000_000, duration.subsec_nanos());\n ```",
                &["millis"],
            )
            .register_documented(
                "from_nanos",
                |nanos: u64| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = ::core::time::Duration::from_nanos(
                                    nanos,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new `Duration` from the specified number of nanoseconds.\n Note: Using this on the return value of `as_nanos()` might cause unexpected behavior:\n `as_nanos()` returns a u128, and can return values that do not fit in u64, e.g. 585 years.\n Instead, consider using the pattern `Duration::new(d.as_secs(), d.subsec_nanos())`\n if you cannot copy/clone the Duration directly.\n # Examples\n ```\n use std::time::Duration;\n let duration = Duration::from_nanos(1_000_000_123);\n assert_eq!(1, duration.as_secs());\n assert_eq!(123, duration.subsec_nanos());\n ```",
                &["nanos"],
            )
            .register_documented(
                "from_secs",
                |secs: u64| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = ::core::time::Duration::from_secs(
                                    secs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new `Duration` from the specified number of whole seconds.\n # Examples\n ```\n use std::time::Duration;\n let duration = Duration::from_secs(5);\n assert_eq!(5, duration.as_secs());\n assert_eq!(0, duration.subsec_nanos());\n ```",
                &["secs"],
            )
            .register_documented(
                "from_secs_f32",
                |secs: f32| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = ::core::time::Duration::from_secs_f32(
                                    secs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new `Duration` from the specified number of seconds represented\n as `f32`.\n # Panics\n This constructor will panic if `secs` is negative, overflows `Duration` or not finite.\n # Examples\n ```\n use std::time::Duration;\n let res = Duration::from_secs_f32(0.0);\n assert_eq!(res, Duration::new(0, 0));\n let res = Duration::from_secs_f32(1e-20);\n assert_eq!(res, Duration::new(0, 0));\n let res = Duration::from_secs_f32(4.2e-7);\n assert_eq!(res, Duration::new(0, 420));\n let res = Duration::from_secs_f32(2.7);\n assert_eq!(res, Duration::new(2, 700_000_048));\n let res = Duration::from_secs_f32(3e10);\n assert_eq!(res, Duration::new(30_000_001_024, 0));\n // subnormal float\n let res = Duration::from_secs_f32(f32::from_bits(1));\n assert_eq!(res, Duration::new(0, 0));\n // conversion uses rounding\n let res = Duration::from_secs_f32(0.999e-9);\n assert_eq!(res, Duration::new(0, 1));\n ```",
                &["secs"],
            )
            .register_documented(
                "from_secs_f64",
                |secs: f64| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = ::core::time::Duration::from_secs_f64(
                                    secs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new `Duration` from the specified number of seconds represented\n as `f64`.\n # Panics\n This constructor will panic if `secs` is negative, overflows `Duration` or not finite.\n # Examples\n ```\n use std::time::Duration;\n let res = Duration::from_secs_f64(0.0);\n assert_eq!(res, Duration::new(0, 0));\n let res = Duration::from_secs_f64(1e-20);\n assert_eq!(res, Duration::new(0, 0));\n let res = Duration::from_secs_f64(4.2e-7);\n assert_eq!(res, Duration::new(0, 420));\n let res = Duration::from_secs_f64(2.7);\n assert_eq!(res, Duration::new(2, 700_000_000));\n let res = Duration::from_secs_f64(3e10);\n assert_eq!(res, Duration::new(30_000_000_000, 0));\n // subnormal float\n let res = Duration::from_secs_f64(f64::from_bits(1));\n assert_eq!(res, Duration::new(0, 0));\n // conversion uses rounding\n let res = Duration::from_secs_f64(0.999e-9);\n assert_eq!(res, Duration::new(0, 1));\n ```",
                &["secs"],
            )
            .register_documented(
                "is_zero",
                |_self: Ref<::core::time::Duration>| {
                    let output: bool = {
                        {
                            let output: bool = ::core::time::Duration::is_zero(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if this `Duration` spans no time.\n # Examples\n ```\n use std::time::Duration;\n assert!(Duration::ZERO.is_zero());\n assert!(Duration::new(0, 0).is_zero());\n assert!(Duration::from_nanos(0).is_zero());\n assert!(Duration::from_secs(0).is_zero());\n assert!(!Duration::new(1, 1).is_zero());\n assert!(!Duration::from_nanos(1).is_zero());\n assert!(!Duration::from_secs(1).is_zero());\n ```",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<::core::time::Duration>, rhs: u32| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = <::core::time::Duration as ::core::ops::Mul<
                                u32,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_f32",
                |_self: Val<::core::time::Duration>, rhs: f32| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = ::core::time::Duration::mul_f32(
                                    _self.into_inner(),
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies `Duration` by `f32`.\n # Panics\n This method will panic if result is negative, overflows `Duration` or not finite.\n # Examples\n ```\n use std::time::Duration;\n let dur = Duration::new(2, 700_000_000);\n assert_eq!(dur.mul_f32(3.14), Duration::new(8, 478_000_641));\n assert_eq!(dur.mul_f32(3.14e5), Duration::new(847_800, 0));\n ```",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_f64",
                |_self: Val<::core::time::Duration>, rhs: f64| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = ::core::time::Duration::mul_f64(
                                    _self.into_inner(),
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies `Duration` by `f64`.\n # Panics\n This method will panic if result is negative, overflows `Duration` or not finite.\n # Examples\n ```\n use std::time::Duration;\n let dur = Duration::new(2, 700_000_000);\n assert_eq!(dur.mul_f64(3.14), Duration::new(8, 478_000_000));\n assert_eq!(dur.mul_f64(3.14e5), Duration::new(847_800, 0));\n ```",
                &["_self", "rhs"],
            )
            .register_documented(
                "new",
                |secs: u64, nanos: u32| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = ::core::time::Duration::new(
                                    secs,
                                    nanos,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new `Duration` from the specified number of whole seconds and\n additional nanoseconds.\n If the number of nanoseconds is greater than 1 billion (the number of\n nanoseconds in a second), then it will carry over into the seconds provided.\n # Panics\n This constructor will panic if the carry from the nanoseconds overflows\n the seconds counter.\n # Examples\n ```\n use std::time::Duration;\n let five_seconds = Duration::new(5, 0);\n ```",
                &["secs", "nanos"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<::core::time::Duration>, rhs: Val<::core::time::Duration>| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = ::core::time::Duration::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Saturating `Duration` addition. Computes `self + other`, returning [`Duration::MAX`]\n if overflow occurred.\n # Examples\n ```\n #![feature(duration_constants)]\n use std::time::Duration;\n assert_eq!(Duration::new(0, 0).saturating_add(Duration::new(0, 1)), Duration::new(0, 1));\n assert_eq!(Duration::new(1, 0).saturating_add(Duration::new(u64::MAX, 0)), Duration::MAX);\n ```",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<::core::time::Duration>, rhs: u32| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = ::core::time::Duration::saturating_mul(
                                    _self.into_inner(),
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Saturating `Duration` multiplication. Computes `self * other`, returning\n [`Duration::MAX`] if overflow occurred.\n # Examples\n ```\n #![feature(duration_constants)]\n use std::time::Duration;\n assert_eq!(Duration::new(0, 500_000_001).saturating_mul(2), Duration::new(1, 2));\n assert_eq!(Duration::new(u64::MAX - 1, 0).saturating_mul(2), Duration::MAX);\n ```",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<::core::time::Duration>, rhs: Val<::core::time::Duration>| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = ::core::time::Duration::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Saturating `Duration` subtraction. Computes `self - other`, returning [`Duration::ZERO`]\n if the result would be negative or if overflow occurred.\n # Examples\n ```\n use std::time::Duration;\n assert_eq!(Duration::new(0, 1).saturating_sub(Duration::new(0, 0)), Duration::new(0, 1));\n assert_eq!(Duration::new(0, 0).saturating_sub(Duration::new(0, 1)), Duration::ZERO);\n ```",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<::core::time::Duration>, rhs: Val<::core::time::Duration>| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = <::core::time::Duration as ::core::ops::Sub<
                                ::core::time::Duration,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "subsec_micros",
                |_self: Ref<::core::time::Duration>| {
                    let output: u32 = {
                        {
                            let output: u32 = ::core::time::Duration::subsec_micros(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the fractional part of this `Duration`, in whole microseconds.\n This method does **not** return the length of the duration when\n represented by microseconds. The returned number always represents a\n fractional portion of a second (i.e., it is less than one million).\n # Examples\n ```\n use std::time::Duration;\n let duration = Duration::from_micros(1_234_567);\n assert_eq!(duration.as_secs(), 1);\n assert_eq!(duration.subsec_micros(), 234_567);\n ```",
                &["_self"],
            )
            .register_documented(
                "subsec_millis",
                |_self: Ref<::core::time::Duration>| {
                    let output: u32 = {
                        {
                            let output: u32 = ::core::time::Duration::subsec_millis(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the fractional part of this `Duration`, in whole milliseconds.\n This method does **not** return the length of the duration when\n represented by milliseconds. The returned number always represents a\n fractional portion of a second (i.e., it is less than one thousand).\n # Examples\n ```\n use std::time::Duration;\n let duration = Duration::from_millis(5_432);\n assert_eq!(duration.as_secs(), 5);\n assert_eq!(duration.subsec_millis(), 432);\n ```",
                &["_self"],
            )
            .register_documented(
                "subsec_nanos",
                |_self: Ref<::core::time::Duration>| {
                    let output: u32 = {
                        {
                            let output: u32 = ::core::time::Duration::subsec_nanos(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the fractional part of this `Duration`, in nanoseconds.\n This method does **not** return the length of the duration when\n represented by nanoseconds. The returned number always represents a\n fractional portion of a second (i.e., it is less than one billion).\n # Examples\n ```\n use std::time::Duration;\n let duration = Duration::from_millis(5_010);\n assert_eq!(duration.as_secs(), 5);\n assert_eq!(duration.subsec_nanos(), 10_000_000);\n ```",
                &["_self"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                ::core::time::Duration,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_instant_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            ::std::time::Instant,
        >::new(world)
            .register_documented(
                "add",
                |_self: Val<::std::time::Instant>, other: Val<::core::time::Duration>| {
                    let output: Val<::std::time::Instant> = {
                        {
                            let output: Val<::std::time::Instant> = <::std::time::Instant as ::core::ops::Add<
                                ::core::time::Duration,
                            >>::add(_self.into_inner(), other.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                " # Panics\n This function may panic if the resulting point in time cannot be represented by the\n underlying data structure. See [`Instant::checked_add`] for a version without panic.",
                &["_self", "other"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<::std::time::Instant>| {
                    let output: () = {
                        {
                            let output: () = <::std::time::Instant as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<::std::time::Instant>| {
                    let output: Val<::std::time::Instant> = {
                        {
                            let output: Val<::std::time::Instant> = <::std::time::Instant as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "duration_since",
                |_self: Ref<::std::time::Instant>, earlier: Val<::std::time::Instant>| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = ::std::time::Instant::duration_since(
                                    &_self,
                                    earlier.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the amount of time elapsed from another instant to this one,\n or zero duration if that instant is later than this one.\n # Panics\n Previous Rust versions panicked when `earlier` was later than `self`. Currently this\n method saturates. Future versions may reintroduce the panic in some circumstances.\n See [Monotonicity].\n [Monotonicity]: Instant#monotonicity\n # Examples\n ```no_run\n use std::time::{Duration, Instant};\n use std::thread::sleep;\n let now = Instant::now();\n sleep(Duration::new(1, 0));\n let new_now = Instant::now();\n println!(\"{:?}\", new_now.duration_since(now));\n println!(\"{:?}\", now.duration_since(new_now)); // 0ns\n ```",
                &["_self", "earlier"],
            )
            .register_documented(
                "elapsed",
                |_self: Ref<::std::time::Instant>| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = ::std::time::Instant::elapsed(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the amount of time elapsed since this instant.\n # Panics\n Previous Rust versions panicked when the current time was earlier than self. Currently this\n method returns a Duration of zero in that case. Future versions may reintroduce the panic.\n See [Monotonicity].\n [Monotonicity]: Instant#monotonicity\n # Examples\n ```no_run\n use std::thread::sleep;\n use std::time::{Duration, Instant};\n let instant = Instant::now();\n let three_secs = Duration::from_secs(3);\n sleep(three_secs);\n assert!(instant.elapsed() >= three_secs);\n ```",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<::std::time::Instant>, other: Ref<::std::time::Instant>| {
                    let output: bool = {
                        {
                            let output: bool = <::std::time::Instant as ::core::cmp::PartialEq<
                                ::std::time::Instant,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "now",
                || {
                    let output: Val<::std::time::Instant> = {
                        {
                            let output: Val<::std::time::Instant> = ::std::time::Instant::now()
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns an instant corresponding to \"now\".\n # Examples\n ```\n use std::time::Instant;\n let now = Instant::now();\n ```",
                &[],
            )
            .register_documented(
                "saturating_duration_since",
                |_self: Ref<::std::time::Instant>, earlier: Val<::std::time::Instant>| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = ::std::time::Instant::saturating_duration_since(
                                    &_self,
                                    earlier.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the amount of time elapsed from another instant to this one,\n or zero duration if that instant is later than this one.\n # Examples\n ```no_run\n use std::time::{Duration, Instant};\n use std::thread::sleep;\n let now = Instant::now();\n sleep(Duration::new(1, 0));\n let new_now = Instant::now();\n println!(\"{:?}\", new_now.saturating_duration_since(now));\n println!(\"{:?}\", now.saturating_duration_since(new_now)); // 0ns\n ```",
                &["_self", "earlier"],
            )
            .register_documented(
                "sub",
                |_self: Val<::std::time::Instant>, other: Val<::core::time::Duration>| {
                    let output: Val<::std::time::Instant> = {
                        {
                            let output: Val<::std::time::Instant> = <::std::time::Instant as ::core::ops::Sub<
                                ::core::time::Duration,
                            >>::sub(_self.into_inner(), other.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "sub",
                |_self: Val<::std::time::Instant>, other: Val<::std::time::Instant>| {
                    let output: Val<::core::time::Duration> = {
                        {
                            let output: Val<::core::time::Duration> = <::std::time::Instant as ::core::ops::Sub<
                                ::std::time::Instant,
                            >>::sub(_self.into_inner(), other.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the amount of time elapsed from another instant to this one,\n or zero duration if that instant is later than this one.\n # Panics\n Previous Rust versions panicked when `other` was later than `self`. Currently this\n method saturates. Future versions may reintroduce the panic in some circumstances.\n See [Monotonicity].\n [Monotonicity]: Instant#monotonicity",
                &["_self", "other"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                ::std::time::Instant,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_range_full_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            ::core::ops::RangeFull,
        >::new(world)
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<::core::ops::RangeFull>| {
                    let output: () = {
                        {
                            let output: () = <::core::ops::RangeFull as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<::core::ops::RangeFull>| {
                    let output: Val<::core::ops::RangeFull> = {
                        {
                            let output: Val<::core::ops::RangeFull> = <::core::ops::RangeFull as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<::core::ops::RangeFull>, other: Ref<::core::ops::RangeFull>| {
                    let output: bool = {
                        {
                            let output: bool = <::core::ops::RangeFull as ::core::cmp::PartialEq<
                                ::core::ops::RangeFull,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                ::core::ops::RangeFull,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_type_id_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            ::core::any::TypeId,
        >::new(world)
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<::core::any::TypeId>| {
                    let output: () = {
                        {
                            let output: () = <::core::any::TypeId as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<::core::any::TypeId>| {
                    let output: Val<::core::any::TypeId> = {
                        {
                            let output: Val<::core::any::TypeId> = <::core::any::TypeId as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<::core::any::TypeId>, other: Ref<::core::any::TypeId>| {
                    let output: bool = {
                        {
                            let output: bool = <::core::any::TypeId as ::core::cmp::PartialEq<
                                ::core::any::TypeId,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                ::core::any::TypeId,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_quat_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::Quat,
        >::new(world)
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Val<bevy::math::Quat>,
                    rhs: Val<bevy::math::Quat>,
                    max_abs_diff: f32|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Quat::abs_diff_eq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs`\n is less than or equal to `max_abs_diff`.\n This can be used to compare if two quaternions contain similar elements. It works\n best when comparing with a known value. The `max_abs_diff` that should be used used\n depends on the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = <bevy::math::Quat as ::core::ops::Add<
                                bevy::math::Quat,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                " Adds two quaternions.\n The sum is not guaranteed to be normalized.\n Note that addition is not the same as combining the rotations represented by the\n two quaternions! That corresponds to multiplication.",
                &["_self", "rhs"],
            )
            .register_documented(
                "angle_between",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Quat::angle_between(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the angle (in radians) for the minimal rotation\n for transforming this quaternion into another.\n Both quaternions must be normalized.\n # Panics\n Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dquat",
                |_self: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::Quat::as_dquat(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::Quat>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = <bevy::math::Quat as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "conjugate",
                |_self: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::conjugate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the quaternion conjugate of `self`. For a unit quaternion the\n conjugate is also the inverse.",
                &["_self"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::Quat>, rhs: f32| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = <bevy::math::Quat as ::core::ops::Div<
                                f32,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Divides a quaternion by a scalar value.\n The quotient is not guaranteed to be normalized.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Quat::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`. The dot product is\n equal to the cosine of the angle between two quaternion rotations.",
                &["_self", "rhs"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::Quat>, rhs: Ref<bevy::math::Quat>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::Quat as ::core::cmp::PartialEq<
                                bevy::math::Quat,
                            >>::eq(&_self, &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "from_affine3",
                |a: Ref<bevy::math::Affine3A>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::from_affine3(
                                    &a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a quaternion from a 3x3 rotation matrix inside a 3D affine transform.\n Note if the input affine matrix contain scales, shears, or other non-rotation\n transformations then the resulting quaternion will be ill-defined.\n # Panics\n Will panic if any input affine matrix column is not normalized when `glam_assert` is\n enabled.",
                &["a"],
            )
            .register_documented(
                "from_array",
                |a: [f32; 4]| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a rotation quaternion from an array.\n # Preconditions\n This function does not check if the input is normalized, it is up to the user to\n provide normalized input or to normalized the resulting quaternion.",
                &["a"],
            )
            .register_documented(
                "from_axis_angle",
                |axis: Val<bevy::math::Vec3>, angle: f32| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::from_axis_angle(
                                    axis.into_inner(),
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Create a quaternion for a normalized rotation `axis` and `angle` (in radians).\n The axis must be a unit vector.\n # Panics\n Will panic if `axis` is not normalized when `glam_assert` is enabled.",
                &["axis", "angle"],
            )
            .register_documented(
                "from_euler",
                |euler: Val<bevy::math::EulerRot>, a: f32, b: f32, c: f32| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::from_euler(
                                    euler.into_inner(),
                                    a,
                                    b,
                                    c,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a quaternion from the given Euler rotation sequence and the angles (in radians).",
                &["euler", "a", "b", "c"],
            )
            .register_documented(
                "from_mat3",
                |mat: Ref<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::from_mat3(
                                    &mat,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a quaternion from a 3x3 rotation matrix.\n Note if the input matrix contain scales, shears, or other non-rotation transformations then\n the resulting quaternion will be ill-defined.\n # Panics\n Will panic if any input matrix column is not normalized when `glam_assert` is enabled.",
                &["mat"],
            )
            .register_documented(
                "from_mat3a",
                |mat: Ref<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::from_mat3a(
                                    &mat,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a quaternion from a 3x3 SIMD aligned rotation matrix.\n Note if the input matrix contain scales, shears, or other non-rotation transformations then\n the resulting quaternion will be ill-defined.\n # Panics\n Will panic if any input matrix column is not normalized when `glam_assert` is enabled.",
                &["mat"],
            )
            .register_documented(
                "from_mat4",
                |mat: Ref<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::from_mat4(
                                    &mat,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a quaternion from the upper 3x3 rotation matrix inside a homogeneous 4x4 matrix.\n Note if the upper 3x3 matrix contain scales, shears, or other non-rotation transformations\n then the resulting quaternion will be ill-defined.\n # Panics\n Will panic if any column of the upper 3x3 rotation matrix is not normalized when\n `glam_assert` is enabled.",
                &["mat"],
            )
            .register_documented(
                "from_rotation_arc",
                |from: Val<bevy::math::Vec3>, to: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_arc(
                                    from.into_inner(),
                                    to.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the\n plane spanned by the two vectors.  Will rotate at most 180 degrees.\n The inputs must be unit vectors.\n `from_rotation_arc(from, to) * from ≈ to`.\n For near-singular cases (from≈to and from≈-to) the current implementation\n is only accurate to about 0.001 (for `f32`).\n # Panics\n Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.",
                &["from", "to"],
            )
            .register_documented(
                "from_rotation_arc_2d",
                |from: Val<bevy::math::Vec2>, to: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_arc_2d(
                                    from.into_inner(),
                                    to.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Gets the minimal rotation for transforming `from` to `to`.  The resulting rotation is\n around the z axis. Will rotate at most 180 degrees.\n The inputs must be unit vectors.\n `from_rotation_arc_2d(from, to) * from ≈ to`.\n For near-singular cases (from≈to and from≈-to) the current implementation\n is only accurate to about 0.001 (for `f32`).\n # Panics\n Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.",
                &["from", "to"],
            )
            .register_documented(
                "from_rotation_arc_colinear",
                |from: Val<bevy::math::Vec3>, to: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_arc_colinear(
                                    from.into_inner(),
                                    to.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Gets the minimal rotation for transforming `from` to either `to` or `-to`.  This means\n that the resulting quaternion will rotate `from` so that it is colinear with `to`.\n The rotation is in the plane spanned by the two vectors.  Will rotate at most 90\n degrees.\n The inputs must be unit vectors.\n `to.dot(from_rotation_arc_colinear(from, to) * from).abs() ≈ 1`.\n # Panics\n Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.",
                &["from", "to"],
            )
            .register_documented(
                "from_rotation_x",
                |angle: f32| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_x(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a quaternion from the `angle` (in radians) around the x axis.",
                &["angle"],
            )
            .register_documented(
                "from_rotation_y",
                |angle: f32| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_y(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a quaternion from the `angle` (in radians) around the y axis.",
                &["angle"],
            )
            .register_documented(
                "from_rotation_z",
                |angle: f32| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::from_rotation_z(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a quaternion from the `angle` (in radians) around the z axis.",
                &["angle"],
            )
            .register_documented(
                "from_scaled_axis",
                |v: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::from_scaled_axis(
                                    v.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Create a quaternion that rotates `v.length()` radians around `v.normalize()`.\n `from_scaled_axis(Vec3::ZERO)` results in the identity quaternion.",
                &["v"],
            )
            .register_documented(
                "from_vec4",
                |v: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::from_vec4(
                                    v.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new rotation quaternion from a 4D vector.\n # Preconditions\n This function does not check if the input is normalized, it is up to the user to\n provide normalized input or to normalized the resulting quaternion.",
                &["v"],
            )
            .register_documented(
                "from_xyzw",
                |x: f32, y: f32, z: f32, w: f32| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::from_xyzw(
                                    x,
                                    y,
                                    z,
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new rotation quaternion.\n This should generally not be called manually unless you know what you are doing.\n Use one of the other constructors instead such as `identity` or `from_axis_angle`.\n `from_xyzw` is mostly used by unit tests and `serde` deserialization.\n # Preconditions\n This function does not check if the input is normalized, it is up to the user to\n provide normalized input or to normalized the resulting quaternion.",
                &["x", "y", "z", "w"],
            )
            .register_documented(
                "inverse",
                |_self: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::inverse(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the inverse of a normalized quaternion.\n Typically quaternion inverse returns the conjugate of a normalized quaternion.\n Because `self` is assumed to already be unit length this method *does not* normalize\n before returning the conjugate.\n # Panics\n Will panic if `self` is not normalized when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "is_finite",
                |_self: Val<bevy::math::Quat>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Quat::is_finite(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.\n If any element is either `NaN`, positive or negative infinity, this will return `false`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Val<bevy::math::Quat>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Quat::is_nan(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NAN`.",
                &["_self"],
            )
            .register_documented(
                "is_near_identity",
                |_self: Val<bevy::math::Quat>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Quat::is_near_identity(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "is_normalized",
                |_self: Val<bevy::math::Quat>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Quat::is_normalized(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns whether `self` of length `1.0` or not.\n Uses a precision threshold of `1e-6`.",
                &["_self"],
            )
            .register_documented(
                "length",
                |_self: Val<bevy::math::Quat>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Quat::length(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the length of `self`.",
                &["_self"],
            )
            .register_documented(
                "length_recip",
                |_self: Val<bevy::math::Quat>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Quat::length_recip(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes `1.0 / length()`.\n For valid results, `self` must _not_ be of length zero.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::Quat>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Quat::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.\n This is generally faster than `length()` as it avoids a square\n root operation.",
                &["_self"],
            )
            .register_documented(
                "lerp",
                |_self: Val<bevy::math::Quat>, end: Val<bevy::math::Quat>, s: f32| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::lerp(
                                    _self.into_inner(),
                                    end.into_inner(),
                                    s,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs a linear interpolation between `self` and `rhs` based on\n the value `s`.\n When `s` is `0.0`, the result will be equal to `self`.  When `s`\n is `1.0`, the result will be equal to `rhs`.\n # Panics\n Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.",
                &["_self", "end", "s"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = <bevy::math::Quat as ::core::ops::Mul<
                                bevy::math::Quat,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies two quaternions. If they each represent a rotation, the result will\n represent the combined rotation.\n Note that due to floating point rounding the result may not be perfectly\n normalized.\n # Panics\n Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Quat as ::core::ops::Mul<
                                bevy::math::Vec3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies a quaternion and a 3D vector, returning the rotated vector.\n # Panics\n Will panic if `self` is not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Quat as ::core::ops::Mul<
                                bevy::math::Vec3A,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Quat>, rhs: f32| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = <bevy::math::Quat as ::core::ops::Mul<
                                f32,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies a quaternion by a scalar value.\n The product is not guaranteed to be normalized.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_quat",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::mul_quat(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies two quaternions. If they each represent a rotation, the result will\n represent the combined rotation.\n Note that due to floating point rounding the result may not be perfectly normalized.\n # Panics\n Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_vec3",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Quat::mul_vec3(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies a quaternion and a 3D vector, returning the rotated vector.\n # Panics\n Will panic if `self` is not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_vec3a",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Quat::mul_vec3a(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies a quaternion and a 3D vector, returning the rotated vector.",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = <bevy::math::Quat as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "normalize",
                |_self: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::normalize(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0.\n For valid results, `self` must _not_ be of length zero.\n Panics\n Will panic if `self` is zero length when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "rotate_towards",
                |
                    _self: Ref<bevy::math::Quat>,
                    rhs: Val<bevy::math::Quat>,
                    max_angle: f32|
                {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::rotate_towards(
                                    &_self,
                                    rhs.into_inner(),
                                    max_angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Rotates towards `rhs` up to `max_angle` (in radians).\n When `max_angle` is `0.0`, the result will be equal to `self`. When `max_angle` is equal to\n `self.angle_between(rhs)`, the result will be equal to `rhs`. If `max_angle` is negative,\n rotates towards the exact opposite of `rhs`. Will not go past the target.\n Both quaternions must be normalized.\n # Panics\n Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.",
                &["_self", "rhs", "max_angle"],
            )
            .register_documented(
                "slerp",
                |_self: Val<bevy::math::Quat>, end: Val<bevy::math::Quat>, s: f32| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::Quat::slerp(
                                    _self.into_inner(),
                                    end.into_inner(),
                                    s,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs a spherical linear interpolation between `self` and `end`\n based on the value `s`.\n When `s` is `0.0`, the result will be equal to `self`.  When `s`\n is `1.0`, the result will be equal to `end`.\n # Panics\n Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.",
                &["_self", "end", "s"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::Quat>, rhs: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = <bevy::math::Quat as ::core::ops::Sub<
                                bevy::math::Quat,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                " Subtracts the `rhs` quaternion from `self`.\n The difference is not guaranteed to be normalized.",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::Quat>| {
                    let output: [f32; 4] = {
                        {
                            let output: [f32; 4] = bevy::math::Quat::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z, w]`",
                &["_self"],
            )
            .register_documented(
                "to_euler",
                |_self: Val<bevy::math::Quat>, order: Val<bevy::math::EulerRot>| {
                    let output: (f32, f32, f32) = {
                        {
                            let output: (f32, f32, f32) = bevy::math::Quat::to_euler(
                                    _self.into_inner(),
                                    order.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the rotation angles for the given euler rotation sequence.",
                &["_self", "order"],
            )
            .register_documented(
                "to_scaled_axis",
                |_self: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Quat::to_scaled_axis(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the rotation axis scaled by the rotation in radians.",
                &["_self"],
            )
            .register_documented(
                "xyz",
                |_self: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Quat::xyz(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector part of the quaternion.",
                &["_self"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::Quat,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_vec_3_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::Vec3,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Val<bevy::math::Vec3>,
                    rhs: Val<bevy::math::Vec3>,
                    max_abs_diff: f32|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Vec3::abs_diff_eq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs` is\n less than or equal to `max_abs_diff`.\n This can be used to compare if two vectors contain similar elements. It works best when\n comparing with a known value. The `max_abs_diff` that should be used used depends on\n the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::Vec3>, rhs: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as ::core::ops::Add<
                                &bevy::math::Vec3,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as ::core::ops::Add<
                                bevy::math::Vec3,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::Vec3>, rhs: f32| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as ::core::ops::Add<
                                f32,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "angle_between",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3::angle_between(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the angle (in radians) between two vectors in the range `[0, +π]`.\n The inputs do not need to be unit vectors however they must be non-zero.",
                &["_self", "rhs"],
            )
            .register_documented(
                "any_orthogonal_vector",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::any_orthogonal_vector(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns some vector that is orthogonal to the given one.\n The input vector must be finite and non-zero.\n The output vector is not necessarily unit length. For that use\n [`Self::any_orthonormal_vector()`] instead.",
                &["_self"],
            )
            .register_documented(
                "any_orthonormal_vector",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::any_orthonormal_vector(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns any unit vector that is orthogonal to the given one.\n The input vector must be unit length.\n # Panics\n Will panic if `self` is not normalized when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "as_dvec3",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::Vec3::as_dvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec3",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::Vec3::as_i16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec3",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::Vec3::as_i64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec3",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::Vec3::as_i8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec3",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::Vec3::as_ivec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec3",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::Vec3::as_u16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec3",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::Vec3::as_u64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec3",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::Vec3::as_u8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec3",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::Vec3::as_uvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "ceil",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::ceil(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the smallest integer greater than or equal to a number for\n each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::Vec3>,
                    min: Val<bevy::math::Vec3>,
                    max: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`f32::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clamp_length",
                |_self: Val<bevy::math::Vec3>, min: f32, max: f32| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::clamp_length(
                                    _self.into_inner(),
                                    min,
                                    max,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no less than `min` and no more than `max`.\n # Panics\n Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clamp_length_max",
                |_self: Val<bevy::math::Vec3>, max: f32| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::clamp_length_max(
                                    _self.into_inner(),
                                    max,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no more than `max`.\n # Panics\n Will panic if `max` is negative when `glam_assert` is enabled.",
                &["_self", "max"],
            )
            .register_documented(
                "clamp_length_min",
                |_self: Val<bevy::math::Vec3>, min: f32| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::clamp_length_min(
                                    _self.into_inner(),
                                    min,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no less than `min`.\n # Panics\n Will panic if `min` is negative when `glam_assert` is enabled.",
                &["_self", "min"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::Vec3::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "copysign",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::copysign(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with signs of `rhs` and the magnitudes of `self`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cross",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::cross(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the cross product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3::distance(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the Euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::Vec3>, rhs: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as ::core::ops::Div<
                                &bevy::math::Vec3,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as ::core::ops::Div<
                                bevy::math::Vec3,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::Vec3>, rhs: f32| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as ::core::ops::Div<
                                f32,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::Vec3>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::Vec3>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::Vec3>, other: Ref<bevy::math::Vec3>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::Vec3 as ::core::cmp::PartialEq<
                                bevy::math::Vec3,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "exp",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::exp(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing `e^self` (the exponential function) for each element of\n `self`.",
                &["_self"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::Vec3>, w: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec3::extend(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` and the given `w` value.",
                &["_self", "w"],
            )
            .register_documented(
                "floor",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::floor(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the largest integer less than or equal to a number for each\n element of `self`.",
                &["_self"],
            )
            .register_documented(
                "fract",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::fract(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the fractional part of the vector as `self - self.trunc()`.\n Note that this differs from the GLSL implementation of `fract` which returns\n `self - self.floor()`.\n Note that this is fast but not precise for large numbers.",
                &["_self"],
            )
            .register_documented(
                "fract_gl",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::fract_gl(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the fractional part of the vector as `self - self.floor()`.\n Note that this differs from the Rust implementation of `fract` which returns\n `self - self.trunc()`.\n Note that this is fast but not precise for large numbers.",
                &["_self"],
            )
            .register_documented(
                "from_array",
                |a: [f32; 3]| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "is_finite",
                |_self: Val<bevy::math::Vec3>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Vec3::is_finite(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.  If any element is either\n `NaN`, positive or negative infinity, this will return `false`.",
                &["_self"],
            )
            .register_documented(
                "is_finite_mask",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::Vec3::is_finite_mask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs `is_finite` on each element of self, returning a vector mask of the results.\n In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Val<bevy::math::Vec3>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Vec3::is_nan(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NaN`.",
                &["_self"],
            )
            .register_documented(
                "is_nan_mask",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::Vec3::is_nan_mask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs `is_nan` on each element of self, returning a vector mask of the results.\n In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.",
                &["_self"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::Vec3>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::Vec3::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "is_normalized",
                |_self: Val<bevy::math::Vec3>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Vec3::is_normalized(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns whether `self` is length `1.0` or not.\n Uses a precision threshold of approximately `1e-4`.",
                &["_self"],
            )
            .register_documented(
                "length",
                |_self: Val<bevy::math::Vec3>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3::length(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the length of `self`.",
                &["_self"],
            )
            .register_documented(
                "length_recip",
                |_self: Val<bevy::math::Vec3>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3::length_recip(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes `1.0 / length()`.\n For valid results, `self` must _not_ be of length zero.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::Vec3>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.\n This is faster than `length()` as it avoids a square root operation.",
                &["_self"],
            )
            .register_documented(
                "lerp",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>, s: f32| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::lerp(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                    s,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs a linear interpolation between `self` and `rhs` based on the value `s`.\n When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result\n will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly\n extrapolated.",
                &["_self", "rhs", "s"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::Vec3>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "midpoint",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::midpoint(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Calculates the midpoint between `self` and `rhs`.\n The midpoint is the average of, or halfway point between, two vectors.\n `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`\n while being slightly cheaper to compute.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::Vec3>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "move_towards",
                |_self: Ref<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>, d: f32| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::move_towards(
                                    &_self,
                                    rhs.into_inner(),
                                    d,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Moves towards `rhs` based on the value `d`.\n When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to\n `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.",
                &["_self", "rhs", "d"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Vec3>, rhs: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as ::core::ops::Mul<
                                &bevy::math::Vec3,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as ::core::ops::Mul<
                                bevy::math::Vec3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Vec3>, rhs: f32| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as ::core::ops::Mul<
                                f32,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_add",
                |
                    _self: Val<bevy::math::Vec3>,
                    a: Val<bevy::math::Vec3>,
                    b: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::mul_add(
                                    _self.into_inner(),
                                    a.into_inner(),
                                    b.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding\n error, yielding a more accurate result than an unfused multiply-add.\n Using `mul_add` *may* be more performant than an unfused multiply-add if the target\n architecture has a dedicated fma CPU instruction. However, this is not always true,\n and will be heavily dependant on designing algorithms with specific target hardware in\n mind.",
                &["_self", "a", "b"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: f32, y: f32, z: f32| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::new(
                                    x,
                                    y,
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z"],
            )
            .register_documented(
                "normalize",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::normalize(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0.\n For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.\n See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].\n Panics\n Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "normalize_or",
                |_self: Val<bevy::math::Vec3>, fallback: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::normalize_or(
                                    _self.into_inner(),
                                    fallback.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0 if possible, else returns a\n fallback value.\n In particular, if the input is zero (or very close to zero), or non-finite,\n the result of this operation will be the fallback value.\n See also [`Self::try_normalize()`].",
                &["_self", "fallback"],
            )
            .register_documented(
                "normalize_or_zero",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::normalize_or_zero(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0 if possible, else returns zero.\n In particular, if the input is zero (or very close to zero), or non-finite,\n the result of this operation will be zero.\n See also [`Self::try_normalize()`].",
                &["_self"],
            )
            .register_documented(
                "powf",
                |_self: Val<bevy::math::Vec3>, n: f32| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::powf(
                                    _self.into_inner(),
                                    n,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing each element of `self` raised to the power of `n`.",
                &["_self", "n"],
            )
            .register_documented(
                "project_onto",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::project_onto(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector projection of `self` onto `rhs`.\n `rhs` must be of non-zero length.\n # Panics\n Will panic if `rhs` is zero length when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "project_onto_normalized",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::project_onto_normalized(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector projection of `self` onto `rhs`.\n `rhs` must be normalized.\n # Panics\n Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "recip",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::recip(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "reflect",
                |_self: Val<bevy::math::Vec3>, normal: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::reflect(
                                    _self.into_inner(),
                                    normal.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the reflection vector for a given incident vector `self` and surface normal\n `normal`.\n `normal` must be normalized.\n # Panics\n Will panic if `normal` is not normalized when `glam_assert` is enabled.",
                &["_self", "normal"],
            )
            .register_documented(
                "refract",
                |_self: Val<bevy::math::Vec3>, normal: Val<bevy::math::Vec3>, eta: f32| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::refract(
                                    _self.into_inner(),
                                    normal.into_inner(),
                                    eta,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the refraction direction for a given incident vector `self`, surface normal\n `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,\n a zero vector will be returned.\n `self` and `normal` must be normalized.\n # Panics\n Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.",
                &["_self", "normal", "eta"],
            )
            .register_documented(
                "reject_from",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::reject_from(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector rejection of `self` from `rhs`.\n The vector rejection is the vector perpendicular to the projection of `self` onto\n `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.\n `rhs` must be of non-zero length.\n # Panics\n Will panic if `rhs` has a length of zero when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "reject_from_normalized",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::reject_from_normalized(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector rejection of `self` from `rhs`.\n The vector rejection is the vector perpendicular to the projection of `self` onto\n `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.\n `rhs` must be normalized.\n # Panics\n Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::Vec3>, rhs: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as ::core::ops::Rem<
                                &bevy::math::Vec3,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as ::core::ops::Rem<
                                bevy::math::Vec3,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::Vec3>, rhs: f32| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as ::core::ops::Rem<
                                f32,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n [Euclidean division]: f32::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "round",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::round(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the nearest integer to a number for each element of `self`.\n Round half-way cases away from 0.0.",
                &["_self"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec3>,
                    if_true: Val<bevy::math::Vec3>,
                    if_false: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n - `1.0` if the number is positive, `+0.0` or `INFINITY`\n - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n - `NAN` if the number is `NAN`",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: f32| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::Vec3>, rhs: Ref<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as ::core::ops::Sub<
                                &bevy::math::Vec3,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::Vec3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as ::core::ops::Sub<
                                bevy::math::Vec3,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::Vec3>, rhs: f32| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Vec3 as ::core::ops::Sub<
                                f32,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::Vec3>| {
                    let output: [f32; 3] = {
                        {
                            let output: [f32; 3] = bevy::math::Vec3::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z]`",
                &["_self"],
            )
            .register_documented(
                "trunc",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::trunc(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the integer part each element of `self`. This means numbers are\n always truncated towards zero.",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec3::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.\n Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::Vec3>, x: f32| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::Vec3>, y: f32| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::Vec3>, z: f32| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec3::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::Vec3,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_socket_addr_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            ::core::net::SocketAddr,
        >::new(world)
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<::core::net::SocketAddr>| {
                    let output: () = {
                        {
                            let output: () = <::core::net::SocketAddr as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<::core::net::SocketAddr>| {
                    let output: Val<::core::net::SocketAddr> = {
                        {
                            let output: Val<::core::net::SocketAddr> = <::core::net::SocketAddr as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "eq",
                |
                    _self: Ref<::core::net::SocketAddr>,
                    other: Ref<::core::net::SocketAddr>|
                {
                    let output: bool = {
                        {
                            let output: bool = <::core::net::SocketAddr as ::core::cmp::PartialEq<
                                ::core::net::SocketAddr,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "is_ipv4",
                |_self: Ref<::core::net::SocketAddr>| {
                    let output: bool = {
                        {
                            let output: bool = ::core::net::SocketAddr::is_ipv4(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns [`true`] if the [IP address] in this `SocketAddr` is an\n [`IPv4` address], and [`false`] otherwise.\n [IP address]: IpAddr\n [`IPv4` address]: IpAddr::V4\n # Examples\n ```\n use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n assert_eq!(socket.is_ipv4(), true);\n assert_eq!(socket.is_ipv6(), false);\n ```",
                &["_self"],
            )
            .register_documented(
                "is_ipv6",
                |_self: Ref<::core::net::SocketAddr>| {
                    let output: bool = {
                        {
                            let output: bool = ::core::net::SocketAddr::is_ipv6(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns [`true`] if the [IP address] in this `SocketAddr` is an\n [`IPv6` address], and [`false`] otherwise.\n [IP address]: IpAddr\n [`IPv6` address]: IpAddr::V6\n # Examples\n ```\n use std::net::{IpAddr, Ipv6Addr, SocketAddr};\n let socket = SocketAddr::new(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 0, 1)), 8080);\n assert_eq!(socket.is_ipv4(), false);\n assert_eq!(socket.is_ipv6(), true);\n ```",
                &["_self"],
            )
            .register_documented(
                "port",
                |_self: Ref<::core::net::SocketAddr>| {
                    let output: u16 = {
                        {
                            let output: u16 = ::core::net::SocketAddr::port(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the port number associated with this socket address.\n # Examples\n ```\n use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n assert_eq!(socket.port(), 8080);\n ```",
                &["_self"],
            )
            .register_documented(
                "set_port",
                |mut _self: Mut<::core::net::SocketAddr>, new_port: u16| {
                    let output: () = {
                        {
                            let output: () = ::core::net::SocketAddr::set_port(
                                    &mut _self,
                                    new_port,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Changes the port number associated with this socket address.\n # Examples\n ```\n use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n let mut socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n socket.set_port(1025);\n assert_eq!(socket.port(), 1025);\n ```",
                &["_self", "new_port"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                ::core::net::SocketAddr,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_i_vec_2_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::IVec2,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::IVec2>, rhs: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as ::core::ops::Add<
                                &bevy::math::IVec2,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as ::core::ops::Add<
                                bevy::math::IVec2,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::IVec2>, rhs: i32| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as ::core::ops::Add<
                                i32,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec2",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::IVec2::as_dvec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec2",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::IVec2::as_i16vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec2",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::IVec2::as_i64vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec2",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::IVec2::as_i8vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec2",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::IVec2::as_u16vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec2",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::IVec2::as_u64vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec2",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::IVec2::as_u8vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec2",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::IVec2::as_uvec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec2",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::IVec2::as_vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::IVec2 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::IVec2>,
                    min: Val<bevy::math::IVec2>,
                    max: Val<bevy::math::IVec2>|
                {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`i32::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::IVec2::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec2::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::IVec2>, rhs: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as ::core::ops::Div<
                                &bevy::math::IVec2,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as ::core::ops::Div<
                                bevy::math::IVec2,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::IVec2>, rhs: i32| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as ::core::ops::Div<
                                i32,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec2::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::IVec2>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec2::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::IVec2>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec2::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::IVec2>, other: Ref<bevy::math::IVec2>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::IVec2 as ::core::cmp::PartialEq<
                                bevy::math::IVec2,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::IVec2>, z: i32| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec2::extend(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` and the given `z` value.",
                &["_self", "z"],
            )
            .register_documented(
                "from_array",
                |a: [i32; 2]| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::IVec2>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::IVec2::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::IVec2>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec2::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::IVec2>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec2::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::IVec2>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec2::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::IVec2>, rhs: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as ::core::ops::Mul<
                                &bevy::math::IVec2,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as ::core::ops::Mul<
                                bevy::math::IVec2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::IVec2>, rhs: i32| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as ::core::ops::Mul<
                                i32,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: i32, y: i32| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::new(
                                    x,
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y"],
            )
            .register_documented(
                "perp",
                |_self: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::perp(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector that is equal to `self` rotated by 90 degrees.",
                &["_self"],
            )
            .register_documented(
                "perp_dot",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec2::perp_dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " The perpendicular dot product of `self` and `rhs`.\n Also known as the wedge product, 2D cross product, and determinant.",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::IVec2>, rhs: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as ::core::ops::Rem<
                                &bevy::math::IVec2,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as ::core::ops::Rem<
                                bevy::math::IVec2,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::IVec2>, rhs: i32| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as ::core::ops::Rem<
                                i32,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.\n [Euclidean division]: i32::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "rotate",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::rotate(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `rhs` rotated by the angle of `self`. If `self` is normalized,\n then this just rotation. This is what you usually want. Otherwise,\n it will be like a rotation with a multiplication by `self`'s length.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_unsigned",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub_unsigned",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::saturating_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec2>,
                    if_true: Val<bevy::math::IVec2>,
                    if_false: Val<bevy::math::IVec2>|
                {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n  - `0` if the number is zero\n  - `1` if the number is positive\n  - `-1` if the number is negative",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: i32| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::IVec2>, rhs: Ref<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as ::core::ops::Sub<
                                &bevy::math::IVec2,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as ::core::ops::Sub<
                                bevy::math::IVec2,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::IVec2>, rhs: i32| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = <bevy::math::IVec2 as ::core::ops::Sub<
                                i32,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::IVec2>| {
                    let output: [i32; 2] = {
                        {
                            let output: [i32; 2] = bevy::math::IVec2::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y]`",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::IVec2>, x: i32| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::IVec2>, y: i32| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_unsigned",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub_unsigned",
                |_self: Val<bevy::math::IVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec2::wrapping_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::IVec2,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_i_vec_3_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::IVec3,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::IVec3>, rhs: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as ::core::ops::Add<
                                &bevy::math::IVec3,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as ::core::ops::Add<
                                bevy::math::IVec3,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::IVec3>, rhs: i32| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as ::core::ops::Add<
                                i32,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec3",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::IVec3::as_dvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec3",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::IVec3::as_i16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec3",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::IVec3::as_i64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec3",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::IVec3::as_i8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec3",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::IVec3::as_u16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec3",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::IVec3::as_u64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec3",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::IVec3::as_u8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec3",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::IVec3::as_uvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec3",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::IVec3::as_vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec3a",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::IVec3::as_vec3a(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::IVec3 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::IVec3>,
                    min: Val<bevy::math::IVec3>,
                    max: Val<bevy::math::IVec3>|
                {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`i32::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::IVec3::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cross",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::cross(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the cross product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec3::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::IVec3>, rhs: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as ::core::ops::Div<
                                &bevy::math::IVec3,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as ::core::ops::Div<
                                bevy::math::IVec3,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::IVec3>, rhs: i32| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as ::core::ops::Div<
                                i32,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec3::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::IVec3>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec3::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::IVec3>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec3::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::IVec3>, other: Ref<bevy::math::IVec3>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::IVec3 as ::core::cmp::PartialEq<
                                bevy::math::IVec3,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::IVec3>, w: i32| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec3::extend(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` and the given `w` value.",
                &["_self", "w"],
            )
            .register_documented(
                "from_array",
                |a: [i32; 3]| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::IVec3>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::IVec3::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::IVec3>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec3::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::IVec3>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec3::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::IVec3>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec3::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::IVec3>, rhs: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as ::core::ops::Mul<
                                &bevy::math::IVec3,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as ::core::ops::Mul<
                                bevy::math::IVec3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::IVec3>, rhs: i32| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as ::core::ops::Mul<
                                i32,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: i32, y: i32, z: i32| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::new(
                                    x,
                                    y,
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::IVec3>, rhs: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as ::core::ops::Rem<
                                &bevy::math::IVec3,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as ::core::ops::Rem<
                                bevy::math::IVec3,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::IVec3>, rhs: i32| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as ::core::ops::Rem<
                                i32,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.\n [Euclidean division]: i32::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_unsigned",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub_unsigned",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::saturating_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec3>,
                    if_true: Val<bevy::math::IVec3>,
                    if_false: Val<bevy::math::IVec3>|
                {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n  - `0` if the number is zero\n  - `1` if the number is positive\n  - `-1` if the number is negative",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: i32| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::IVec3>, rhs: Ref<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as ::core::ops::Sub<
                                &bevy::math::IVec3,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as ::core::ops::Sub<
                                bevy::math::IVec3,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::IVec3>, rhs: i32| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = <bevy::math::IVec3 as ::core::ops::Sub<
                                i32,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::IVec3>| {
                    let output: [i32; 3] = {
                        {
                            let output: [i32; 3] = bevy::math::IVec3::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z]`",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::IVec3::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.\n Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::IVec3>, x: i32| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::IVec3>, y: i32| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::IVec3>, z: i32| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_unsigned",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub_unsigned",
                |_self: Val<bevy::math::IVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec3::wrapping_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::IVec3,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_i_vec_4_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::IVec4,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::IVec4>, rhs: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as ::core::ops::Add<
                                &bevy::math::IVec4,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as ::core::ops::Add<
                                bevy::math::IVec4,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::IVec4>, rhs: i32| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as ::core::ops::Add<
                                i32,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec4",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::IVec4::as_dvec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec4",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::IVec4::as_i16vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec4",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::IVec4::as_i64vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec4",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::IVec4::as_i8vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec4",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::IVec4::as_u16vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec4",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::IVec4::as_u64vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec4",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::IVec4::as_u8vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec4",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::IVec4::as_uvec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec4",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::IVec4::as_vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::IVec4 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::IVec4>,
                    min: Val<bevy::math::IVec4>,
                    max: Val<bevy::math::IVec4>|
                {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`i32::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::IVec4::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec4::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::IVec4>, rhs: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as ::core::ops::Div<
                                &bevy::math::IVec4,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as ::core::ops::Div<
                                bevy::math::IVec4,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::IVec4>, rhs: i32| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as ::core::ops::Div<
                                i32,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec4::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::IVec4>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec4::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::IVec4>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec4::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::IVec4>, other: Ref<bevy::math::IVec4>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::IVec4 as ::core::cmp::PartialEq<
                                bevy::math::IVec4,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "from_array",
                |a: [i32; 4]| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::IVec4>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::IVec4::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 4 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::IVec4>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec4::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::IVec4>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec4::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::IVec4>| {
                    let output: i32 = {
                        {
                            let output: i32 = bevy::math::IVec4::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::IVec4>, rhs: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as ::core::ops::Mul<
                                &bevy::math::IVec4,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as ::core::ops::Mul<
                                bevy::math::IVec4,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::IVec4>, rhs: i32| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as ::core::ops::Mul<
                                i32,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: i32, y: i32, z: i32, w: i32| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::new(
                                    x,
                                    y,
                                    z,
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z", "w"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::IVec4>, rhs: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as ::core::ops::Rem<
                                &bevy::math::IVec4,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as ::core::ops::Rem<
                                bevy::math::IVec4,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::IVec4>, rhs: i32| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as ::core::ops::Rem<
                                i32,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.\n [Euclidean division]: i32::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_unsigned",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub_unsigned",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::saturating_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec4>,
                    if_true: Val<bevy::math::IVec4>,
                    if_false: Val<bevy::math::IVec4>|
                {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n  - `0` if the number is zero\n  - `1` if the number is positive\n  - `-1` if the number is negative",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: i32| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::IVec4>, rhs: Ref<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as ::core::ops::Sub<
                                &bevy::math::IVec4,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as ::core::ops::Sub<
                                bevy::math::IVec4,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::IVec4>, rhs: i32| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = <bevy::math::IVec4 as ::core::ops::Sub<
                                i32,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::IVec4>| {
                    let output: [i32; 4] = {
                        {
                            let output: [i32; 4] = bevy::math::IVec4::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z, w]`",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::IVec4::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.\n Truncation to [`IVec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].",
                &["_self"],
            )
            .register_documented(
                "with_w",
                |_self: Val<bevy::math::IVec4>, w: i32| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::with_w(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `w`.",
                &["_self", "w"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::IVec4>, x: i32| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::IVec4>, y: i32| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::IVec4>, z: i32| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_unsigned",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub_unsigned",
                |_self: Val<bevy::math::IVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::IVec4::wrapping_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::IVec4,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_i_8_vec_2_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::I8Vec2,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I8Vec2>, rhs: Ref<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = <bevy::math::I8Vec2 as ::core::ops::Add<
                                &bevy::math::I8Vec2,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = <bevy::math::I8Vec2 as ::core::ops::Add<
                                bevy::math::I8Vec2,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I8Vec2>, rhs: i8| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = <bevy::math::I8Vec2 as ::core::ops::Add<
                                i8,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec2",
                |_self: Ref<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::I8Vec2::as_dvec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec2",
                |_self: Ref<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I8Vec2::as_i16vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec2",
                |_self: Ref<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I8Vec2::as_i64vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec2",
                |_self: Ref<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::I8Vec2::as_ivec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec2",
                |_self: Ref<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::I8Vec2::as_u16vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec2",
                |_self: Ref<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::I8Vec2::as_u64vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec2",
                |_self: Ref<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::I8Vec2::as_u8vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec2",
                |_self: Ref<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::I8Vec2::as_uvec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec2",
                |_self: Ref<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::I8Vec2::as_vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::I8Vec2>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::I8Vec2 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::I8Vec2>,
                    min: Val<bevy::math::I8Vec2>,
                    max: Val<bevy::math::I8Vec2>|
                {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`i8::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = <bevy::math::I8Vec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::I8Vec2::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::I8Vec2::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::I8Vec2::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::I8Vec2::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::I8Vec2::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::I8Vec2::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec2::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I8Vec2>, rhs: Ref<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = <bevy::math::I8Vec2 as ::core::ops::Div<
                                &bevy::math::I8Vec2,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = <bevy::math::I8Vec2 as ::core::ops::Div<
                                bevy::math::I8Vec2,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I8Vec2>, rhs: i8| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = <bevy::math::I8Vec2 as ::core::ops::Div<
                                i8,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec2::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::I8Vec2>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec2::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::I8Vec2>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec2::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::I8Vec2>, other: Ref<bevy::math::I8Vec2>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::I8Vec2 as ::core::cmp::PartialEq<
                                bevy::math::I8Vec2,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::I8Vec2>, z: i8| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec2::extend(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` and the given `z` value.",
                &["_self", "z"],
            )
            .register_documented(
                "from_array",
                |a: [i8; 2]| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::I8Vec2>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::I8Vec2::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::I8Vec2>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec2::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::I8Vec2>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec2::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::I8Vec2>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec2::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I8Vec2>, rhs: Ref<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = <bevy::math::I8Vec2 as ::core::ops::Mul<
                                &bevy::math::I8Vec2,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = <bevy::math::I8Vec2 as ::core::ops::Mul<
                                bevy::math::I8Vec2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I8Vec2>, rhs: i8| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = <bevy::math::I8Vec2 as ::core::ops::Mul<
                                i8,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = <bevy::math::I8Vec2 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: i8, y: i8| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::new(
                                    x,
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y"],
            )
            .register_documented(
                "perp",
                |_self: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::perp(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector that is equal to `self` rotated by 90 degrees.",
                &["_self"],
            )
            .register_documented(
                "perp_dot",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec2::perp_dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " The perpendicular dot product of `self` and `rhs`.\n Also known as the wedge product, 2D cross product, and determinant.",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I8Vec2>, rhs: Ref<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = <bevy::math::I8Vec2 as ::core::ops::Rem<
                                &bevy::math::I8Vec2,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = <bevy::math::I8Vec2 as ::core::ops::Rem<
                                bevy::math::I8Vec2,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I8Vec2>, rhs: i8| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = <bevy::math::I8Vec2 as ::core::ops::Rem<
                                i8,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.\n [Euclidean division]: i8::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "rotate",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::rotate(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `rhs` rotated by the angle of `self`. If `self` is normalized,\n then this just rotation. This is what you usually want. Otherwise,\n it will be like a rotation with a multiplication by `self`'s length.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_unsigned",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::saturating_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub_unsigned",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::saturating_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec2>,
                    if_true: Val<bevy::math::I8Vec2>,
                    if_false: Val<bevy::math::I8Vec2>|
                {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n  - `0` if the number is zero\n  - `1` if the number is positive\n  - `-1` if the number is negative",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: i8| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I8Vec2>, rhs: Ref<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = <bevy::math::I8Vec2 as ::core::ops::Sub<
                                &bevy::math::I8Vec2,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = <bevy::math::I8Vec2 as ::core::ops::Sub<
                                bevy::math::I8Vec2,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I8Vec2>, rhs: i8| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = <bevy::math::I8Vec2 as ::core::ops::Sub<
                                i8,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::I8Vec2>| {
                    let output: [i8; 2] = {
                        {
                            let output: [i8; 2] = bevy::math::I8Vec2::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y]`",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::I8Vec2>, x: i8| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::I8Vec2>, y: i8| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_unsigned",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::wrapping_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub_unsigned",
                |_self: Val<bevy::math::I8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec2::wrapping_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::I8Vec2,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_i_8_vec_3_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::I8Vec3,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I8Vec3>, rhs: Ref<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = <bevy::math::I8Vec3 as ::core::ops::Add<
                                &bevy::math::I8Vec3,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = <bevy::math::I8Vec3 as ::core::ops::Add<
                                bevy::math::I8Vec3,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I8Vec3>, rhs: i8| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = <bevy::math::I8Vec3 as ::core::ops::Add<
                                i8,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec3",
                |_self: Ref<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::I8Vec3::as_dvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec3",
                |_self: Ref<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I8Vec3::as_i16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec3",
                |_self: Ref<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I8Vec3::as_i64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec3",
                |_self: Ref<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::I8Vec3::as_ivec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec3",
                |_self: Ref<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::I8Vec3::as_u16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec3",
                |_self: Ref<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::I8Vec3::as_u64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec3",
                |_self: Ref<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::I8Vec3::as_u8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec3",
                |_self: Ref<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::I8Vec3::as_uvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec3",
                |_self: Ref<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::I8Vec3::as_vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec3a",
                |_self: Ref<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::I8Vec3::as_vec3a(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::I8Vec3>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::I8Vec3 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::I8Vec3>,
                    min: Val<bevy::math::I8Vec3>,
                    max: Val<bevy::math::I8Vec3>|
                {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`i8::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = <bevy::math::I8Vec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::I8Vec3::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::I8Vec3::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::I8Vec3::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::I8Vec3::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::I8Vec3::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::I8Vec3::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cross",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::cross(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the cross product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec3::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I8Vec3>, rhs: Ref<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = <bevy::math::I8Vec3 as ::core::ops::Div<
                                &bevy::math::I8Vec3,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = <bevy::math::I8Vec3 as ::core::ops::Div<
                                bevy::math::I8Vec3,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I8Vec3>, rhs: i8| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = <bevy::math::I8Vec3 as ::core::ops::Div<
                                i8,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec3::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::I8Vec3>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec3::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::I8Vec3>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec3::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::I8Vec3>, other: Ref<bevy::math::I8Vec3>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::I8Vec3 as ::core::cmp::PartialEq<
                                bevy::math::I8Vec3,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::I8Vec3>, w: i8| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec3::extend(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` and the given `w` value.",
                &["_self", "w"],
            )
            .register_documented(
                "from_array",
                |a: [i8; 3]| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::I8Vec3>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::I8Vec3::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::I8Vec3>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec3::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::I8Vec3>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec3::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::I8Vec3>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec3::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I8Vec3>, rhs: Ref<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = <bevy::math::I8Vec3 as ::core::ops::Mul<
                                &bevy::math::I8Vec3,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = <bevy::math::I8Vec3 as ::core::ops::Mul<
                                bevy::math::I8Vec3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I8Vec3>, rhs: i8| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = <bevy::math::I8Vec3 as ::core::ops::Mul<
                                i8,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = <bevy::math::I8Vec3 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: i8, y: i8, z: i8| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::new(
                                    x,
                                    y,
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I8Vec3>, rhs: Ref<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = <bevy::math::I8Vec3 as ::core::ops::Rem<
                                &bevy::math::I8Vec3,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = <bevy::math::I8Vec3 as ::core::ops::Rem<
                                bevy::math::I8Vec3,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I8Vec3>, rhs: i8| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = <bevy::math::I8Vec3 as ::core::ops::Rem<
                                i8,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.\n [Euclidean division]: i8::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_unsigned",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::saturating_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub_unsigned",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::saturating_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec3>,
                    if_true: Val<bevy::math::I8Vec3>,
                    if_false: Val<bevy::math::I8Vec3>|
                {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n  - `0` if the number is zero\n  - `1` if the number is positive\n  - `-1` if the number is negative",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: i8| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I8Vec3>, rhs: Ref<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = <bevy::math::I8Vec3 as ::core::ops::Sub<
                                &bevy::math::I8Vec3,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = <bevy::math::I8Vec3 as ::core::ops::Sub<
                                bevy::math::I8Vec3,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I8Vec3>, rhs: i8| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = <bevy::math::I8Vec3 as ::core::ops::Sub<
                                i8,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::I8Vec3>| {
                    let output: [i8; 3] = {
                        {
                            let output: [i8; 3] = bevy::math::I8Vec3::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z]`",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I8Vec3::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.\n Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::I8Vec3>, x: i8| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::I8Vec3>, y: i8| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::I8Vec3>, z: i8| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_unsigned",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::wrapping_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub_unsigned",
                |_self: Val<bevy::math::I8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec3::wrapping_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::I8Vec3,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_i_8_vec_4_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::I8Vec4,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I8Vec4>, rhs: Ref<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = <bevy::math::I8Vec4 as ::core::ops::Add<
                                &bevy::math::I8Vec4,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = <bevy::math::I8Vec4 as ::core::ops::Add<
                                bevy::math::I8Vec4,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I8Vec4>, rhs: i8| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = <bevy::math::I8Vec4 as ::core::ops::Add<
                                i8,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec4",
                |_self: Ref<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::I8Vec4::as_dvec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec4",
                |_self: Ref<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I8Vec4::as_i16vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec4",
                |_self: Ref<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I8Vec4::as_i64vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec4",
                |_self: Ref<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::I8Vec4::as_ivec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec4",
                |_self: Ref<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::I8Vec4::as_u16vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec4",
                |_self: Ref<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::I8Vec4::as_u64vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec4",
                |_self: Ref<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::I8Vec4::as_u8vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec4",
                |_self: Ref<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::I8Vec4::as_uvec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec4",
                |_self: Ref<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::I8Vec4::as_vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::I8Vec4>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::I8Vec4 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::I8Vec4>,
                    min: Val<bevy::math::I8Vec4>,
                    max: Val<bevy::math::I8Vec4>|
                {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`i8::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = <bevy::math::I8Vec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::I8Vec4::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::I8Vec4::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::I8Vec4::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::I8Vec4::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::I8Vec4::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::I8Vec4::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec4::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I8Vec4>, rhs: Ref<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = <bevy::math::I8Vec4 as ::core::ops::Div<
                                &bevy::math::I8Vec4,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = <bevy::math::I8Vec4 as ::core::ops::Div<
                                bevy::math::I8Vec4,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I8Vec4>, rhs: i8| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = <bevy::math::I8Vec4 as ::core::ops::Div<
                                i8,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec4::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::I8Vec4>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec4::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::I8Vec4>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec4::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::I8Vec4>, other: Ref<bevy::math::I8Vec4>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::I8Vec4 as ::core::cmp::PartialEq<
                                bevy::math::I8Vec4,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "from_array",
                |a: [i8; 4]| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::I8Vec4>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::I8Vec4::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 4 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::I8Vec4>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec4::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::I8Vec4>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec4::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::I8Vec4>| {
                    let output: i8 = {
                        {
                            let output: i8 = bevy::math::I8Vec4::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I8Vec4>, rhs: Ref<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = <bevy::math::I8Vec4 as ::core::ops::Mul<
                                &bevy::math::I8Vec4,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = <bevy::math::I8Vec4 as ::core::ops::Mul<
                                bevy::math::I8Vec4,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I8Vec4>, rhs: i8| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = <bevy::math::I8Vec4 as ::core::ops::Mul<
                                i8,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = <bevy::math::I8Vec4 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: i8, y: i8, z: i8, w: i8| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::new(
                                    x,
                                    y,
                                    z,
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z", "w"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I8Vec4>, rhs: Ref<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = <bevy::math::I8Vec4 as ::core::ops::Rem<
                                &bevy::math::I8Vec4,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = <bevy::math::I8Vec4 as ::core::ops::Rem<
                                bevy::math::I8Vec4,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I8Vec4>, rhs: i8| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = <bevy::math::I8Vec4 as ::core::ops::Rem<
                                i8,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.\n [Euclidean division]: i8::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_unsigned",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::saturating_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub_unsigned",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::saturating_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec4>,
                    if_true: Val<bevy::math::I8Vec4>,
                    if_false: Val<bevy::math::I8Vec4>|
                {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n  - `0` if the number is zero\n  - `1` if the number is positive\n  - `-1` if the number is negative",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: i8| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I8Vec4>, rhs: Ref<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = <bevy::math::I8Vec4 as ::core::ops::Sub<
                                &bevy::math::I8Vec4,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = <bevy::math::I8Vec4 as ::core::ops::Sub<
                                bevy::math::I8Vec4,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I8Vec4>, rhs: i8| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = <bevy::math::I8Vec4 as ::core::ops::Sub<
                                i8,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::I8Vec4>| {
                    let output: [i8; 4] = {
                        {
                            let output: [i8; 4] = bevy::math::I8Vec4::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z, w]`",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I8Vec4::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.\n Truncation to [`I8Vec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].",
                &["_self"],
            )
            .register_documented(
                "with_w",
                |_self: Val<bevy::math::I8Vec4>, w: i8| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::with_w(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `w`.",
                &["_self", "w"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::I8Vec4>, x: i8| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::I8Vec4>, y: i8| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::I8Vec4>, z: i8| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_unsigned",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::wrapping_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub_unsigned",
                |_self: Val<bevy::math::I8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I8Vec4::wrapping_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::I8Vec4,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_i_16_vec_2_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::I16Vec2,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I16Vec2>, rhs: Ref<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = <bevy::math::I16Vec2 as ::core::ops::Add<
                                &bevy::math::I16Vec2,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = <bevy::math::I16Vec2 as ::core::ops::Add<
                                bevy::math::I16Vec2,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I16Vec2>, rhs: i16| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = <bevy::math::I16Vec2 as ::core::ops::Add<
                                i16,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec2",
                |_self: Ref<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::I16Vec2::as_dvec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec2",
                |_self: Ref<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I16Vec2::as_i64vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec2",
                |_self: Ref<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I16Vec2::as_i8vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec2",
                |_self: Ref<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::I16Vec2::as_ivec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec2",
                |_self: Ref<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::I16Vec2::as_u16vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec2",
                |_self: Ref<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::I16Vec2::as_u64vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec2",
                |_self: Ref<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::I16Vec2::as_u8vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec2",
                |_self: Ref<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::I16Vec2::as_uvec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec2",
                |_self: Ref<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::I16Vec2::as_vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::I16Vec2>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::I16Vec2 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::I16Vec2>,
                    min: Val<bevy::math::I16Vec2>,
                    max: Val<bevy::math::I16Vec2>|
                {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`i16::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = <bevy::math::I16Vec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::I16Vec2::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::I16Vec2::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::I16Vec2::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::I16Vec2::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::I16Vec2::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::I16Vec2::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec2::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I16Vec2>, rhs: Ref<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = <bevy::math::I16Vec2 as ::core::ops::Div<
                                &bevy::math::I16Vec2,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = <bevy::math::I16Vec2 as ::core::ops::Div<
                                bevy::math::I16Vec2,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I16Vec2>, rhs: i16| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = <bevy::math::I16Vec2 as ::core::ops::Div<
                                i16,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec2::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::I16Vec2>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec2::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::I16Vec2>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec2::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::I16Vec2>, other: Ref<bevy::math::I16Vec2>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::I16Vec2 as ::core::cmp::PartialEq<
                                bevy::math::I16Vec2,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::I16Vec2>, z: i16| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec2::extend(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` and the given `z` value.",
                &["_self", "z"],
            )
            .register_documented(
                "from_array",
                |a: [i16; 2]| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::I16Vec2>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::I16Vec2::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::I16Vec2>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec2::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::I16Vec2>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec2::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::I16Vec2>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec2::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I16Vec2>, rhs: Ref<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = <bevy::math::I16Vec2 as ::core::ops::Mul<
                                &bevy::math::I16Vec2,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = <bevy::math::I16Vec2 as ::core::ops::Mul<
                                bevy::math::I16Vec2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I16Vec2>, rhs: i16| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = <bevy::math::I16Vec2 as ::core::ops::Mul<
                                i16,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = <bevy::math::I16Vec2 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: i16, y: i16| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::new(
                                    x,
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y"],
            )
            .register_documented(
                "perp",
                |_self: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::perp(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector that is equal to `self` rotated by 90 degrees.",
                &["_self"],
            )
            .register_documented(
                "perp_dot",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec2::perp_dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " The perpendicular dot product of `self` and `rhs`.\n Also known as the wedge product, 2D cross product, and determinant.",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I16Vec2>, rhs: Ref<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = <bevy::math::I16Vec2 as ::core::ops::Rem<
                                &bevy::math::I16Vec2,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = <bevy::math::I16Vec2 as ::core::ops::Rem<
                                bevy::math::I16Vec2,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I16Vec2>, rhs: i16| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = <bevy::math::I16Vec2 as ::core::ops::Rem<
                                i16,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.\n [Euclidean division]: i16::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "rotate",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::rotate(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `rhs` rotated by the angle of `self`. If `self` is normalized,\n then this just rotation. This is what you usually want. Otherwise,\n it will be like a rotation with a multiplication by `self`'s length.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_unsigned",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::saturating_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub_unsigned",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::saturating_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec2>,
                    if_true: Val<bevy::math::I16Vec2>,
                    if_false: Val<bevy::math::I16Vec2>|
                {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n  - `0` if the number is zero\n  - `1` if the number is positive\n  - `-1` if the number is negative",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: i16| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I16Vec2>, rhs: Ref<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = <bevy::math::I16Vec2 as ::core::ops::Sub<
                                &bevy::math::I16Vec2,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = <bevy::math::I16Vec2 as ::core::ops::Sub<
                                bevy::math::I16Vec2,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I16Vec2>, rhs: i16| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = <bevy::math::I16Vec2 as ::core::ops::Sub<
                                i16,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::I16Vec2>| {
                    let output: [i16; 2] = {
                        {
                            let output: [i16; 2] = bevy::math::I16Vec2::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y]`",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::I16Vec2>, x: i16| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::I16Vec2>, y: i16| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_unsigned",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::wrapping_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub_unsigned",
                |_self: Val<bevy::math::I16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec2::wrapping_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::I16Vec2,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_i_16_vec_3_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::I16Vec3,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I16Vec3>, rhs: Ref<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = <bevy::math::I16Vec3 as ::core::ops::Add<
                                &bevy::math::I16Vec3,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = <bevy::math::I16Vec3 as ::core::ops::Add<
                                bevy::math::I16Vec3,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I16Vec3>, rhs: i16| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = <bevy::math::I16Vec3 as ::core::ops::Add<
                                i16,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec3",
                |_self: Ref<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::I16Vec3::as_dvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec3",
                |_self: Ref<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I16Vec3::as_i64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec3",
                |_self: Ref<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I16Vec3::as_i8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec3",
                |_self: Ref<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::I16Vec3::as_ivec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec3",
                |_self: Ref<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::I16Vec3::as_u16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec3",
                |_self: Ref<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::I16Vec3::as_u64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec3",
                |_self: Ref<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::I16Vec3::as_u8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec3",
                |_self: Ref<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::I16Vec3::as_uvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec3",
                |_self: Ref<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::I16Vec3::as_vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec3a",
                |_self: Ref<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::I16Vec3::as_vec3a(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::I16Vec3>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::I16Vec3 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::I16Vec3>,
                    min: Val<bevy::math::I16Vec3>,
                    max: Val<bevy::math::I16Vec3>|
                {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`i16::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = <bevy::math::I16Vec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::I16Vec3::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::I16Vec3::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::I16Vec3::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::I16Vec3::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::I16Vec3::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::I16Vec3::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cross",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::cross(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the cross product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec3::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I16Vec3>, rhs: Ref<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = <bevy::math::I16Vec3 as ::core::ops::Div<
                                &bevy::math::I16Vec3,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = <bevy::math::I16Vec3 as ::core::ops::Div<
                                bevy::math::I16Vec3,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I16Vec3>, rhs: i16| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = <bevy::math::I16Vec3 as ::core::ops::Div<
                                i16,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec3::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::I16Vec3>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec3::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::I16Vec3>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec3::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::I16Vec3>, other: Ref<bevy::math::I16Vec3>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::I16Vec3 as ::core::cmp::PartialEq<
                                bevy::math::I16Vec3,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::I16Vec3>, w: i16| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec3::extend(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` and the given `w` value.",
                &["_self", "w"],
            )
            .register_documented(
                "from_array",
                |a: [i16; 3]| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::I16Vec3>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::I16Vec3::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::I16Vec3>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec3::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::I16Vec3>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec3::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::I16Vec3>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec3::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I16Vec3>, rhs: Ref<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = <bevy::math::I16Vec3 as ::core::ops::Mul<
                                &bevy::math::I16Vec3,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = <bevy::math::I16Vec3 as ::core::ops::Mul<
                                bevy::math::I16Vec3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I16Vec3>, rhs: i16| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = <bevy::math::I16Vec3 as ::core::ops::Mul<
                                i16,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = <bevy::math::I16Vec3 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: i16, y: i16, z: i16| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::new(
                                    x,
                                    y,
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I16Vec3>, rhs: Ref<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = <bevy::math::I16Vec3 as ::core::ops::Rem<
                                &bevy::math::I16Vec3,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = <bevy::math::I16Vec3 as ::core::ops::Rem<
                                bevy::math::I16Vec3,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I16Vec3>, rhs: i16| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = <bevy::math::I16Vec3 as ::core::ops::Rem<
                                i16,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.\n [Euclidean division]: i16::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_unsigned",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::saturating_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub_unsigned",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::saturating_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec3>,
                    if_true: Val<bevy::math::I16Vec3>,
                    if_false: Val<bevy::math::I16Vec3>|
                {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n  - `0` if the number is zero\n  - `1` if the number is positive\n  - `-1` if the number is negative",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: i16| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I16Vec3>, rhs: Ref<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = <bevy::math::I16Vec3 as ::core::ops::Sub<
                                &bevy::math::I16Vec3,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = <bevy::math::I16Vec3 as ::core::ops::Sub<
                                bevy::math::I16Vec3,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I16Vec3>, rhs: i16| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = <bevy::math::I16Vec3 as ::core::ops::Sub<
                                i16,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::I16Vec3>| {
                    let output: [i16; 3] = {
                        {
                            let output: [i16; 3] = bevy::math::I16Vec3::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z]`",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I16Vec3::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.\n Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::I16Vec3>, x: i16| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::I16Vec3>, y: i16| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::I16Vec3>, z: i16| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_unsigned",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::wrapping_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub_unsigned",
                |_self: Val<bevy::math::I16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec3::wrapping_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::I16Vec3,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_i_16_vec_4_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::I16Vec4,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I16Vec4>, rhs: Ref<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = <bevy::math::I16Vec4 as ::core::ops::Add<
                                &bevy::math::I16Vec4,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = <bevy::math::I16Vec4 as ::core::ops::Add<
                                bevy::math::I16Vec4,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I16Vec4>, rhs: i16| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = <bevy::math::I16Vec4 as ::core::ops::Add<
                                i16,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec4",
                |_self: Ref<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::I16Vec4::as_dvec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec4",
                |_self: Ref<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I16Vec4::as_i64vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec4",
                |_self: Ref<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I16Vec4::as_i8vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec4",
                |_self: Ref<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::I16Vec4::as_ivec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec4",
                |_self: Ref<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::I16Vec4::as_u16vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec4",
                |_self: Ref<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::I16Vec4::as_u64vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec4",
                |_self: Ref<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::I16Vec4::as_u8vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec4",
                |_self: Ref<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::I16Vec4::as_uvec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec4",
                |_self: Ref<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::I16Vec4::as_vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::I16Vec4>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::I16Vec4 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::I16Vec4>,
                    min: Val<bevy::math::I16Vec4>,
                    max: Val<bevy::math::I16Vec4>|
                {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`i16::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = <bevy::math::I16Vec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::I16Vec4::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::I16Vec4::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::I16Vec4::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::I16Vec4::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::I16Vec4::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::I16Vec4::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec4::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I16Vec4>, rhs: Ref<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = <bevy::math::I16Vec4 as ::core::ops::Div<
                                &bevy::math::I16Vec4,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = <bevy::math::I16Vec4 as ::core::ops::Div<
                                bevy::math::I16Vec4,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I16Vec4>, rhs: i16| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = <bevy::math::I16Vec4 as ::core::ops::Div<
                                i16,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec4::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::I16Vec4>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec4::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::I16Vec4>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec4::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::I16Vec4>, other: Ref<bevy::math::I16Vec4>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::I16Vec4 as ::core::cmp::PartialEq<
                                bevy::math::I16Vec4,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "from_array",
                |a: [i16; 4]| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::I16Vec4>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::I16Vec4::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 4 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::I16Vec4>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec4::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::I16Vec4>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec4::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::I16Vec4>| {
                    let output: i16 = {
                        {
                            let output: i16 = bevy::math::I16Vec4::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I16Vec4>, rhs: Ref<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = <bevy::math::I16Vec4 as ::core::ops::Mul<
                                &bevy::math::I16Vec4,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = <bevy::math::I16Vec4 as ::core::ops::Mul<
                                bevy::math::I16Vec4,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I16Vec4>, rhs: i16| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = <bevy::math::I16Vec4 as ::core::ops::Mul<
                                i16,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = <bevy::math::I16Vec4 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: i16, y: i16, z: i16, w: i16| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::new(
                                    x,
                                    y,
                                    z,
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z", "w"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I16Vec4>, rhs: Ref<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = <bevy::math::I16Vec4 as ::core::ops::Rem<
                                &bevy::math::I16Vec4,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = <bevy::math::I16Vec4 as ::core::ops::Rem<
                                bevy::math::I16Vec4,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I16Vec4>, rhs: i16| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = <bevy::math::I16Vec4 as ::core::ops::Rem<
                                i16,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.\n [Euclidean division]: i16::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_unsigned",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::saturating_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub_unsigned",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::saturating_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec4>,
                    if_true: Val<bevy::math::I16Vec4>,
                    if_false: Val<bevy::math::I16Vec4>|
                {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n  - `0` if the number is zero\n  - `1` if the number is positive\n  - `-1` if the number is negative",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: i16| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I16Vec4>, rhs: Ref<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = <bevy::math::I16Vec4 as ::core::ops::Sub<
                                &bevy::math::I16Vec4,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = <bevy::math::I16Vec4 as ::core::ops::Sub<
                                bevy::math::I16Vec4,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I16Vec4>, rhs: i16| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = <bevy::math::I16Vec4 as ::core::ops::Sub<
                                i16,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::I16Vec4>| {
                    let output: [i16; 4] = {
                        {
                            let output: [i16; 4] = bevy::math::I16Vec4::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z, w]`",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I16Vec4::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.\n Truncation to [`I16Vec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].",
                &["_self"],
            )
            .register_documented(
                "with_w",
                |_self: Val<bevy::math::I16Vec4>, w: i16| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::with_w(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `w`.",
                &["_self", "w"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::I16Vec4>, x: i16| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::I16Vec4>, y: i16| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::I16Vec4>, z: i16| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_unsigned",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::wrapping_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub_unsigned",
                |_self: Val<bevy::math::I16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I16Vec4::wrapping_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::I16Vec4,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_i_64_vec_2_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::I64Vec2,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I64Vec2>, rhs: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as ::core::ops::Add<
                                &bevy::math::I64Vec2,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as ::core::ops::Add<
                                bevy::math::I64Vec2,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I64Vec2>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as ::core::ops::Add<
                                i64,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec2",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::I64Vec2::as_dvec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec2",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::I64Vec2::as_i16vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec2",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::I64Vec2::as_i8vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec2",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::I64Vec2::as_ivec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec2",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::I64Vec2::as_u16vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec2",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::I64Vec2::as_u64vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec2",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::I64Vec2::as_u8vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec2",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::I64Vec2::as_uvec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec2",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::I64Vec2::as_vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::I64Vec2 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::I64Vec2>,
                    min: Val<bevy::math::I64Vec2>,
                    max: Val<bevy::math::I64Vec2>|
                {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`i64::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::I64Vec2::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec2::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I64Vec2>, rhs: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as ::core::ops::Div<
                                &bevy::math::I64Vec2,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as ::core::ops::Div<
                                bevy::math::I64Vec2,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I64Vec2>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as ::core::ops::Div<
                                i64,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec2::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec2::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec2::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::I64Vec2>, other: Ref<bevy::math::I64Vec2>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::I64Vec2 as ::core::cmp::PartialEq<
                                bevy::math::I64Vec2,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::I64Vec2>, z: i64| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec2::extend(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` and the given `z` value.",
                &["_self", "z"],
            )
            .register_documented(
                "from_array",
                |a: [i64; 2]| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::I64Vec2::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec2::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec2::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec2::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I64Vec2>, rhs: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as ::core::ops::Mul<
                                &bevy::math::I64Vec2,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as ::core::ops::Mul<
                                bevy::math::I64Vec2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I64Vec2>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as ::core::ops::Mul<
                                i64,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: i64, y: i64| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::new(
                                    x,
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y"],
            )
            .register_documented(
                "perp",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::perp(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector that is equal to `self` rotated by 90 degrees.",
                &["_self"],
            )
            .register_documented(
                "perp_dot",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec2::perp_dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " The perpendicular dot product of `self` and `rhs`.\n Also known as the wedge product, 2D cross product, and determinant.",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I64Vec2>, rhs: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as ::core::ops::Rem<
                                &bevy::math::I64Vec2,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as ::core::ops::Rem<
                                bevy::math::I64Vec2,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I64Vec2>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as ::core::ops::Rem<
                                i64,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.\n [Euclidean division]: i64::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "rotate",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::rotate(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `rhs` rotated by the angle of `self`. If `self` is normalized,\n then this just rotation. This is what you usually want. Otherwise,\n it will be like a rotation with a multiplication by `self`'s length.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_unsigned",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub_unsigned",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::saturating_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec2>,
                    if_true: Val<bevy::math::I64Vec2>,
                    if_false: Val<bevy::math::I64Vec2>|
                {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n  - `0` if the number is zero\n  - `1` if the number is positive\n  - `-1` if the number is negative",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: i64| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I64Vec2>, rhs: Ref<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as ::core::ops::Sub<
                                &bevy::math::I64Vec2,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as ::core::ops::Sub<
                                bevy::math::I64Vec2,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I64Vec2>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = <bevy::math::I64Vec2 as ::core::ops::Sub<
                                i64,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::I64Vec2>| {
                    let output: [i64; 2] = {
                        {
                            let output: [i64; 2] = bevy::math::I64Vec2::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y]`",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::I64Vec2>, x: i64| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::I64Vec2>, y: i64| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_unsigned",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub_unsigned",
                |_self: Val<bevy::math::I64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec2::wrapping_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::I64Vec2,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_i_64_vec_3_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::I64Vec3,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I64Vec3>, rhs: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as ::core::ops::Add<
                                &bevy::math::I64Vec3,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as ::core::ops::Add<
                                bevy::math::I64Vec3,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I64Vec3>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as ::core::ops::Add<
                                i64,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec3",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::I64Vec3::as_dvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec3",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::I64Vec3::as_i16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec3",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::I64Vec3::as_i8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec3",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::I64Vec3::as_ivec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec3",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::I64Vec3::as_u16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec3",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::I64Vec3::as_u64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec3",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::I64Vec3::as_u8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec3",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::I64Vec3::as_uvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec3",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::I64Vec3::as_vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec3a",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::I64Vec3::as_vec3a(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::I64Vec3 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::I64Vec3>,
                    min: Val<bevy::math::I64Vec3>,
                    max: Val<bevy::math::I64Vec3>|
                {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`i64::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::I64Vec3::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cross",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::cross(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the cross product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec3::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I64Vec3>, rhs: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as ::core::ops::Div<
                                &bevy::math::I64Vec3,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as ::core::ops::Div<
                                bevy::math::I64Vec3,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I64Vec3>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as ::core::ops::Div<
                                i64,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec3::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec3::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec3::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::I64Vec3>, other: Ref<bevy::math::I64Vec3>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::I64Vec3 as ::core::cmp::PartialEq<
                                bevy::math::I64Vec3,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::I64Vec3>, w: i64| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec3::extend(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` and the given `w` value.",
                &["_self", "w"],
            )
            .register_documented(
                "from_array",
                |a: [i64; 3]| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::I64Vec3::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec3::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec3::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec3::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I64Vec3>, rhs: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as ::core::ops::Mul<
                                &bevy::math::I64Vec3,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as ::core::ops::Mul<
                                bevy::math::I64Vec3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I64Vec3>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as ::core::ops::Mul<
                                i64,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: i64, y: i64, z: i64| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::new(
                                    x,
                                    y,
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I64Vec3>, rhs: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as ::core::ops::Rem<
                                &bevy::math::I64Vec3,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as ::core::ops::Rem<
                                bevy::math::I64Vec3,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I64Vec3>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as ::core::ops::Rem<
                                i64,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.\n [Euclidean division]: i64::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_unsigned",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub_unsigned",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::saturating_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec3>,
                    if_true: Val<bevy::math::I64Vec3>,
                    if_false: Val<bevy::math::I64Vec3>|
                {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n  - `0` if the number is zero\n  - `1` if the number is positive\n  - `-1` if the number is negative",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: i64| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I64Vec3>, rhs: Ref<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as ::core::ops::Sub<
                                &bevy::math::I64Vec3,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as ::core::ops::Sub<
                                bevy::math::I64Vec3,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I64Vec3>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = <bevy::math::I64Vec3 as ::core::ops::Sub<
                                i64,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::I64Vec3>| {
                    let output: [i64; 3] = {
                        {
                            let output: [i64; 3] = bevy::math::I64Vec3::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z]`",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::I64Vec3::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.\n Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::I64Vec3>, x: i64| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::I64Vec3>, y: i64| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::I64Vec3>, z: i64| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_unsigned",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub_unsigned",
                |_self: Val<bevy::math::I64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec3::wrapping_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::I64Vec3,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_i_64_vec_4_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::I64Vec4,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I64Vec4>, rhs: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as ::core::ops::Add<
                                &bevy::math::I64Vec4,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as ::core::ops::Add<
                                bevy::math::I64Vec4,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::I64Vec4>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as ::core::ops::Add<
                                i64,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec4",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::I64Vec4::as_dvec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec4",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::I64Vec4::as_i16vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec4",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::I64Vec4::as_i8vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec4",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::I64Vec4::as_ivec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec4",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::I64Vec4::as_u16vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec4",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::I64Vec4::as_u64vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec4",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::I64Vec4::as_u8vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec4",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::I64Vec4::as_uvec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec4",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::I64Vec4::as_vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::I64Vec4 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::I64Vec4>,
                    min: Val<bevy::math::I64Vec4>,
                    max: Val<bevy::math::I64Vec4>|
                {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`i64::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::I64Vec4::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec4::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I64Vec4>, rhs: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as ::core::ops::Div<
                                &bevy::math::I64Vec4,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as ::core::ops::Div<
                                bevy::math::I64Vec4,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::I64Vec4>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as ::core::ops::Div<
                                i64,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec4::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec4::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec4::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::I64Vec4>, other: Ref<bevy::math::I64Vec4>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::I64Vec4 as ::core::cmp::PartialEq<
                                bevy::math::I64Vec4,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "from_array",
                |a: [i64; 4]| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::I64Vec4::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 4 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec4::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec4::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: i64 = {
                        {
                            let output: i64 = bevy::math::I64Vec4::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I64Vec4>, rhs: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as ::core::ops::Mul<
                                &bevy::math::I64Vec4,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as ::core::ops::Mul<
                                bevy::math::I64Vec4,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::I64Vec4>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as ::core::ops::Mul<
                                i64,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: i64, y: i64, z: i64, w: i64| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::new(
                                    x,
                                    y,
                                    z,
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z", "w"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I64Vec4>, rhs: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as ::core::ops::Rem<
                                &bevy::math::I64Vec4,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as ::core::ops::Rem<
                                bevy::math::I64Vec4,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::I64Vec4>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as ::core::ops::Rem<
                                i64,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n # Panics\n This function will panic if any `rhs` element is 0 or the division results in overflow.\n [Euclidean division]: i64::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_unsigned",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " In other words this computes `[self.x.saturating_add_unsigned(rhs.x), self.y.saturating_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub_unsigned",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::saturating_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.saturating_sub_unsigned(rhs.x), self.y.saturating_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec4>,
                    if_true: Val<bevy::math::I64Vec4>,
                    if_false: Val<bevy::math::I64Vec4>|
                {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n  - `0` if the number is zero\n  - `1` if the number is positive\n  - `-1` if the number is negative",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: i64| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I64Vec4>, rhs: Ref<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as ::core::ops::Sub<
                                &bevy::math::I64Vec4,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as ::core::ops::Sub<
                                bevy::math::I64Vec4,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::I64Vec4>, rhs: i64| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = <bevy::math::I64Vec4 as ::core::ops::Sub<
                                i64,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::I64Vec4>| {
                    let output: [i64; 4] = {
                        {
                            let output: [i64; 4] = bevy::math::I64Vec4::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z, w]`",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::I64Vec4::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.\n Truncation to [`I64Vec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].",
                &["_self"],
            )
            .register_documented(
                "with_w",
                |_self: Val<bevy::math::I64Vec4>, w: i64| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::with_w(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `w`.",
                &["_self", "w"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::I64Vec4>, x: i64| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::I64Vec4>, y: i64| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::I64Vec4>, z: i64| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_unsigned",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_add_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_add_unsigned(rhs.x), self.y.wrapping_add_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub_unsigned",
                |_self: Val<bevy::math::I64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::I64Vec4::wrapping_sub_unsigned(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and unsigned vector `rhs`.\n In other words this computes `[self.x.wrapping_sub_unsigned(rhs.x), self.y.wrapping_sub_unsigned(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::I64Vec4,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_u_vec_2_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::UVec2,
        >::new(world)
            .register_documented(
                "add",
                |_self: Val<bevy::math::UVec2>, rhs: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as ::core::ops::Add<
                                &bevy::math::UVec2,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as ::core::ops::Add<
                                bevy::math::UVec2,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::UVec2>, rhs: u32| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as ::core::ops::Add<
                                u32,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec2",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::UVec2::as_dvec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec2",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::UVec2::as_i16vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec2",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::UVec2::as_i64vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec2",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::UVec2::as_i8vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec2",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::UVec2::as_ivec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec2",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::UVec2::as_u16vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec2",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::UVec2::as_u64vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec2",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::UVec2::as_u8vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_vec2",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::UVec2::as_vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::UVec2 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::UVec2>,
                    min: Val<bevy::math::UVec2>,
                    max: Val<bevy::math::UVec2>|
                {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`u32::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::UVec2::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::UVec2>, rhs: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as ::core::ops::Div<
                                &bevy::math::UVec2,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as ::core::ops::Div<
                                bevy::math::UVec2,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::UVec2>, rhs: u32| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as ::core::ops::Div<
                                u32,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::UVec2::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::UVec2>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::UVec2::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::UVec2>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::UVec2::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::UVec2>, other: Ref<bevy::math::UVec2>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::UVec2 as ::core::cmp::PartialEq<
                                bevy::math::UVec2,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::UVec2>, z: u32| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec2::extend(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` and the given `z` value.",
                &["_self", "z"],
            )
            .register_documented(
                "from_array",
                |a: [u32; 2]| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::UVec2>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::UVec2::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::UVec2>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::UVec2::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::UVec2>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::UVec2::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::UVec2>, rhs: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as ::core::ops::Mul<
                                &bevy::math::UVec2,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as ::core::ops::Mul<
                                bevy::math::UVec2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::UVec2>, rhs: u32| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as ::core::ops::Mul<
                                u32,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "new",
                |x: u32, y: u32| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::new(
                                    x,
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::UVec2>, rhs: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as ::core::ops::Rem<
                                &bevy::math::UVec2,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as ::core::ops::Rem<
                                bevy::math::UVec2,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::UVec2>, rhs: u32| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as ::core::ops::Rem<
                                u32,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_signed",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec2>,
                    if_true: Val<bevy::math::UVec2>,
                    if_false: Val<bevy::math::UVec2>|
                {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "splat",
                |v: u32| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::UVec2>, rhs: Ref<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as ::core::ops::Sub<
                                &bevy::math::UVec2,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as ::core::ops::Sub<
                                bevy::math::UVec2,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::UVec2>, rhs: u32| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = <bevy::math::UVec2 as ::core::ops::Sub<
                                u32,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::UVec2>| {
                    let output: [u32; 2] = {
                        {
                            let output: [u32; 2] = bevy::math::UVec2::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y]`",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::UVec2>, x: u32| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::UVec2>, y: u32| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_signed",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::IVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::UVec2>, rhs: Val<bevy::math::UVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec2::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::UVec2,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_u_vec_3_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::UVec3,
        >::new(world)
            .register_documented(
                "add",
                |_self: Val<bevy::math::UVec3>, rhs: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as ::core::ops::Add<
                                &bevy::math::UVec3,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as ::core::ops::Add<
                                bevy::math::UVec3,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::UVec3>, rhs: u32| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as ::core::ops::Add<
                                u32,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec3",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::UVec3::as_dvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec3",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::UVec3::as_i16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec3",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::UVec3::as_i64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec3",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::UVec3::as_i8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec3",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::UVec3::as_ivec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec3",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::UVec3::as_u16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec3",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::UVec3::as_u64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec3",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::UVec3::as_u8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_vec3",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::UVec3::as_vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec3a",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::UVec3::as_vec3a(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::UVec3 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::UVec3>,
                    min: Val<bevy::math::UVec3>,
                    max: Val<bevy::math::UVec3>|
                {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`u32::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::UVec3::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cross",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::cross(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the cross product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::UVec3>, rhs: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as ::core::ops::Div<
                                &bevy::math::UVec3,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as ::core::ops::Div<
                                bevy::math::UVec3,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::UVec3>, rhs: u32| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as ::core::ops::Div<
                                u32,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::UVec3::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::UVec3>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::UVec3::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::UVec3>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::UVec3::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::UVec3>, other: Ref<bevy::math::UVec3>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::UVec3 as ::core::cmp::PartialEq<
                                bevy::math::UVec3,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::UVec3>, w: u32| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec3::extend(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` and the given `w` value.",
                &["_self", "w"],
            )
            .register_documented(
                "from_array",
                |a: [u32; 3]| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::UVec3>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::UVec3::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::UVec3>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::UVec3::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::UVec3>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::UVec3::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::UVec3>, rhs: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as ::core::ops::Mul<
                                &bevy::math::UVec3,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as ::core::ops::Mul<
                                bevy::math::UVec3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::UVec3>, rhs: u32| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as ::core::ops::Mul<
                                u32,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "new",
                |x: u32, y: u32, z: u32| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::new(
                                    x,
                                    y,
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::UVec3>, rhs: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as ::core::ops::Rem<
                                &bevy::math::UVec3,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as ::core::ops::Rem<
                                bevy::math::UVec3,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::UVec3>, rhs: u32| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as ::core::ops::Rem<
                                u32,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_signed",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec3>,
                    if_true: Val<bevy::math::UVec3>,
                    if_false: Val<bevy::math::UVec3>|
                {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "splat",
                |v: u32| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::UVec3>, rhs: Ref<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as ::core::ops::Sub<
                                &bevy::math::UVec3,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as ::core::ops::Sub<
                                bevy::math::UVec3,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::UVec3>, rhs: u32| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = <bevy::math::UVec3 as ::core::ops::Sub<
                                u32,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::UVec3>| {
                    let output: [u32; 3] = {
                        {
                            let output: [u32; 3] = bevy::math::UVec3::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z]`",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::UVec3::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.\n Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::UVec3>, x: u32| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::UVec3>, y: u32| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::UVec3>, z: u32| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_signed",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::IVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::UVec3>, rhs: Val<bevy::math::UVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec3::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::UVec3,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_u_vec_4_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::UVec4,
        >::new(world)
            .register_documented(
                "add",
                |_self: Val<bevy::math::UVec4>, rhs: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as ::core::ops::Add<
                                &bevy::math::UVec4,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as ::core::ops::Add<
                                bevy::math::UVec4,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::UVec4>, rhs: u32| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as ::core::ops::Add<
                                u32,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec4",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::UVec4::as_dvec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec4",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::UVec4::as_i16vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec4",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::UVec4::as_i64vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec4",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::UVec4::as_i8vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec4",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::UVec4::as_ivec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec4",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::UVec4::as_u16vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec4",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::UVec4::as_u64vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec4",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::UVec4::as_u8vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_vec4",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::UVec4::as_vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::UVec4 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::UVec4>,
                    min: Val<bevy::math::UVec4>,
                    max: Val<bevy::math::UVec4>|
                {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`u32::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::UVec4::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::UVec4>, rhs: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as ::core::ops::Div<
                                &bevy::math::UVec4,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as ::core::ops::Div<
                                bevy::math::UVec4,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::UVec4>, rhs: u32| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as ::core::ops::Div<
                                u32,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::UVec4::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::UVec4>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::UVec4::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::UVec4>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::UVec4::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::UVec4>, other: Ref<bevy::math::UVec4>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::UVec4 as ::core::cmp::PartialEq<
                                bevy::math::UVec4,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "from_array",
                |a: [u32; 4]| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::UVec4>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::UVec4::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::UVec4>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::UVec4::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::UVec4>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::UVec4::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::UVec4>, rhs: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as ::core::ops::Mul<
                                &bevy::math::UVec4,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as ::core::ops::Mul<
                                bevy::math::UVec4,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::UVec4>, rhs: u32| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as ::core::ops::Mul<
                                u32,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "new",
                |x: u32, y: u32, z: u32, w: u32| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::new(
                                    x,
                                    y,
                                    z,
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z", "w"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::UVec4>, rhs: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as ::core::ops::Rem<
                                &bevy::math::UVec4,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as ::core::ops::Rem<
                                bevy::math::UVec4,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::UVec4>, rhs: u32| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as ::core::ops::Rem<
                                u32,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_signed",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec4>,
                    if_true: Val<bevy::math::UVec4>,
                    if_false: Val<bevy::math::UVec4>|
                {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "splat",
                |v: u32| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::UVec4>, rhs: Ref<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as ::core::ops::Sub<
                                &bevy::math::UVec4,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as ::core::ops::Sub<
                                bevy::math::UVec4,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::UVec4>, rhs: u32| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = <bevy::math::UVec4 as ::core::ops::Sub<
                                u32,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::UVec4>| {
                    let output: [u32; 4] = {
                        {
                            let output: [u32; 4] = bevy::math::UVec4::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z, w]`",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::UVec4::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.\n Truncation to [`UVec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].",
                &["_self"],
            )
            .register_documented(
                "with_w",
                |_self: Val<bevy::math::UVec4>, w: u32| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::with_w(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `w`.",
                &["_self", "w"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::UVec4>, x: u32| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::UVec4>, y: u32| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::UVec4>, z: u32| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_signed",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::IVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::UVec4>, rhs: Val<bevy::math::UVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::UVec4::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::UVec4,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_u_8_vec_2_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::U8Vec2,
        >::new(world)
            .register_documented(
                "add",
                |_self: Val<bevy::math::U8Vec2>, rhs: Ref<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = <bevy::math::U8Vec2 as ::core::ops::Add<
                                &bevy::math::U8Vec2,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = <bevy::math::U8Vec2 as ::core::ops::Add<
                                bevy::math::U8Vec2,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::U8Vec2>, rhs: u8| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = <bevy::math::U8Vec2 as ::core::ops::Add<
                                u8,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec2",
                |_self: Ref<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::U8Vec2::as_dvec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec2",
                |_self: Ref<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::U8Vec2::as_i16vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec2",
                |_self: Ref<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::U8Vec2::as_i64vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec2",
                |_self: Ref<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::U8Vec2::as_i8vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec2",
                |_self: Ref<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::U8Vec2::as_ivec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec2",
                |_self: Ref<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U8Vec2::as_u16vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec2",
                |_self: Ref<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U8Vec2::as_u64vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec2",
                |_self: Ref<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::U8Vec2::as_uvec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec2",
                |_self: Ref<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::U8Vec2::as_vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::U8Vec2>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::U8Vec2 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::U8Vec2>,
                    min: Val<bevy::math::U8Vec2>,
                    max: Val<bevy::math::U8Vec2>|
                {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`u8::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = <bevy::math::U8Vec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::U8Vec2::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::U8Vec2::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::U8Vec2::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::U8Vec2::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::U8Vec2::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::U8Vec2::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U8Vec2>, rhs: Ref<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = <bevy::math::U8Vec2 as ::core::ops::Div<
                                &bevy::math::U8Vec2,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = <bevy::math::U8Vec2 as ::core::ops::Div<
                                bevy::math::U8Vec2,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U8Vec2>, rhs: u8| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = <bevy::math::U8Vec2 as ::core::ops::Div<
                                u8,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: u8 = {
                        {
                            let output: u8 = bevy::math::U8Vec2::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::U8Vec2>| {
                    let output: u8 = {
                        {
                            let output: u8 = bevy::math::U8Vec2::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::U8Vec2>| {
                    let output: u8 = {
                        {
                            let output: u8 = bevy::math::U8Vec2::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::U8Vec2>, other: Ref<bevy::math::U8Vec2>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::U8Vec2 as ::core::cmp::PartialEq<
                                bevy::math::U8Vec2,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::U8Vec2>, z: u8| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec2::extend(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` and the given `z` value.",
                &["_self", "z"],
            )
            .register_documented(
                "from_array",
                |a: [u8; 2]| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::U8Vec2>| {
                    let output: u8 = {
                        {
                            let output: u8 = bevy::math::U8Vec2::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::U8Vec2>| {
                    let output: u8 = {
                        {
                            let output: u8 = bevy::math::U8Vec2::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::U8Vec2>| {
                    let output: u8 = {
                        {
                            let output: u8 = bevy::math::U8Vec2::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U8Vec2>, rhs: Ref<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = <bevy::math::U8Vec2 as ::core::ops::Mul<
                                &bevy::math::U8Vec2,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = <bevy::math::U8Vec2 as ::core::ops::Mul<
                                bevy::math::U8Vec2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U8Vec2>, rhs: u8| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = <bevy::math::U8Vec2 as ::core::ops::Mul<
                                u8,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "new",
                |x: u8, y: u8| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::new(
                                    x,
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U8Vec2>, rhs: Ref<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = <bevy::math::U8Vec2 as ::core::ops::Rem<
                                &bevy::math::U8Vec2,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = <bevy::math::U8Vec2 as ::core::ops::Rem<
                                bevy::math::U8Vec2,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U8Vec2>, rhs: u8| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = <bevy::math::U8Vec2 as ::core::ops::Rem<
                                u8,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_signed",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::saturating_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec2>,
                    if_true: Val<bevy::math::U8Vec2>,
                    if_false: Val<bevy::math::U8Vec2>|
                {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "splat",
                |v: u8| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U8Vec2>, rhs: Ref<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = <bevy::math::U8Vec2 as ::core::ops::Sub<
                                &bevy::math::U8Vec2,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = <bevy::math::U8Vec2 as ::core::ops::Sub<
                                bevy::math::U8Vec2,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U8Vec2>, rhs: u8| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = <bevy::math::U8Vec2 as ::core::ops::Sub<
                                u8,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::U8Vec2>| {
                    let output: [u8; 2] = {
                        {
                            let output: [u8; 2] = bevy::math::U8Vec2::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y]`",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::U8Vec2>, x: u8| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::U8Vec2>, y: u8| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_signed",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::I8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::wrapping_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::U8Vec2>, rhs: Val<bevy::math::U8Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec2::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::U8Vec2,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_u_8_vec_3_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::U8Vec3,
        >::new(world)
            .register_documented(
                "add",
                |_self: Val<bevy::math::U8Vec3>, rhs: Ref<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = <bevy::math::U8Vec3 as ::core::ops::Add<
                                &bevy::math::U8Vec3,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = <bevy::math::U8Vec3 as ::core::ops::Add<
                                bevy::math::U8Vec3,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::U8Vec3>, rhs: u8| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = <bevy::math::U8Vec3 as ::core::ops::Add<
                                u8,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec3",
                |_self: Ref<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::U8Vec3::as_dvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec3",
                |_self: Ref<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::U8Vec3::as_i16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec3",
                |_self: Ref<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::U8Vec3::as_i64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec3",
                |_self: Ref<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::U8Vec3::as_i8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec3",
                |_self: Ref<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::U8Vec3::as_ivec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec3",
                |_self: Ref<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U8Vec3::as_u16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec3",
                |_self: Ref<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U8Vec3::as_u64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec3",
                |_self: Ref<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::U8Vec3::as_uvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec3",
                |_self: Ref<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::U8Vec3::as_vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec3a",
                |_self: Ref<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::U8Vec3::as_vec3a(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::U8Vec3>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::U8Vec3 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::U8Vec3>,
                    min: Val<bevy::math::U8Vec3>,
                    max: Val<bevy::math::U8Vec3>|
                {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`u8::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = <bevy::math::U8Vec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::U8Vec3::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::U8Vec3::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::U8Vec3::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::U8Vec3::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::U8Vec3::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::U8Vec3::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cross",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::cross(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the cross product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U8Vec3>, rhs: Ref<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = <bevy::math::U8Vec3 as ::core::ops::Div<
                                &bevy::math::U8Vec3,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = <bevy::math::U8Vec3 as ::core::ops::Div<
                                bevy::math::U8Vec3,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U8Vec3>, rhs: u8| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = <bevy::math::U8Vec3 as ::core::ops::Div<
                                u8,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: u8 = {
                        {
                            let output: u8 = bevy::math::U8Vec3::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::U8Vec3>| {
                    let output: u8 = {
                        {
                            let output: u8 = bevy::math::U8Vec3::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::U8Vec3>| {
                    let output: u8 = {
                        {
                            let output: u8 = bevy::math::U8Vec3::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::U8Vec3>, other: Ref<bevy::math::U8Vec3>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::U8Vec3 as ::core::cmp::PartialEq<
                                bevy::math::U8Vec3,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::U8Vec3>, w: u8| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec3::extend(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` and the given `w` value.",
                &["_self", "w"],
            )
            .register_documented(
                "from_array",
                |a: [u8; 3]| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::U8Vec3>| {
                    let output: u8 = {
                        {
                            let output: u8 = bevy::math::U8Vec3::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::U8Vec3>| {
                    let output: u8 = {
                        {
                            let output: u8 = bevy::math::U8Vec3::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::U8Vec3>| {
                    let output: u8 = {
                        {
                            let output: u8 = bevy::math::U8Vec3::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U8Vec3>, rhs: Ref<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = <bevy::math::U8Vec3 as ::core::ops::Mul<
                                &bevy::math::U8Vec3,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = <bevy::math::U8Vec3 as ::core::ops::Mul<
                                bevy::math::U8Vec3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U8Vec3>, rhs: u8| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = <bevy::math::U8Vec3 as ::core::ops::Mul<
                                u8,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "new",
                |x: u8, y: u8, z: u8| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::new(
                                    x,
                                    y,
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U8Vec3>, rhs: Ref<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = <bevy::math::U8Vec3 as ::core::ops::Rem<
                                &bevy::math::U8Vec3,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = <bevy::math::U8Vec3 as ::core::ops::Rem<
                                bevy::math::U8Vec3,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U8Vec3>, rhs: u8| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = <bevy::math::U8Vec3 as ::core::ops::Rem<
                                u8,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_signed",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::saturating_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec3>,
                    if_true: Val<bevy::math::U8Vec3>,
                    if_false: Val<bevy::math::U8Vec3>|
                {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "splat",
                |v: u8| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U8Vec3>, rhs: Ref<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = <bevy::math::U8Vec3 as ::core::ops::Sub<
                                &bevy::math::U8Vec3,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = <bevy::math::U8Vec3 as ::core::ops::Sub<
                                bevy::math::U8Vec3,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U8Vec3>, rhs: u8| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = <bevy::math::U8Vec3 as ::core::ops::Sub<
                                u8,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::U8Vec3>| {
                    let output: [u8; 3] = {
                        {
                            let output: [u8; 3] = bevy::math::U8Vec3::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z]`",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U8Vec3::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.\n Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::U8Vec3>, x: u8| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::U8Vec3>, y: u8| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::U8Vec3>, z: u8| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_signed",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::I8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::wrapping_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::U8Vec3>, rhs: Val<bevy::math::U8Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec3::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::U8Vec3,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_u_8_vec_4_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::U8Vec4,
        >::new(world)
            .register_documented(
                "add",
                |_self: Val<bevy::math::U8Vec4>, rhs: Ref<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = <bevy::math::U8Vec4 as ::core::ops::Add<
                                &bevy::math::U8Vec4,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = <bevy::math::U8Vec4 as ::core::ops::Add<
                                bevy::math::U8Vec4,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::U8Vec4>, rhs: u8| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = <bevy::math::U8Vec4 as ::core::ops::Add<
                                u8,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec4",
                |_self: Ref<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::U8Vec4::as_dvec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec4",
                |_self: Ref<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::U8Vec4::as_i16vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec4",
                |_self: Ref<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::U8Vec4::as_i64vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec4",
                |_self: Ref<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::U8Vec4::as_i8vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec4",
                |_self: Ref<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::U8Vec4::as_ivec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec4",
                |_self: Ref<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U8Vec4::as_u16vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec4",
                |_self: Ref<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U8Vec4::as_u64vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec4",
                |_self: Ref<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::U8Vec4::as_uvec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec4",
                |_self: Ref<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::U8Vec4::as_vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::U8Vec4>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::U8Vec4 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::U8Vec4>,
                    min: Val<bevy::math::U8Vec4>,
                    max: Val<bevy::math::U8Vec4>|
                {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`u8::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = <bevy::math::U8Vec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::U8Vec4::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::U8Vec4::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::U8Vec4::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::U8Vec4::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::U8Vec4::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::U8Vec4::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U8Vec4>, rhs: Ref<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = <bevy::math::U8Vec4 as ::core::ops::Div<
                                &bevy::math::U8Vec4,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = <bevy::math::U8Vec4 as ::core::ops::Div<
                                bevy::math::U8Vec4,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U8Vec4>, rhs: u8| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = <bevy::math::U8Vec4 as ::core::ops::Div<
                                u8,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: u8 = {
                        {
                            let output: u8 = bevy::math::U8Vec4::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::U8Vec4>| {
                    let output: u8 = {
                        {
                            let output: u8 = bevy::math::U8Vec4::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::U8Vec4>| {
                    let output: u8 = {
                        {
                            let output: u8 = bevy::math::U8Vec4::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::U8Vec4>, other: Ref<bevy::math::U8Vec4>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::U8Vec4 as ::core::cmp::PartialEq<
                                bevy::math::U8Vec4,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "from_array",
                |a: [u8; 4]| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::U8Vec4>| {
                    let output: u8 = {
                        {
                            let output: u8 = bevy::math::U8Vec4::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::U8Vec4>| {
                    let output: u8 = {
                        {
                            let output: u8 = bevy::math::U8Vec4::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::U8Vec4>| {
                    let output: u8 = {
                        {
                            let output: u8 = bevy::math::U8Vec4::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U8Vec4>, rhs: Ref<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = <bevy::math::U8Vec4 as ::core::ops::Mul<
                                &bevy::math::U8Vec4,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = <bevy::math::U8Vec4 as ::core::ops::Mul<
                                bevy::math::U8Vec4,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U8Vec4>, rhs: u8| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = <bevy::math::U8Vec4 as ::core::ops::Mul<
                                u8,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "new",
                |x: u8, y: u8, z: u8, w: u8| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::new(
                                    x,
                                    y,
                                    z,
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z", "w"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U8Vec4>, rhs: Ref<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = <bevy::math::U8Vec4 as ::core::ops::Rem<
                                &bevy::math::U8Vec4,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = <bevy::math::U8Vec4 as ::core::ops::Rem<
                                bevy::math::U8Vec4,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U8Vec4>, rhs: u8| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = <bevy::math::U8Vec4 as ::core::ops::Rem<
                                u8,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_signed",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::saturating_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec4>,
                    if_true: Val<bevy::math::U8Vec4>,
                    if_false: Val<bevy::math::U8Vec4>|
                {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "splat",
                |v: u8| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U8Vec4>, rhs: Ref<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = <bevy::math::U8Vec4 as ::core::ops::Sub<
                                &bevy::math::U8Vec4,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = <bevy::math::U8Vec4 as ::core::ops::Sub<
                                bevy::math::U8Vec4,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U8Vec4>, rhs: u8| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = <bevy::math::U8Vec4 as ::core::ops::Sub<
                                u8,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::U8Vec4>| {
                    let output: [u8; 4] = {
                        {
                            let output: [u8; 4] = bevy::math::U8Vec4::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z, w]`",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U8Vec4::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.\n Truncation to [`U8Vec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].",
                &["_self"],
            )
            .register_documented(
                "with_w",
                |_self: Val<bevy::math::U8Vec4>, w: u8| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::with_w(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `w`.",
                &["_self", "w"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::U8Vec4>, x: u8| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::U8Vec4>, y: u8| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::U8Vec4>, z: u8| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_signed",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::I8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::wrapping_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::U8Vec4>, rhs: Val<bevy::math::U8Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U8Vec4::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::U8Vec4,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_u_16_vec_2_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::U16Vec2,
        >::new(world)
            .register_documented(
                "add",
                |_self: Val<bevy::math::U16Vec2>, rhs: Ref<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = <bevy::math::U16Vec2 as ::core::ops::Add<
                                &bevy::math::U16Vec2,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = <bevy::math::U16Vec2 as ::core::ops::Add<
                                bevy::math::U16Vec2,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::U16Vec2>, rhs: u16| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = <bevy::math::U16Vec2 as ::core::ops::Add<
                                u16,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec2",
                |_self: Ref<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::U16Vec2::as_dvec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec2",
                |_self: Ref<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::U16Vec2::as_i16vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec2",
                |_self: Ref<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::U16Vec2::as_i64vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec2",
                |_self: Ref<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::U16Vec2::as_i8vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec2",
                |_self: Ref<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::U16Vec2::as_ivec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec2",
                |_self: Ref<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U16Vec2::as_u64vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec2",
                |_self: Ref<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U16Vec2::as_u8vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec2",
                |_self: Ref<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::U16Vec2::as_uvec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec2",
                |_self: Ref<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::U16Vec2::as_vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::U16Vec2>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::U16Vec2 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::U16Vec2>,
                    min: Val<bevy::math::U16Vec2>,
                    max: Val<bevy::math::U16Vec2>|
                {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`u16::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = <bevy::math::U16Vec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::U16Vec2::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::U16Vec2::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::U16Vec2::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::U16Vec2::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::U16Vec2::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::U16Vec2::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U16Vec2>, rhs: Ref<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = <bevy::math::U16Vec2 as ::core::ops::Div<
                                &bevy::math::U16Vec2,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = <bevy::math::U16Vec2 as ::core::ops::Div<
                                bevy::math::U16Vec2,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U16Vec2>, rhs: u16| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = <bevy::math::U16Vec2 as ::core::ops::Div<
                                u16,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: u16 = {
                        {
                            let output: u16 = bevy::math::U16Vec2::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::U16Vec2>| {
                    let output: u16 = {
                        {
                            let output: u16 = bevy::math::U16Vec2::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::U16Vec2>| {
                    let output: u16 = {
                        {
                            let output: u16 = bevy::math::U16Vec2::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::U16Vec2>, other: Ref<bevy::math::U16Vec2>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::U16Vec2 as ::core::cmp::PartialEq<
                                bevy::math::U16Vec2,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::U16Vec2>, z: u16| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec2::extend(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` and the given `z` value.",
                &["_self", "z"],
            )
            .register_documented(
                "from_array",
                |a: [u16; 2]| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::U16Vec2>| {
                    let output: u16 = {
                        {
                            let output: u16 = bevy::math::U16Vec2::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::U16Vec2>| {
                    let output: u16 = {
                        {
                            let output: u16 = bevy::math::U16Vec2::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::U16Vec2>| {
                    let output: u16 = {
                        {
                            let output: u16 = bevy::math::U16Vec2::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U16Vec2>, rhs: Ref<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = <bevy::math::U16Vec2 as ::core::ops::Mul<
                                &bevy::math::U16Vec2,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = <bevy::math::U16Vec2 as ::core::ops::Mul<
                                bevy::math::U16Vec2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U16Vec2>, rhs: u16| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = <bevy::math::U16Vec2 as ::core::ops::Mul<
                                u16,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "new",
                |x: u16, y: u16| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::new(
                                    x,
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U16Vec2>, rhs: Ref<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = <bevy::math::U16Vec2 as ::core::ops::Rem<
                                &bevy::math::U16Vec2,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = <bevy::math::U16Vec2 as ::core::ops::Rem<
                                bevy::math::U16Vec2,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U16Vec2>, rhs: u16| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = <bevy::math::U16Vec2 as ::core::ops::Rem<
                                u16,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_signed",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::saturating_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec2>,
                    if_true: Val<bevy::math::U16Vec2>,
                    if_false: Val<bevy::math::U16Vec2>|
                {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "splat",
                |v: u16| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U16Vec2>, rhs: Ref<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = <bevy::math::U16Vec2 as ::core::ops::Sub<
                                &bevy::math::U16Vec2,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = <bevy::math::U16Vec2 as ::core::ops::Sub<
                                bevy::math::U16Vec2,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U16Vec2>, rhs: u16| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = <bevy::math::U16Vec2 as ::core::ops::Sub<
                                u16,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::U16Vec2>| {
                    let output: [u16; 2] = {
                        {
                            let output: [u16; 2] = bevy::math::U16Vec2::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y]`",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::U16Vec2>, x: u16| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::U16Vec2>, y: u16| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_signed",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::I16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::wrapping_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::U16Vec2>, rhs: Val<bevy::math::U16Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec2::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::U16Vec2,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_u_16_vec_3_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::U16Vec3,
        >::new(world)
            .register_documented(
                "add",
                |_self: Val<bevy::math::U16Vec3>, rhs: Ref<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = <bevy::math::U16Vec3 as ::core::ops::Add<
                                &bevy::math::U16Vec3,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = <bevy::math::U16Vec3 as ::core::ops::Add<
                                bevy::math::U16Vec3,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::U16Vec3>, rhs: u16| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = <bevy::math::U16Vec3 as ::core::ops::Add<
                                u16,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec3",
                |_self: Ref<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::U16Vec3::as_dvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec3",
                |_self: Ref<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::U16Vec3::as_i16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec3",
                |_self: Ref<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::U16Vec3::as_i64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec3",
                |_self: Ref<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::U16Vec3::as_i8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec3",
                |_self: Ref<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::U16Vec3::as_ivec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec3",
                |_self: Ref<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U16Vec3::as_u64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec3",
                |_self: Ref<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U16Vec3::as_u8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec3",
                |_self: Ref<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::U16Vec3::as_uvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec3",
                |_self: Ref<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::U16Vec3::as_vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec3a",
                |_self: Ref<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::U16Vec3::as_vec3a(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::U16Vec3>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::U16Vec3 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::U16Vec3>,
                    min: Val<bevy::math::U16Vec3>,
                    max: Val<bevy::math::U16Vec3>|
                {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`u16::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = <bevy::math::U16Vec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::U16Vec3::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::U16Vec3::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::U16Vec3::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::U16Vec3::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::U16Vec3::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::U16Vec3::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cross",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::cross(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the cross product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U16Vec3>, rhs: Ref<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = <bevy::math::U16Vec3 as ::core::ops::Div<
                                &bevy::math::U16Vec3,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = <bevy::math::U16Vec3 as ::core::ops::Div<
                                bevy::math::U16Vec3,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U16Vec3>, rhs: u16| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = <bevy::math::U16Vec3 as ::core::ops::Div<
                                u16,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: u16 = {
                        {
                            let output: u16 = bevy::math::U16Vec3::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::U16Vec3>| {
                    let output: u16 = {
                        {
                            let output: u16 = bevy::math::U16Vec3::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::U16Vec3>| {
                    let output: u16 = {
                        {
                            let output: u16 = bevy::math::U16Vec3::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::U16Vec3>, other: Ref<bevy::math::U16Vec3>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::U16Vec3 as ::core::cmp::PartialEq<
                                bevy::math::U16Vec3,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::U16Vec3>, w: u16| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec3::extend(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` and the given `w` value.",
                &["_self", "w"],
            )
            .register_documented(
                "from_array",
                |a: [u16; 3]| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::U16Vec3>| {
                    let output: u16 = {
                        {
                            let output: u16 = bevy::math::U16Vec3::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::U16Vec3>| {
                    let output: u16 = {
                        {
                            let output: u16 = bevy::math::U16Vec3::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::U16Vec3>| {
                    let output: u16 = {
                        {
                            let output: u16 = bevy::math::U16Vec3::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U16Vec3>, rhs: Ref<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = <bevy::math::U16Vec3 as ::core::ops::Mul<
                                &bevy::math::U16Vec3,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = <bevy::math::U16Vec3 as ::core::ops::Mul<
                                bevy::math::U16Vec3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U16Vec3>, rhs: u16| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = <bevy::math::U16Vec3 as ::core::ops::Mul<
                                u16,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "new",
                |x: u16, y: u16, z: u16| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::new(
                                    x,
                                    y,
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U16Vec3>, rhs: Ref<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = <bevy::math::U16Vec3 as ::core::ops::Rem<
                                &bevy::math::U16Vec3,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = <bevy::math::U16Vec3 as ::core::ops::Rem<
                                bevy::math::U16Vec3,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U16Vec3>, rhs: u16| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = <bevy::math::U16Vec3 as ::core::ops::Rem<
                                u16,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_signed",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::saturating_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec3>,
                    if_true: Val<bevy::math::U16Vec3>,
                    if_false: Val<bevy::math::U16Vec3>|
                {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "splat",
                |v: u16| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U16Vec3>, rhs: Ref<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = <bevy::math::U16Vec3 as ::core::ops::Sub<
                                &bevy::math::U16Vec3,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = <bevy::math::U16Vec3 as ::core::ops::Sub<
                                bevy::math::U16Vec3,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U16Vec3>, rhs: u16| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = <bevy::math::U16Vec3 as ::core::ops::Sub<
                                u16,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::U16Vec3>| {
                    let output: [u16; 3] = {
                        {
                            let output: [u16; 3] = bevy::math::U16Vec3::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z]`",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U16Vec3::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.\n Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::U16Vec3>, x: u16| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::U16Vec3>, y: u16| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::U16Vec3>, z: u16| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_signed",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::I16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::wrapping_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::U16Vec3>, rhs: Val<bevy::math::U16Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec3::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::U16Vec3,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_u_16_vec_4_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::U16Vec4,
        >::new(world)
            .register_documented(
                "add",
                |_self: Val<bevy::math::U16Vec4>, rhs: Ref<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = <bevy::math::U16Vec4 as ::core::ops::Add<
                                &bevy::math::U16Vec4,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = <bevy::math::U16Vec4 as ::core::ops::Add<
                                bevy::math::U16Vec4,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::U16Vec4>, rhs: u16| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = <bevy::math::U16Vec4 as ::core::ops::Add<
                                u16,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec4",
                |_self: Ref<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::U16Vec4::as_dvec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec4",
                |_self: Ref<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::U16Vec4::as_i16vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec4",
                |_self: Ref<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::U16Vec4::as_i64vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec4",
                |_self: Ref<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::U16Vec4::as_i8vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec4",
                |_self: Ref<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::U16Vec4::as_ivec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec4",
                |_self: Ref<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U16Vec4::as_u64vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec4",
                |_self: Ref<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U16Vec4::as_u8vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec4",
                |_self: Ref<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::U16Vec4::as_uvec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec4",
                |_self: Ref<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::U16Vec4::as_vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::U16Vec4>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::U16Vec4 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::U16Vec4>,
                    min: Val<bevy::math::U16Vec4>,
                    max: Val<bevy::math::U16Vec4>|
                {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`u16::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = <bevy::math::U16Vec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::U16Vec4::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::U16Vec4::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::U16Vec4::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::U16Vec4::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::U16Vec4::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::U16Vec4::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U16Vec4>, rhs: Ref<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = <bevy::math::U16Vec4 as ::core::ops::Div<
                                &bevy::math::U16Vec4,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = <bevy::math::U16Vec4 as ::core::ops::Div<
                                bevy::math::U16Vec4,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U16Vec4>, rhs: u16| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = <bevy::math::U16Vec4 as ::core::ops::Div<
                                u16,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: u16 = {
                        {
                            let output: u16 = bevy::math::U16Vec4::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::U16Vec4>| {
                    let output: u16 = {
                        {
                            let output: u16 = bevy::math::U16Vec4::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::U16Vec4>| {
                    let output: u16 = {
                        {
                            let output: u16 = bevy::math::U16Vec4::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::U16Vec4>, other: Ref<bevy::math::U16Vec4>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::U16Vec4 as ::core::cmp::PartialEq<
                                bevy::math::U16Vec4,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "from_array",
                |a: [u16; 4]| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::U16Vec4>| {
                    let output: u16 = {
                        {
                            let output: u16 = bevy::math::U16Vec4::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::U16Vec4>| {
                    let output: u16 = {
                        {
                            let output: u16 = bevy::math::U16Vec4::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::U16Vec4>| {
                    let output: u16 = {
                        {
                            let output: u16 = bevy::math::U16Vec4::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U16Vec4>, rhs: Ref<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = <bevy::math::U16Vec4 as ::core::ops::Mul<
                                &bevy::math::U16Vec4,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = <bevy::math::U16Vec4 as ::core::ops::Mul<
                                bevy::math::U16Vec4,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U16Vec4>, rhs: u16| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = <bevy::math::U16Vec4 as ::core::ops::Mul<
                                u16,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "new",
                |x: u16, y: u16, z: u16, w: u16| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::new(
                                    x,
                                    y,
                                    z,
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z", "w"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U16Vec4>, rhs: Ref<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = <bevy::math::U16Vec4 as ::core::ops::Rem<
                                &bevy::math::U16Vec4,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = <bevy::math::U16Vec4 as ::core::ops::Rem<
                                bevy::math::U16Vec4,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U16Vec4>, rhs: u16| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = <bevy::math::U16Vec4 as ::core::ops::Rem<
                                u16,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_signed",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::saturating_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec4>,
                    if_true: Val<bevy::math::U16Vec4>,
                    if_false: Val<bevy::math::U16Vec4>|
                {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "splat",
                |v: u16| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U16Vec4>, rhs: Ref<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = <bevy::math::U16Vec4 as ::core::ops::Sub<
                                &bevy::math::U16Vec4,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = <bevy::math::U16Vec4 as ::core::ops::Sub<
                                bevy::math::U16Vec4,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U16Vec4>, rhs: u16| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = <bevy::math::U16Vec4 as ::core::ops::Sub<
                                u16,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::U16Vec4>| {
                    let output: [u16; 4] = {
                        {
                            let output: [u16; 4] = bevy::math::U16Vec4::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z, w]`",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U16Vec4::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.\n Truncation to [`U16Vec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].",
                &["_self"],
            )
            .register_documented(
                "with_w",
                |_self: Val<bevy::math::U16Vec4>, w: u16| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::with_w(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `w`.",
                &["_self", "w"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::U16Vec4>, x: u16| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::U16Vec4>, y: u16| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::U16Vec4>, z: u16| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_signed",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::I16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::wrapping_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::U16Vec4>, rhs: Val<bevy::math::U16Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U16Vec4::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::U16Vec4,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_u_64_vec_2_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::U64Vec2,
        >::new(world)
            .register_documented(
                "add",
                |_self: Val<bevy::math::U64Vec2>, rhs: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as ::core::ops::Add<
                                &bevy::math::U64Vec2,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as ::core::ops::Add<
                                bevy::math::U64Vec2,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::U64Vec2>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as ::core::ops::Add<
                                u64,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec2",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::U64Vec2::as_dvec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec2",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::U64Vec2::as_i16vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec2",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::U64Vec2::as_i64vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec2",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::U64Vec2::as_i8vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec2",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::U64Vec2::as_ivec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec2",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::U64Vec2::as_u16vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec2",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::U64Vec2::as_u8vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec2",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::U64Vec2::as_uvec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec2",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::U64Vec2::as_vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::U64Vec2 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::U64Vec2>,
                    min: Val<bevy::math::U64Vec2>,
                    max: Val<bevy::math::U64Vec2>|
                {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`u64::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::U64Vec2::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U64Vec2>, rhs: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as ::core::ops::Div<
                                &bevy::math::U64Vec2,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as ::core::ops::Div<
                                bevy::math::U64Vec2,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U64Vec2>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as ::core::ops::Div<
                                u64,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: u64 = {
                        {
                            let output: u64 = bevy::math::U64Vec2::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::U64Vec2>| {
                    let output: u64 = {
                        {
                            let output: u64 = bevy::math::U64Vec2::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::U64Vec2>| {
                    let output: u64 = {
                        {
                            let output: u64 = bevy::math::U64Vec2::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::U64Vec2>, other: Ref<bevy::math::U64Vec2>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::U64Vec2 as ::core::cmp::PartialEq<
                                bevy::math::U64Vec2,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::U64Vec2>, z: u64| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec2::extend(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` and the given `z` value.",
                &["_self", "z"],
            )
            .register_documented(
                "from_array",
                |a: [u64; 2]| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::U64Vec2>| {
                    let output: u64 = {
                        {
                            let output: u64 = bevy::math::U64Vec2::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::U64Vec2>| {
                    let output: u64 = {
                        {
                            let output: u64 = bevy::math::U64Vec2::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::U64Vec2>| {
                    let output: u64 = {
                        {
                            let output: u64 = bevy::math::U64Vec2::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U64Vec2>, rhs: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as ::core::ops::Mul<
                                &bevy::math::U64Vec2,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as ::core::ops::Mul<
                                bevy::math::U64Vec2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U64Vec2>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as ::core::ops::Mul<
                                u64,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "new",
                |x: u64, y: u64| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::new(
                                    x,
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U64Vec2>, rhs: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as ::core::ops::Rem<
                                &bevy::math::U64Vec2,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as ::core::ops::Rem<
                                bevy::math::U64Vec2,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U64Vec2>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as ::core::ops::Rem<
                                u64,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_signed",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec2>,
                    if_true: Val<bevy::math::U64Vec2>,
                    if_false: Val<bevy::math::U64Vec2>|
                {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "splat",
                |v: u64| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U64Vec2>, rhs: Ref<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as ::core::ops::Sub<
                                &bevy::math::U64Vec2,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as ::core::ops::Sub<
                                bevy::math::U64Vec2,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U64Vec2>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = <bevy::math::U64Vec2 as ::core::ops::Sub<
                                u64,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::U64Vec2>| {
                    let output: [u64; 2] = {
                        {
                            let output: [u64; 2] = bevy::math::U64Vec2::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y]`",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::U64Vec2>, x: u64| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::U64Vec2>, y: u64| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_signed",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::I64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::U64Vec2>, rhs: Val<bevy::math::U64Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec2::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::U64Vec2,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_u_64_vec_3_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::U64Vec3,
        >::new(world)
            .register_documented(
                "add",
                |_self: Val<bevy::math::U64Vec3>, rhs: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as ::core::ops::Add<
                                &bevy::math::U64Vec3,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as ::core::ops::Add<
                                bevy::math::U64Vec3,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::U64Vec3>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as ::core::ops::Add<
                                u64,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec3",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::U64Vec3::as_dvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec3",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::U64Vec3::as_i16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec3",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::U64Vec3::as_i64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec3",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::U64Vec3::as_i8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec3",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::U64Vec3::as_ivec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec3",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::U64Vec3::as_u16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec3",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::U64Vec3::as_u8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec3",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::U64Vec3::as_uvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec3",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::U64Vec3::as_vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec3a",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::U64Vec3::as_vec3a(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::U64Vec3 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::U64Vec3>,
                    min: Val<bevy::math::U64Vec3>,
                    max: Val<bevy::math::U64Vec3>|
                {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`u64::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::U64Vec3::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cross",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::cross(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the cross product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U64Vec3>, rhs: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as ::core::ops::Div<
                                &bevy::math::U64Vec3,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as ::core::ops::Div<
                                bevy::math::U64Vec3,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U64Vec3>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as ::core::ops::Div<
                                u64,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: u64 = {
                        {
                            let output: u64 = bevy::math::U64Vec3::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::U64Vec3>| {
                    let output: u64 = {
                        {
                            let output: u64 = bevy::math::U64Vec3::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::U64Vec3>| {
                    let output: u64 = {
                        {
                            let output: u64 = bevy::math::U64Vec3::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::U64Vec3>, other: Ref<bevy::math::U64Vec3>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::U64Vec3 as ::core::cmp::PartialEq<
                                bevy::math::U64Vec3,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::U64Vec3>, w: u64| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec3::extend(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` and the given `w` value.",
                &["_self", "w"],
            )
            .register_documented(
                "from_array",
                |a: [u64; 3]| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::U64Vec3>| {
                    let output: u64 = {
                        {
                            let output: u64 = bevy::math::U64Vec3::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::U64Vec3>| {
                    let output: u64 = {
                        {
                            let output: u64 = bevy::math::U64Vec3::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::U64Vec3>| {
                    let output: u64 = {
                        {
                            let output: u64 = bevy::math::U64Vec3::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U64Vec3>, rhs: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as ::core::ops::Mul<
                                &bevy::math::U64Vec3,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as ::core::ops::Mul<
                                bevy::math::U64Vec3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U64Vec3>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as ::core::ops::Mul<
                                u64,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "new",
                |x: u64, y: u64, z: u64| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::new(
                                    x,
                                    y,
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U64Vec3>, rhs: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as ::core::ops::Rem<
                                &bevy::math::U64Vec3,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as ::core::ops::Rem<
                                bevy::math::U64Vec3,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U64Vec3>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as ::core::ops::Rem<
                                u64,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_signed",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec3>,
                    if_true: Val<bevy::math::U64Vec3>,
                    if_false: Val<bevy::math::U64Vec3>|
                {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "splat",
                |v: u64| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U64Vec3>, rhs: Ref<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as ::core::ops::Sub<
                                &bevy::math::U64Vec3,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as ::core::ops::Sub<
                                bevy::math::U64Vec3,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U64Vec3>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = <bevy::math::U64Vec3 as ::core::ops::Sub<
                                u64,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::U64Vec3>| {
                    let output: [u64; 3] = {
                        {
                            let output: [u64; 3] = bevy::math::U64Vec3::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z]`",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::U64Vec3::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.\n Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::U64Vec3>, x: u64| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::U64Vec3>, y: u64| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::U64Vec3>, z: u64| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_signed",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::I64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::U64Vec3>, rhs: Val<bevy::math::U64Vec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec3::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::U64Vec3,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_u_64_vec_4_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::U64Vec4,
        >::new(world)
            .register_documented(
                "add",
                |_self: Val<bevy::math::U64Vec4>, rhs: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as ::core::ops::Add<
                                &bevy::math::U64Vec4,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as ::core::ops::Add<
                                bevy::math::U64Vec4,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::U64Vec4>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as ::core::ops::Add<
                                u64,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec4",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::U64Vec4::as_dvec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec4",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::U64Vec4::as_i16vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec4",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::U64Vec4::as_i64vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec4",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::U64Vec4::as_i8vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec4",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::U64Vec4::as_ivec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec4",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::U64Vec4::as_u16vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec4",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::U64Vec4::as_u8vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec4",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::U64Vec4::as_uvec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec4",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::U64Vec4::as_vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::U64Vec4 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::U64Vec4>,
                    min: Val<bevy::math::U64Vec4>,
                    max: Val<bevy::math::U64Vec4>|
                {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`u64::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::U64Vec4::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U64Vec4>, rhs: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as ::core::ops::Div<
                                &bevy::math::U64Vec4,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as ::core::ops::Div<
                                bevy::math::U64Vec4,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::U64Vec4>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as ::core::ops::Div<
                                u64,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: u64 = {
                        {
                            let output: u64 = bevy::math::U64Vec4::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::U64Vec4>| {
                    let output: u64 = {
                        {
                            let output: u64 = bevy::math::U64Vec4::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::U64Vec4>| {
                    let output: u64 = {
                        {
                            let output: u64 = bevy::math::U64Vec4::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::U64Vec4>, other: Ref<bevy::math::U64Vec4>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::U64Vec4 as ::core::cmp::PartialEq<
                                bevy::math::U64Vec4,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "from_array",
                |a: [u64; 4]| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::U64Vec4>| {
                    let output: u64 = {
                        {
                            let output: u64 = bevy::math::U64Vec4::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.",
                &["_self"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::U64Vec4>| {
                    let output: u64 = {
                        {
                            let output: u64 = bevy::math::U64Vec4::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::U64Vec4>| {
                    let output: u64 = {
                        {
                            let output: u64 = bevy::math::U64Vec4::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U64Vec4>, rhs: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as ::core::ops::Mul<
                                &bevy::math::U64Vec4,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as ::core::ops::Mul<
                                bevy::math::U64Vec4,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::U64Vec4>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as ::core::ops::Mul<
                                u64,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "new",
                |x: u64, y: u64, z: u64, w: u64| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::new(
                                    x,
                                    y,
                                    z,
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z", "w"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U64Vec4>, rhs: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as ::core::ops::Rem<
                                &bevy::math::U64Vec4,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as ::core::ops::Rem<
                                bevy::math::U64Vec4,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::U64Vec4>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as ::core::ops::Rem<
                                u64,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and `rhs`.\n In other words this computes `[self.x.saturating_add(rhs.x), self.y.saturating_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_add_signed",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.saturating_add_signed(rhs.x), self.y.saturating_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_div",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating division of `self` and `rhs`.\n In other words this computes `[self.x.saturating_div(rhs.x), self.y.saturating_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_mul",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating multiplication of `self` and `rhs`.\n In other words this computes `[self.x.saturating_mul(rhs.x), self.y.saturating_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "saturating_sub",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::saturating_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the saturating subtraction of `self` and `rhs`.\n In other words this computes `[self.x.saturating_sub(rhs.x), self.y.saturating_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec4>,
                    if_true: Val<bevy::math::U64Vec4>,
                    if_false: Val<bevy::math::U64Vec4>|
                {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "splat",
                |v: u64| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U64Vec4>, rhs: Ref<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as ::core::ops::Sub<
                                &bevy::math::U64Vec4,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as ::core::ops::Sub<
                                bevy::math::U64Vec4,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::U64Vec4>, rhs: u64| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = <bevy::math::U64Vec4 as ::core::ops::Sub<
                                u64,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::U64Vec4>| {
                    let output: [u64; 4] = {
                        {
                            let output: [u64; 4] = bevy::math::U64Vec4::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z, w]`",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::U64Vec4::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.\n Truncation to [`U64Vec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].",
                &["_self"],
            )
            .register_documented(
                "with_w",
                |_self: Val<bevy::math::U64Vec4>, w: u64| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::with_w(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `w`.",
                &["_self", "w"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::U64Vec4>, x: u64| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::U64Vec4>, y: u64| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::U64Vec4>, z: u64| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            )
            .register_documented(
                "wrapping_add",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_add(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_add(rhs.x), self.y.wrapping_add(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_add_signed",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::I64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_add_signed(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping addition of `self` and signed vector `rhs`.\n In other words this computes `[self.x.wrapping_add_signed(rhs.x), self.y.wrapping_add_signed(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_div",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_div(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping division of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_div(rhs.x), self.y.wrapping_div(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_mul",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_mul(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping multiplication of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_mul(rhs.x), self.y.wrapping_mul(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "wrapping_sub",
                |_self: Val<bevy::math::U64Vec4>, rhs: Val<bevy::math::U64Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::U64Vec4::wrapping_sub(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the wrapping subtraction of `self` and `rhs`.\n In other words this computes `[self.x.wrapping_sub(rhs.x), self.y.wrapping_sub(rhs.y), ..]`.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::U64Vec4,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_vec_2_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::Vec2,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Val<bevy::math::Vec2>,
                    rhs: Val<bevy::math::Vec2>,
                    max_abs_diff: f32|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Vec2::abs_diff_eq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs` is\n less than or equal to `max_abs_diff`.\n This can be used to compare if two vectors contain similar elements. It works best when\n comparing with a known value. The `max_abs_diff` that should be used used depends on\n the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::Vec2>, rhs: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as ::core::ops::Add<
                                &bevy::math::Vec2,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as ::core::ops::Add<
                                bevy::math::Vec2,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::Vec2>, rhs: f32| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as ::core::ops::Add<
                                f32,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "angle_between",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec2::angle_between(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "angle_to",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec2::angle_to(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the angle of rotation (in radians) from `self` to `rhs` in the range `[-π, +π]`.\n The inputs do not need to be unit vectors however they must be non-zero.",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec2",
                |_self: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::Vec2::as_dvec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec2",
                |_self: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::Vec2::as_i16vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec2",
                |_self: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::Vec2::as_i64vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec2",
                |_self: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::Vec2::as_i8vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec2",
                |_self: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::Vec2::as_ivec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec2",
                |_self: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::Vec2::as_u16vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec2",
                |_self: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::Vec2::as_u64vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec2",
                |_self: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::Vec2::as_u8vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec2",
                |_self: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::Vec2::as_uvec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "ceil",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::ceil(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the smallest integer greater than or equal to a number for\n each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::Vec2>,
                    min: Val<bevy::math::Vec2>,
                    max: Val<bevy::math::Vec2>|
                {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`f32::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clamp_length",
                |_self: Val<bevy::math::Vec2>, min: f32, max: f32| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::clamp_length(
                                    _self.into_inner(),
                                    min,
                                    max,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no less than `min` and no more than `max`.\n # Panics\n Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clamp_length_max",
                |_self: Val<bevy::math::Vec2>, max: f32| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::clamp_length_max(
                                    _self.into_inner(),
                                    max,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no more than `max`.\n # Panics\n Will panic if `max` is negative when `glam_assert` is enabled.",
                &["_self", "max"],
            )
            .register_documented(
                "clamp_length_min",
                |_self: Val<bevy::math::Vec2>, min: f32| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::clamp_length_min(
                                    _self.into_inner(),
                                    min,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no less than `min`.\n # Panics\n Will panic if `min` is negative when `glam_assert` is enabled.",
                &["_self", "min"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::Vec2::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "copysign",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::copysign(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with signs of `rhs` and the magnitudes of `self`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec2::distance(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the Euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec2::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::Vec2>, rhs: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as ::core::ops::Div<
                                &bevy::math::Vec2,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as ::core::ops::Div<
                                bevy::math::Vec2,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::Vec2>, rhs: f32| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as ::core::ops::Div<
                                f32,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec2::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::Vec2>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec2::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::Vec2>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec2::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::Vec2>, other: Ref<bevy::math::Vec2>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::Vec2 as ::core::cmp::PartialEq<
                                bevy::math::Vec2,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "exp",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::exp(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing `e^self` (the exponential function) for each element of\n `self`.",
                &["_self"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::Vec2>, z: f32| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec2::extend(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` and the given `z` value.",
                &["_self", "z"],
            )
            .register_documented(
                "floor",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::floor(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the largest integer less than or equal to a number for each\n element of `self`.",
                &["_self"],
            )
            .register_documented(
                "fract",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::fract(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the fractional part of the vector as `self - self.trunc()`.\n Note that this differs from the GLSL implementation of `fract` which returns\n `self - self.floor()`.\n Note that this is fast but not precise for large numbers.",
                &["_self"],
            )
            .register_documented(
                "fract_gl",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::fract_gl(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the fractional part of the vector as `self - self.floor()`.\n Note that this differs from the Rust implementation of `fract` which returns\n `self - self.trunc()`.\n Note that this is fast but not precise for large numbers.",
                &["_self"],
            )
            .register_documented(
                "from_angle",
                |angle: f32| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::from_angle(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector containing `[angle.cos(), angle.sin()]`. This can be used in\n conjunction with the [`rotate()`][Self::rotate()] method, e.g.\n `Vec2::from_angle(PI).rotate(Vec2::Y)` will create the vector `[-1, 0]`\n and rotate [`Vec2::Y`] around it returning `-Vec2::Y`.",
                &["angle"],
            )
            .register_documented(
                "from_array",
                |a: [f32; 2]| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "is_finite",
                |_self: Val<bevy::math::Vec2>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Vec2::is_finite(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.  If any element is either\n `NaN`, positive or negative infinity, this will return `false`.",
                &["_self"],
            )
            .register_documented(
                "is_finite_mask",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::Vec2::is_finite_mask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs `is_finite` on each element of self, returning a vector mask of the results.\n In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Val<bevy::math::Vec2>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Vec2::is_nan(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NaN`.",
                &["_self"],
            )
            .register_documented(
                "is_nan_mask",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::Vec2::is_nan_mask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs `is_nan` on each element of self, returning a vector mask of the results.\n In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.",
                &["_self"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::Vec2>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::Vec2::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "is_normalized",
                |_self: Val<bevy::math::Vec2>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Vec2::is_normalized(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns whether `self` is length `1.0` or not.\n Uses a precision threshold of approximately `1e-4`.",
                &["_self"],
            )
            .register_documented(
                "length",
                |_self: Val<bevy::math::Vec2>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec2::length(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the length of `self`.",
                &["_self"],
            )
            .register_documented(
                "length_recip",
                |_self: Val<bevy::math::Vec2>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec2::length_recip(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes `1.0 / length()`.\n For valid results, `self` must _not_ be of length zero.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::Vec2>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec2::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.\n This is faster than `length()` as it avoids a square root operation.",
                &["_self"],
            )
            .register_documented(
                "lerp",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>, s: f32| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::lerp(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                    s,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs a linear interpolation between `self` and `rhs` based on the value `s`.\n When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result\n will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly\n extrapolated.",
                &["_self", "rhs", "s"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::Vec2>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec2::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "midpoint",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::midpoint(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Calculates the midpoint between `self` and `rhs`.\n The midpoint is the average of, or halfway point between, two vectors.\n `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`\n while being slightly cheaper to compute.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::Vec2>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec2::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "move_towards",
                |_self: Ref<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>, d: f32| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::move_towards(
                                    &_self,
                                    rhs.into_inner(),
                                    d,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Moves towards `rhs` based on the value `d`.\n When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to\n `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.",
                &["_self", "rhs", "d"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Vec2>, rhs: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as ::core::ops::Mul<
                                &bevy::math::Vec2,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as ::core::ops::Mul<
                                bevy::math::Vec2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Vec2>, rhs: f32| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as ::core::ops::Mul<
                                f32,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_add",
                |
                    _self: Val<bevy::math::Vec2>,
                    a: Val<bevy::math::Vec2>,
                    b: Val<bevy::math::Vec2>|
                {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::mul_add(
                                    _self.into_inner(),
                                    a.into_inner(),
                                    b.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding\n error, yielding a more accurate result than an unfused multiply-add.\n Using `mul_add` *may* be more performant than an unfused multiply-add if the target\n architecture has a dedicated fma CPU instruction. However, this is not always true,\n and will be heavily dependant on designing algorithms with specific target hardware in\n mind.",
                &["_self", "a", "b"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: f32, y: f32| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::new(
                                    x,
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y"],
            )
            .register_documented(
                "normalize",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::normalize(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0.\n For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.\n See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].\n Panics\n Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "normalize_or",
                |_self: Val<bevy::math::Vec2>, fallback: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::normalize_or(
                                    _self.into_inner(),
                                    fallback.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0 if possible, else returns a\n fallback value.\n In particular, if the input is zero (or very close to zero), or non-finite,\n the result of this operation will be the fallback value.\n See also [`Self::try_normalize()`].",
                &["_self", "fallback"],
            )
            .register_documented(
                "normalize_or_zero",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::normalize_or_zero(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0 if possible, else returns zero.\n In particular, if the input is zero (or very close to zero), or non-finite,\n the result of this operation will be zero.\n See also [`Self::try_normalize()`].",
                &["_self"],
            )
            .register_documented(
                "perp",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::perp(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector that is equal to `self` rotated by 90 degrees.",
                &["_self"],
            )
            .register_documented(
                "perp_dot",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec2::perp_dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " The perpendicular dot product of `self` and `rhs`.\n Also known as the wedge product, 2D cross product, and determinant.",
                &["_self", "rhs"],
            )
            .register_documented(
                "powf",
                |_self: Val<bevy::math::Vec2>, n: f32| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::powf(
                                    _self.into_inner(),
                                    n,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing each element of `self` raised to the power of `n`.",
                &["_self", "n"],
            )
            .register_documented(
                "project_onto",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::project_onto(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector projection of `self` onto `rhs`.\n `rhs` must be of non-zero length.\n # Panics\n Will panic if `rhs` is zero length when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "project_onto_normalized",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::project_onto_normalized(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector projection of `self` onto `rhs`.\n `rhs` must be normalized.\n # Panics\n Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "recip",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::recip(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "reflect",
                |_self: Val<bevy::math::Vec2>, normal: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::reflect(
                                    _self.into_inner(),
                                    normal.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the reflection vector for a given incident vector `self` and surface normal\n `normal`.\n `normal` must be normalized.\n # Panics\n Will panic if `normal` is not normalized when `glam_assert` is enabled.",
                &["_self", "normal"],
            )
            .register_documented(
                "refract",
                |_self: Val<bevy::math::Vec2>, normal: Val<bevy::math::Vec2>, eta: f32| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::refract(
                                    _self.into_inner(),
                                    normal.into_inner(),
                                    eta,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the refraction direction for a given incident vector `self`, surface normal\n `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,\n a zero vector will be returned.\n `self` and `normal` must be normalized.\n # Panics\n Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.",
                &["_self", "normal", "eta"],
            )
            .register_documented(
                "reject_from",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::reject_from(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector rejection of `self` from `rhs`.\n The vector rejection is the vector perpendicular to the projection of `self` onto\n `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.\n `rhs` must be of non-zero length.\n # Panics\n Will panic if `rhs` has a length of zero when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "reject_from_normalized",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::reject_from_normalized(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector rejection of `self` from `rhs`.\n The vector rejection is the vector perpendicular to the projection of `self` onto\n `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.\n `rhs` must be normalized.\n # Panics\n Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::Vec2>, rhs: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as ::core::ops::Rem<
                                &bevy::math::Vec2,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as ::core::ops::Rem<
                                bevy::math::Vec2,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::Vec2>, rhs: f32| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as ::core::ops::Rem<
                                f32,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n [Euclidean division]: f32::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "rotate",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::rotate(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `rhs` rotated by the angle of `self`. If `self` is normalized,\n then this just rotation. This is what you usually want. Otherwise,\n it will be like a rotation with a multiplication by `self`'s length.",
                &["_self", "rhs"],
            )
            .register_documented(
                "rotate_towards",
                |
                    _self: Ref<bevy::math::Vec2>,
                    rhs: Val<bevy::math::Vec2>,
                    max_angle: f32|
                {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::rotate_towards(
                                    &_self,
                                    rhs.into_inner(),
                                    max_angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Rotates towards `rhs` up to `max_angle` (in radians).\n When `max_angle` is `0.0`, the result will be equal to `self`. When `max_angle` is equal to\n `self.angle_between(rhs)`, the result will be equal to `rhs`. If `max_angle` is negative,\n rotates towards the exact opposite of `rhs`. Will not go past the target.",
                &["_self", "rhs", "max_angle"],
            )
            .register_documented(
                "round",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::round(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the nearest integer to a number for each element of `self`.\n Round half-way cases away from 0.0.",
                &["_self"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec2>,
                    if_true: Val<bevy::math::Vec2>,
                    if_false: Val<bevy::math::Vec2>|
                {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n - `1.0` if the number is positive, `+0.0` or `INFINITY`\n - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n - `NAN` if the number is `NAN`",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: f32| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::Vec2>, rhs: Ref<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as ::core::ops::Sub<
                                &bevy::math::Vec2,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::Vec2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as ::core::ops::Sub<
                                bevy::math::Vec2,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::Vec2>, rhs: f32| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = <bevy::math::Vec2 as ::core::ops::Sub<
                                f32,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_angle",
                |_self: Val<bevy::math::Vec2>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec2::to_angle(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the angle (in radians) of this vector in the range `[-π, +π]`.\n The input does not need to be a unit vector however it must be non-zero.",
                &["_self"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::Vec2>| {
                    let output: [f32; 2] = {
                        {
                            let output: [f32; 2] = bevy::math::Vec2::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y]`",
                &["_self"],
            )
            .register_documented(
                "trunc",
                |_self: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::trunc(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the integer part each element of `self`. This means numbers are\n always truncated towards zero.",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::Vec2>, x: f32| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::Vec2>, y: f32| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec2::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::Vec2,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_vec_3_a_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::Vec3A,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Val<bevy::math::Vec3A>,
                    rhs: Val<bevy::math::Vec3A>,
                    max_abs_diff: f32|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Vec3A::abs_diff_eq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs` is\n less than or equal to `max_abs_diff`.\n This can be used to compare if two vectors contain similar elements. It works best when\n comparing with a known value. The `max_abs_diff` that should be used used depends on\n the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as ::core::ops::Add<
                                &bevy::math::Vec3A,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as ::core::ops::Add<
                                bevy::math::Vec3A,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::Vec3A>, rhs: f32| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as ::core::ops::Add<
                                f32,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "angle_between",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3A::angle_between(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the angle (in radians) between two vectors in the range `[0, +π]`.\n The inputs do not need to be unit vectors however they must be non-zero.",
                &["_self", "rhs"],
            )
            .register_documented(
                "any_orthogonal_vector",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::any_orthogonal_vector(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns some vector that is orthogonal to the given one.\n The input vector must be finite and non-zero.\n The output vector is not necessarily unit length. For that use\n [`Self::any_orthonormal_vector()`] instead.",
                &["_self"],
            )
            .register_documented(
                "any_orthonormal_vector",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::any_orthonormal_vector(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns any unit vector that is orthogonal to the given one.\n The input vector must be unit length.\n # Panics\n Will panic if `self` is not normalized when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "as_dvec3",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::Vec3A::as_dvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec3",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::Vec3A::as_i16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec3",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::Vec3A::as_i64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec3",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::Vec3A::as_i8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec3",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::Vec3A::as_ivec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec3",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::Vec3A::as_u16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec3",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::Vec3A::as_u64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec3",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::Vec3A::as_u8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec3",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::Vec3A::as_uvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "ceil",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::ceil(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the smallest integer greater than or equal to a number for\n each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::Vec3A>,
                    min: Val<bevy::math::Vec3A>,
                    max: Val<bevy::math::Vec3A>|
                {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`f32::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clamp_length",
                |_self: Val<bevy::math::Vec3A>, min: f32, max: f32| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::clamp_length(
                                    _self.into_inner(),
                                    min,
                                    max,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no less than `min` and no more than `max`.\n # Panics\n Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clamp_length_max",
                |_self: Val<bevy::math::Vec3A>, max: f32| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::clamp_length_max(
                                    _self.into_inner(),
                                    max,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no more than `max`.\n # Panics\n Will panic if `max` is negative when `glam_assert` is enabled.",
                &["_self", "max"],
            )
            .register_documented(
                "clamp_length_min",
                |_self: Val<bevy::math::Vec3A>, min: f32| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::clamp_length_min(
                                    _self.into_inner(),
                                    min,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no less than `min`.\n # Panics\n Will panic if `min` is negative when `glam_assert` is enabled.",
                &["_self", "min"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::BVec3A> = {
                        {
                            let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::BVec3A> = {
                        {
                            let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::BVec3A> = {
                        {
                            let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::BVec3A> = {
                        {
                            let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::BVec3A> = {
                        {
                            let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::BVec3A> = {
                        {
                            let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "copysign",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::copysign(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with signs of `rhs` and the magnitudes of `self`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cross",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::cross(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the cross product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3A::distance(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the Euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3A::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as ::core::ops::Div<
                                &bevy::math::Vec3A,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as ::core::ops::Div<
                                bevy::math::Vec3A,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::Vec3A>, rhs: f32| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as ::core::ops::Div<
                                f32,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3A::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3A::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3A::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::Vec3A as ::core::cmp::PartialEq<
                                bevy::math::Vec3A,
                            >>::eq(&_self, &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "exp",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::exp(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing `e^self` (the exponential function) for each element of\n `self`.",
                &["_self"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::Vec3A>, w: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec3A::extend(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` and the given `w` value.",
                &["_self", "w"],
            )
            .register_documented(
                "floor",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::floor(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the largest integer less than or equal to a number for each\n element of `self`.",
                &["_self"],
            )
            .register_documented(
                "fract",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::fract(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the fractional part of the vector as `self - self.trunc()`.\n Note that this differs from the GLSL implementation of `fract` which returns\n `self - self.floor()`.\n Note that this is fast but not precise for large numbers.",
                &["_self"],
            )
            .register_documented(
                "fract_gl",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::fract_gl(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the fractional part of the vector as `self - self.floor()`.\n Note that this differs from the Rust implementation of `fract` which returns\n `self - self.trunc()`.\n Note that this is fast but not precise for large numbers.",
                &["_self"],
            )
            .register_documented(
                "from_array",
                |a: [f32; 3]| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "from_vec4",
                |v: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::from_vec4(
                                    v.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a [`Vec3A`] from the `x`, `y` and `z` elements of `self` discarding `w`.\n On architectures where SIMD is supported such as SSE2 on `x86_64` this conversion is a noop.",
                &["v"],
            )
            .register_documented(
                "is_finite",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Vec3A::is_finite(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.  If any element is either\n `NaN`, positive or negative infinity, this will return `false`.",
                &["_self"],
            )
            .register_documented(
                "is_finite_mask",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::BVec3A> = {
                        {
                            let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::is_finite_mask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs `is_finite` on each element of self, returning a vector mask of the results.\n In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Vec3A::is_nan(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NaN`.",
                &["_self"],
            )
            .register_documented(
                "is_nan_mask",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::BVec3A> = {
                        {
                            let output: Val<bevy::math::BVec3A> = bevy::math::Vec3A::is_nan_mask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs `is_nan` on each element of self, returning a vector mask of the results.\n In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.",
                &["_self"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::Vec3A::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "is_normalized",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Vec3A::is_normalized(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns whether `self` is length `1.0` or not.\n Uses a precision threshold of approximately `1e-4`.",
                &["_self"],
            )
            .register_documented(
                "length",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3A::length(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the length of `self`.",
                &["_self"],
            )
            .register_documented(
                "length_recip",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3A::length_recip(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes `1.0 / length()`.\n For valid results, `self` must _not_ be of length zero.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3A::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.\n This is faster than `length()` as it avoids a square root operation.",
                &["_self"],
            )
            .register_documented(
                "lerp",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>, s: f32| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::lerp(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                    s,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs a linear interpolation between `self` and `rhs` based on the value `s`.\n When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result\n will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly\n extrapolated.",
                &["_self", "rhs", "s"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3A::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "midpoint",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::midpoint(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Calculates the midpoint between `self` and `rhs`.\n The midpoint is the average of, or halfway point between, two vectors.\n `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`\n while being slightly cheaper to compute.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec3A::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "move_towards",
                |_self: Ref<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>, d: f32| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::move_towards(
                                    &_self,
                                    rhs.into_inner(),
                                    d,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Moves towards `rhs` based on the value `d`.\n When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to\n `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.",
                &["_self", "rhs", "d"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as ::core::ops::Mul<
                                &bevy::math::Vec3A,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as ::core::ops::Mul<
                                bevy::math::Vec3A,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Vec3A>, rhs: f32| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as ::core::ops::Mul<
                                f32,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_add",
                |
                    _self: Val<bevy::math::Vec3A>,
                    a: Val<bevy::math::Vec3A>,
                    b: Val<bevy::math::Vec3A>|
                {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::mul_add(
                                    _self.into_inner(),
                                    a.into_inner(),
                                    b.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding\n error, yielding a more accurate result than an unfused multiply-add.\n Using `mul_add` *may* be more performant than an unfused multiply-add if the target\n architecture has a dedicated fma CPU instruction. However, this is not always true,\n and will be heavily dependant on designing algorithms with specific target hardware in\n mind.",
                &["_self", "a", "b"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: f32, y: f32, z: f32| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::new(
                                    x,
                                    y,
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z"],
            )
            .register_documented(
                "normalize",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::normalize(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0.\n For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.\n See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].\n Panics\n Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "normalize_or",
                |_self: Val<bevy::math::Vec3A>, fallback: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::normalize_or(
                                    _self.into_inner(),
                                    fallback.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0 if possible, else returns a\n fallback value.\n In particular, if the input is zero (or very close to zero), or non-finite,\n the result of this operation will be the fallback value.\n See also [`Self::try_normalize()`].",
                &["_self", "fallback"],
            )
            .register_documented(
                "normalize_or_zero",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::normalize_or_zero(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0 if possible, else returns zero.\n In particular, if the input is zero (or very close to zero), or non-finite,\n the result of this operation will be zero.\n See also [`Self::try_normalize()`].",
                &["_self"],
            )
            .register_documented(
                "powf",
                |_self: Val<bevy::math::Vec3A>, n: f32| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::powf(
                                    _self.into_inner(),
                                    n,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing each element of `self` raised to the power of `n`.",
                &["_self", "n"],
            )
            .register_documented(
                "project_onto",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::project_onto(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector projection of `self` onto `rhs`.\n `rhs` must be of non-zero length.\n # Panics\n Will panic if `rhs` is zero length when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "project_onto_normalized",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::project_onto_normalized(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector projection of `self` onto `rhs`.\n `rhs` must be normalized.\n # Panics\n Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "recip",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::recip(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "reflect",
                |_self: Val<bevy::math::Vec3A>, normal: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::reflect(
                                    _self.into_inner(),
                                    normal.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the reflection vector for a given incident vector `self` and surface normal\n `normal`.\n `normal` must be normalized.\n # Panics\n Will panic if `normal` is not normalized when `glam_assert` is enabled.",
                &["_self", "normal"],
            )
            .register_documented(
                "refract",
                |
                    _self: Val<bevy::math::Vec3A>,
                    normal: Val<bevy::math::Vec3A>,
                    eta: f32|
                {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::refract(
                                    _self.into_inner(),
                                    normal.into_inner(),
                                    eta,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the refraction direction for a given incident vector `self`, surface normal\n `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,\n a zero vector will be returned.\n `self` and `normal` must be normalized.\n # Panics\n Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.",
                &["_self", "normal", "eta"],
            )
            .register_documented(
                "reject_from",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::reject_from(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector rejection of `self` from `rhs`.\n The vector rejection is the vector perpendicular to the projection of `self` onto\n `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.\n `rhs` must be of non-zero length.\n # Panics\n Will panic if `rhs` has a length of zero when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "reject_from_normalized",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::reject_from_normalized(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector rejection of `self` from `rhs`.\n The vector rejection is the vector perpendicular to the projection of `self` onto\n `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.\n `rhs` must be normalized.\n # Panics\n Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as ::core::ops::Rem<
                                &bevy::math::Vec3A,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as ::core::ops::Rem<
                                bevy::math::Vec3A,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::Vec3A>, rhs: f32| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as ::core::ops::Rem<
                                f32,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n [Euclidean division]: f32::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "round",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::round(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the nearest integer to a number for each element of `self`.\n Round half-way cases away from 0.0.",
                &["_self"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec3A>,
                    if_true: Val<bevy::math::Vec3A>,
                    if_false: Val<bevy::math::Vec3A>|
                {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n - `1.0` if the number is positive, `+0.0` or `INFINITY`\n - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n - `NAN` if the number is `NAN`",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: f32| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::Vec3A>, rhs: Ref<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as ::core::ops::Sub<
                                &bevy::math::Vec3A,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::Vec3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as ::core::ops::Sub<
                                bevy::math::Vec3A,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::Vec3A>, rhs: f32| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Vec3A as ::core::ops::Sub<
                                f32,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::Vec3A>| {
                    let output: [f32; 3] = {
                        {
                            let output: [f32; 3] = bevy::math::Vec3A::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z]`",
                &["_self"],
            )
            .register_documented(
                "trunc",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::trunc(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the integer part each element of `self`. This means numbers are\n always truncated towards zero.",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Vec3A::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.\n Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::Vec3A>, x: f32| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::Vec3A>, y: f32| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::Vec3A>, z: f32| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Vec3A::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::Vec3A,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_vec_4_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::Vec4,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Val<bevy::math::Vec4>,
                    rhs: Val<bevy::math::Vec4>,
                    max_abs_diff: f32|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Vec4::abs_diff_eq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs` is\n less than or equal to `max_abs_diff`.\n This can be used to compare if two vectors contain similar elements. It works best when\n comparing with a known value. The `max_abs_diff` that should be used used depends on\n the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as ::core::ops::Add<
                                &bevy::math::Vec4,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as ::core::ops::Add<
                                bevy::math::Vec4,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::Vec4>, rhs: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as ::core::ops::Add<
                                f32,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dvec4",
                |_self: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::Vec4::as_dvec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f64`.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec4",
                |_self: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::Vec4::as_i16vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec4",
                |_self: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::Vec4::as_i64vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec4",
                |_self: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::Vec4::as_i8vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec4",
                |_self: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::Vec4::as_ivec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec4",
                |_self: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::Vec4::as_u16vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec4",
                |_self: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::Vec4::as_u64vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec4",
                |_self: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::Vec4::as_u8vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec4",
                |_self: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::Vec4::as_uvec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "ceil",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::ceil(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the smallest integer greater than or equal to a number for\n each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::Vec4>,
                    min: Val<bevy::math::Vec4>,
                    max: Val<bevy::math::Vec4>|
                {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`f32::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clamp_length",
                |_self: Val<bevy::math::Vec4>, min: f32, max: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::clamp_length(
                                    _self.into_inner(),
                                    min,
                                    max,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no less than `min` and no more than `max`.\n # Panics\n Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clamp_length_max",
                |_self: Val<bevy::math::Vec4>, max: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::clamp_length_max(
                                    _self.into_inner(),
                                    max,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no more than `max`.\n # Panics\n Will panic if `max` is negative when `glam_assert` is enabled.",
                &["_self", "max"],
            )
            .register_documented(
                "clamp_length_min",
                |_self: Val<bevy::math::Vec4>, min: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::clamp_length_min(
                                    _self.into_inner(),
                                    min,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no less than `min`.\n # Panics\n Will panic if `min` is negative when `glam_assert` is enabled.",
                &["_self", "min"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::BVec4A> = {
                        {
                            let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::BVec4A> = {
                        {
                            let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::BVec4A> = {
                        {
                            let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::BVec4A> = {
                        {
                            let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::BVec4A> = {
                        {
                            let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::BVec4A> = {
                        {
                            let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "copysign",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::copysign(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with signs of `rhs` and the magnitudes of `self`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec4::distance(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the Euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec4::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as ::core::ops::Div<
                                &bevy::math::Vec4,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as ::core::ops::Div<
                                bevy::math::Vec4,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::Vec4>, rhs: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as ::core::ops::Div<
                                f32,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec4::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::Vec4>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec4::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::Vec4>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec4::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::Vec4 as ::core::cmp::PartialEq<
                                bevy::math::Vec4,
                            >>::eq(&_self, &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "exp",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::exp(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing `e^self` (the exponential function) for each element of\n `self`.",
                &["_self"],
            )
            .register_documented(
                "floor",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::floor(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the largest integer less than or equal to a number for each\n element of `self`.",
                &["_self"],
            )
            .register_documented(
                "fract",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::fract(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the fractional part of the vector as `self - self.trunc()`.\n Note that this differs from the GLSL implementation of `fract` which returns\n `self - self.floor()`.\n Note that this is fast but not precise for large numbers.",
                &["_self"],
            )
            .register_documented(
                "fract_gl",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::fract_gl(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the fractional part of the vector as `self - self.floor()`.\n Note that this differs from the Rust implementation of `fract` which returns\n `self - self.trunc()`.\n Note that this is fast but not precise for large numbers.",
                &["_self"],
            )
            .register_documented(
                "from_array",
                |a: [f32; 4]| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "is_finite",
                |_self: Val<bevy::math::Vec4>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Vec4::is_finite(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.  If any element is either\n `NaN`, positive or negative infinity, this will return `false`.",
                &["_self"],
            )
            .register_documented(
                "is_finite_mask",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::BVec4A> = {
                        {
                            let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::is_finite_mask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs `is_finite` on each element of self, returning a vector mask of the results.\n In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Val<bevy::math::Vec4>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Vec4::is_nan(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NaN`.",
                &["_self"],
            )
            .register_documented(
                "is_nan_mask",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::BVec4A> = {
                        {
                            let output: Val<bevy::math::BVec4A> = bevy::math::Vec4::is_nan_mask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs `is_nan` on each element of self, returning a vector mask of the results.\n In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.",
                &["_self"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::Vec4>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::Vec4::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 4 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "is_normalized",
                |_self: Val<bevy::math::Vec4>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Vec4::is_normalized(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns whether `self` is length `1.0` or not.\n Uses a precision threshold of approximately `1e-4`.",
                &["_self"],
            )
            .register_documented(
                "length",
                |_self: Val<bevy::math::Vec4>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec4::length(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the length of `self`.",
                &["_self"],
            )
            .register_documented(
                "length_recip",
                |_self: Val<bevy::math::Vec4>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec4::length_recip(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes `1.0 / length()`.\n For valid results, `self` must _not_ be of length zero.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::Vec4>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec4::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.\n This is faster than `length()` as it avoids a square root operation.",
                &["_self"],
            )
            .register_documented(
                "lerp",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>, s: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::lerp(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                    s,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs a linear interpolation between `self` and `rhs` based on the value `s`.\n When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result\n will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly\n extrapolated.",
                &["_self", "rhs", "s"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::Vec4>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec4::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "midpoint",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::midpoint(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Calculates the midpoint between `self` and `rhs`.\n The midpoint is the average of, or halfway point between, two vectors.\n `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`\n while being slightly cheaper to compute.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::Vec4>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Vec4::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "move_towards",
                |_self: Ref<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>, d: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::move_towards(
                                    &_self,
                                    rhs.into_inner(),
                                    d,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Moves towards `rhs` based on the value `d`.\n When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to\n `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.",
                &["_self", "rhs", "d"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as ::core::ops::Mul<
                                &bevy::math::Vec4,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as ::core::ops::Mul<
                                bevy::math::Vec4,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Vec4>, rhs: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as ::core::ops::Mul<
                                f32,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_add",
                |
                    _self: Val<bevy::math::Vec4>,
                    a: Val<bevy::math::Vec4>,
                    b: Val<bevy::math::Vec4>|
                {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::mul_add(
                                    _self.into_inner(),
                                    a.into_inner(),
                                    b.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding\n error, yielding a more accurate result than an unfused multiply-add.\n Using `mul_add` *may* be more performant than an unfused multiply-add if the target\n architecture has a dedicated fma CPU instruction. However, this is not always true,\n and will be heavily dependant on designing algorithms with specific target hardware in\n mind.",
                &["_self", "a", "b"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: f32, y: f32, z: f32, w: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::new(
                                    x,
                                    y,
                                    z,
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z", "w"],
            )
            .register_documented(
                "normalize",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::normalize(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0.\n For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.\n See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].\n Panics\n Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "normalize_or",
                |_self: Val<bevy::math::Vec4>, fallback: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::normalize_or(
                                    _self.into_inner(),
                                    fallback.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0 if possible, else returns a\n fallback value.\n In particular, if the input is zero (or very close to zero), or non-finite,\n the result of this operation will be the fallback value.\n See also [`Self::try_normalize()`].",
                &["_self", "fallback"],
            )
            .register_documented(
                "normalize_or_zero",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::normalize_or_zero(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0 if possible, else returns zero.\n In particular, if the input is zero (or very close to zero), or non-finite,\n the result of this operation will be zero.\n See also [`Self::try_normalize()`].",
                &["_self"],
            )
            .register_documented(
                "powf",
                |_self: Val<bevy::math::Vec4>, n: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::powf(
                                    _self.into_inner(),
                                    n,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing each element of `self` raised to the power of `n`.",
                &["_self", "n"],
            )
            .register_documented(
                "project_onto",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::project_onto(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector projection of `self` onto `rhs`.\n `rhs` must be of non-zero length.\n # Panics\n Will panic if `rhs` is zero length when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "project_onto_normalized",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::project_onto_normalized(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector projection of `self` onto `rhs`.\n `rhs` must be normalized.\n # Panics\n Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "recip",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::recip(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "reflect",
                |_self: Val<bevy::math::Vec4>, normal: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::reflect(
                                    _self.into_inner(),
                                    normal.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the reflection vector for a given incident vector `self` and surface normal\n `normal`.\n `normal` must be normalized.\n # Panics\n Will panic if `normal` is not normalized when `glam_assert` is enabled.",
                &["_self", "normal"],
            )
            .register_documented(
                "refract",
                |_self: Val<bevy::math::Vec4>, normal: Val<bevy::math::Vec4>, eta: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::refract(
                                    _self.into_inner(),
                                    normal.into_inner(),
                                    eta,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the refraction direction for a given incident vector `self`, surface normal\n `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,\n a zero vector will be returned.\n `self` and `normal` must be normalized.\n # Panics\n Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.",
                &["_self", "normal", "eta"],
            )
            .register_documented(
                "reject_from",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::reject_from(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector rejection of `self` from `rhs`.\n The vector rejection is the vector perpendicular to the projection of `self` onto\n `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.\n `rhs` must be of non-zero length.\n # Panics\n Will panic if `rhs` has a length of zero when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "reject_from_normalized",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::reject_from_normalized(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector rejection of `self` from `rhs`.\n The vector rejection is the vector perpendicular to the projection of `self` onto\n `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.\n `rhs` must be normalized.\n # Panics\n Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as ::core::ops::Rem<
                                &bevy::math::Vec4,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as ::core::ops::Rem<
                                bevy::math::Vec4,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::Vec4>, rhs: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as ::core::ops::Rem<
                                f32,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n [Euclidean division]: f32::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "round",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::round(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the nearest integer to a number for each element of `self`.\n Round half-way cases away from 0.0.",
                &["_self"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec4A>,
                    if_true: Val<bevy::math::Vec4>,
                    if_false: Val<bevy::math::Vec4>|
                {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n - `1.0` if the number is positive, `+0.0` or `INFINITY`\n - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n - `NAN` if the number is `NAN`",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::Vec4>, rhs: Ref<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as ::core::ops::Sub<
                                &bevy::math::Vec4,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::Vec4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as ::core::ops::Sub<
                                bevy::math::Vec4,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::Vec4>, rhs: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = <bevy::math::Vec4 as ::core::ops::Sub<
                                f32,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::Vec4>| {
                    let output: [f32; 4] = {
                        {
                            let output: [f32; 4] = bevy::math::Vec4::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z, w]`",
                &["_self"],
            )
            .register_documented(
                "trunc",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::trunc(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the integer part each element of `self`. This means numbers are\n always truncated towards zero.",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Vec4::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.\n Truncation to [`Vec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].\n To truncate to [`Vec3A`] use [`Vec3A::from()`].",
                &["_self"],
            )
            .register_documented(
                "with_w",
                |_self: Val<bevy::math::Vec4>, w: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::with_w(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `w`.",
                &["_self", "w"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::Vec4>, x: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::Vec4>, y: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::Vec4>, z: f32| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Vec4::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::Vec4,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_b_vec_2_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::BVec2,
        >::new(world)
            .register_documented(
                "all",
                |_self: Val<bevy::math::BVec2>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::BVec2::all(_self.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if all the elements are true, false otherwise.",
                &["_self"],
            )
            .register_documented(
                "any",
                |_self: Val<bevy::math::BVec2>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::BVec2::any(_self.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if any of the elements are true, false otherwise.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::BVec2>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::BVec2 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "bitmask",
                |_self: Val<bevy::math::BVec2>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::BVec2::bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 2 bits set from the elements of `self`.\n A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::BVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = <bevy::math::BVec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::BVec2>, other: Ref<bevy::math::BVec2>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::BVec2 as ::core::cmp::PartialEq<
                                bevy::math::BVec2,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "from_array",
                |a: [bool; 2]| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::BVec2::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector mask from a bool array.",
                &["a"],
            )
            .register_documented(
                "new",
                |x: bool, y: bool| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::BVec2::new(
                                    x,
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector mask.",
                &["x", "y"],
            )
            .register_documented(
                "set",
                |mut _self: Mut<bevy::math::BVec2>, index: usize, value: bool| {
                    let output: () = {
                        {
                            let output: () = bevy::math::BVec2::set(
                                    &mut _self,
                                    index,
                                    value,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Sets the element at `index`.\n Panics if `index` is greater than 1.",
                &["_self", "index", "value"],
            )
            .register_documented(
                "splat",
                |v: bool| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::BVec2::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector mask with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "test",
                |_self: Ref<bevy::math::BVec2>, index: usize| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::BVec2::test(&_self, index)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Tests the value at `index`.\n Panics if `index` is greater than 1.",
                &["_self", "index"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::BVec2,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_b_vec_3_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::BVec3,
        >::new(world)
            .register_documented(
                "all",
                |_self: Val<bevy::math::BVec3>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::BVec3::all(_self.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if all the elements are true, false otherwise.",
                &["_self"],
            )
            .register_documented(
                "any",
                |_self: Val<bevy::math::BVec3>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::BVec3::any(_self.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if any of the elements are true, false otherwise.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::BVec3>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::BVec3 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "bitmask",
                |_self: Val<bevy::math::BVec3>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::BVec3::bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 3 bits set from the elements of `self`.\n A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::BVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = <bevy::math::BVec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::BVec3>, other: Ref<bevy::math::BVec3>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::BVec3 as ::core::cmp::PartialEq<
                                bevy::math::BVec3,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "from_array",
                |a: [bool; 3]| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::BVec3::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector mask from a bool array.",
                &["a"],
            )
            .register_documented(
                "new",
                |x: bool, y: bool, z: bool| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::BVec3::new(
                                    x,
                                    y,
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector mask.",
                &["x", "y", "z"],
            )
            .register_documented(
                "set",
                |mut _self: Mut<bevy::math::BVec3>, index: usize, value: bool| {
                    let output: () = {
                        {
                            let output: () = bevy::math::BVec3::set(
                                    &mut _self,
                                    index,
                                    value,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Sets the element at `index`.\n Panics if `index` is greater than 2.",
                &["_self", "index", "value"],
            )
            .register_documented(
                "splat",
                |v: bool| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::BVec3::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector mask with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "test",
                |_self: Ref<bevy::math::BVec3>, index: usize| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::BVec3::test(&_self, index)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Tests the value at `index`.\n Panics if `index` is greater than 2.",
                &["_self", "index"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::BVec3,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_b_vec_4_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::BVec4,
        >::new(world)
            .register_documented(
                "all",
                |_self: Val<bevy::math::BVec4>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::BVec4::all(_self.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if all the elements are true, false otherwise.",
                &["_self"],
            )
            .register_documented(
                "any",
                |_self: Val<bevy::math::BVec4>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::BVec4::any(_self.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if any of the elements are true, false otherwise.",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::BVec4>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::BVec4 as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "bitmask",
                |_self: Val<bevy::math::BVec4>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::BVec4::bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 4 bits set from the elements of `self`.\n A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::BVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = <bevy::math::BVec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::BVec4>, other: Ref<bevy::math::BVec4>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::BVec4 as ::core::cmp::PartialEq<
                                bevy::math::BVec4,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "from_array",
                |a: [bool; 4]| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::BVec4::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector mask from a bool array.",
                &["a"],
            )
            .register_documented(
                "new",
                |x: bool, y: bool, z: bool, w: bool| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::BVec4::new(
                                    x,
                                    y,
                                    z,
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector mask.",
                &["x", "y", "z", "w"],
            )
            .register_documented(
                "set",
                |mut _self: Mut<bevy::math::BVec4>, index: usize, value: bool| {
                    let output: () = {
                        {
                            let output: () = bevy::math::BVec4::set(
                                    &mut _self,
                                    index,
                                    value,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Sets the element at `index`.\n Panics if `index` is greater than 3.",
                &["_self", "index", "value"],
            )
            .register_documented(
                "splat",
                |v: bool| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::BVec4::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector mask with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "test",
                |_self: Ref<bevy::math::BVec4>, index: usize| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::BVec4::test(&_self, index)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Tests the value at `index`.\n Panics if `index` is greater than 3.",
                &["_self", "index"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::BVec4,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_d_vec_2_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::DVec2,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Val<bevy::math::DVec2>,
                    rhs: Val<bevy::math::DVec2>,
                    max_abs_diff: f64|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DVec2::abs_diff_eq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs` is\n less than or equal to `max_abs_diff`.\n This can be used to compare if two vectors contain similar elements. It works best when\n comparing with a known value. The `max_abs_diff` that should be used used depends on\n the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::DVec2>, rhs: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as ::core::ops::Add<
                                &bevy::math::DVec2,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as ::core::ops::Add<
                                bevy::math::DVec2,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::DVec2>, rhs: f64| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as ::core::ops::Add<
                                f64,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "angle_between",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec2::angle_between(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "angle_to",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec2::angle_to(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the angle of rotation (in radians) from `self` to `rhs` in the range `[-π, +π]`.\n The inputs do not need to be unit vectors however they must be non-zero.",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_i16vec2",
                |_self: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::I16Vec2> = {
                        {
                            let output: Val<bevy::math::I16Vec2> = bevy::math::DVec2::as_i16vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec2",
                |_self: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::I64Vec2> = {
                        {
                            let output: Val<bevy::math::I64Vec2> = bevy::math::DVec2::as_i64vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec2",
                |_self: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::I8Vec2> = {
                        {
                            let output: Val<bevy::math::I8Vec2> = bevy::math::DVec2::as_i8vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec2",
                |_self: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::IVec2> = {
                        {
                            let output: Val<bevy::math::IVec2> = bevy::math::DVec2::as_ivec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec2",
                |_self: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::U16Vec2> = {
                        {
                            let output: Val<bevy::math::U16Vec2> = bevy::math::DVec2::as_u16vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec2",
                |_self: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::U64Vec2> = {
                        {
                            let output: Val<bevy::math::U64Vec2> = bevy::math::DVec2::as_u64vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec2",
                |_self: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::U8Vec2> = {
                        {
                            let output: Val<bevy::math::U8Vec2> = bevy::math::DVec2::as_u8vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec2",
                |_self: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::UVec2> = {
                        {
                            let output: Val<bevy::math::UVec2> = bevy::math::DVec2::as_uvec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec2",
                |_self: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::DVec2::as_vec2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "ceil",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::ceil(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the smallest integer greater than or equal to a number for\n each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::DVec2>,
                    min: Val<bevy::math::DVec2>,
                    max: Val<bevy::math::DVec2>|
                {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`f64::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clamp_length",
                |_self: Val<bevy::math::DVec2>, min: f64, max: f64| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::clamp_length(
                                    _self.into_inner(),
                                    min,
                                    max,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no less than `min` and no more than `max`.\n # Panics\n Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clamp_length_max",
                |_self: Val<bevy::math::DVec2>, max: f64| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::clamp_length_max(
                                    _self.into_inner(),
                                    max,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no more than `max`.\n # Panics\n Will panic if `max` is negative when `glam_assert` is enabled.",
                &["_self", "max"],
            )
            .register_documented(
                "clamp_length_min",
                |_self: Val<bevy::math::DVec2>, min: f64| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::clamp_length_min(
                                    _self.into_inner(),
                                    min,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no less than `min`.\n # Panics\n Will panic if `min` is negative when `glam_assert` is enabled.",
                &["_self", "min"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::DVec2::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "copysign",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::copysign(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with signs of `rhs` and the magnitudes of `self`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec2::distance(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the Euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec2::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::DVec2>, rhs: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as ::core::ops::Div<
                                &bevy::math::DVec2,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as ::core::ops::Div<
                                bevy::math::DVec2,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::DVec2>, rhs: f64| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as ::core::ops::Div<
                                f64,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec2::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::DVec2>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec2::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::DVec2>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec2::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::DVec2>, other: Ref<bevy::math::DVec2>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::DVec2 as ::core::cmp::PartialEq<
                                bevy::math::DVec2,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "exp",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::exp(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing `e^self` (the exponential function) for each element of\n `self`.",
                &["_self"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::DVec2>, z: f64| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec2::extend(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` and the given `z` value.",
                &["_self", "z"],
            )
            .register_documented(
                "floor",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::floor(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the largest integer less than or equal to a number for each\n element of `self`.",
                &["_self"],
            )
            .register_documented(
                "fract",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::fract(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the fractional part of the vector as `self - self.trunc()`.\n Note that this differs from the GLSL implementation of `fract` which returns\n `self - self.floor()`.\n Note that this is fast but not precise for large numbers.",
                &["_self"],
            )
            .register_documented(
                "fract_gl",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::fract_gl(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the fractional part of the vector as `self - self.floor()`.\n Note that this differs from the Rust implementation of `fract` which returns\n `self - self.trunc()`.\n Note that this is fast but not precise for large numbers.",
                &["_self"],
            )
            .register_documented(
                "from_angle",
                |angle: f64| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::from_angle(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector containing `[angle.cos(), angle.sin()]`. This can be used in\n conjunction with the [`rotate()`][Self::rotate()] method, e.g.\n `DVec2::from_angle(PI).rotate(DVec2::Y)` will create the vector `[-1, 0]`\n and rotate [`DVec2::Y`] around it returning `-DVec2::Y`.",
                &["angle"],
            )
            .register_documented(
                "from_array",
                |a: [f64; 2]| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "is_finite",
                |_self: Val<bevy::math::DVec2>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DVec2::is_finite(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.  If any element is either\n `NaN`, positive or negative infinity, this will return `false`.",
                &["_self"],
            )
            .register_documented(
                "is_finite_mask",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::DVec2::is_finite_mask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs `is_finite` on each element of self, returning a vector mask of the results.\n In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Val<bevy::math::DVec2>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DVec2::is_nan(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NaN`.",
                &["_self"],
            )
            .register_documented(
                "is_nan_mask",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::BVec2> = {
                        {
                            let output: Val<bevy::math::BVec2> = bevy::math::DVec2::is_nan_mask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs `is_nan` on each element of self, returning a vector mask of the results.\n In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.",
                &["_self"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::DVec2>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::DVec2::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 2 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "is_normalized",
                |_self: Val<bevy::math::DVec2>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DVec2::is_normalized(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns whether `self` is length `1.0` or not.\n Uses a precision threshold of approximately `1e-4`.",
                &["_self"],
            )
            .register_documented(
                "length",
                |_self: Val<bevy::math::DVec2>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec2::length(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the length of `self`.",
                &["_self"],
            )
            .register_documented(
                "length_recip",
                |_self: Val<bevy::math::DVec2>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec2::length_recip(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes `1.0 / length()`.\n For valid results, `self` must _not_ be of length zero.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::DVec2>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec2::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.\n This is faster than `length()` as it avoids a square root operation.",
                &["_self"],
            )
            .register_documented(
                "lerp",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>, s: f64| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::lerp(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                    s,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs a linear interpolation between `self` and `rhs` based on the value `s`.\n When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result\n will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly\n extrapolated.",
                &["_self", "rhs", "s"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::DVec2>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec2::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "midpoint",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::midpoint(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Calculates the midpoint between `self` and `rhs`.\n The midpoint is the average of, or halfway point between, two vectors.\n `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`\n while being slightly cheaper to compute.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::DVec2>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec2::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "move_towards",
                |_self: Ref<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>, d: f64| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::move_towards(
                                    &_self,
                                    rhs.into_inner(),
                                    d,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Moves towards `rhs` based on the value `d`.\n When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to\n `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.",
                &["_self", "rhs", "d"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DVec2>, rhs: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as ::core::ops::Mul<
                                &bevy::math::DVec2,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as ::core::ops::Mul<
                                bevy::math::DVec2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DVec2>, rhs: f64| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as ::core::ops::Mul<
                                f64,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_add",
                |
                    _self: Val<bevy::math::DVec2>,
                    a: Val<bevy::math::DVec2>,
                    b: Val<bevy::math::DVec2>|
                {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::mul_add(
                                    _self.into_inner(),
                                    a.into_inner(),
                                    b.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding\n error, yielding a more accurate result than an unfused multiply-add.\n Using `mul_add` *may* be more performant than an unfused multiply-add if the target\n architecture has a dedicated fma CPU instruction. However, this is not always true,\n and will be heavily dependant on designing algorithms with specific target hardware in\n mind.",
                &["_self", "a", "b"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: f64, y: f64| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::new(
                                    x,
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y"],
            )
            .register_documented(
                "normalize",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::normalize(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0.\n For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.\n See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].\n Panics\n Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "normalize_or",
                |_self: Val<bevy::math::DVec2>, fallback: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::normalize_or(
                                    _self.into_inner(),
                                    fallback.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0 if possible, else returns a\n fallback value.\n In particular, if the input is zero (or very close to zero), or non-finite,\n the result of this operation will be the fallback value.\n See also [`Self::try_normalize()`].",
                &["_self", "fallback"],
            )
            .register_documented(
                "normalize_or_zero",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::normalize_or_zero(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0 if possible, else returns zero.\n In particular, if the input is zero (or very close to zero), or non-finite,\n the result of this operation will be zero.\n See also [`Self::try_normalize()`].",
                &["_self"],
            )
            .register_documented(
                "perp",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::perp(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector that is equal to `self` rotated by 90 degrees.",
                &["_self"],
            )
            .register_documented(
                "perp_dot",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec2::perp_dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " The perpendicular dot product of `self` and `rhs`.\n Also known as the wedge product, 2D cross product, and determinant.",
                &["_self", "rhs"],
            )
            .register_documented(
                "powf",
                |_self: Val<bevy::math::DVec2>, n: f64| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::powf(
                                    _self.into_inner(),
                                    n,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing each element of `self` raised to the power of `n`.",
                &["_self", "n"],
            )
            .register_documented(
                "project_onto",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::project_onto(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector projection of `self` onto `rhs`.\n `rhs` must be of non-zero length.\n # Panics\n Will panic if `rhs` is zero length when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "project_onto_normalized",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::project_onto_normalized(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector projection of `self` onto `rhs`.\n `rhs` must be normalized.\n # Panics\n Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "recip",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::recip(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "reflect",
                |_self: Val<bevy::math::DVec2>, normal: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::reflect(
                                    _self.into_inner(),
                                    normal.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the reflection vector for a given incident vector `self` and surface normal\n `normal`.\n `normal` must be normalized.\n # Panics\n Will panic if `normal` is not normalized when `glam_assert` is enabled.",
                &["_self", "normal"],
            )
            .register_documented(
                "refract",
                |
                    _self: Val<bevy::math::DVec2>,
                    normal: Val<bevy::math::DVec2>,
                    eta: f64|
                {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::refract(
                                    _self.into_inner(),
                                    normal.into_inner(),
                                    eta,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the refraction direction for a given incident vector `self`, surface normal\n `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,\n a zero vector will be returned.\n `self` and `normal` must be normalized.\n # Panics\n Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.",
                &["_self", "normal", "eta"],
            )
            .register_documented(
                "reject_from",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::reject_from(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector rejection of `self` from `rhs`.\n The vector rejection is the vector perpendicular to the projection of `self` onto\n `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.\n `rhs` must be of non-zero length.\n # Panics\n Will panic if `rhs` has a length of zero when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "reject_from_normalized",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::reject_from_normalized(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector rejection of `self` from `rhs`.\n The vector rejection is the vector perpendicular to the projection of `self` onto\n `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.\n `rhs` must be normalized.\n # Panics\n Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::DVec2>, rhs: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as ::core::ops::Rem<
                                &bevy::math::DVec2,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as ::core::ops::Rem<
                                bevy::math::DVec2,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::DVec2>, rhs: f64| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as ::core::ops::Rem<
                                f64,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n [Euclidean division]: f64::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "rotate",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::rotate(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `rhs` rotated by the angle of `self`. If `self` is normalized,\n then this just rotation. This is what you usually want. Otherwise,\n it will be like a rotation with a multiplication by `self`'s length.",
                &["_self", "rhs"],
            )
            .register_documented(
                "rotate_towards",
                |
                    _self: Ref<bevy::math::DVec2>,
                    rhs: Val<bevy::math::DVec2>,
                    max_angle: f64|
                {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::rotate_towards(
                                    &_self,
                                    rhs.into_inner(),
                                    max_angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Rotates towards `rhs` up to `max_angle` (in radians).\n When `max_angle` is `0.0`, the result will be equal to `self`. When `max_angle` is equal to\n `self.angle_between(rhs)`, the result will be equal to `rhs`. If `max_angle` is negative,\n rotates towards the exact opposite of `rhs`. Will not go past the target.",
                &["_self", "rhs", "max_angle"],
            )
            .register_documented(
                "round",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::round(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the nearest integer to a number for each element of `self`.\n Round half-way cases away from 0.0.",
                &["_self"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec2>,
                    if_true: Val<bevy::math::DVec2>,
                    if_false: Val<bevy::math::DVec2>|
                {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n - `1.0` if the number is positive, `+0.0` or `INFINITY`\n - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n - `NAN` if the number is `NAN`",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: f64| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::DVec2>, rhs: Ref<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as ::core::ops::Sub<
                                &bevy::math::DVec2,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::DVec2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as ::core::ops::Sub<
                                bevy::math::DVec2,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::DVec2>, rhs: f64| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = <bevy::math::DVec2 as ::core::ops::Sub<
                                f64,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_angle",
                |_self: Val<bevy::math::DVec2>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec2::to_angle(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the angle (in radians) of this vector in the range `[-π, +π]`.\n The input does not need to be a unit vector however it must be non-zero.",
                &["_self"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::DVec2>| {
                    let output: [f64; 2] = {
                        {
                            let output: [f64; 2] = bevy::math::DVec2::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y]`",
                &["_self"],
            )
            .register_documented(
                "trunc",
                |_self: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::trunc(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the integer part each element of `self`. This means numbers are\n always truncated towards zero.",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::DVec2>, x: f64| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::DVec2>, y: f64| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec2::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::DVec2,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_d_vec_3_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::DVec3,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Val<bevy::math::DVec3>,
                    rhs: Val<bevy::math::DVec3>,
                    max_abs_diff: f64|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DVec3::abs_diff_eq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs` is\n less than or equal to `max_abs_diff`.\n This can be used to compare if two vectors contain similar elements. It works best when\n comparing with a known value. The `max_abs_diff` that should be used used depends on\n the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::DVec3>, rhs: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as ::core::ops::Add<
                                &bevy::math::DVec3,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as ::core::ops::Add<
                                bevy::math::DVec3,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::DVec3>, rhs: f64| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as ::core::ops::Add<
                                f64,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "angle_between",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec3::angle_between(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the angle (in radians) between two vectors in the range `[0, +π]`.\n The inputs do not need to be unit vectors however they must be non-zero.",
                &["_self", "rhs"],
            )
            .register_documented(
                "any_orthogonal_vector",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::any_orthogonal_vector(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns some vector that is orthogonal to the given one.\n The input vector must be finite and non-zero.\n The output vector is not necessarily unit length. For that use\n [`Self::any_orthonormal_vector()`] instead.",
                &["_self"],
            )
            .register_documented(
                "any_orthonormal_vector",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::any_orthonormal_vector(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns any unit vector that is orthogonal to the given one.\n The input vector must be unit length.\n # Panics\n Will panic if `self` is not normalized when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "as_i16vec3",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::I16Vec3> = {
                        {
                            let output: Val<bevy::math::I16Vec3> = bevy::math::DVec3::as_i16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec3",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::I64Vec3> = {
                        {
                            let output: Val<bevy::math::I64Vec3> = bevy::math::DVec3::as_i64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec3",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::I8Vec3> = {
                        {
                            let output: Val<bevy::math::I8Vec3> = bevy::math::DVec3::as_i8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec3",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::IVec3> = {
                        {
                            let output: Val<bevy::math::IVec3> = bevy::math::DVec3::as_ivec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec3",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::U16Vec3> = {
                        {
                            let output: Val<bevy::math::U16Vec3> = bevy::math::DVec3::as_u16vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec3",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::U64Vec3> = {
                        {
                            let output: Val<bevy::math::U64Vec3> = bevy::math::DVec3::as_u64vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec3",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::U8Vec3> = {
                        {
                            let output: Val<bevy::math::U8Vec3> = bevy::math::DVec3::as_u8vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec3",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::UVec3> = {
                        {
                            let output: Val<bevy::math::UVec3> = bevy::math::DVec3::as_uvec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec3",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::DVec3::as_vec3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec3a",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::DVec3::as_vec3a(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "ceil",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::ceil(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the smallest integer greater than or equal to a number for\n each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::DVec3>,
                    min: Val<bevy::math::DVec3>,
                    max: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`f64::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clamp_length",
                |_self: Val<bevy::math::DVec3>, min: f64, max: f64| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::clamp_length(
                                    _self.into_inner(),
                                    min,
                                    max,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no less than `min` and no more than `max`.\n # Panics\n Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clamp_length_max",
                |_self: Val<bevy::math::DVec3>, max: f64| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::clamp_length_max(
                                    _self.into_inner(),
                                    max,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no more than `max`.\n # Panics\n Will panic if `max` is negative when `glam_assert` is enabled.",
                &["_self", "max"],
            )
            .register_documented(
                "clamp_length_min",
                |_self: Val<bevy::math::DVec3>, min: f64| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::clamp_length_min(
                                    _self.into_inner(),
                                    min,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no less than `min`.\n # Panics\n Will panic if `min` is negative when `glam_assert` is enabled.",
                &["_self", "min"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::DVec3::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "copysign",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::copysign(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with signs of `rhs` and the magnitudes of `self`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cross",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::cross(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the cross product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec3::distance(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the Euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec3::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::DVec3>, rhs: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as ::core::ops::Div<
                                &bevy::math::DVec3,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as ::core::ops::Div<
                                bevy::math::DVec3,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::DVec3>, rhs: f64| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as ::core::ops::Div<
                                f64,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec3::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::DVec3>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec3::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::DVec3>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec3::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::DVec3>, other: Ref<bevy::math::DVec3>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::DVec3 as ::core::cmp::PartialEq<
                                bevy::math::DVec3,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "exp",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::exp(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing `e^self` (the exponential function) for each element of\n `self`.",
                &["_self"],
            )
            .register_documented(
                "extend",
                |_self: Val<bevy::math::DVec3>, w: f64| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec3::extend(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` and the given `w` value.",
                &["_self", "w"],
            )
            .register_documented(
                "floor",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::floor(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the largest integer less than or equal to a number for each\n element of `self`.",
                &["_self"],
            )
            .register_documented(
                "fract",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::fract(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the fractional part of the vector as `self - self.trunc()`.\n Note that this differs from the GLSL implementation of `fract` which returns\n `self - self.floor()`.\n Note that this is fast but not precise for large numbers.",
                &["_self"],
            )
            .register_documented(
                "fract_gl",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::fract_gl(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the fractional part of the vector as `self - self.floor()`.\n Note that this differs from the Rust implementation of `fract` which returns\n `self - self.trunc()`.\n Note that this is fast but not precise for large numbers.",
                &["_self"],
            )
            .register_documented(
                "from_array",
                |a: [f64; 3]| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "is_finite",
                |_self: Val<bevy::math::DVec3>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DVec3::is_finite(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.  If any element is either\n `NaN`, positive or negative infinity, this will return `false`.",
                &["_self"],
            )
            .register_documented(
                "is_finite_mask",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::DVec3::is_finite_mask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs `is_finite` on each element of self, returning a vector mask of the results.\n In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Val<bevy::math::DVec3>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DVec3::is_nan(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NaN`.",
                &["_self"],
            )
            .register_documented(
                "is_nan_mask",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::BVec3> = {
                        {
                            let output: Val<bevy::math::BVec3> = bevy::math::DVec3::is_nan_mask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs `is_nan` on each element of self, returning a vector mask of the results.\n In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.",
                &["_self"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::DVec3>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::DVec3::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 3 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "is_normalized",
                |_self: Val<bevy::math::DVec3>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DVec3::is_normalized(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns whether `self` is length `1.0` or not.\n Uses a precision threshold of approximately `1e-4`.",
                &["_self"],
            )
            .register_documented(
                "length",
                |_self: Val<bevy::math::DVec3>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec3::length(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the length of `self`.",
                &["_self"],
            )
            .register_documented(
                "length_recip",
                |_self: Val<bevy::math::DVec3>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec3::length_recip(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes `1.0 / length()`.\n For valid results, `self` must _not_ be of length zero.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::DVec3>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec3::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.\n This is faster than `length()` as it avoids a square root operation.",
                &["_self"],
            )
            .register_documented(
                "lerp",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>, s: f64| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::lerp(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                    s,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs a linear interpolation between `self` and `rhs` based on the value `s`.\n When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result\n will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly\n extrapolated.",
                &["_self", "rhs", "s"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::DVec3>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec3::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "midpoint",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::midpoint(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Calculates the midpoint between `self` and `rhs`.\n The midpoint is the average of, or halfway point between, two vectors.\n `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`\n while being slightly cheaper to compute.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::DVec3>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec3::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "move_towards",
                |_self: Ref<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>, d: f64| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::move_towards(
                                    &_self,
                                    rhs.into_inner(),
                                    d,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Moves towards `rhs` based on the value `d`.\n When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to\n `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.",
                &["_self", "rhs", "d"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DVec3>, rhs: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as ::core::ops::Mul<
                                &bevy::math::DVec3,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as ::core::ops::Mul<
                                bevy::math::DVec3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DVec3>, rhs: f64| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as ::core::ops::Mul<
                                f64,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_add",
                |
                    _self: Val<bevy::math::DVec3>,
                    a: Val<bevy::math::DVec3>,
                    b: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::mul_add(
                                    _self.into_inner(),
                                    a.into_inner(),
                                    b.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding\n error, yielding a more accurate result than an unfused multiply-add.\n Using `mul_add` *may* be more performant than an unfused multiply-add if the target\n architecture has a dedicated fma CPU instruction. However, this is not always true,\n and will be heavily dependant on designing algorithms with specific target hardware in\n mind.",
                &["_self", "a", "b"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: f64, y: f64, z: f64| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::new(
                                    x,
                                    y,
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z"],
            )
            .register_documented(
                "normalize",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::normalize(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0.\n For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.\n See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].\n Panics\n Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "normalize_or",
                |_self: Val<bevy::math::DVec3>, fallback: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::normalize_or(
                                    _self.into_inner(),
                                    fallback.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0 if possible, else returns a\n fallback value.\n In particular, if the input is zero (or very close to zero), or non-finite,\n the result of this operation will be the fallback value.\n See also [`Self::try_normalize()`].",
                &["_self", "fallback"],
            )
            .register_documented(
                "normalize_or_zero",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::normalize_or_zero(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0 if possible, else returns zero.\n In particular, if the input is zero (or very close to zero), or non-finite,\n the result of this operation will be zero.\n See also [`Self::try_normalize()`].",
                &["_self"],
            )
            .register_documented(
                "powf",
                |_self: Val<bevy::math::DVec3>, n: f64| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::powf(
                                    _self.into_inner(),
                                    n,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing each element of `self` raised to the power of `n`.",
                &["_self", "n"],
            )
            .register_documented(
                "project_onto",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::project_onto(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector projection of `self` onto `rhs`.\n `rhs` must be of non-zero length.\n # Panics\n Will panic if `rhs` is zero length when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "project_onto_normalized",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::project_onto_normalized(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector projection of `self` onto `rhs`.\n `rhs` must be normalized.\n # Panics\n Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "recip",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::recip(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "reflect",
                |_self: Val<bevy::math::DVec3>, normal: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::reflect(
                                    _self.into_inner(),
                                    normal.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the reflection vector for a given incident vector `self` and surface normal\n `normal`.\n `normal` must be normalized.\n # Panics\n Will panic if `normal` is not normalized when `glam_assert` is enabled.",
                &["_self", "normal"],
            )
            .register_documented(
                "refract",
                |
                    _self: Val<bevy::math::DVec3>,
                    normal: Val<bevy::math::DVec3>,
                    eta: f64|
                {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::refract(
                                    _self.into_inner(),
                                    normal.into_inner(),
                                    eta,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the refraction direction for a given incident vector `self`, surface normal\n `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,\n a zero vector will be returned.\n `self` and `normal` must be normalized.\n # Panics\n Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.",
                &["_self", "normal", "eta"],
            )
            .register_documented(
                "reject_from",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::reject_from(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector rejection of `self` from `rhs`.\n The vector rejection is the vector perpendicular to the projection of `self` onto\n `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.\n `rhs` must be of non-zero length.\n # Panics\n Will panic if `rhs` has a length of zero when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "reject_from_normalized",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::reject_from_normalized(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector rejection of `self` from `rhs`.\n The vector rejection is the vector perpendicular to the projection of `self` onto\n `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.\n `rhs` must be normalized.\n # Panics\n Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::DVec3>, rhs: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as ::core::ops::Rem<
                                &bevy::math::DVec3,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as ::core::ops::Rem<
                                bevy::math::DVec3,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::DVec3>, rhs: f64| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as ::core::ops::Rem<
                                f64,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n [Euclidean division]: f64::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "round",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::round(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the nearest integer to a number for each element of `self`.\n Round half-way cases away from 0.0.",
                &["_self"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec3>,
                    if_true: Val<bevy::math::DVec3>,
                    if_false: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n - `1.0` if the number is positive, `+0.0` or `INFINITY`\n - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n - `NAN` if the number is `NAN`",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: f64| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::DVec3>, rhs: Ref<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as ::core::ops::Sub<
                                &bevy::math::DVec3,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::DVec3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as ::core::ops::Sub<
                                bevy::math::DVec3,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::DVec3>, rhs: f64| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DVec3 as ::core::ops::Sub<
                                f64,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::DVec3>| {
                    let output: [f64; 3] = {
                        {
                            let output: [f64; 3] = bevy::math::DVec3::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z]`",
                &["_self"],
            )
            .register_documented(
                "trunc",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::trunc(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the integer part each element of `self`. This means numbers are\n always truncated towards zero.",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DVec3::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.\n Truncation may also be performed by using [`self.xy()`][crate::swizzles::Vec3Swizzles::xy()].",
                &["_self"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::DVec3>, x: f64| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::DVec3>, y: f64| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::DVec3>, z: f64| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec3::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::DVec3,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_d_vec_4_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::DVec4,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::abs(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the absolute value of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Val<bevy::math::DVec4>,
                    rhs: Val<bevy::math::DVec4>,
                    max_abs_diff: f64|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DVec4::abs_diff_eq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs` is\n less than or equal to `max_abs_diff`.\n This can be used to compare if two vectors contain similar elements. It works best when\n comparing with a known value. The `max_abs_diff` that should be used used depends on\n the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::DVec4>, rhs: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as ::core::ops::Add<
                                &bevy::math::DVec4,
                            >>::add(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as ::core::ops::Add<
                                bevy::math::DVec4,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::DVec4>, rhs: f64| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as ::core::ops::Add<
                                f64,
                            >>::add(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_i16vec4",
                |_self: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::I16Vec4> = {
                        {
                            let output: Val<bevy::math::I16Vec4> = bevy::math::DVec4::as_i16vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i16`.",
                &["_self"],
            )
            .register_documented(
                "as_i64vec4",
                |_self: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::I64Vec4> = {
                        {
                            let output: Val<bevy::math::I64Vec4> = bevy::math::DVec4::as_i64vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i64`.",
                &["_self"],
            )
            .register_documented(
                "as_i8vec4",
                |_self: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::I8Vec4> = {
                        {
                            let output: Val<bevy::math::I8Vec4> = bevy::math::DVec4::as_i8vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i8`.",
                &["_self"],
            )
            .register_documented(
                "as_ivec4",
                |_self: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::IVec4> = {
                        {
                            let output: Val<bevy::math::IVec4> = bevy::math::DVec4::as_ivec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `i32`.",
                &["_self"],
            )
            .register_documented(
                "as_u16vec4",
                |_self: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::U16Vec4> = {
                        {
                            let output: Val<bevy::math::U16Vec4> = bevy::math::DVec4::as_u16vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u16`.",
                &["_self"],
            )
            .register_documented(
                "as_u64vec4",
                |_self: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::U64Vec4> = {
                        {
                            let output: Val<bevy::math::U64Vec4> = bevy::math::DVec4::as_u64vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u64`.",
                &["_self"],
            )
            .register_documented(
                "as_u8vec4",
                |_self: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::U8Vec4> = {
                        {
                            let output: Val<bevy::math::U8Vec4> = bevy::math::DVec4::as_u8vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u8`.",
                &["_self"],
            )
            .register_documented(
                "as_uvec4",
                |_self: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::UVec4> = {
                        {
                            let output: Val<bevy::math::UVec4> = bevy::math::DVec4::as_uvec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `u32`.",
                &["_self"],
            )
            .register_documented(
                "as_vec4",
                |_self: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::DVec4::as_vec4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Casts all elements of `self` to `f32`.",
                &["_self"],
            )
            .register_documented(
                "ceil",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::ceil(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the smallest integer greater than or equal to a number for\n each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "clamp",
                |
                    _self: Val<bevy::math::DVec4>,
                    min: Val<bevy::math::DVec4>,
                    max: Val<bevy::math::DVec4>|
                {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::clamp(
                                    _self.into_inner(),
                                    min.into_inner(),
                                    max.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Component-wise clamping of values, similar to [`f64::clamp`].\n Each element in `min` must be less-or-equal to the corresponding element in `max`.\n # Panics\n Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clamp_length",
                |_self: Val<bevy::math::DVec4>, min: f64, max: f64| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::clamp_length(
                                    _self.into_inner(),
                                    min,
                                    max,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no less than `min` and no more than `max`.\n # Panics\n Will panic if `min` is greater than `max`, or if either `min` or `max` is negative, when `glam_assert` is enabled.",
                &["_self", "min", "max"],
            )
            .register_documented(
                "clamp_length_max",
                |_self: Val<bevy::math::DVec4>, max: f64| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::clamp_length_max(
                                    _self.into_inner(),
                                    max,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no more than `max`.\n # Panics\n Will panic if `max` is negative when `glam_assert` is enabled.",
                &["_self", "max"],
            )
            .register_documented(
                "clamp_length_min",
                |_self: Val<bevy::math::DVec4>, min: f64| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::clamp_length_min(
                                    _self.into_inner(),
                                    min,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with a length no less than `min`.\n # Panics\n Will panic if `min` is negative when `glam_assert` is enabled.",
                &["_self", "min"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "cmpeq",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmpeq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `==` comparison for each element of\n `self` and `rhs`.\n In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpge",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmpge(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpgt",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmpgt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `>` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmple",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmple(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmplt",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmplt(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `<` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "cmpne",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::DVec4::cmpne(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector mask containing the result of a `!=` comparison for each element of\n `self` and `rhs`.\n In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all\n elements.",
                &["_self", "rhs"],
            )
            .register_documented(
                "copysign",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::copysign(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with signs of `rhs` and the magnitudes of `self`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec4::distance(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the Euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "distance_squared",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec4::distance_squared(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Compute the squared euclidean distance between two points in space.",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::DVec4>, rhs: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as ::core::ops::Div<
                                &bevy::math::DVec4,
                            >>::div(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as ::core::ops::Div<
                                bevy::math::DVec4,
                            >>::div(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::DVec4>, rhs: f64| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as ::core::ops::Div<
                                f64,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_euclid",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::div_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise quotient of [Euclidean division] of `self` by `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec4::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot_into_vec",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::dot_into_vec(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector where every component is the dot product of `self` and `rhs`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "element_product",
                |_self: Val<bevy::math::DVec4>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec4::element_product(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the product of all elements of `self`.\n In other words, this computes `self.x * self.y * ..`.",
                &["_self"],
            )
            .register_documented(
                "element_sum",
                |_self: Val<bevy::math::DVec4>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec4::element_sum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the sum of all elements of `self`.\n In other words, this computes `self.x + self.y + ..`.",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::DVec4>, other: Ref<bevy::math::DVec4>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::DVec4 as ::core::cmp::PartialEq<
                                bevy::math::DVec4,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "exp",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::exp(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing `e^self` (the exponential function) for each element of\n `self`.",
                &["_self"],
            )
            .register_documented(
                "floor",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::floor(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the largest integer less than or equal to a number for each\n element of `self`.",
                &["_self"],
            )
            .register_documented(
                "fract",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::fract(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the fractional part of the vector as `self - self.trunc()`.\n Note that this differs from the GLSL implementation of `fract` which returns\n `self - self.floor()`.\n Note that this is fast but not precise for large numbers.",
                &["_self"],
            )
            .register_documented(
                "fract_gl",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::fract_gl(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the fractional part of the vector as `self - self.floor()`.\n Note that this differs from the Rust implementation of `fract` which returns\n `self - self.trunc()`.\n Note that this is fast but not precise for large numbers.",
                &["_self"],
            )
            .register_documented(
                "from_array",
                |a: [f64; 4]| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector from an array.",
                &["a"],
            )
            .register_documented(
                "is_finite",
                |_self: Val<bevy::math::DVec4>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DVec4::is_finite(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.  If any element is either\n `NaN`, positive or negative infinity, this will return `false`.",
                &["_self"],
            )
            .register_documented(
                "is_finite_mask",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::DVec4::is_finite_mask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs `is_finite` on each element of self, returning a vector mask of the results.\n In other words, this computes `[x.is_finite(), y.is_finite(), ...]`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Val<bevy::math::DVec4>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DVec4::is_nan(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NaN`.",
                &["_self"],
            )
            .register_documented(
                "is_nan_mask",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::BVec4> = {
                        {
                            let output: Val<bevy::math::BVec4> = bevy::math::DVec4::is_nan_mask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs `is_nan` on each element of self, returning a vector mask of the results.\n In other words, this computes `[x.is_nan(), y.is_nan(), ...]`.",
                &["_self"],
            )
            .register_documented(
                "is_negative_bitmask",
                |_self: Val<bevy::math::DVec4>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::DVec4::is_negative_bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 4 bits set to the sign bits from the elements of `self`.\n A negative element results in a `1` bit and a positive element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "is_normalized",
                |_self: Val<bevy::math::DVec4>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DVec4::is_normalized(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns whether `self` is length `1.0` or not.\n Uses a precision threshold of approximately `1e-4`.",
                &["_self"],
            )
            .register_documented(
                "length",
                |_self: Val<bevy::math::DVec4>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec4::length(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the length of `self`.",
                &["_self"],
            )
            .register_documented(
                "length_recip",
                |_self: Val<bevy::math::DVec4>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec4::length_recip(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes `1.0 / length()`.\n For valid results, `self` must _not_ be of length zero.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::DVec4>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec4::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.\n This is faster than `length()` as it avoids a square root operation.",
                &["_self"],
            )
            .register_documented(
                "lerp",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>, s: f64| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::lerp(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                    s,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs a linear interpolation between `self` and `rhs` based on the value `s`.\n When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result\n will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly\n extrapolated.",
                &["_self", "rhs", "s"],
            )
            .register_documented(
                "max",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::max(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the maximum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "max_element",
                |_self: Val<bevy::math::DVec4>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec4::max_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal maximum of `self`.\n In other words this computes `max(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "midpoint",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::midpoint(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Calculates the midpoint between `self` and `rhs`.\n The midpoint is the average of, or halfway point between, two vectors.\n `a.midpoint(b)` should yield the same result as `a.lerp(b, 0.5)`\n while being slightly cheaper to compute.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::min(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the minimum values for each element of `self` and `rhs`.\n In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "min_element",
                |_self: Val<bevy::math::DVec4>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DVec4::min_element(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the horizontal minimum of `self`.\n In other words this computes `min(x, y, ..)`.",
                &["_self"],
            )
            .register_documented(
                "move_towards",
                |_self: Ref<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>, d: f64| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::move_towards(
                                    &_self,
                                    rhs.into_inner(),
                                    d,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Moves towards `rhs` based on the value `d`.\n When `d` is `0.0`, the result will be equal to `self`. When `d` is equal to\n `self.distance(rhs)`, the result will be equal to `rhs`. Will not go past `rhs`.",
                &["_self", "rhs", "d"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DVec4>, rhs: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as ::core::ops::Mul<
                                &bevy::math::DVec4,
                            >>::mul(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as ::core::ops::Mul<
                                bevy::math::DVec4,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DVec4>, rhs: f64| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as ::core::ops::Mul<
                                f64,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_add",
                |
                    _self: Val<bevy::math::DVec4>,
                    a: Val<bevy::math::DVec4>,
                    b: Val<bevy::math::DVec4>|
                {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::mul_add(
                                    _self.into_inner(),
                                    a.into_inner(),
                                    b.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding\n error, yielding a more accurate result than an unfused multiply-add.\n Using `mul_add` *may* be more performant than an unfused multiply-add if the target\n architecture has a dedicated fma CPU instruction. However, this is not always true,\n and will be heavily dependant on designing algorithms with specific target hardware in\n mind.",
                &["_self", "a", "b"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "new",
                |x: f64, y: f64, z: f64, w: f64| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::new(
                                    x,
                                    y,
                                    z,
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector.",
                &["x", "y", "z", "w"],
            )
            .register_documented(
                "normalize",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::normalize(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0.\n For valid results, `self` must be finite and _not_ of length zero, nor very close to zero.\n See also [`Self::try_normalize()`] and [`Self::normalize_or_zero()`].\n Panics\n Will panic if the resulting normalized vector is not finite when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "normalize_or",
                |_self: Val<bevy::math::DVec4>, fallback: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::normalize_or(
                                    _self.into_inner(),
                                    fallback.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0 if possible, else returns a\n fallback value.\n In particular, if the input is zero (or very close to zero), or non-finite,\n the result of this operation will be the fallback value.\n See also [`Self::try_normalize()`].",
                &["_self", "fallback"],
            )
            .register_documented(
                "normalize_or_zero",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::normalize_or_zero(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0 if possible, else returns zero.\n In particular, if the input is zero (or very close to zero), or non-finite,\n the result of this operation will be zero.\n See also [`Self::try_normalize()`].",
                &["_self"],
            )
            .register_documented(
                "powf",
                |_self: Val<bevy::math::DVec4>, n: f64| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::powf(
                                    _self.into_inner(),
                                    n,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing each element of `self` raised to the power of `n`.",
                &["_self", "n"],
            )
            .register_documented(
                "project_onto",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::project_onto(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector projection of `self` onto `rhs`.\n `rhs` must be of non-zero length.\n # Panics\n Will panic if `rhs` is zero length when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "project_onto_normalized",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::project_onto_normalized(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector projection of `self` onto `rhs`.\n `rhs` must be normalized.\n # Panics\n Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "recip",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::recip(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
                &["_self"],
            )
            .register_documented(
                "reflect",
                |_self: Val<bevy::math::DVec4>, normal: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::reflect(
                                    _self.into_inner(),
                                    normal.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the reflection vector for a given incident vector `self` and surface normal\n `normal`.\n `normal` must be normalized.\n # Panics\n Will panic if `normal` is not normalized when `glam_assert` is enabled.",
                &["_self", "normal"],
            )
            .register_documented(
                "refract",
                |
                    _self: Val<bevy::math::DVec4>,
                    normal: Val<bevy::math::DVec4>,
                    eta: f64|
                {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::refract(
                                    _self.into_inner(),
                                    normal.into_inner(),
                                    eta,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the refraction direction for a given incident vector `self`, surface normal\n `normal` and ratio of indices of refraction, `eta`. When total internal reflection occurs,\n a zero vector will be returned.\n `self` and `normal` must be normalized.\n # Panics\n Will panic if `self` or `normal` is not normalized when `glam_assert` is enabled.",
                &["_self", "normal", "eta"],
            )
            .register_documented(
                "reject_from",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::reject_from(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector rejection of `self` from `rhs`.\n The vector rejection is the vector perpendicular to the projection of `self` onto\n `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.\n `rhs` must be of non-zero length.\n # Panics\n Will panic if `rhs` has a length of zero when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "reject_from_normalized",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::reject_from_normalized(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector rejection of `self` from `rhs`.\n The vector rejection is the vector perpendicular to the projection of `self` onto\n `rhs`, in rhs words the result of `self - self.project_onto(rhs)`.\n `rhs` must be normalized.\n # Panics\n Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::DVec4>, rhs: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as ::core::ops::Rem<
                                &bevy::math::DVec4,
                            >>::rem(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as ::core::ops::Rem<
                                bevy::math::DVec4,
                            >>::rem(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem",
                |_self: Val<bevy::math::DVec4>, rhs: f64| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as ::core::ops::Rem<
                                f64,
                            >>::rem(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "rem_euclid",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::rem_euclid(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the element-wise remainder of [Euclidean division] of `self` by `rhs`.\n [Euclidean division]: f64::rem_euclid",
                &["_self", "rhs"],
            )
            .register_documented(
                "round",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::round(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the nearest integer to a number for each element of `self`.\n Round half-way cases away from 0.0.",
                &["_self"],
            )
            .register_documented(
                "select",
                |
                    mask: Val<bevy::math::BVec4>,
                    if_true: Val<bevy::math::DVec4>,
                    if_false: Val<bevy::math::DVec4>|
                {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::select(
                                    mask.into_inner(),
                                    if_true.into_inner(),
                                    if_false.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector from the elements in `if_true` and `if_false`, selecting which to use\n for each element of `self`.\n A true element in the mask uses the corresponding element from `if_true`, and false\n uses the element from `if_false`.",
                &["mask", "if_true", "if_false"],
            )
            .register_documented(
                "signum",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::signum(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector with elements representing the sign of `self`.\n - `1.0` if the number is positive, `+0.0` or `INFINITY`\n - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n - `NAN` if the number is `NAN`",
                &["_self"],
            )
            .register_documented(
                "splat",
                |v: f64| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::DVec4>, rhs: Ref<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as ::core::ops::Sub<
                                &bevy::math::DVec4,
                            >>::sub(_self.into_inner(), &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::DVec4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as ::core::ops::Sub<
                                bevy::math::DVec4,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::DVec4>, rhs: f64| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = <bevy::math::DVec4 as ::core::ops::Sub<
                                f64,
                            >>::sub(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::DVec4>| {
                    let output: [f64; 4] = {
                        {
                            let output: [f64; 4] = bevy::math::DVec4::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z, w]`",
                &["_self"],
            )
            .register_documented(
                "trunc",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::trunc(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a vector containing the integer part each element of `self`. This means numbers are\n always truncated towards zero.",
                &["_self"],
            )
            .register_documented(
                "truncate",
                |_self: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DVec4::truncate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.\n Truncation to [`DVec3`] may also be performed by using [`self.xyz()`][crate::swizzles::Vec4Swizzles::xyz()].",
                &["_self"],
            )
            .register_documented(
                "with_w",
                |_self: Val<bevy::math::DVec4>, w: f64| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::with_w(
                                    _self.into_inner(),
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `w`.",
                &["_self", "w"],
            )
            .register_documented(
                "with_x",
                |_self: Val<bevy::math::DVec4>, x: f64| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::with_x(
                                    _self.into_inner(),
                                    x,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `x`.",
                &["_self", "x"],
            )
            .register_documented(
                "with_y",
                |_self: Val<bevy::math::DVec4>, y: f64| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::with_y(
                                    _self.into_inner(),
                                    y,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `y`.",
                &["_self", "y"],
            )
            .register_documented(
                "with_z",
                |_self: Val<bevy::math::DVec4>, z: f64| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DVec4::with_z(
                                    _self.into_inner(),
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4D vector from `self` with the given value of `z`.",
                &["_self", "z"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::DVec4,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_mat_2_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::Mat2,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = bevy::math::Mat2::abs(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Takes the absolute value of each element in `self`",
                &["_self"],
            )
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::Mat2>,
                    rhs: Val<bevy::math::Mat2>,
                    max_abs_diff: f32|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Mat2::abs_diff_eq(
                                    &_self,
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs`\n is less than or equal to `max_abs_diff`.\n This can be used to compare if two matrices contain similar elements. It works best\n when comparing with a known value. The `max_abs_diff` that should be used used\n depends on the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::Mat2>, rhs: Val<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as ::core::ops::Add<
                                bevy::math::Mat2,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add_mat2",
                |_self: Ref<bevy::math::Mat2>, rhs: Ref<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = bevy::math::Mat2::add_mat2(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Adds two 2x2 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dmat2",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = bevy::math::Mat2::as_dmat2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "col",
                |_self: Ref<bevy::math::Mat2>, index: usize| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Mat2::col(
                                    &_self,
                                    index,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the matrix column for the given `index`.\n # Panics\n Panics if `index` is greater than 1.",
                &["_self", "index"],
            )
            .register_documented(
                "determinant",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Mat2::determinant(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the determinant of `self`.",
                &["_self"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::Mat2>, rhs: f32| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as ::core::ops::Div<
                                f32,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_scalar",
                |_self: Ref<bevy::math::Mat2>, rhs: f32| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = bevy::math::Mat2::div_scalar(
                                    &_self,
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Divides a 2x2 matrix by a scalar.",
                &["_self", "rhs"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::Mat2>, rhs: Ref<bevy::math::Mat2>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::Mat2 as ::core::cmp::PartialEq<
                                bevy::math::Mat2,
                            >>::eq(&_self, &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "from_angle",
                |angle: f32| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_angle(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2x2 matrix containing a rotation of `angle` (in radians).",
                &["angle"],
            )
            .register_documented(
                "from_cols",
                |x_axis: Val<bevy::math::Vec2>, y_axis: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_cols(
                                    x_axis.into_inner(),
                                    y_axis.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2x2 matrix from two column vectors.",
                &["x_axis", "y_axis"],
            )
            .register_documented(
                "from_diagonal",
                |diagonal: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_diagonal(
                                    diagonal.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2x2 matrix with its diagonal set to `diagonal` and all other entries set to 0.",
                &["diagonal"],
            )
            .register_documented(
                "from_mat3",
                |m: Val<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_mat3(
                                    m.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2x2 matrix from a 3x3 matrix, discarding the 2nd row and column.",
                &["m"],
            )
            .register_documented(
                "from_mat3_minor",
                |m: Val<bevy::math::Mat3>, i: usize, j: usize| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_mat3_minor(
                                    m.into_inner(),
                                    i,
                                    j,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2x2 matrix from the minor of the given 3x3 matrix, discarding the `i`th column\n and `j`th row.\n # Panics\n Panics if `i` or `j` is greater than 2.",
                &["m", "i", "j"],
            )
            .register_documented(
                "from_mat3a",
                |m: Val<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_mat3a(
                                    m.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2x2 matrix from a 3x3 matrix, discarding the 2nd row and column.",
                &["m"],
            )
            .register_documented(
                "from_mat3a_minor",
                |m: Val<bevy::math::Mat3A>, i: usize, j: usize| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_mat3a_minor(
                                    m.into_inner(),
                                    i,
                                    j,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2x2 matrix from the minor of the given 3x3 matrix, discarding the `i`th column\n and `j`th row.\n # Panics\n Panics if `i` or `j` is greater than 2.",
                &["m", "i", "j"],
            )
            .register_documented(
                "from_scale_angle",
                |scale: Val<bevy::math::Vec2>, angle: f32| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = bevy::math::Mat2::from_scale_angle(
                                    scale.into_inner(),
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2x2 matrix containing the combining non-uniform `scale` and rotation of\n `angle` (in radians).",
                &["scale", "angle"],
            )
            .register_documented(
                "inverse",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = bevy::math::Mat2::inverse(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the inverse of `self`.\n If the matrix is not invertible the returned matrix will be invalid.\n # Panics\n Will panic if the determinant of `self` is zero when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "is_finite",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Mat2::is_finite(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.\n If any element is either `NaN`, positive or negative infinity, this will return `false`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Mat2::is_nan(&_self).into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NaN`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Mat2>, rhs: Val<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as ::core::ops::Mul<
                                bevy::math::Mat2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Mat2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = <bevy::math::Mat2 as ::core::ops::Mul<
                                bevy::math::Vec2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Mat2>, rhs: f32| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as ::core::ops::Mul<
                                f32,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_mat2",
                |_self: Ref<bevy::math::Mat2>, rhs: Ref<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = bevy::math::Mat2::mul_mat2(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies two 2x2 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_scalar",
                |_self: Ref<bevy::math::Mat2>, rhs: f32| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = bevy::math::Mat2::mul_scalar(
                                    &_self,
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies a 2x2 matrix by a scalar.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_vec2",
                |_self: Ref<bevy::math::Mat2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Mat2::mul_vec2(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms a 2D vector.",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "row",
                |_self: Ref<bevy::math::Mat2>, index: usize| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Mat2::row(
                                    &_self,
                                    index,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the matrix row for the given `index`.\n # Panics\n Panics if `index` is greater than 1.",
                &["_self", "index"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::Mat2>, rhs: Val<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = <bevy::math::Mat2 as ::core::ops::Sub<
                                bevy::math::Mat2,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub_mat2",
                |_self: Ref<bevy::math::Mat2>, rhs: Ref<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = bevy::math::Mat2::sub_mat2(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Subtracts two 2x2 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_cols_array",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: [f32; 4] = {
                        {
                            let output: [f32; 4] = bevy::math::Mat2::to_cols_array(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[f32; 4]` array storing data in column major order.\n If you require data in row major order `transpose` the matrix first.",
                &["_self"],
            )
            .register_documented(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: [[f32; 2]; 2] = {
                        {
                            let output: [[f32; 2]; 2] = bevy::math::Mat2::to_cols_array_2d(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[[f32; 2]; 2]` 2D array storing data in column major order.\n If you require data in row major order `transpose` the matrix first.",
                &["_self"],
            )
            .register_documented(
                "transpose",
                |_self: Ref<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = bevy::math::Mat2::transpose(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the transpose of `self`.",
                &["_self"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::Mat2,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_mat_3_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::Mat3,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::abs(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Takes the absolute value of each element in `self`",
                &["_self"],
            )
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::Mat3>,
                    rhs: Val<bevy::math::Mat3>,
                    max_abs_diff: f32|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Mat3::abs_diff_eq(
                                    &_self,
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs`\n is less than or equal to `max_abs_diff`.\n This can be used to compare if two matrices contain similar elements. It works best\n when comparing with a known value. The `max_abs_diff` that should be used used\n depends on the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::Mat3>, rhs: Val<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as ::core::ops::Add<
                                bevy::math::Mat3,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add_mat3",
                |_self: Ref<bevy::math::Mat3>, rhs: Ref<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::add_mat3(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Adds two 3x3 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dmat3",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::Mat3::as_dmat3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "col",
                |_self: Ref<bevy::math::Mat3>, index: usize| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Mat3::col(
                                    &_self,
                                    index,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the matrix column for the given `index`.\n # Panics\n Panics if `index` is greater than 2.",
                &["_self", "index"],
            )
            .register_documented(
                "determinant",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Mat3::determinant(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the determinant of `self`.",
                &["_self"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::Mat3>, rhs: f32| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as ::core::ops::Div<
                                f32,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_scalar",
                |_self: Ref<bevy::math::Mat3>, rhs: f32| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::div_scalar(
                                    &_self,
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Divides a 3x3 matrix by a scalar.",
                &["_self", "rhs"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::Mat3>, rhs: Ref<bevy::math::Mat3>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::Mat3 as ::core::cmp::PartialEq<
                                bevy::math::Mat3,
                            >>::eq(&_self, &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "from_angle",
                |angle: f32| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_angle(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 2D rotation `angle` (in\n radians).\n The resulting matrix can be used to transform 2D points and vectors. See\n [`Self::transform_point2()`] and [`Self::transform_vector2()`].",
                &["angle"],
            )
            .register_documented(
                "from_axis_angle",
                |axis: Val<bevy::math::Vec3>, angle: f32| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_axis_angle(
                                    axis.into_inner(),
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in\n radians).\n # Panics\n Will panic if `axis` is not normalized when `glam_assert` is enabled.",
                &["axis", "angle"],
            )
            .register_documented(
                "from_cols",
                |
                    x_axis: Val<bevy::math::Vec3>,
                    y_axis: Val<bevy::math::Vec3>,
                    z_axis: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_cols(
                                    x_axis.into_inner(),
                                    y_axis.into_inner(),
                                    z_axis.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3x3 matrix from three column vectors.",
                &["x_axis", "y_axis", "z_axis"],
            )
            .register_documented(
                "from_diagonal",
                |diagonal: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_diagonal(
                                    diagonal.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.",
                &["diagonal"],
            )
            .register_documented(
                "from_euler",
                |order: Val<bevy::math::EulerRot>, a: f32, b: f32, c: f32| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_euler(
                                    order.into_inner(),
                                    a,
                                    b,
                                    c,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in\n radians).",
                &["order", "a", "b", "c"],
            )
            .register_documented(
                "from_mat2",
                |m: Val<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_mat2(
                                    m.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 2x2 matrix.\n The resulting matrix can be used to transform 2D points and vectors. See\n [`Self::transform_point2()`] and [`Self::transform_vector2()`].",
                &["m"],
            )
            .register_documented(
                "from_mat4",
                |m: Val<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_mat4(
                                    m.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3x3 matrix from a 4x4 matrix, discarding the 4th row and column.",
                &["m"],
            )
            .register_documented(
                "from_mat4_minor",
                |m: Val<bevy::math::Mat4>, i: usize, j: usize| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_mat4_minor(
                                    m.into_inner(),
                                    i,
                                    j,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3x3 matrix from the minor of the given 4x4 matrix, discarding the `i`th column\n and `j`th row.\n # Panics\n Panics if `i` or `j` is greater than 3.",
                &["m", "i", "j"],
            )
            .register_documented(
                "from_quat",
                |rotation: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_quat(
                                    rotation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D rotation matrix from the given quaternion.\n # Panics\n Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
                &["rotation"],
            )
            .register_documented(
                "from_rotation_x",
                |angle: f32| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_rotation_x(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D rotation matrix from `angle` (in radians) around the x axis.",
                &["angle"],
            )
            .register_documented(
                "from_rotation_y",
                |angle: f32| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_rotation_y(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D rotation matrix from `angle` (in radians) around the y axis.",
                &["angle"],
            )
            .register_documented(
                "from_rotation_z",
                |angle: f32| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_rotation_z(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D rotation matrix from `angle` (in radians) around the z axis.",
                &["angle"],
            )
            .register_documented(
                "from_scale",
                |scale: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_scale(
                                    scale.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given non-uniform 2D `scale`.\n The resulting matrix can be used to transform 2D points and vectors. See\n [`Self::transform_point2()`] and [`Self::transform_vector2()`].\n # Panics\n Will panic if all elements of `scale` are zero when `glam_assert` is enabled.",
                &["scale"],
            )
            .register_documented(
                "from_scale_angle_translation",
                |
                    scale: Val<bevy::math::Vec2>,
                    angle: f32,
                    translation: Val<bevy::math::Vec2>|
                {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_scale_angle_translation(
                                    scale.into_inner(),
                                    angle,
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in\n radians) and `translation`.\n The resulting matrix can be used to transform 2D points and vectors. See\n [`Self::transform_point2()`] and [`Self::transform_vector2()`].",
                &["scale", "angle", "translation"],
            )
            .register_documented(
                "from_translation",
                |translation: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::from_translation(
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 2D `translation`.\n The resulting matrix can be used to transform 2D points and vectors. See\n [`Self::transform_point2()`] and [`Self::transform_vector2()`].",
                &["translation"],
            )
            .register_documented(
                "inverse",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::inverse(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the inverse of `self`.\n If the matrix is not invertible the returned matrix will be invalid.\n # Panics\n Will panic if the determinant of `self` is zero when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "is_finite",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Mat3::is_finite(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.\n If any element is either `NaN`, positive or negative infinity, this will return `false`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Mat3::is_nan(&_self).into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NaN`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Mat3>, rhs: Val<bevy::math::Affine2>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as ::core::ops::Mul<
                                bevy::math::Affine2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Mat3>, rhs: Val<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as ::core::ops::Mul<
                                bevy::math::Mat3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Mat3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Mat3 as ::core::ops::Mul<
                                bevy::math::Vec3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Mat3>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Mat3 as ::core::ops::Mul<
                                bevy::math::Vec3A,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Mat3>, rhs: f32| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as ::core::ops::Mul<
                                f32,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_mat3",
                |_self: Ref<bevy::math::Mat3>, rhs: Ref<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::mul_mat3(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies two 3x3 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_scalar",
                |_self: Ref<bevy::math::Mat3>, rhs: f32| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::mul_scalar(
                                    &_self,
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies a 3x3 matrix by a scalar.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_vec3",
                |_self: Ref<bevy::math::Mat3>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Mat3::mul_vec3(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms a 3D vector.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_vec3a",
                |_self: Ref<bevy::math::Mat3>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Mat3::mul_vec3a(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms a [`Vec3A`].",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "row",
                |_self: Ref<bevy::math::Mat3>, index: usize| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Mat3::row(
                                    &_self,
                                    index,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the matrix row for the given `index`.\n # Panics\n Panics if `index` is greater than 2.",
                &["_self", "index"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::Mat3>, rhs: Val<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = <bevy::math::Mat3 as ::core::ops::Sub<
                                bevy::math::Mat3,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub_mat3",
                |_self: Ref<bevy::math::Mat3>, rhs: Ref<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::sub_mat3(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Subtracts two 3x3 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_cols_array",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: [f32; 9] = {
                        {
                            let output: [f32; 9] = bevy::math::Mat3::to_cols_array(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[f32; 9]` array storing data in column major order.\n If you require data in row major order `transpose` the matrix first.",
                &["_self"],
            )
            .register_documented(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: [[f32; 3]; 3] = {
                        {
                            let output: [[f32; 3]; 3] = bevy::math::Mat3::to_cols_array_2d(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[[f32; 3]; 3]` 3D array storing data in column major order.\n If you require data in row major order `transpose` the matrix first.",
                &["_self"],
            )
            .register_documented(
                "to_euler",
                |_self: Ref<bevy::math::Mat3>, order: Val<bevy::math::EulerRot>| {
                    let output: (f32, f32, f32) = {
                        {
                            let output: (f32, f32, f32) = bevy::math::Mat3::to_euler(
                                    &_self,
                                    order.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Extract Euler angles with the given Euler rotation order.\n Note if the input matrix contains scales, shears, or other non-rotation transformations then\n the resulting Euler angles will be ill-defined.\n # Panics\n Will panic if any input matrix column is not normalized when `glam_assert` is enabled.",
                &["_self", "order"],
            )
            .register_documented(
                "transform_point2",
                |_self: Ref<bevy::math::Mat3>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Mat3::transform_point2(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given 2D vector as a point.\n This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.\n This method assumes that `self` contains a valid affine transform.\n # Panics\n Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "transform_vector2",
                |_self: Ref<bevy::math::Mat3>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Mat3::transform_vector2(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Rotates the given 2D vector.\n This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.\n This method assumes that `self` contains a valid affine transform.\n # Panics\n Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "transpose",
                |_self: Ref<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::Mat3::transpose(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the transpose of `self`.",
                &["_self"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::Mat3,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_mat_3_a_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::Mat3A,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::abs(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Takes the absolute value of each element in `self`",
                &["_self"],
            )
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::Mat3A>,
                    rhs: Val<bevy::math::Mat3A>,
                    max_abs_diff: f32|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Mat3A::abs_diff_eq(
                                    &_self,
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs`\n is less than or equal to `max_abs_diff`.\n This can be used to compare if two matrices contain similar elements. It works best\n when comparing with a known value. The `max_abs_diff` that should be used used\n depends on the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::Mat3A>, rhs: Val<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as ::core::ops::Add<
                                bevy::math::Mat3A,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add_mat3",
                |_self: Ref<bevy::math::Mat3A>, rhs: Ref<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::add_mat3(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Adds two 3x3 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dmat3",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::Mat3A::as_dmat3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "col",
                |_self: Ref<bevy::math::Mat3A>, index: usize| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Mat3A::col(
                                    &_self,
                                    index,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the matrix column for the given `index`.\n # Panics\n Panics if `index` is greater than 2.",
                &["_self", "index"],
            )
            .register_documented(
                "determinant",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Mat3A::determinant(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the determinant of `self`.",
                &["_self"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::Mat3A>, rhs: f32| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as ::core::ops::Div<
                                f32,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_scalar",
                |_self: Ref<bevy::math::Mat3A>, rhs: f32| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::div_scalar(
                                    &_self,
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Divides a 3x3 matrix by a scalar.",
                &["_self", "rhs"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::Mat3A>, rhs: Ref<bevy::math::Mat3A>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::Mat3A as ::core::cmp::PartialEq<
                                bevy::math::Mat3A,
                            >>::eq(&_self, &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "from_angle",
                |angle: f32| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_angle(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 2D rotation `angle` (in\n radians).\n The resulting matrix can be used to transform 2D points and vectors. See\n [`Self::transform_point2()`] and [`Self::transform_vector2()`].",
                &["angle"],
            )
            .register_documented(
                "from_axis_angle",
                |axis: Val<bevy::math::Vec3>, angle: f32| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_axis_angle(
                                    axis.into_inner(),
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in\n radians).\n # Panics\n Will panic if `axis` is not normalized when `glam_assert` is enabled.",
                &["axis", "angle"],
            )
            .register_documented(
                "from_cols",
                |
                    x_axis: Val<bevy::math::Vec3A>,
                    y_axis: Val<bevy::math::Vec3A>,
                    z_axis: Val<bevy::math::Vec3A>|
                {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_cols(
                                    x_axis.into_inner(),
                                    y_axis.into_inner(),
                                    z_axis.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3x3 matrix from three column vectors.",
                &["x_axis", "y_axis", "z_axis"],
            )
            .register_documented(
                "from_diagonal",
                |diagonal: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_diagonal(
                                    diagonal.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.",
                &["diagonal"],
            )
            .register_documented(
                "from_euler",
                |order: Val<bevy::math::EulerRot>, a: f32, b: f32, c: f32| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_euler(
                                    order.into_inner(),
                                    a,
                                    b,
                                    c,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in\n radians).",
                &["order", "a", "b", "c"],
            )
            .register_documented(
                "from_mat2",
                |m: Val<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_mat2(
                                    m.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 2x2 matrix.\n The resulting matrix can be used to transform 2D points and vectors. See\n [`Self::transform_point2()`] and [`Self::transform_vector2()`].",
                &["m"],
            )
            .register_documented(
                "from_mat4",
                |m: Val<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_mat4(
                                    m.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3x3 matrix from a 4x4 matrix, discarding the 4th row and column.",
                &["m"],
            )
            .register_documented(
                "from_mat4_minor",
                |m: Val<bevy::math::Mat4>, i: usize, j: usize| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_mat4_minor(
                                    m.into_inner(),
                                    i,
                                    j,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3x3 matrix from the minor of the given 4x4 matrix, discarding the `i`th column\n and `j`th row.\n # Panics\n Panics if `i` or `j` is greater than 3.",
                &["m", "i", "j"],
            )
            .register_documented(
                "from_quat",
                |rotation: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_quat(
                                    rotation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D rotation matrix from the given quaternion.\n # Panics\n Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
                &["rotation"],
            )
            .register_documented(
                "from_rotation_x",
                |angle: f32| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_rotation_x(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D rotation matrix from `angle` (in radians) around the x axis.",
                &["angle"],
            )
            .register_documented(
                "from_rotation_y",
                |angle: f32| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_rotation_y(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D rotation matrix from `angle` (in radians) around the y axis.",
                &["angle"],
            )
            .register_documented(
                "from_rotation_z",
                |angle: f32| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_rotation_z(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D rotation matrix from `angle` (in radians) around the z axis.",
                &["angle"],
            )
            .register_documented(
                "from_scale",
                |scale: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_scale(
                                    scale.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given non-uniform 2D `scale`.\n The resulting matrix can be used to transform 2D points and vectors. See\n [`Self::transform_point2()`] and [`Self::transform_vector2()`].\n # Panics\n Will panic if all elements of `scale` are zero when `glam_assert` is enabled.",
                &["scale"],
            )
            .register_documented(
                "from_scale_angle_translation",
                |
                    scale: Val<bevy::math::Vec2>,
                    angle: f32,
                    translation: Val<bevy::math::Vec2>|
                {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_scale_angle_translation(
                                    scale.into_inner(),
                                    angle,
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in\n radians) and `translation`.\n The resulting matrix can be used to transform 2D points and vectors. See\n [`Self::transform_point2()`] and [`Self::transform_vector2()`].",
                &["scale", "angle", "translation"],
            )
            .register_documented(
                "from_translation",
                |translation: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::from_translation(
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 2D `translation`.\n The resulting matrix can be used to transform 2D points and vectors. See\n [`Self::transform_point2()`] and [`Self::transform_vector2()`].",
                &["translation"],
            )
            .register_documented(
                "inverse",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::inverse(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the inverse of `self`.\n If the matrix is not invertible the returned matrix will be invalid.\n # Panics\n Will panic if the determinant of `self` is zero when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "is_finite",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Mat3A::is_finite(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.\n If any element is either `NaN`, positive or negative infinity, this will return `false`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Mat3A::is_nan(&_self).into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NaN`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Mat3A>, rhs: Val<bevy::math::Affine2>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as ::core::ops::Mul<
                                bevy::math::Affine2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Mat3A>, rhs: Val<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as ::core::ops::Mul<
                                bevy::math::Mat3A,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Mat3A>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = <bevy::math::Mat3A as ::core::ops::Mul<
                                bevy::math::Vec3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Mat3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = <bevy::math::Mat3A as ::core::ops::Mul<
                                bevy::math::Vec3A,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Mat3A>, rhs: f32| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as ::core::ops::Mul<
                                f32,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_mat3",
                |_self: Ref<bevy::math::Mat3A>, rhs: Ref<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::mul_mat3(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies two 3x3 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_scalar",
                |_self: Ref<bevy::math::Mat3A>, rhs: f32| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::mul_scalar(
                                    &_self,
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies a 3x3 matrix by a scalar.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_vec3",
                |_self: Ref<bevy::math::Mat3A>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Mat3A::mul_vec3(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms a 3D vector.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_vec3a",
                |_self: Ref<bevy::math::Mat3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Mat3A::mul_vec3a(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms a [`Vec3A`].",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "row",
                |_self: Ref<bevy::math::Mat3A>, index: usize| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Mat3A::row(
                                    &_self,
                                    index,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the matrix row for the given `index`.\n # Panics\n Panics if `index` is greater than 2.",
                &["_self", "index"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::Mat3A>, rhs: Val<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = <bevy::math::Mat3A as ::core::ops::Sub<
                                bevy::math::Mat3A,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub_mat3",
                |_self: Ref<bevy::math::Mat3A>, rhs: Ref<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::sub_mat3(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Subtracts two 3x3 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_cols_array",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: [f32; 9] = {
                        {
                            let output: [f32; 9] = bevy::math::Mat3A::to_cols_array(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[f32; 9]` array storing data in column major order.\n If you require data in row major order `transpose` the matrix first.",
                &["_self"],
            )
            .register_documented(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: [[f32; 3]; 3] = {
                        {
                            let output: [[f32; 3]; 3] = bevy::math::Mat3A::to_cols_array_2d(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[[f32; 3]; 3]` 3D array storing data in column major order.\n If you require data in row major order `transpose` the matrix first.",
                &["_self"],
            )
            .register_documented(
                "to_euler",
                |_self: Ref<bevy::math::Mat3A>, order: Val<bevy::math::EulerRot>| {
                    let output: (f32, f32, f32) = {
                        {
                            let output: (f32, f32, f32) = bevy::math::Mat3A::to_euler(
                                    &_self,
                                    order.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Extract Euler angles with the given Euler rotation order.\n Note if the input matrix contains scales, shears, or other non-rotation transformations then\n the resulting Euler angles will be ill-defined.\n # Panics\n Will panic if any input matrix column is not normalized when `glam_assert` is enabled.",
                &["_self", "order"],
            )
            .register_documented(
                "transform_point2",
                |_self: Ref<bevy::math::Mat3A>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Mat3A::transform_point2(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given 2D vector as a point.\n This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.\n This method assumes that `self` contains a valid affine transform.\n # Panics\n Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "transform_vector2",
                |_self: Ref<bevy::math::Mat3A>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Mat3A::transform_vector2(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Rotates the given 2D vector.\n This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.\n This method assumes that `self` contains a valid affine transform.\n # Panics\n Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "transpose",
                |_self: Ref<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = bevy::math::Mat3A::transpose(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the transpose of `self`.",
                &["_self"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::Mat3A,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_mat_4_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::Mat4,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::abs(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Takes the absolute value of each element in `self`",
                &["_self"],
            )
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::Mat4>,
                    rhs: Val<bevy::math::Mat4>,
                    max_abs_diff: f32|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Mat4::abs_diff_eq(
                                    &_self,
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs`\n is less than or equal to `max_abs_diff`.\n This can be used to compare if two matrices contain similar elements. It works best\n when comparing with a known value. The `max_abs_diff` that should be used used\n depends on the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::Mat4>, rhs: Val<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as ::core::ops::Add<
                                bevy::math::Mat4,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add_mat4",
                |_self: Ref<bevy::math::Mat4>, rhs: Ref<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::add_mat4(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Adds two 4x4 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_dmat4",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::Mat4::as_dmat4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "col",
                |_self: Ref<bevy::math::Mat4>, index: usize| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Mat4::col(
                                    &_self,
                                    index,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the matrix column for the given `index`.\n # Panics\n Panics if `index` is greater than 3.",
                &["_self", "index"],
            )
            .register_documented(
                "determinant",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: f32 = {
                        {
                            let output: f32 = bevy::math::Mat4::determinant(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the determinant of `self`.",
                &["_self"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::Mat4>, rhs: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as ::core::ops::Div<
                                f32,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_scalar",
                |_self: Ref<bevy::math::Mat4>, rhs: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::div_scalar(
                                    &_self,
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Divides a 4x4 matrix by a scalar.",
                &["_self", "rhs"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::Mat4>, rhs: Ref<bevy::math::Mat4>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::Mat4 as ::core::cmp::PartialEq<
                                bevy::math::Mat4,
                            >>::eq(&_self, &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "from_axis_angle",
                |axis: Val<bevy::math::Vec3>, angle: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_axis_angle(
                                    axis.into_inner(),
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix containing a 3D rotation around a normalized\n rotation `axis` of `angle` (in radians).\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].\n # Panics\n Will panic if `axis` is not normalized when `glam_assert` is enabled.",
                &["axis", "angle"],
            )
            .register_documented(
                "from_cols",
                |
                    x_axis: Val<bevy::math::Vec4>,
                    y_axis: Val<bevy::math::Vec4>,
                    z_axis: Val<bevy::math::Vec4>,
                    w_axis: Val<bevy::math::Vec4>|
                {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_cols(
                                    x_axis.into_inner(),
                                    y_axis.into_inner(),
                                    z_axis.into_inner(),
                                    w_axis.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4x4 matrix from four column vectors.",
                &["x_axis", "y_axis", "z_axis", "w_axis"],
            )
            .register_documented(
                "from_diagonal",
                |diagonal: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_diagonal(
                                    diagonal.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4x4 matrix with its diagonal set to `diagonal` and all other entries set to 0.",
                &["diagonal"],
            )
            .register_documented(
                "from_euler",
                |order: Val<bevy::math::EulerRot>, a: f32, b: f32, c: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_euler(
                                    order.into_inner(),
                                    a,
                                    b,
                                    c,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a affine transformation matrix containing a rotation from the given euler\n rotation sequence and angles (in radians).\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].",
                &["order", "a", "b", "c"],
            )
            .register_documented(
                "from_mat3",
                |m: Val<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_mat3(
                                    m.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 3x3 linear transformation\n matrix.\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].",
                &["m"],
            )
            .register_documented(
                "from_mat3a",
                |m: Val<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_mat3a(
                                    m.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 3x3 linear transformation\n matrix.\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].",
                &["m"],
            )
            .register_documented(
                "from_quat",
                |rotation: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_quat(
                                    rotation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given `rotation` quaternion.\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].\n # Panics\n Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
                &["rotation"],
            )
            .register_documented(
                "from_rotation_translation",
                |rotation: Val<bevy::math::Quat>, translation: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_rotation_translation(
                                    rotation.into_inner(),
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 3D `translation`.\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].\n # Panics\n Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
                &["rotation", "translation"],
            )
            .register_documented(
                "from_rotation_x",
                |angle: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_rotation_x(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix containing a 3D rotation around the x axis of\n `angle` (in radians).\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].",
                &["angle"],
            )
            .register_documented(
                "from_rotation_y",
                |angle: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_rotation_y(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix containing a 3D rotation around the y axis of\n `angle` (in radians).\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].",
                &["angle"],
            )
            .register_documented(
                "from_rotation_z",
                |angle: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_rotation_z(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix containing a 3D rotation around the z axis of\n `angle` (in radians).\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].",
                &["angle"],
            )
            .register_documented(
                "from_scale",
                |scale: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_scale(
                                    scale.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix containing the given 3D non-uniform `scale`.\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].\n # Panics\n Will panic if all elements of `scale` are zero when `glam_assert` is enabled.",
                &["scale"],
            )
            .register_documented(
                "from_scale_rotation_translation",
                |
                    scale: Val<bevy::math::Vec3>,
                    rotation: Val<bevy::math::Quat>,
                    translation: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_scale_rotation_translation(
                                    scale.into_inner(),
                                    rotation.into_inner(),
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 3D `scale`, `rotation` and\n `translation`.\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].\n # Panics\n Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
                &["scale", "rotation", "translation"],
            )
            .register_documented(
                "from_translation",
                |translation: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::from_translation(
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 3D `translation`.\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].",
                &["translation"],
            )
            .register_documented(
                "inverse",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::inverse(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the inverse of `self`.\n If the matrix is not invertible the returned matrix will be invalid.\n # Panics\n Will panic if the determinant of `self` is zero when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "is_finite",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Mat4::is_finite(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.\n If any element is either `NaN`, positive or negative infinity, this will return `false`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Mat4::is_nan(&_self).into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NaN`.",
                &["_self"],
            )
            .register_documented(
                "look_at_lh",
                |
                    eye: Val<bevy::math::Vec3>,
                    center: Val<bevy::math::Vec3>,
                    up: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::look_at_lh(
                                    eye.into_inner(),
                                    center.into_inner(),
                                    up.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a left-handed view matrix using a camera position, an up direction, and a focal\n point.\n For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.\n # Panics\n Will panic if `up` is not normalized when `glam_assert` is enabled.",
                &["eye", "center", "up"],
            )
            .register_documented(
                "look_at_rh",
                |
                    eye: Val<bevy::math::Vec3>,
                    center: Val<bevy::math::Vec3>,
                    up: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::look_at_rh(
                                    eye.into_inner(),
                                    center.into_inner(),
                                    up.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a right-handed view matrix using a camera position, an up direction, and a focal\n point.\n For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.\n # Panics\n Will panic if `up` is not normalized when `glam_assert` is enabled.",
                &["eye", "center", "up"],
            )
            .register_documented(
                "look_to_lh",
                |
                    eye: Val<bevy::math::Vec3>,
                    dir: Val<bevy::math::Vec3>,
                    up: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::look_to_lh(
                                    eye.into_inner(),
                                    dir.into_inner(),
                                    up.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a left-handed view matrix using a camera position, an up direction, and a facing\n direction.\n For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.",
                &["eye", "dir", "up"],
            )
            .register_documented(
                "look_to_rh",
                |
                    eye: Val<bevy::math::Vec3>,
                    dir: Val<bevy::math::Vec3>,
                    up: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::look_to_rh(
                                    eye.into_inner(),
                                    dir.into_inner(),
                                    up.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a right-handed view matrix using a camera position, an up direction, and a facing\n direction.\n For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.",
                &["eye", "dir", "up"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Mat4>, rhs: Val<bevy::math::Affine3A>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as ::core::ops::Mul<
                                bevy::math::Affine3A,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Mat4>, rhs: Val<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as ::core::ops::Mul<
                                bevy::math::Mat4,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Mat4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = <bevy::math::Mat4 as ::core::ops::Mul<
                                bevy::math::Vec4,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Mat4>, rhs: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as ::core::ops::Mul<
                                f32,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_mat4",
                |_self: Ref<bevy::math::Mat4>, rhs: Ref<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::mul_mat4(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies two 4x4 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_scalar",
                |_self: Ref<bevy::math::Mat4>, rhs: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::mul_scalar(
                                    &_self,
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies a 4x4 matrix by a scalar.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_vec4",
                |_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec4>| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Mat4::mul_vec4(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms a 4D vector.",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "orthographic_lh",
                |left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::orthographic_lh(
                                    left,
                                    right,
                                    bottom,
                                    top,
                                    near,
                                    far,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a left-handed orthographic projection matrix with `[0,1]` depth range.\n Useful to map a left-handed coordinate system to the normalized device coordinates that WebGPU/Direct3D/Metal expect.",
                &["left", "right", "bottom", "top", "near", "far"],
            )
            .register_documented(
                "orthographic_rh",
                |left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::orthographic_rh(
                                    left,
                                    right,
                                    bottom,
                                    top,
                                    near,
                                    far,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a right-handed orthographic projection matrix with `[0,1]` depth range.\n Useful to map a right-handed coordinate system to the normalized device coordinates that WebGPU/Direct3D/Metal expect.",
                &["left", "right", "bottom", "top", "near", "far"],
            )
            .register_documented(
                "orthographic_rh_gl",
                |left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::orthographic_rh_gl(
                                    left,
                                    right,
                                    bottom,
                                    top,
                                    near,
                                    far,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a right-handed orthographic projection matrix with `[-1,1]` depth\n range.  This is the same as the OpenGL `glOrtho` function in OpenGL.\n See\n <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml>\n Useful to map a right-handed coordinate system to the normalized device coordinates that OpenGL expects.",
                &["left", "right", "bottom", "top", "near", "far"],
            )
            .register_documented(
                "perspective_infinite_lh",
                |fov_y_radians: f32, aspect_ratio: f32, z_near: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_infinite_lh(
                                    fov_y_radians,
                                    aspect_ratio,
                                    z_near,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.\n Like `perspective_lh`, but with an infinite value for `z_far`.\n The result is that points near `z_near` are mapped to depth `0`, and as they move towards infinity the depth approaches `1`.\n # Panics\n Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is\n enabled.",
                &["fov_y_radians", "aspect_ratio", "z_near"],
            )
            .register_documented(
                "perspective_infinite_reverse_lh",
                |fov_y_radians: f32, aspect_ratio: f32, z_near: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_infinite_reverse_lh(
                                    fov_y_radians,
                                    aspect_ratio,
                                    z_near,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an infinite reverse left-handed perspective projection matrix with `[0,1]` depth range.\n Similar to `perspective_infinite_lh`, but maps `Z = z_near` to a depth of `1` and `Z = infinity` to a depth of `0`.\n # Panics\n Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.",
                &["fov_y_radians", "aspect_ratio", "z_near"],
            )
            .register_documented(
                "perspective_infinite_reverse_rh",
                |fov_y_radians: f32, aspect_ratio: f32, z_near: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_infinite_reverse_rh(
                                    fov_y_radians,
                                    aspect_ratio,
                                    z_near,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an infinite reverse right-handed perspective projection matrix with `[0,1]` depth range.\n Similar to `perspective_infinite_rh`, but maps `Z = z_near` to a depth of `1` and `Z = infinity` to a depth of `0`.\n # Panics\n Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.",
                &["fov_y_radians", "aspect_ratio", "z_near"],
            )
            .register_documented(
                "perspective_infinite_rh",
                |fov_y_radians: f32, aspect_ratio: f32, z_near: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_infinite_rh(
                                    fov_y_radians,
                                    aspect_ratio,
                                    z_near,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an infinite right-handed perspective projection matrix with `[0,1]` depth range.\n Like `perspective_rh`, but with an infinite value for `z_far`.\n The result is that points near `z_near` are mapped to depth `0`, and as they move towards infinity the depth approaches `1`.\n # Panics\n Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is\n enabled.",
                &["fov_y_radians", "aspect_ratio", "z_near"],
            )
            .register_documented(
                "perspective_lh",
                |fov_y_radians: f32, aspect_ratio: f32, z_near: f32, z_far: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_lh(
                                    fov_y_radians,
                                    aspect_ratio,
                                    z_near,
                                    z_far,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a left-handed perspective projection matrix with `[0,1]` depth range.\n Useful to map the standard left-handed coordinate system into what WebGPU/Metal/Direct3D expect.\n # Panics\n Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is\n enabled.",
                &["fov_y_radians", "aspect_ratio", "z_near", "z_far"],
            )
            .register_documented(
                "perspective_rh",
                |fov_y_radians: f32, aspect_ratio: f32, z_near: f32, z_far: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_rh(
                                    fov_y_radians,
                                    aspect_ratio,
                                    z_near,
                                    z_far,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a right-handed perspective projection matrix with `[0,1]` depth range.\n Useful to map the standard right-handed coordinate system into what WebGPU/Metal/Direct3D expect.\n # Panics\n Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is\n enabled.",
                &["fov_y_radians", "aspect_ratio", "z_near", "z_far"],
            )
            .register_documented(
                "perspective_rh_gl",
                |fov_y_radians: f32, aspect_ratio: f32, z_near: f32, z_far: f32| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::perspective_rh_gl(
                                    fov_y_radians,
                                    aspect_ratio,
                                    z_near,
                                    z_far,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a right-handed perspective projection matrix with `[-1,1]` depth range.\n Useful to map the standard right-handed coordinate system into what OpenGL expects.\n This is the same as the OpenGL `gluPerspective` function.\n See <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml>",
                &["fov_y_radians", "aspect_ratio", "z_near", "z_far"],
            )
            .register_documented(
                "project_point3",
                |_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Mat4::project_point3(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given 3D vector as a point, applying perspective correction.\n This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is `1.0`.\n The perspective divide is performed meaning the resulting 3D vector is divided by `w`.\n This method assumes that `self` contains a projective transform.",
                &["_self", "rhs"],
            )
            .register_documented(
                "project_point3a",
                |_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Mat4::project_point3a(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given [`Vec3A`] as a 3D point, applying perspective correction.\n This is the equivalent of multiplying the [`Vec3A`] as a 4D vector where `w` is `1.0`.\n The perspective divide is performed meaning the resulting 3D vector is divided by `w`.\n This method assumes that `self` contains a projective transform.",
                &["_self", "rhs"],
            )
            .register_documented(
                "row",
                |_self: Ref<bevy::math::Mat4>, index: usize| {
                    let output: Val<bevy::math::Vec4> = {
                        {
                            let output: Val<bevy::math::Vec4> = bevy::math::Mat4::row(
                                    &_self,
                                    index,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the matrix row for the given `index`.\n # Panics\n Panics if `index` is greater than 3.",
                &["_self", "index"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::Mat4>, rhs: Val<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = <bevy::math::Mat4 as ::core::ops::Sub<
                                bevy::math::Mat4,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub_mat4",
                |_self: Ref<bevy::math::Mat4>, rhs: Ref<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::sub_mat4(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Subtracts two 4x4 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_cols_array",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: [f32; 16] = {
                        {
                            let output: [f32; 16] = bevy::math::Mat4::to_cols_array(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[f32; 16]` array storing data in column major order.\n If you require data in row major order `transpose` the matrix first.",
                &["_self"],
            )
            .register_documented(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: [[f32; 4]; 4] = {
                        {
                            let output: [[f32; 4]; 4] = bevy::math::Mat4::to_cols_array_2d(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[[f32; 4]; 4]` 4D array storing data in column major order.\n If you require data in row major order `transpose` the matrix first.",
                &["_self"],
            )
            .register_documented(
                "to_euler",
                |_self: Ref<bevy::math::Mat4>, order: Val<bevy::math::EulerRot>| {
                    let output: (f32, f32, f32) = {
                        {
                            let output: (f32, f32, f32) = bevy::math::Mat4::to_euler(
                                    &_self,
                                    order.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Extract Euler angles with the given Euler rotation order.\n Note if the upper 3x3 matrix contain scales, shears, or other non-rotation transformations\n then the resulting Euler angles will be ill-defined.\n # Panics\n Will panic if any column of the upper 3x3 rotation matrix is not normalized when\n `glam_assert` is enabled.",
                &["_self", "order"],
            )
            .register_documented(
                "transform_point3",
                |_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Mat4::transform_point3(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given 3D vector as a point.\n This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is\n `1.0`.\n This method assumes that `self` contains a valid affine transform. It does not perform\n a perspective divide, if `self` contains a perspective transform, or if you are unsure,\n the [`Self::project_point3()`] method should be used instead.\n # Panics\n Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "transform_point3a",
                |_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Mat4::transform_point3a(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given [`Vec3A`] as 3D point.\n This is the equivalent of multiplying the [`Vec3A`] as a 4D vector where `w` is `1.0`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "transform_vector3",
                |_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Mat4::transform_vector3(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the give 3D vector as a direction.\n This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is\n `0.0`.\n This method assumes that `self` contains a valid affine transform.\n # Panics\n Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "transform_vector3a",
                |_self: Ref<bevy::math::Mat4>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Mat4::transform_vector3a(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the give [`Vec3A`] as 3D vector.\n This is the equivalent of multiplying the [`Vec3A`] as a 4D vector where `w` is `0.0`.",
                &["_self", "rhs"],
            )
            .register_documented(
                "transpose",
                |_self: Ref<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::Mat4::transpose(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the transpose of `self`.",
                &["_self"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::Mat4,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_d_mat_2_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::DMat2,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = bevy::math::DMat2::abs(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Takes the absolute value of each element in `self`",
                &["_self"],
            )
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::DMat2>,
                    rhs: Val<bevy::math::DMat2>,
                    max_abs_diff: f64|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DMat2::abs_diff_eq(
                                    &_self,
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs`\n is less than or equal to `max_abs_diff`.\n This can be used to compare if two matrices contain similar elements. It works best\n when comparing with a known value. The `max_abs_diff` that should be used used\n depends on the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::DMat2>, rhs: Val<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as ::core::ops::Add<
                                bevy::math::DMat2,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add_mat2",
                |_self: Ref<bevy::math::DMat2>, rhs: Ref<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = bevy::math::DMat2::add_mat2(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Adds two 2x2 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_mat2",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: Val<bevy::math::Mat2> = {
                        {
                            let output: Val<bevy::math::Mat2> = bevy::math::DMat2::as_mat2(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "col",
                |_self: Ref<bevy::math::DMat2>, index: usize| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DMat2::col(
                                    &_self,
                                    index,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the matrix column for the given `index`.\n # Panics\n Panics if `index` is greater than 1.",
                &["_self", "index"],
            )
            .register_documented(
                "determinant",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DMat2::determinant(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the determinant of `self`.",
                &["_self"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::DMat2>, rhs: f64| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as ::core::ops::Div<
                                f64,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_scalar",
                |_self: Ref<bevy::math::DMat2>, rhs: f64| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = bevy::math::DMat2::div_scalar(
                                    &_self,
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Divides a 2x2 matrix by a scalar.",
                &["_self", "rhs"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::DMat2>, rhs: Ref<bevy::math::DMat2>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::DMat2 as ::core::cmp::PartialEq<
                                bevy::math::DMat2,
                            >>::eq(&_self, &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "from_angle",
                |angle: f64| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_angle(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2x2 matrix containing a rotation of `angle` (in radians).",
                &["angle"],
            )
            .register_documented(
                "from_cols",
                |x_axis: Val<bevy::math::DVec2>, y_axis: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_cols(
                                    x_axis.into_inner(),
                                    y_axis.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2x2 matrix from two column vectors.",
                &["x_axis", "y_axis"],
            )
            .register_documented(
                "from_diagonal",
                |diagonal: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_diagonal(
                                    diagonal.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2x2 matrix with its diagonal set to `diagonal` and all other entries set to 0.",
                &["diagonal"],
            )
            .register_documented(
                "from_mat3",
                |m: Val<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_mat3(
                                    m.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2x2 matrix from a 3x3 matrix, discarding the 2nd row and column.",
                &["m"],
            )
            .register_documented(
                "from_mat3_minor",
                |m: Val<bevy::math::DMat3>, i: usize, j: usize| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_mat3_minor(
                                    m.into_inner(),
                                    i,
                                    j,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2x2 matrix from the minor of the given 3x3 matrix, discarding the `i`th column\n and `j`th row.\n # Panics\n Panics if `i` or `j` is greater than 2.",
                &["m", "i", "j"],
            )
            .register_documented(
                "from_scale_angle",
                |scale: Val<bevy::math::DVec2>, angle: f64| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = bevy::math::DMat2::from_scale_angle(
                                    scale.into_inner(),
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 2x2 matrix containing the combining non-uniform `scale` and rotation of\n `angle` (in radians).",
                &["scale", "angle"],
            )
            .register_documented(
                "inverse",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = bevy::math::DMat2::inverse(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the inverse of `self`.\n If the matrix is not invertible the returned matrix will be invalid.\n # Panics\n Will panic if the determinant of `self` is zero when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "is_finite",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DMat2::is_finite(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.\n If any element is either `NaN`, positive or negative infinity, this will return `false`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DMat2::is_nan(&_self).into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NaN`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DMat2>, rhs: Val<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as ::core::ops::Mul<
                                bevy::math::DMat2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DMat2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = <bevy::math::DMat2 as ::core::ops::Mul<
                                bevy::math::DVec2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DMat2>, rhs: f64| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as ::core::ops::Mul<
                                f64,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_mat2",
                |_self: Ref<bevy::math::DMat2>, rhs: Ref<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = bevy::math::DMat2::mul_mat2(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies two 2x2 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_scalar",
                |_self: Ref<bevy::math::DMat2>, rhs: f64| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = bevy::math::DMat2::mul_scalar(
                                    &_self,
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies a 2x2 matrix by a scalar.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_vec2",
                |_self: Ref<bevy::math::DMat2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DMat2::mul_vec2(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms a 2D vector.",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "row",
                |_self: Ref<bevy::math::DMat2>, index: usize| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DMat2::row(
                                    &_self,
                                    index,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the matrix row for the given `index`.\n # Panics\n Panics if `index` is greater than 1.",
                &["_self", "index"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::DMat2>, rhs: Val<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = <bevy::math::DMat2 as ::core::ops::Sub<
                                bevy::math::DMat2,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub_mat2",
                |_self: Ref<bevy::math::DMat2>, rhs: Ref<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = bevy::math::DMat2::sub_mat2(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Subtracts two 2x2 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_cols_array",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: [f64; 4] = {
                        {
                            let output: [f64; 4] = bevy::math::DMat2::to_cols_array(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[f64; 4]` array storing data in column major order.\n If you require data in row major order `transpose` the matrix first.",
                &["_self"],
            )
            .register_documented(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: [[f64; 2]; 2] = {
                        {
                            let output: [[f64; 2]; 2] = bevy::math::DMat2::to_cols_array_2d(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[[f64; 2]; 2]` 2D array storing data in column major order.\n If you require data in row major order `transpose` the matrix first.",
                &["_self"],
            )
            .register_documented(
                "transpose",
                |_self: Ref<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat2> = {
                        {
                            let output: Val<bevy::math::DMat2> = bevy::math::DMat2::transpose(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the transpose of `self`.",
                &["_self"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::DMat2,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_d_mat_3_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::DMat3,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::abs(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Takes the absolute value of each element in `self`",
                &["_self"],
            )
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::DMat3>,
                    rhs: Val<bevy::math::DMat3>,
                    max_abs_diff: f64|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DMat3::abs_diff_eq(
                                    &_self,
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs`\n is less than or equal to `max_abs_diff`.\n This can be used to compare if two matrices contain similar elements. It works best\n when comparing with a known value. The `max_abs_diff` that should be used used\n depends on the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::DMat3>, rhs: Val<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as ::core::ops::Add<
                                bevy::math::DMat3,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add_mat3",
                |_self: Ref<bevy::math::DMat3>, rhs: Ref<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::add_mat3(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Adds two 3x3 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_mat3",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = bevy::math::DMat3::as_mat3(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "col",
                |_self: Ref<bevy::math::DMat3>, index: usize| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DMat3::col(
                                    &_self,
                                    index,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the matrix column for the given `index`.\n # Panics\n Panics if `index` is greater than 2.",
                &["_self", "index"],
            )
            .register_documented(
                "determinant",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DMat3::determinant(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the determinant of `self`.",
                &["_self"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::DMat3>, rhs: f64| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as ::core::ops::Div<
                                f64,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_scalar",
                |_self: Ref<bevy::math::DMat3>, rhs: f64| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::div_scalar(
                                    &_self,
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Divides a 3x3 matrix by a scalar.",
                &["_self", "rhs"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::DMat3>, rhs: Ref<bevy::math::DMat3>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::DMat3 as ::core::cmp::PartialEq<
                                bevy::math::DMat3,
                            >>::eq(&_self, &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "from_angle",
                |angle: f64| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_angle(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 2D rotation `angle` (in\n radians).\n The resulting matrix can be used to transform 2D points and vectors. See\n [`Self::transform_point2()`] and [`Self::transform_vector2()`].",
                &["angle"],
            )
            .register_documented(
                "from_axis_angle",
                |axis: Val<bevy::math::DVec3>, angle: f64| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_axis_angle(
                                    axis.into_inner(),
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in\n radians).\n # Panics\n Will panic if `axis` is not normalized when `glam_assert` is enabled.",
                &["axis", "angle"],
            )
            .register_documented(
                "from_cols",
                |
                    x_axis: Val<bevy::math::DVec3>,
                    y_axis: Val<bevy::math::DVec3>,
                    z_axis: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_cols(
                                    x_axis.into_inner(),
                                    y_axis.into_inner(),
                                    z_axis.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3x3 matrix from three column vectors.",
                &["x_axis", "y_axis", "z_axis"],
            )
            .register_documented(
                "from_diagonal",
                |diagonal: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_diagonal(
                                    diagonal.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.",
                &["diagonal"],
            )
            .register_documented(
                "from_euler",
                |order: Val<bevy::math::EulerRot>, a: f64, b: f64, c: f64| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_euler(
                                    order.into_inner(),
                                    a,
                                    b,
                                    c,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in\n radians).",
                &["order", "a", "b", "c"],
            )
            .register_documented(
                "from_mat2",
                |m: Val<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_mat2(
                                    m.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 2x2 matrix.\n The resulting matrix can be used to transform 2D points and vectors. See\n [`Self::transform_point2()`] and [`Self::transform_vector2()`].",
                &["m"],
            )
            .register_documented(
                "from_mat4",
                |m: Val<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_mat4(
                                    m.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3x3 matrix from a 4x4 matrix, discarding the 4th row and column.",
                &["m"],
            )
            .register_documented(
                "from_mat4_minor",
                |m: Val<bevy::math::DMat4>, i: usize, j: usize| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_mat4_minor(
                                    m.into_inner(),
                                    i,
                                    j,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3x3 matrix from the minor of the given 4x4 matrix, discarding the `i`th column\n and `j`th row.\n # Panics\n Panics if `i` or `j` is greater than 3.",
                &["m", "i", "j"],
            )
            .register_documented(
                "from_quat",
                |rotation: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_quat(
                                    rotation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D rotation matrix from the given quaternion.\n # Panics\n Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
                &["rotation"],
            )
            .register_documented(
                "from_rotation_x",
                |angle: f64| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_rotation_x(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D rotation matrix from `angle` (in radians) around the x axis.",
                &["angle"],
            )
            .register_documented(
                "from_rotation_y",
                |angle: f64| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_rotation_y(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D rotation matrix from `angle` (in radians) around the y axis.",
                &["angle"],
            )
            .register_documented(
                "from_rotation_z",
                |angle: f64| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_rotation_z(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 3D rotation matrix from `angle` (in radians) around the z axis.",
                &["angle"],
            )
            .register_documented(
                "from_scale",
                |scale: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_scale(
                                    scale.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given non-uniform 2D `scale`.\n The resulting matrix can be used to transform 2D points and vectors. See\n [`Self::transform_point2()`] and [`Self::transform_vector2()`].\n # Panics\n Will panic if all elements of `scale` are zero when `glam_assert` is enabled.",
                &["scale"],
            )
            .register_documented(
                "from_scale_angle_translation",
                |
                    scale: Val<bevy::math::DVec2>,
                    angle: f64,
                    translation: Val<bevy::math::DVec2>|
                {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_scale_angle_translation(
                                    scale.into_inner(),
                                    angle,
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in\n radians) and `translation`.\n The resulting matrix can be used to transform 2D points and vectors. See\n [`Self::transform_point2()`] and [`Self::transform_vector2()`].",
                &["scale", "angle", "translation"],
            )
            .register_documented(
                "from_translation",
                |translation: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::from_translation(
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 2D `translation`.\n The resulting matrix can be used to transform 2D points and vectors. See\n [`Self::transform_point2()`] and [`Self::transform_vector2()`].",
                &["translation"],
            )
            .register_documented(
                "inverse",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::inverse(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the inverse of `self`.\n If the matrix is not invertible the returned matrix will be invalid.\n # Panics\n Will panic if the determinant of `self` is zero when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "is_finite",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DMat3::is_finite(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.\n If any element is either `NaN`, positive or negative infinity, this will return `false`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DMat3::is_nan(&_self).into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NaN`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DMat3>, rhs: Val<bevy::math::DAffine2>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as ::core::ops::Mul<
                                bevy::math::DAffine2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DMat3>, rhs: Val<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as ::core::ops::Mul<
                                bevy::math::DMat3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DMat3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DMat3 as ::core::ops::Mul<
                                bevy::math::DVec3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DMat3>, rhs: f64| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as ::core::ops::Mul<
                                f64,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_mat3",
                |_self: Ref<bevy::math::DMat3>, rhs: Ref<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::mul_mat3(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies two 3x3 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_scalar",
                |_self: Ref<bevy::math::DMat3>, rhs: f64| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::mul_scalar(
                                    &_self,
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies a 3x3 matrix by a scalar.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_vec3",
                |_self: Ref<bevy::math::DMat3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DMat3::mul_vec3(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms a 3D vector.",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "row",
                |_self: Ref<bevy::math::DMat3>, index: usize| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DMat3::row(
                                    &_self,
                                    index,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the matrix row for the given `index`.\n # Panics\n Panics if `index` is greater than 2.",
                &["_self", "index"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::DMat3>, rhs: Val<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = <bevy::math::DMat3 as ::core::ops::Sub<
                                bevy::math::DMat3,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub_mat3",
                |_self: Ref<bevy::math::DMat3>, rhs: Ref<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::sub_mat3(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Subtracts two 3x3 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_cols_array",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: [f64; 9] = {
                        {
                            let output: [f64; 9] = bevy::math::DMat3::to_cols_array(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[f64; 9]` array storing data in column major order.\n If you require data in row major order `transpose` the matrix first.",
                &["_self"],
            )
            .register_documented(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: [[f64; 3]; 3] = {
                        {
                            let output: [[f64; 3]; 3] = bevy::math::DMat3::to_cols_array_2d(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[[f64; 3]; 3]` 3D array storing data in column major order.\n If you require data in row major order `transpose` the matrix first.",
                &["_self"],
            )
            .register_documented(
                "to_euler",
                |_self: Ref<bevy::math::DMat3>, order: Val<bevy::math::EulerRot>| {
                    let output: (f64, f64, f64) = {
                        {
                            let output: (f64, f64, f64) = bevy::math::DMat3::to_euler(
                                    &_self,
                                    order.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Extract Euler angles with the given Euler rotation order.\n Note if the input matrix contains scales, shears, or other non-rotation transformations then\n the resulting Euler angles will be ill-defined.\n # Panics\n Will panic if any input matrix column is not normalized when `glam_assert` is enabled.",
                &["_self", "order"],
            )
            .register_documented(
                "transform_point2",
                |_self: Ref<bevy::math::DMat3>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DMat3::transform_point2(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given 2D vector as a point.\n This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.\n This method assumes that `self` contains a valid affine transform.\n # Panics\n Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "transform_vector2",
                |_self: Ref<bevy::math::DMat3>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DMat3::transform_vector2(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Rotates the given 2D vector.\n This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.\n This method assumes that `self` contains a valid affine transform.\n # Panics\n Will panic if the 2nd row of `self` is not `(0, 0, 1)` when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "transpose",
                |_self: Ref<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = bevy::math::DMat3::transpose(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the transpose of `self`.",
                &["_self"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::DMat3,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_d_mat_4_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::DMat4,
        >::new(world)
            .register_documented(
                "abs",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::abs(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Takes the absolute value of each element in `self`",
                &["_self"],
            )
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::DMat4>,
                    rhs: Val<bevy::math::DMat4>,
                    max_abs_diff: f64|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DMat4::abs_diff_eq(
                                    &_self,
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs`\n is less than or equal to `max_abs_diff`.\n This can be used to compare if two matrices contain similar elements. It works best\n when comparing with a known value. The `max_abs_diff` that should be used used\n depends on the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::DMat4>, rhs: Val<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as ::core::ops::Add<
                                bevy::math::DMat4,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "add_mat4",
                |_self: Ref<bevy::math::DMat4>, rhs: Ref<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::add_mat4(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Adds two 4x4 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_mat4",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = bevy::math::DMat4::as_mat4(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "col",
                |_self: Ref<bevy::math::DMat4>, index: usize| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DMat4::col(
                                    &_self,
                                    index,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the matrix column for the given `index`.\n # Panics\n Panics if `index` is greater than 3.",
                &["_self", "index"],
            )
            .register_documented(
                "determinant",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DMat4::determinant(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the determinant of `self`.",
                &["_self"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::DMat4>, rhs: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as ::core::ops::Div<
                                f64,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "div_scalar",
                |_self: Ref<bevy::math::DMat4>, rhs: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::div_scalar(
                                    &_self,
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Divides a 4x4 matrix by a scalar.",
                &["_self", "rhs"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::DMat4>, rhs: Ref<bevy::math::DMat4>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::DMat4 as ::core::cmp::PartialEq<
                                bevy::math::DMat4,
                            >>::eq(&_self, &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "from_axis_angle",
                |axis: Val<bevy::math::DVec3>, angle: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_axis_angle(
                                    axis.into_inner(),
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix containing a 3D rotation around a normalized\n rotation `axis` of `angle` (in radians).\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].\n # Panics\n Will panic if `axis` is not normalized when `glam_assert` is enabled.",
                &["axis", "angle"],
            )
            .register_documented(
                "from_cols",
                |
                    x_axis: Val<bevy::math::DVec4>,
                    y_axis: Val<bevy::math::DVec4>,
                    z_axis: Val<bevy::math::DVec4>,
                    w_axis: Val<bevy::math::DVec4>|
                {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_cols(
                                    x_axis.into_inner(),
                                    y_axis.into_inner(),
                                    z_axis.into_inner(),
                                    w_axis.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4x4 matrix from four column vectors.",
                &["x_axis", "y_axis", "z_axis", "w_axis"],
            )
            .register_documented(
                "from_diagonal",
                |diagonal: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_diagonal(
                                    diagonal.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a 4x4 matrix with its diagonal set to `diagonal` and all other entries set to 0.",
                &["diagonal"],
            )
            .register_documented(
                "from_euler",
                |order: Val<bevy::math::EulerRot>, a: f64, b: f64, c: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_euler(
                                    order.into_inner(),
                                    a,
                                    b,
                                    c,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a affine transformation matrix containing a rotation from the given euler\n rotation sequence and angles (in radians).\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].",
                &["order", "a", "b", "c"],
            )
            .register_documented(
                "from_mat3",
                |m: Val<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_mat3(
                                    m.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 3x3 linear transformation\n matrix.\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].",
                &["m"],
            )
            .register_documented(
                "from_quat",
                |rotation: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_quat(
                                    rotation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given `rotation` quaternion.\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].\n # Panics\n Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
                &["rotation"],
            )
            .register_documented(
                "from_rotation_translation",
                |rotation: Val<bevy::math::DQuat>, translation: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_rotation_translation(
                                    rotation.into_inner(),
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 3D `translation`.\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].\n # Panics\n Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
                &["rotation", "translation"],
            )
            .register_documented(
                "from_rotation_x",
                |angle: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_rotation_x(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix containing a 3D rotation around the x axis of\n `angle` (in radians).\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].",
                &["angle"],
            )
            .register_documented(
                "from_rotation_y",
                |angle: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_rotation_y(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix containing a 3D rotation around the y axis of\n `angle` (in radians).\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].",
                &["angle"],
            )
            .register_documented(
                "from_rotation_z",
                |angle: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_rotation_z(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix containing a 3D rotation around the z axis of\n `angle` (in radians).\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].",
                &["angle"],
            )
            .register_documented(
                "from_scale",
                |scale: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_scale(
                                    scale.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix containing the given 3D non-uniform `scale`.\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].\n # Panics\n Will panic if all elements of `scale` are zero when `glam_assert` is enabled.",
                &["scale"],
            )
            .register_documented(
                "from_scale_rotation_translation",
                |
                    scale: Val<bevy::math::DVec3>,
                    rotation: Val<bevy::math::DQuat>,
                    translation: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_scale_rotation_translation(
                                    scale.into_inner(),
                                    rotation.into_inner(),
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 3D `scale`, `rotation` and\n `translation`.\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].\n # Panics\n Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
                &["scale", "rotation", "translation"],
            )
            .register_documented(
                "from_translation",
                |translation: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::from_translation(
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation matrix from the given 3D `translation`.\n The resulting matrix can be used to transform 3D points and vectors. See\n [`Self::transform_point3()`] and [`Self::transform_vector3()`].",
                &["translation"],
            )
            .register_documented(
                "inverse",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::inverse(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the inverse of `self`.\n If the matrix is not invertible the returned matrix will be invalid.\n # Panics\n Will panic if the determinant of `self` is zero when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "is_finite",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DMat4::is_finite(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.\n If any element is either `NaN`, positive or negative infinity, this will return `false`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DMat4::is_nan(&_self).into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NaN`.",
                &["_self"],
            )
            .register_documented(
                "look_at_lh",
                |
                    eye: Val<bevy::math::DVec3>,
                    center: Val<bevy::math::DVec3>,
                    up: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::look_at_lh(
                                    eye.into_inner(),
                                    center.into_inner(),
                                    up.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a left-handed view matrix using a camera position, an up direction, and a focal\n point.\n For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.\n # Panics\n Will panic if `up` is not normalized when `glam_assert` is enabled.",
                &["eye", "center", "up"],
            )
            .register_documented(
                "look_at_rh",
                |
                    eye: Val<bevy::math::DVec3>,
                    center: Val<bevy::math::DVec3>,
                    up: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::look_at_rh(
                                    eye.into_inner(),
                                    center.into_inner(),
                                    up.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a right-handed view matrix using a camera position, an up direction, and a focal\n point.\n For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.\n # Panics\n Will panic if `up` is not normalized when `glam_assert` is enabled.",
                &["eye", "center", "up"],
            )
            .register_documented(
                "look_to_lh",
                |
                    eye: Val<bevy::math::DVec3>,
                    dir: Val<bevy::math::DVec3>,
                    up: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::look_to_lh(
                                    eye.into_inner(),
                                    dir.into_inner(),
                                    up.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a left-handed view matrix using a camera position, an up direction, and a facing\n direction.\n For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.",
                &["eye", "dir", "up"],
            )
            .register_documented(
                "look_to_rh",
                |
                    eye: Val<bevy::math::DVec3>,
                    dir: Val<bevy::math::DVec3>,
                    up: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::look_to_rh(
                                    eye.into_inner(),
                                    dir.into_inner(),
                                    up.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a right-handed view matrix using a camera position, an up direction, and a facing\n direction.\n For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.",
                &["eye", "dir", "up"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DMat4>, rhs: Val<bevy::math::DAffine3>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as ::core::ops::Mul<
                                bevy::math::DAffine3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DMat4>, rhs: Val<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as ::core::ops::Mul<
                                bevy::math::DMat4,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DMat4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = <bevy::math::DMat4 as ::core::ops::Mul<
                                bevy::math::DVec4,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DMat4>, rhs: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as ::core::ops::Mul<
                                f64,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_mat4",
                |_self: Ref<bevy::math::DMat4>, rhs: Ref<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::mul_mat4(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies two 4x4 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_scalar",
                |_self: Ref<bevy::math::DMat4>, rhs: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::mul_scalar(
                                    &_self,
                                    rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies a 4x4 matrix by a scalar.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_vec4",
                |_self: Ref<bevy::math::DMat4>, rhs: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DMat4::mul_vec4(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms a 4D vector.",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "orthographic_lh",
                |left: f64, right: f64, bottom: f64, top: f64, near: f64, far: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::orthographic_lh(
                                    left,
                                    right,
                                    bottom,
                                    top,
                                    near,
                                    far,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a left-handed orthographic projection matrix with `[0,1]` depth range.\n Useful to map a left-handed coordinate system to the normalized device coordinates that WebGPU/Direct3D/Metal expect.",
                &["left", "right", "bottom", "top", "near", "far"],
            )
            .register_documented(
                "orthographic_rh",
                |left: f64, right: f64, bottom: f64, top: f64, near: f64, far: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::orthographic_rh(
                                    left,
                                    right,
                                    bottom,
                                    top,
                                    near,
                                    far,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a right-handed orthographic projection matrix with `[0,1]` depth range.\n Useful to map a right-handed coordinate system to the normalized device coordinates that WebGPU/Direct3D/Metal expect.",
                &["left", "right", "bottom", "top", "near", "far"],
            )
            .register_documented(
                "orthographic_rh_gl",
                |left: f64, right: f64, bottom: f64, top: f64, near: f64, far: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::orthographic_rh_gl(
                                    left,
                                    right,
                                    bottom,
                                    top,
                                    near,
                                    far,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a right-handed orthographic projection matrix with `[-1,1]` depth\n range.  This is the same as the OpenGL `glOrtho` function in OpenGL.\n See\n <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml>\n Useful to map a right-handed coordinate system to the normalized device coordinates that OpenGL expects.",
                &["left", "right", "bottom", "top", "near", "far"],
            )
            .register_documented(
                "perspective_infinite_lh",
                |fov_y_radians: f64, aspect_ratio: f64, z_near: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_infinite_lh(
                                    fov_y_radians,
                                    aspect_ratio,
                                    z_near,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.\n Like `perspective_lh`, but with an infinite value for `z_far`.\n The result is that points near `z_near` are mapped to depth `0`, and as they move towards infinity the depth approaches `1`.\n # Panics\n Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is\n enabled.",
                &["fov_y_radians", "aspect_ratio", "z_near"],
            )
            .register_documented(
                "perspective_infinite_reverse_lh",
                |fov_y_radians: f64, aspect_ratio: f64, z_near: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_infinite_reverse_lh(
                                    fov_y_radians,
                                    aspect_ratio,
                                    z_near,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an infinite reverse left-handed perspective projection matrix with `[0,1]` depth range.\n Similar to `perspective_infinite_lh`, but maps `Z = z_near` to a depth of `1` and `Z = infinity` to a depth of `0`.\n # Panics\n Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.",
                &["fov_y_radians", "aspect_ratio", "z_near"],
            )
            .register_documented(
                "perspective_infinite_reverse_rh",
                |fov_y_radians: f64, aspect_ratio: f64, z_near: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_infinite_reverse_rh(
                                    fov_y_radians,
                                    aspect_ratio,
                                    z_near,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an infinite reverse right-handed perspective projection matrix with `[0,1]` depth range.\n Similar to `perspective_infinite_rh`, but maps `Z = z_near` to a depth of `1` and `Z = infinity` to a depth of `0`.\n # Panics\n Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.",
                &["fov_y_radians", "aspect_ratio", "z_near"],
            )
            .register_documented(
                "perspective_infinite_rh",
                |fov_y_radians: f64, aspect_ratio: f64, z_near: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_infinite_rh(
                                    fov_y_radians,
                                    aspect_ratio,
                                    z_near,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an infinite right-handed perspective projection matrix with `[0,1]` depth range.\n Like `perspective_rh`, but with an infinite value for `z_far`.\n The result is that points near `z_near` are mapped to depth `0`, and as they move towards infinity the depth approaches `1`.\n # Panics\n Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is\n enabled.",
                &["fov_y_radians", "aspect_ratio", "z_near"],
            )
            .register_documented(
                "perspective_lh",
                |fov_y_radians: f64, aspect_ratio: f64, z_near: f64, z_far: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_lh(
                                    fov_y_radians,
                                    aspect_ratio,
                                    z_near,
                                    z_far,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a left-handed perspective projection matrix with `[0,1]` depth range.\n Useful to map the standard left-handed coordinate system into what WebGPU/Metal/Direct3D expect.\n # Panics\n Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is\n enabled.",
                &["fov_y_radians", "aspect_ratio", "z_near", "z_far"],
            )
            .register_documented(
                "perspective_rh",
                |fov_y_radians: f64, aspect_ratio: f64, z_near: f64, z_far: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_rh(
                                    fov_y_radians,
                                    aspect_ratio,
                                    z_near,
                                    z_far,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a right-handed perspective projection matrix with `[0,1]` depth range.\n Useful to map the standard right-handed coordinate system into what WebGPU/Metal/Direct3D expect.\n # Panics\n Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is\n enabled.",
                &["fov_y_radians", "aspect_ratio", "z_near", "z_far"],
            )
            .register_documented(
                "perspective_rh_gl",
                |fov_y_radians: f64, aspect_ratio: f64, z_near: f64, z_far: f64| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::perspective_rh_gl(
                                    fov_y_radians,
                                    aspect_ratio,
                                    z_near,
                                    z_far,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a right-handed perspective projection matrix with `[-1,1]` depth range.\n Useful to map the standard right-handed coordinate system into what OpenGL expects.\n This is the same as the OpenGL `gluPerspective` function.\n See <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml>",
                &["fov_y_radians", "aspect_ratio", "z_near", "z_far"],
            )
            .register_documented(
                "project_point3",
                |_self: Ref<bevy::math::DMat4>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DMat4::project_point3(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given 3D vector as a point, applying perspective correction.\n This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is `1.0`.\n The perspective divide is performed meaning the resulting 3D vector is divided by `w`.\n This method assumes that `self` contains a projective transform.",
                &["_self", "rhs"],
            )
            .register_documented(
                "row",
                |_self: Ref<bevy::math::DMat4>, index: usize| {
                    let output: Val<bevy::math::DVec4> = {
                        {
                            let output: Val<bevy::math::DVec4> = bevy::math::DMat4::row(
                                    &_self,
                                    index,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the matrix row for the given `index`.\n # Panics\n Panics if `index` is greater than 3.",
                &["_self", "index"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::DMat4>, rhs: Val<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = <bevy::math::DMat4 as ::core::ops::Sub<
                                bevy::math::DMat4,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "sub_mat4",
                |_self: Ref<bevy::math::DMat4>, rhs: Ref<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::sub_mat4(
                                    &_self,
                                    &rhs,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Subtracts two 4x4 matrices.",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_cols_array",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: [f64; 16] = {
                        {
                            let output: [f64; 16] = bevy::math::DMat4::to_cols_array(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[f64; 16]` array storing data in column major order.\n If you require data in row major order `transpose` the matrix first.",
                &["_self"],
            )
            .register_documented(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: [[f64; 4]; 4] = {
                        {
                            let output: [[f64; 4]; 4] = bevy::math::DMat4::to_cols_array_2d(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[[f64; 4]; 4]` 4D array storing data in column major order.\n If you require data in row major order `transpose` the matrix first.",
                &["_self"],
            )
            .register_documented(
                "to_euler",
                |_self: Ref<bevy::math::DMat4>, order: Val<bevy::math::EulerRot>| {
                    let output: (f64, f64, f64) = {
                        {
                            let output: (f64, f64, f64) = bevy::math::DMat4::to_euler(
                                    &_self,
                                    order.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Extract Euler angles with the given Euler rotation order.\n Note if the upper 3x3 matrix contain scales, shears, or other non-rotation transformations\n then the resulting Euler angles will be ill-defined.\n # Panics\n Will panic if any column of the upper 3x3 rotation matrix is not normalized when\n `glam_assert` is enabled.",
                &["_self", "order"],
            )
            .register_documented(
                "transform_point3",
                |_self: Ref<bevy::math::DMat4>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DMat4::transform_point3(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given 3D vector as a point.\n This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is\n `1.0`.\n This method assumes that `self` contains a valid affine transform. It does not perform\n a perspective divide, if `self` contains a perspective transform, or if you are unsure,\n the [`Self::project_point3()`] method should be used instead.\n # Panics\n Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "transform_vector3",
                |_self: Ref<bevy::math::DMat4>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DMat4::transform_vector3(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the give 3D vector as a direction.\n This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is\n `0.0`.\n This method assumes that `self` contains a valid affine transform.\n # Panics\n Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "transpose",
                |_self: Ref<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = bevy::math::DMat4::transpose(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the transpose of `self`.",
                &["_self"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::DMat4,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_affine_2_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::Affine2,
        >::new(world)
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::Affine2>,
                    rhs: Val<bevy::math::Affine2>,
                    max_abs_diff: f32|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Affine2::abs_diff_eq(
                                    &_self,
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs`\n is less than or equal to `max_abs_diff`.\n This can be used to compare if two 3x4 matrices contain similar elements. It works\n best when comparing with a known value. The `max_abs_diff` that should be used used\n depends on the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::Affine2>| {
                    let output: Val<bevy::math::Affine2> = {
                        {
                            let output: Val<bevy::math::Affine2> = <bevy::math::Affine2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::Affine2>, rhs: Ref<bevy::math::Affine2>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::Affine2 as ::core::cmp::PartialEq<
                                bevy::math::Affine2,
                            >>::eq(&_self, &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "from_angle",
                |angle: f32| {
                    let output: Val<bevy::math::Affine2> = {
                        {
                            let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_angle(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from the given rotation `angle`.",
                &["angle"],
            )
            .register_documented(
                "from_angle_translation",
                |angle: f32, translation: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Affine2> = {
                        {
                            let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_angle_translation(
                                    angle,
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from the given 2D rotation `angle` (in radians) and\n `translation`.\n Equivalent to `Affine2::from_translation(translation) * Affine2::from_angle(angle)`",
                &["angle", "translation"],
            )
            .register_documented(
                "from_cols",
                |
                    x_axis: Val<bevy::math::Vec2>,
                    y_axis: Val<bevy::math::Vec2>,
                    z_axis: Val<bevy::math::Vec2>|
                {
                    let output: Val<bevy::math::Affine2> = {
                        {
                            let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_cols(
                                    x_axis.into_inner(),
                                    y_axis.into_inner(),
                                    z_axis.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from three column vectors.",
                &["x_axis", "y_axis", "z_axis"],
            )
            .register_documented(
                "from_mat2",
                |matrix2: Val<bevy::math::Mat2>| {
                    let output: Val<bevy::math::Affine2> = {
                        {
                            let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_mat2(
                                    matrix2.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation)",
                &["matrix2"],
            )
            .register_documented(
                "from_mat2_translation",
                |matrix2: Val<bevy::math::Mat2>, translation: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Affine2> = {
                        {
                            let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_mat2_translation(
                                    matrix2.into_inner(),
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation) and a\n translation vector.\n Equivalent to\n `Affine2::from_translation(translation) * Affine2::from_mat2(mat2)`",
                &["matrix2", "translation"],
            )
            .register_documented(
                "from_mat3",
                |m: Val<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Affine2> = {
                        {
                            let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_mat3(
                                    m.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " The given `Mat3` must be an affine transform,",
                &["m"],
            )
            .register_documented(
                "from_mat3a",
                |m: Val<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Affine2> = {
                        {
                            let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_mat3a(
                                    m.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " The given [`Mat3A`] must be an affine transform,",
                &["m"],
            )
            .register_documented(
                "from_scale",
                |scale: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Affine2> = {
                        {
                            let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_scale(
                                    scale.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform that changes scale.\n Note that if any scale is zero the transform will be non-invertible.",
                &["scale"],
            )
            .register_documented(
                "from_scale_angle_translation",
                |
                    scale: Val<bevy::math::Vec2>,
                    angle: f32,
                    translation: Val<bevy::math::Vec2>|
                {
                    let output: Val<bevy::math::Affine2> = {
                        {
                            let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_scale_angle_translation(
                                    scale.into_inner(),
                                    angle,
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from the given 2D `scale`, rotation `angle` (in radians) and\n `translation`.\n Equivalent to `Affine2::from_translation(translation) *\n Affine2::from_angle(angle) * Affine2::from_scale(scale)`",
                &["scale", "angle", "translation"],
            )
            .register_documented(
                "from_translation",
                |translation: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Affine2> = {
                        {
                            let output: Val<bevy::math::Affine2> = bevy::math::Affine2::from_translation(
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation from the given 2D `translation`.",
                &["translation"],
            )
            .register_documented(
                "inverse",
                |_self: Ref<bevy::math::Affine2>| {
                    let output: Val<bevy::math::Affine2> = {
                        {
                            let output: Val<bevy::math::Affine2> = bevy::math::Affine2::inverse(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Return the inverse of this transform.\n Note that if the transform is not invertible the result will be invalid.",
                &["_self"],
            )
            .register_documented(
                "is_finite",
                |_self: Ref<bevy::math::Affine2>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Affine2::is_finite(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.\n If any element is either `NaN`, positive or negative infinity, this will return\n `false`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Ref<bevy::math::Affine2>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Affine2::is_nan(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NaN`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Affine2>, rhs: Val<bevy::math::Affine2>| {
                    let output: Val<bevy::math::Affine2> = {
                        {
                            let output: Val<bevy::math::Affine2> = <bevy::math::Affine2 as ::core::ops::Mul<
                                bevy::math::Affine2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Affine2>, rhs: Val<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Mat3> = {
                        {
                            let output: Val<bevy::math::Mat3> = <bevy::math::Affine2 as ::core::ops::Mul<
                                bevy::math::Mat3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Affine2>, rhs: Val<bevy::math::Mat3A>| {
                    let output: Val<bevy::math::Mat3A> = {
                        {
                            let output: Val<bevy::math::Mat3A> = <bevy::math::Affine2 as ::core::ops::Mul<
                                bevy::math::Mat3A,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_cols_array",
                |_self: Ref<bevy::math::Affine2>| {
                    let output: [f32; 6] = {
                        {
                            let output: [f32; 6] = bevy::math::Affine2::to_cols_array(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[f32; 6]` array storing data in column major order.",
                &["_self"],
            )
            .register_documented(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::Affine2>| {
                    let output: [[f32; 2]; 3] = {
                        {
                            let output: [[f32; 2]; 3] = bevy::math::Affine2::to_cols_array_2d(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[[f32; 2]; 3]` 2D array storing data in\n column major order.\n If you require data in row major order `transpose` the matrix first.",
                &["_self"],
            )
            .register_documented(
                "transform_point2",
                |_self: Ref<bevy::math::Affine2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Affine2::transform_point2(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given 2D point, applying shear, scale, rotation and translation.",
                &["_self", "rhs"],
            )
            .register_documented(
                "transform_vector2",
                |_self: Ref<bevy::math::Affine2>, rhs: Val<bevy::math::Vec2>| {
                    let output: Val<bevy::math::Vec2> = {
                        {
                            let output: Val<bevy::math::Vec2> = bevy::math::Affine2::transform_vector2(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given 2D vector, applying shear, scale and rotation (but NOT\n translation).\n To also apply translation, use [`Self::transform_point2()`] instead.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::Affine2,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_affine_3_a_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::Affine3A,
        >::new(world)
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::Affine3A>,
                    rhs: Val<bevy::math::Affine3A>,
                    max_abs_diff: f32|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Affine3A::abs_diff_eq(
                                    &_self,
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs`\n is less than or equal to `max_abs_diff`.\n This can be used to compare if two 3x4 matrices contain similar elements. It works\n best when comparing with a known value. The `max_abs_diff` that should be used used\n depends on the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::Affine3A>| {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = <bevy::math::Affine3A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::Affine3A>, rhs: Ref<bevy::math::Affine3A>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::Affine3A as ::core::cmp::PartialEq<
                                bevy::math::Affine3A,
                            >>::eq(&_self, &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "from_axis_angle",
                |axis: Val<bevy::math::Vec3>, angle: f32| {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_axis_angle(
                                    axis.into_inner(),
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform containing a 3D rotation around a normalized\n rotation `axis` of `angle` (in radians).",
                &["axis", "angle"],
            )
            .register_documented(
                "from_cols",
                |
                    x_axis: Val<bevy::math::Vec3A>,
                    y_axis: Val<bevy::math::Vec3A>,
                    z_axis: Val<bevy::math::Vec3A>,
                    w_axis: Val<bevy::math::Vec3A>|
                {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_cols(
                                    x_axis.into_inner(),
                                    y_axis.into_inner(),
                                    z_axis.into_inner(),
                                    w_axis.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from three column vectors.",
                &["x_axis", "y_axis", "z_axis", "w_axis"],
            )
            .register_documented(
                "from_mat3",
                |mat3: Val<bevy::math::Mat3>| {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_mat3(
                                    mat3.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from a 3x3 matrix (expressing scale, shear and\n rotation)",
                &["mat3"],
            )
            .register_documented(
                "from_mat3_translation",
                |mat3: Val<bevy::math::Mat3>, translation: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_mat3_translation(
                                    mat3.into_inner(),
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from a 3x3 matrix (expressing scale, shear and rotation)\n and a translation vector.\n Equivalent to `Affine3A::from_translation(translation) * Affine3A::from_mat3(mat3)`",
                &["mat3", "translation"],
            )
            .register_documented(
                "from_mat4",
                |m: Val<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_mat4(
                                    m.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " The given `Mat4` must be an affine transform,\n i.e. contain no perspective transform.",
                &["m"],
            )
            .register_documented(
                "from_quat",
                |rotation: Val<bevy::math::Quat>| {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_quat(
                                    rotation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from the given `rotation` quaternion.",
                &["rotation"],
            )
            .register_documented(
                "from_rotation_translation",
                |rotation: Val<bevy::math::Quat>, translation: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_rotation_translation(
                                    rotation.into_inner(),
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from the given 3D `rotation` and `translation`.\n Equivalent to `Affine3A::from_translation(translation) * Affine3A::from_quat(rotation)`",
                &["rotation", "translation"],
            )
            .register_documented(
                "from_rotation_x",
                |angle: f32| {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_rotation_x(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform containing a 3D rotation around the x axis of\n `angle` (in radians).",
                &["angle"],
            )
            .register_documented(
                "from_rotation_y",
                |angle: f32| {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_rotation_y(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform containing a 3D rotation around the y axis of\n `angle` (in radians).",
                &["angle"],
            )
            .register_documented(
                "from_rotation_z",
                |angle: f32| {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_rotation_z(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform containing a 3D rotation around the z axis of\n `angle` (in radians).",
                &["angle"],
            )
            .register_documented(
                "from_scale",
                |scale: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_scale(
                                    scale.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform that changes scale.\n Note that if any scale is zero the transform will be non-invertible.",
                &["scale"],
            )
            .register_documented(
                "from_scale_rotation_translation",
                |
                    scale: Val<bevy::math::Vec3>,
                    rotation: Val<bevy::math::Quat>,
                    translation: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_scale_rotation_translation(
                                    scale.into_inner(),
                                    rotation.into_inner(),
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from the given 3D `scale`, `rotation` and\n `translation`.\n Equivalent to `Affine3A::from_translation(translation) *\n Affine3A::from_quat(rotation) * Affine3A::from_scale(scale)`",
                &["scale", "rotation", "translation"],
            )
            .register_documented(
                "from_translation",
                |translation: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::from_translation(
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation from the given 3D `translation`.",
                &["translation"],
            )
            .register_documented(
                "inverse",
                |_self: Ref<bevy::math::Affine3A>| {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::inverse(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Return the inverse of this transform.\n Note that if the transform is not invertible the result will be invalid.",
                &["_self"],
            )
            .register_documented(
                "is_finite",
                |_self: Ref<bevy::math::Affine3A>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Affine3A::is_finite(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.\n If any element is either `NaN`, positive or negative infinity, this will return\n `false`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Ref<bevy::math::Affine3A>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::Affine3A::is_nan(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NaN`.",
                &["_self"],
            )
            .register_documented(
                "look_at_lh",
                |
                    eye: Val<bevy::math::Vec3>,
                    center: Val<bevy::math::Vec3>,
                    up: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::look_at_lh(
                                    eye.into_inner(),
                                    center.into_inner(),
                                    up.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a left-handed view transform using a camera position, an up direction, and a focal\n point.\n For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.\n # Panics\n Will panic if `up` is not normalized when `glam_assert` is enabled.",
                &["eye", "center", "up"],
            )
            .register_documented(
                "look_at_rh",
                |
                    eye: Val<bevy::math::Vec3>,
                    center: Val<bevy::math::Vec3>,
                    up: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::look_at_rh(
                                    eye.into_inner(),
                                    center.into_inner(),
                                    up.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a right-handed view transform using a camera position, an up direction, and a focal\n point.\n For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.\n # Panics\n Will panic if `up` is not normalized when `glam_assert` is enabled.",
                &["eye", "center", "up"],
            )
            .register_documented(
                "look_to_lh",
                |
                    eye: Val<bevy::math::Vec3>,
                    dir: Val<bevy::math::Vec3>,
                    up: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::look_to_lh(
                                    eye.into_inner(),
                                    dir.into_inner(),
                                    up.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a left-handed view transform using a camera position, an up direction, and a facing\n direction.\n For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.",
                &["eye", "dir", "up"],
            )
            .register_documented(
                "look_to_rh",
                |
                    eye: Val<bevy::math::Vec3>,
                    dir: Val<bevy::math::Vec3>,
                    up: Val<bevy::math::Vec3>|
                {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = bevy::math::Affine3A::look_to_rh(
                                    eye.into_inner(),
                                    dir.into_inner(),
                                    up.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a right-handed view transform using a camera position, an up direction, and a facing\n direction.\n For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.",
                &["eye", "dir", "up"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Affine3A>, rhs: Val<bevy::math::Affine3A>| {
                    let output: Val<bevy::math::Affine3A> = {
                        {
                            let output: Val<bevy::math::Affine3A> = <bevy::math::Affine3A as ::core::ops::Mul<
                                bevy::math::Affine3A,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::Affine3A>, rhs: Val<bevy::math::Mat4>| {
                    let output: Val<bevy::math::Mat4> = {
                        {
                            let output: Val<bevy::math::Mat4> = <bevy::math::Affine3A as ::core::ops::Mul<
                                bevy::math::Mat4,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_cols_array",
                |_self: Ref<bevy::math::Affine3A>| {
                    let output: [f32; 12] = {
                        {
                            let output: [f32; 12] = bevy::math::Affine3A::to_cols_array(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[f32; 12]` array storing data in column major order.",
                &["_self"],
            )
            .register_documented(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::Affine3A>| {
                    let output: [[f32; 3]; 4] = {
                        {
                            let output: [[f32; 3]; 4] = bevy::math::Affine3A::to_cols_array_2d(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[[f32; 3]; 4]` 3D array storing data in\n column major order.\n If you require data in row major order `transpose` the matrix first.",
                &["_self"],
            )
            .register_documented(
                "transform_point3",
                |_self: Ref<bevy::math::Affine3A>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Affine3A::transform_point3(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given 3D points, applying shear, scale, rotation and translation.",
                &["_self", "rhs"],
            )
            .register_documented(
                "transform_point3a",
                |_self: Ref<bevy::math::Affine3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Affine3A::transform_point3a(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given [`Vec3A`], applying shear, scale, rotation and translation.",
                &["_self", "rhs"],
            )
            .register_documented(
                "transform_vector3",
                |_self: Ref<bevy::math::Affine3A>, rhs: Val<bevy::math::Vec3>| {
                    let output: Val<bevy::math::Vec3> = {
                        {
                            let output: Val<bevy::math::Vec3> = bevy::math::Affine3A::transform_vector3(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given 3D vector, applying shear, scale and rotation (but NOT\n translation).\n To also apply translation, use [`Self::transform_point3()`] instead.",
                &["_self", "rhs"],
            )
            .register_documented(
                "transform_vector3a",
                |_self: Ref<bevy::math::Affine3A>, rhs: Val<bevy::math::Vec3A>| {
                    let output: Val<bevy::math::Vec3A> = {
                        {
                            let output: Val<bevy::math::Vec3A> = bevy::math::Affine3A::transform_vector3a(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given [`Vec3A`], applying shear, scale and rotation (but NOT\n translation).\n To also apply translation, use [`Self::transform_point3a()`] instead.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::Affine3A,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_d_affine_2_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::DAffine2,
        >::new(world)
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::DAffine2>,
                    rhs: Val<bevy::math::DAffine2>,
                    max_abs_diff: f64|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DAffine2::abs_diff_eq(
                                    &_self,
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs`\n is less than or equal to `max_abs_diff`.\n This can be used to compare if two 3x4 matrices contain similar elements. It works\n best when comparing with a known value. The `max_abs_diff` that should be used used\n depends on the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::DAffine2>| {
                    let output: Val<bevy::math::DAffine2> = {
                        {
                            let output: Val<bevy::math::DAffine2> = <bevy::math::DAffine2 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::DAffine2>, rhs: Ref<bevy::math::DAffine2>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::DAffine2 as ::core::cmp::PartialEq<
                                bevy::math::DAffine2,
                            >>::eq(&_self, &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "from_angle",
                |angle: f64| {
                    let output: Val<bevy::math::DAffine2> = {
                        {
                            let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_angle(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from the given rotation `angle`.",
                &["angle"],
            )
            .register_documented(
                "from_angle_translation",
                |angle: f64, translation: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DAffine2> = {
                        {
                            let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_angle_translation(
                                    angle,
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from the given 2D rotation `angle` (in radians) and\n `translation`.\n Equivalent to `DAffine2::from_translation(translation) * DAffine2::from_angle(angle)`",
                &["angle", "translation"],
            )
            .register_documented(
                "from_cols",
                |
                    x_axis: Val<bevy::math::DVec2>,
                    y_axis: Val<bevy::math::DVec2>,
                    z_axis: Val<bevy::math::DVec2>|
                {
                    let output: Val<bevy::math::DAffine2> = {
                        {
                            let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_cols(
                                    x_axis.into_inner(),
                                    y_axis.into_inner(),
                                    z_axis.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from three column vectors.",
                &["x_axis", "y_axis", "z_axis"],
            )
            .register_documented(
                "from_mat2",
                |matrix2: Val<bevy::math::DMat2>| {
                    let output: Val<bevy::math::DAffine2> = {
                        {
                            let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_mat2(
                                    matrix2.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation)",
                &["matrix2"],
            )
            .register_documented(
                "from_mat2_translation",
                |matrix2: Val<bevy::math::DMat2>, translation: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DAffine2> = {
                        {
                            let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_mat2_translation(
                                    matrix2.into_inner(),
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation) and a\n translation vector.\n Equivalent to\n `DAffine2::from_translation(translation) * DAffine2::from_mat2(mat2)`",
                &["matrix2", "translation"],
            )
            .register_documented(
                "from_mat3",
                |m: Val<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DAffine2> = {
                        {
                            let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_mat3(
                                    m.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " The given `DMat3` must be an affine transform,",
                &["m"],
            )
            .register_documented(
                "from_scale",
                |scale: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DAffine2> = {
                        {
                            let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_scale(
                                    scale.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform that changes scale.\n Note that if any scale is zero the transform will be non-invertible.",
                &["scale"],
            )
            .register_documented(
                "from_scale_angle_translation",
                |
                    scale: Val<bevy::math::DVec2>,
                    angle: f64,
                    translation: Val<bevy::math::DVec2>|
                {
                    let output: Val<bevy::math::DAffine2> = {
                        {
                            let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_scale_angle_translation(
                                    scale.into_inner(),
                                    angle,
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from the given 2D `scale`, rotation `angle` (in radians) and\n `translation`.\n Equivalent to `DAffine2::from_translation(translation) *\n DAffine2::from_angle(angle) * DAffine2::from_scale(scale)`",
                &["scale", "angle", "translation"],
            )
            .register_documented(
                "from_translation",
                |translation: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DAffine2> = {
                        {
                            let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::from_translation(
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation from the given 2D `translation`.",
                &["translation"],
            )
            .register_documented(
                "inverse",
                |_self: Ref<bevy::math::DAffine2>| {
                    let output: Val<bevy::math::DAffine2> = {
                        {
                            let output: Val<bevy::math::DAffine2> = bevy::math::DAffine2::inverse(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Return the inverse of this transform.\n Note that if the transform is not invertible the result will be invalid.",
                &["_self"],
            )
            .register_documented(
                "is_finite",
                |_self: Ref<bevy::math::DAffine2>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DAffine2::is_finite(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.\n If any element is either `NaN`, positive or negative infinity, this will return\n `false`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Ref<bevy::math::DAffine2>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DAffine2::is_nan(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NaN`.",
                &["_self"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DAffine2>, rhs: Val<bevy::math::DAffine2>| {
                    let output: Val<bevy::math::DAffine2> = {
                        {
                            let output: Val<bevy::math::DAffine2> = <bevy::math::DAffine2 as ::core::ops::Mul<
                                bevy::math::DAffine2,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DAffine2>, rhs: Val<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DMat3> = {
                        {
                            let output: Val<bevy::math::DMat3> = <bevy::math::DAffine2 as ::core::ops::Mul<
                                bevy::math::DMat3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_cols_array",
                |_self: Ref<bevy::math::DAffine2>| {
                    let output: [f64; 6] = {
                        {
                            let output: [f64; 6] = bevy::math::DAffine2::to_cols_array(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[f64; 6]` array storing data in column major order.",
                &["_self"],
            )
            .register_documented(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::DAffine2>| {
                    let output: [[f64; 2]; 3] = {
                        {
                            let output: [[f64; 2]; 3] = bevy::math::DAffine2::to_cols_array_2d(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[[f64; 2]; 3]` 2D array storing data in\n column major order.\n If you require data in row major order `transpose` the matrix first.",
                &["_self"],
            )
            .register_documented(
                "transform_point2",
                |_self: Ref<bevy::math::DAffine2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DAffine2::transform_point2(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given 2D point, applying shear, scale, rotation and translation.",
                &["_self", "rhs"],
            )
            .register_documented(
                "transform_vector2",
                |_self: Ref<bevy::math::DAffine2>, rhs: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DVec2> = {
                        {
                            let output: Val<bevy::math::DVec2> = bevy::math::DAffine2::transform_vector2(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given 2D vector, applying shear, scale and rotation (but NOT\n translation).\n To also apply translation, use [`Self::transform_point2()`] instead.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::DAffine2,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_d_affine_3_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::DAffine3,
        >::new(world)
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Ref<bevy::math::DAffine3>,
                    rhs: Val<bevy::math::DAffine3>,
                    max_abs_diff: f64|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DAffine3::abs_diff_eq(
                                    &_self,
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs`\n is less than or equal to `max_abs_diff`.\n This can be used to compare if two 3x4 matrices contain similar elements. It works\n best when comparing with a known value. The `max_abs_diff` that should be used used\n depends on the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::DAffine3>| {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = <bevy::math::DAffine3 as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::DAffine3>, rhs: Ref<bevy::math::DAffine3>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::DAffine3 as ::core::cmp::PartialEq<
                                bevy::math::DAffine3,
                            >>::eq(&_self, &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "from_axis_angle",
                |axis: Val<bevy::math::DVec3>, angle: f64| {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_axis_angle(
                                    axis.into_inner(),
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform containing a 3D rotation around a normalized\n rotation `axis` of `angle` (in radians).",
                &["axis", "angle"],
            )
            .register_documented(
                "from_cols",
                |
                    x_axis: Val<bevy::math::DVec3>,
                    y_axis: Val<bevy::math::DVec3>,
                    z_axis: Val<bevy::math::DVec3>,
                    w_axis: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_cols(
                                    x_axis.into_inner(),
                                    y_axis.into_inner(),
                                    z_axis.into_inner(),
                                    w_axis.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from three column vectors.",
                &["x_axis", "y_axis", "z_axis", "w_axis"],
            )
            .register_documented(
                "from_mat3",
                |mat3: Val<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_mat3(
                                    mat3.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from a 3x3 matrix (expressing scale, shear and\n rotation)",
                &["mat3"],
            )
            .register_documented(
                "from_mat3_translation",
                |mat3: Val<bevy::math::DMat3>, translation: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_mat3_translation(
                                    mat3.into_inner(),
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from a 3x3 matrix (expressing scale, shear and rotation)\n and a translation vector.\n Equivalent to `DAffine3::from_translation(translation) * DAffine3::from_mat3(mat3)`",
                &["mat3", "translation"],
            )
            .register_documented(
                "from_mat4",
                |m: Val<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_mat4(
                                    m.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " The given `DMat4` must be an affine transform,\n i.e. contain no perspective transform.",
                &["m"],
            )
            .register_documented(
                "from_quat",
                |rotation: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_quat(
                                    rotation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from the given `rotation` quaternion.",
                &["rotation"],
            )
            .register_documented(
                "from_rotation_translation",
                |rotation: Val<bevy::math::DQuat>, translation: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_rotation_translation(
                                    rotation.into_inner(),
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from the given 3D `rotation` and `translation`.\n Equivalent to `DAffine3::from_translation(translation) * DAffine3::from_quat(rotation)`",
                &["rotation", "translation"],
            )
            .register_documented(
                "from_rotation_x",
                |angle: f64| {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_rotation_x(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform containing a 3D rotation around the x axis of\n `angle` (in radians).",
                &["angle"],
            )
            .register_documented(
                "from_rotation_y",
                |angle: f64| {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_rotation_y(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform containing a 3D rotation around the y axis of\n `angle` (in radians).",
                &["angle"],
            )
            .register_documented(
                "from_rotation_z",
                |angle: f64| {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_rotation_z(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform containing a 3D rotation around the z axis of\n `angle` (in radians).",
                &["angle"],
            )
            .register_documented(
                "from_scale",
                |scale: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_scale(
                                    scale.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform that changes scale.\n Note that if any scale is zero the transform will be non-invertible.",
                &["scale"],
            )
            .register_documented(
                "from_scale_rotation_translation",
                |
                    scale: Val<bevy::math::DVec3>,
                    rotation: Val<bevy::math::DQuat>,
                    translation: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_scale_rotation_translation(
                                    scale.into_inner(),
                                    rotation.into_inner(),
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transform from the given 3D `scale`, `rotation` and\n `translation`.\n Equivalent to `DAffine3::from_translation(translation) *\n DAffine3::from_quat(rotation) * DAffine3::from_scale(scale)`",
                &["scale", "rotation", "translation"],
            )
            .register_documented(
                "from_translation",
                |translation: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::from_translation(
                                    translation.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates an affine transformation from the given 3D `translation`.",
                &["translation"],
            )
            .register_documented(
                "inverse",
                |_self: Ref<bevy::math::DAffine3>| {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::inverse(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Return the inverse of this transform.\n Note that if the transform is not invertible the result will be invalid.",
                &["_self"],
            )
            .register_documented(
                "is_finite",
                |_self: Ref<bevy::math::DAffine3>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DAffine3::is_finite(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.\n If any element is either `NaN`, positive or negative infinity, this will return\n `false`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Ref<bevy::math::DAffine3>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DAffine3::is_nan(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NaN`.",
                &["_self"],
            )
            .register_documented(
                "look_at_lh",
                |
                    eye: Val<bevy::math::DVec3>,
                    center: Val<bevy::math::DVec3>,
                    up: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::look_at_lh(
                                    eye.into_inner(),
                                    center.into_inner(),
                                    up.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a left-handed view transform using a camera position, an up direction, and a focal\n point.\n For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.\n # Panics\n Will panic if `up` is not normalized when `glam_assert` is enabled.",
                &["eye", "center", "up"],
            )
            .register_documented(
                "look_at_rh",
                |
                    eye: Val<bevy::math::DVec3>,
                    center: Val<bevy::math::DVec3>,
                    up: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::look_at_rh(
                                    eye.into_inner(),
                                    center.into_inner(),
                                    up.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a right-handed view transform using a camera position, an up direction, and a focal\n point.\n For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.\n # Panics\n Will panic if `up` is not normalized when `glam_assert` is enabled.",
                &["eye", "center", "up"],
            )
            .register_documented(
                "look_to_lh",
                |
                    eye: Val<bevy::math::DVec3>,
                    dir: Val<bevy::math::DVec3>,
                    up: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::look_to_lh(
                                    eye.into_inner(),
                                    dir.into_inner(),
                                    up.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a left-handed view transform using a camera position, an up direction, and a facing\n direction.\n For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.",
                &["eye", "dir", "up"],
            )
            .register_documented(
                "look_to_rh",
                |
                    eye: Val<bevy::math::DVec3>,
                    dir: Val<bevy::math::DVec3>,
                    up: Val<bevy::math::DVec3>|
                {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = bevy::math::DAffine3::look_to_rh(
                                    eye.into_inner(),
                                    dir.into_inner(),
                                    up.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a right-handed view transform using a camera position, an up direction, and a facing\n direction.\n For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.",
                &["eye", "dir", "up"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DAffine3>, rhs: Val<bevy::math::DAffine3>| {
                    let output: Val<bevy::math::DAffine3> = {
                        {
                            let output: Val<bevy::math::DAffine3> = <bevy::math::DAffine3 as ::core::ops::Mul<
                                bevy::math::DAffine3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DAffine3>, rhs: Val<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DMat4> = {
                        {
                            let output: Val<bevy::math::DMat4> = <bevy::math::DAffine3 as ::core::ops::Mul<
                                bevy::math::DMat4,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_cols_array",
                |_self: Ref<bevy::math::DAffine3>| {
                    let output: [f64; 12] = {
                        {
                            let output: [f64; 12] = bevy::math::DAffine3::to_cols_array(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[f64; 12]` array storing data in column major order.",
                &["_self"],
            )
            .register_documented(
                "to_cols_array_2d",
                |_self: Ref<bevy::math::DAffine3>| {
                    let output: [[f64; 3]; 4] = {
                        {
                            let output: [[f64; 3]; 4] = bevy::math::DAffine3::to_cols_array_2d(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a `[[f64; 3]; 4]` 3D array storing data in\n column major order.\n If you require data in row major order `transpose` the matrix first.",
                &["_self"],
            )
            .register_documented(
                "transform_point3",
                |_self: Ref<bevy::math::DAffine3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DAffine3::transform_point3(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given 3D points, applying shear, scale, rotation and translation.",
                &["_self", "rhs"],
            )
            .register_documented(
                "transform_vector3",
                |_self: Ref<bevy::math::DAffine3>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DAffine3::transform_vector3(
                                    &_self,
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Transforms the given 3D vector, applying shear, scale and rotation (but NOT\n translation).\n To also apply translation, use [`Self::transform_point3()`] instead.",
                &["_self", "rhs"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::DAffine3,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_d_quat_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::DQuat,
        >::new(world)
            .register_documented(
                "abs_diff_eq",
                |
                    _self: Val<bevy::math::DQuat>,
                    rhs: Val<bevy::math::DQuat>,
                    max_abs_diff: f64|
                {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DQuat::abs_diff_eq(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                    max_abs_diff,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if the absolute difference of all elements between `self` and `rhs`\n is less than or equal to `max_abs_diff`.\n This can be used to compare if two quaternions contain similar elements. It works\n best when comparing with a known value. The `max_abs_diff` that should be used used\n depends on the values being compared against.\n For more see\n [comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).",
                &["_self", "rhs", "max_abs_diff"],
            )
            .register_documented(
                "add",
                |_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as ::core::ops::Add<
                                bevy::math::DQuat,
                            >>::add(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                " Adds two quaternions.\n The sum is not guaranteed to be normalized.\n Note that addition is not the same as combining the rotations represented by the\n two quaternions! That corresponds to multiplication.",
                &["_self", "rhs"],
            )
            .register_documented(
                "angle_between",
                |_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DQuat::angle_between(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the angle (in radians) for the minimal rotation\n for transforming this quaternion into another.\n Both quaternions must be normalized.\n # Panics\n Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "as_quat",
                |_self: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::Quat> = {
                        {
                            let output: Val<bevy::math::Quat> = bevy::math::DQuat::as_quat(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "conjugate",
                |_self: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::conjugate(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the quaternion conjugate of `self`. For a unit quaternion the\n conjugate is also the inverse.",
                &["_self"],
            )
            .register_documented(
                "div",
                |_self: Val<bevy::math::DQuat>, rhs: f64| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as ::core::ops::Div<
                                f64,
                            >>::div(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Divides a quaternion by a scalar value.\n The quotient is not guaranteed to be normalized.",
                &["_self", "rhs"],
            )
            .register_documented(
                "dot",
                |_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DQuat::dot(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the dot product of `self` and `rhs`. The dot product is\n equal to the cosine of the angle between two quaternion rotations.",
                &["_self", "rhs"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::DQuat>, rhs: Ref<bevy::math::DQuat>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::DQuat as ::core::cmp::PartialEq<
                                bevy::math::DQuat,
                            >>::eq(&_self, &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "from_affine3",
                |a: Ref<bevy::math::DAffine3>| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_affine3(
                                    &a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a quaternion from a 3x3 rotation matrix inside a 3D affine transform.\n Note if the input affine matrix contain scales, shears, or other non-rotation\n transformations then the resulting quaternion will be ill-defined.\n # Panics\n Will panic if any input affine matrix column is not normalized when `glam_assert` is\n enabled.",
                &["a"],
            )
            .register_documented(
                "from_array",
                |a: [f64; 4]| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a rotation quaternion from an array.\n # Preconditions\n This function does not check if the input is normalized, it is up to the user to\n provide normalized input or to normalized the resulting quaternion.",
                &["a"],
            )
            .register_documented(
                "from_axis_angle",
                |axis: Val<bevy::math::DVec3>, angle: f64| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_axis_angle(
                                    axis.into_inner(),
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Create a quaternion for a normalized rotation `axis` and `angle` (in radians).\n The axis must be a unit vector.\n # Panics\n Will panic if `axis` is not normalized when `glam_assert` is enabled.",
                &["axis", "angle"],
            )
            .register_documented(
                "from_euler",
                |euler: Val<bevy::math::EulerRot>, a: f64, b: f64, c: f64| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_euler(
                                    euler.into_inner(),
                                    a,
                                    b,
                                    c,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a quaternion from the given Euler rotation sequence and the angles (in radians).",
                &["euler", "a", "b", "c"],
            )
            .register_documented(
                "from_mat3",
                |mat: Ref<bevy::math::DMat3>| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_mat3(
                                    &mat,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a quaternion from a 3x3 rotation matrix.\n Note if the input matrix contain scales, shears, or other non-rotation transformations then\n the resulting quaternion will be ill-defined.\n # Panics\n Will panic if any input matrix column is not normalized when `glam_assert` is enabled.",
                &["mat"],
            )
            .register_documented(
                "from_mat4",
                |mat: Ref<bevy::math::DMat4>| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_mat4(
                                    &mat,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a quaternion from the upper 3x3 rotation matrix inside a homogeneous 4x4 matrix.\n Note if the upper 3x3 matrix contain scales, shears, or other non-rotation transformations\n then the resulting quaternion will be ill-defined.\n # Panics\n Will panic if any column of the upper 3x3 rotation matrix is not normalized when\n `glam_assert` is enabled.",
                &["mat"],
            )
            .register_documented(
                "from_rotation_arc",
                |from: Val<bevy::math::DVec3>, to: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_arc(
                                    from.into_inner(),
                                    to.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the\n plane spanned by the two vectors.  Will rotate at most 180 degrees.\n The inputs must be unit vectors.\n `from_rotation_arc(from, to) * from ≈ to`.\n For near-singular cases (from≈to and from≈-to) the current implementation\n is only accurate to about 0.001 (for `f32`).\n # Panics\n Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.",
                &["from", "to"],
            )
            .register_documented(
                "from_rotation_arc_2d",
                |from: Val<bevy::math::DVec2>, to: Val<bevy::math::DVec2>| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_arc_2d(
                                    from.into_inner(),
                                    to.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Gets the minimal rotation for transforming `from` to `to`.  The resulting rotation is\n around the z axis. Will rotate at most 180 degrees.\n The inputs must be unit vectors.\n `from_rotation_arc_2d(from, to) * from ≈ to`.\n For near-singular cases (from≈to and from≈-to) the current implementation\n is only accurate to about 0.001 (for `f32`).\n # Panics\n Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.",
                &["from", "to"],
            )
            .register_documented(
                "from_rotation_arc_colinear",
                |from: Val<bevy::math::DVec3>, to: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_arc_colinear(
                                    from.into_inner(),
                                    to.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Gets the minimal rotation for transforming `from` to either `to` or `-to`.  This means\n that the resulting quaternion will rotate `from` so that it is colinear with `to`.\n The rotation is in the plane spanned by the two vectors.  Will rotate at most 90\n degrees.\n The inputs must be unit vectors.\n `to.dot(from_rotation_arc_colinear(from, to) * from).abs() ≈ 1`.\n # Panics\n Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.",
                &["from", "to"],
            )
            .register_documented(
                "from_rotation_x",
                |angle: f64| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_x(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a quaternion from the `angle` (in radians) around the x axis.",
                &["angle"],
            )
            .register_documented(
                "from_rotation_y",
                |angle: f64| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_y(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a quaternion from the `angle` (in radians) around the y axis.",
                &["angle"],
            )
            .register_documented(
                "from_rotation_z",
                |angle: f64| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_rotation_z(
                                    angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a quaternion from the `angle` (in radians) around the z axis.",
                &["angle"],
            )
            .register_documented(
                "from_scaled_axis",
                |v: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_scaled_axis(
                                    v.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Create a quaternion that rotates `v.length()` radians around `v.normalize()`.\n `from_scaled_axis(Vec3::ZERO)` results in the identity quaternion.",
                &["v"],
            )
            .register_documented(
                "from_vec4",
                |v: Val<bevy::math::DVec4>| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_vec4(
                                    v.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new rotation quaternion from a 4D vector.\n # Preconditions\n This function does not check if the input is normalized, it is up to the user to\n provide normalized input or to normalized the resulting quaternion.",
                &["v"],
            )
            .register_documented(
                "from_xyzw",
                |x: f64, y: f64, z: f64, w: f64| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::from_xyzw(
                                    x,
                                    y,
                                    z,
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new rotation quaternion.\n This should generally not be called manually unless you know what you are doing.\n Use one of the other constructors instead such as `identity` or `from_axis_angle`.\n `from_xyzw` is mostly used by unit tests and `serde` deserialization.\n # Preconditions\n This function does not check if the input is normalized, it is up to the user to\n provide normalized input or to normalized the resulting quaternion.",
                &["x", "y", "z", "w"],
            )
            .register_documented(
                "inverse",
                |_self: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::inverse(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the inverse of a normalized quaternion.\n Typically quaternion inverse returns the conjugate of a normalized quaternion.\n Because `self` is assumed to already be unit length this method *does not* normalize\n before returning the conjugate.\n # Panics\n Will panic if `self` is not normalized when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "is_finite",
                |_self: Val<bevy::math::DQuat>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DQuat::is_finite(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if, and only if, all elements are finite.\n If any element is either `NaN`, positive or negative infinity, this will return `false`.",
                &["_self"],
            )
            .register_documented(
                "is_nan",
                |_self: Val<bevy::math::DQuat>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DQuat::is_nan(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `true` if any elements are `NAN`.",
                &["_self"],
            )
            .register_documented(
                "is_near_identity",
                |_self: Val<bevy::math::DQuat>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DQuat::is_near_identity(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "is_normalized",
                |_self: Val<bevy::math::DQuat>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::DQuat::is_normalized(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns whether `self` of length `1.0` or not.\n Uses a precision threshold of `1e-6`.",
                &["_self"],
            )
            .register_documented(
                "length",
                |_self: Val<bevy::math::DQuat>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DQuat::length(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the length of `self`.",
                &["_self"],
            )
            .register_documented(
                "length_recip",
                |_self: Val<bevy::math::DQuat>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DQuat::length_recip(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes `1.0 / length()`.\n For valid results, `self` must _not_ be of length zero.",
                &["_self"],
            )
            .register_documented(
                "length_squared",
                |_self: Val<bevy::math::DQuat>| {
                    let output: f64 = {
                        {
                            let output: f64 = bevy::math::DQuat::length_squared(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Computes the squared length of `self`.\n This is generally faster than `length()` as it avoids a square\n root operation.",
                &["_self"],
            )
            .register_documented(
                "lerp",
                |_self: Val<bevy::math::DQuat>, end: Val<bevy::math::DQuat>, s: f64| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::lerp(
                                    _self.into_inner(),
                                    end.into_inner(),
                                    s,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs a linear interpolation between `self` and `rhs` based on\n the value `s`.\n When `s` is `0.0`, the result will be equal to `self`.  When `s`\n is `1.0`, the result will be equal to `rhs`.\n # Panics\n Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.",
                &["_self", "end", "s"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as ::core::ops::Mul<
                                bevy::math::DQuat,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies two quaternions. If they each represent a rotation, the result will\n represent the combined rotation.\n Note that due to floating point rounding the result may not be perfectly\n normalized.\n # Panics\n Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = <bevy::math::DQuat as ::core::ops::Mul<
                                bevy::math::DVec3,
                            >>::mul(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies a quaternion and a 3D vector, returning the rotated vector.\n # Panics\n Will panic if `self` is not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul",
                |_self: Val<bevy::math::DQuat>, rhs: f64| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as ::core::ops::Mul<
                                f64,
                            >>::mul(_self.into_inner(), rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies a quaternion by a scalar value.\n The product is not guaranteed to be normalized.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_quat",
                |_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::mul_quat(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies two quaternions. If they each represent a rotation, the result will\n represent the combined rotation.\n Note that due to floating point rounding the result may not be perfectly normalized.\n # Panics\n Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "mul_vec3",
                |_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DVec3>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DQuat::mul_vec3(
                                    _self.into_inner(),
                                    rhs.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Multiplies a quaternion and a 3D vector, returning the rotated vector.\n # Panics\n Will panic if `self` is not normalized when `glam_assert` is enabled.",
                &["_self", "rhs"],
            )
            .register_documented(
                "neg",
                |_self: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as ::core::ops::Neg>::neg(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "normalize",
                |_self: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::normalize(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns `self` normalized to length 1.0.\n For valid results, `self` must _not_ be of length zero.\n Panics\n Will panic if `self` is zero length when `glam_assert` is enabled.",
                &["_self"],
            )
            .register_documented(
                "rotate_towards",
                |
                    _self: Ref<bevy::math::DQuat>,
                    rhs: Val<bevy::math::DQuat>,
                    max_angle: f64|
                {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::rotate_towards(
                                    &_self,
                                    rhs.into_inner(),
                                    max_angle,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Rotates towards `rhs` up to `max_angle` (in radians).\n When `max_angle` is `0.0`, the result will be equal to `self`. When `max_angle` is equal to\n `self.angle_between(rhs)`, the result will be equal to `rhs`. If `max_angle` is negative,\n rotates towards the exact opposite of `rhs`. Will not go past the target.\n Both quaternions must be normalized.\n # Panics\n Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.",
                &["_self", "rhs", "max_angle"],
            )
            .register_documented(
                "slerp",
                |_self: Val<bevy::math::DQuat>, end: Val<bevy::math::DQuat>, s: f64| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = bevy::math::DQuat::slerp(
                                    _self.into_inner(),
                                    end.into_inner(),
                                    s,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Performs a spherical linear interpolation between `self` and `end`\n based on the value `s`.\n When `s` is `0.0`, the result will be equal to `self`.  When `s`\n is `1.0`, the result will be equal to `end`.\n # Panics\n Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.",
                &["_self", "end", "s"],
            )
            .register_documented(
                "sub",
                |_self: Val<bevy::math::DQuat>, rhs: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DQuat> = {
                        {
                            let output: Val<bevy::math::DQuat> = <bevy::math::DQuat as ::core::ops::Sub<
                                bevy::math::DQuat,
                            >>::sub(_self.into_inner(), rhs.into_inner())
                                .into();
                            output
                        }
                    };
                    output
                },
                " Subtracts the `rhs` quaternion from `self`.\n The difference is not guaranteed to be normalized.",
                &["_self", "rhs"],
            )
            .register_documented(
                "to_array",
                |_self: Ref<bevy::math::DQuat>| {
                    let output: [f64; 4] = {
                        {
                            let output: [f64; 4] = bevy::math::DQuat::to_array(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " `[x, y, z, w]`",
                &["_self"],
            )
            .register_documented(
                "to_euler",
                |_self: Val<bevy::math::DQuat>, order: Val<bevy::math::EulerRot>| {
                    let output: (f64, f64, f64) = {
                        {
                            let output: (f64, f64, f64) = bevy::math::DQuat::to_euler(
                                    _self.into_inner(),
                                    order.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the rotation angles for the given euler rotation sequence.",
                &["_self", "order"],
            )
            .register_documented(
                "to_scaled_axis",
                |_self: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DQuat::to_scaled_axis(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the rotation axis scaled by the rotation in radians.",
                &["_self"],
            )
            .register_documented(
                "xyz",
                |_self: Val<bevy::math::DQuat>| {
                    let output: Val<bevy::math::DVec3> = {
                        {
                            let output: Val<bevy::math::DVec3> = bevy::math::DQuat::xyz(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the vector part of the quaternion.",
                &["_self"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::DQuat,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_euler_rot_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::EulerRot,
        >::new(world)
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<bevy::math::EulerRot>| {
                    let output: () = {
                        {
                            let output: () = <bevy::math::EulerRot as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::EulerRot>| {
                    let output: Val<bevy::math::EulerRot> = {
                        {
                            let output: Val<bevy::math::EulerRot> = <bevy::math::EulerRot as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::EulerRot>, other: Ref<bevy::math::EulerRot>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::EulerRot as ::core::cmp::PartialEq<
                                bevy::math::EulerRot,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::EulerRot,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_b_vec_3_a_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::BVec3A,
        >::new(world)
            .register_documented(
                "all",
                |_self: Val<bevy::math::BVec3A>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::BVec3A::all(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if all the elements are true, false otherwise.",
                &["_self"],
            )
            .register_documented(
                "any",
                |_self: Val<bevy::math::BVec3A>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::BVec3A::any(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if any of the elements are true, false otherwise.",
                &["_self"],
            )
            .register_documented(
                "bitmask",
                |_self: Val<bevy::math::BVec3A>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::BVec3A::bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 3 bits set from the elements of `self`.\n A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::BVec3A>| {
                    let output: Val<bevy::math::BVec3A> = {
                        {
                            let output: Val<bevy::math::BVec3A> = <bevy::math::BVec3A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::BVec3A>, rhs: Ref<bevy::math::BVec3A>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::BVec3A as ::core::cmp::PartialEq<
                                bevy::math::BVec3A,
                            >>::eq(&_self, &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "from_array",
                |a: [bool; 3]| {
                    let output: Val<bevy::math::BVec3A> = {
                        {
                            let output: Val<bevy::math::BVec3A> = bevy::math::BVec3A::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector mask from a bool array.",
                &["a"],
            )
            .register_documented(
                "new",
                |x: bool, y: bool, z: bool| {
                    let output: Val<bevy::math::BVec3A> = {
                        {
                            let output: Val<bevy::math::BVec3A> = bevy::math::BVec3A::new(
                                    x,
                                    y,
                                    z,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector mask.",
                &["x", "y", "z"],
            )
            .register_documented(
                "set",
                |mut _self: Mut<bevy::math::BVec3A>, index: usize, value: bool| {
                    let output: () = {
                        {
                            let output: () = bevy::math::BVec3A::set(
                                    &mut _self,
                                    index,
                                    value,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Sets the element at `index`.\n Panics if `index` is greater than 2.",
                &["_self", "index", "value"],
            )
            .register_documented(
                "splat",
                |v: bool| {
                    let output: Val<bevy::math::BVec3A> = {
                        {
                            let output: Val<bevy::math::BVec3A> = bevy::math::BVec3A::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector mask with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "test",
                |_self: Ref<bevy::math::BVec3A>, index: usize| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::BVec3A::test(&_self, index)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Tests the value at `index`.\n Panics if `index` is greater than 2.",
                &["_self", "index"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::BVec3A,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_b_vec_4_a_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            bevy::math::BVec4A,
        >::new(world)
            .register_documented(
                "all",
                |_self: Val<bevy::math::BVec4A>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::BVec4A::all(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if all the elements are true, false otherwise.",
                &["_self"],
            )
            .register_documented(
                "any",
                |_self: Val<bevy::math::BVec4A>| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::BVec4A::any(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns true if any of the elements are true, false otherwise.",
                &["_self"],
            )
            .register_documented(
                "bitmask",
                |_self: Val<bevy::math::BVec4A>| {
                    let output: u32 = {
                        {
                            let output: u32 = bevy::math::BVec4A::bitmask(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns a bitmask with the lowest 4 bits set from the elements of `self`.\n A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes\n into the first lowest bit, element `y` into the second, etc.",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<bevy::math::BVec4A>| {
                    let output: Val<bevy::math::BVec4A> = {
                        {
                            let output: Val<bevy::math::BVec4A> = <bevy::math::BVec4A as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<bevy::math::BVec4A>, rhs: Ref<bevy::math::BVec4A>| {
                    let output: bool = {
                        {
                            let output: bool = <bevy::math::BVec4A as ::core::cmp::PartialEq<
                                bevy::math::BVec4A,
                            >>::eq(&_self, &rhs)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "rhs"],
            )
            .register_documented(
                "from_array",
                |a: [bool; 4]| {
                    let output: Val<bevy::math::BVec4A> = {
                        {
                            let output: Val<bevy::math::BVec4A> = bevy::math::BVec4A::from_array(
                                    a,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector mask from a bool array.",
                &["a"],
            )
            .register_documented(
                "new",
                |x: bool, y: bool, z: bool, w: bool| {
                    let output: Val<bevy::math::BVec4A> = {
                        {
                            let output: Val<bevy::math::BVec4A> = bevy::math::BVec4A::new(
                                    x,
                                    y,
                                    z,
                                    w,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a new vector mask.",
                &["x", "y", "z", "w"],
            )
            .register_documented(
                "set",
                |mut _self: Mut<bevy::math::BVec4A>, index: usize, value: bool| {
                    let output: () = {
                        {
                            let output: () = bevy::math::BVec4A::set(
                                    &mut _self,
                                    index,
                                    value,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Sets the element at `index`.\n Panics if `index` is greater than 3.",
                &["_self", "index", "value"],
            )
            .register_documented(
                "splat",
                |v: bool| {
                    let output: Val<bevy::math::BVec4A> = {
                        {
                            let output: Val<bevy::math::BVec4A> = bevy::math::BVec4A::splat(
                                    v,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a vector mask with all elements set to `v`.",
                &["v"],
            )
            .register_documented(
                "test",
                |_self: Ref<bevy::math::BVec4A>, index: usize| {
                    let output: bool = {
                        {
                            let output: bool = bevy::math::BVec4A::test(&_self, index)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Tests the value at `index`.\n Panics if `index` is greater than 3.",
                &["_self", "index"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                bevy::math::BVec4A,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_smol_str_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            ::smol_str::SmolStr,
        >::new(world)
            .register_documented(
                "clone",
                |_self: Ref<::smol_str::SmolStr>| {
                    let output: Val<::smol_str::SmolStr> = {
                        {
                            let output: Val<::smol_str::SmolStr> = <::smol_str::SmolStr as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "eq",
                |_self: Ref<::smol_str::SmolStr>, other: Ref<::smol_str::SmolStr>| {
                    let output: bool = {
                        {
                            let output: bool = <::smol_str::SmolStr as ::core::cmp::PartialEq<
                                ::smol_str::SmolStr,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "is_empty",
                |_self: Ref<::smol_str::SmolStr>| {
                    let output: bool = {
                        {
                            let output: bool = ::smol_str::SmolStr::is_empty(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "is_heap_allocated",
                |_self: Ref<::smol_str::SmolStr>| {
                    let output: bool = {
                        {
                            let output: bool = ::smol_str::SmolStr::is_heap_allocated(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "len",
                |_self: Ref<::smol_str::SmolStr>| {
                    let output: usize = {
                        {
                            let output: usize = ::smol_str::SmolStr::len(&_self).into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "to_string",
                |_self: Ref<::smol_str::SmolStr>| {
                    let output: ::std::string::String = {
                        {
                            let output: ::std::string::String = ::smol_str::SmolStr::to_string(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                ::smol_str::SmolStr,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    pub(crate) fn register_uuid_functions(world: &mut bevy::ecs::world::World) {
        bevy_mod_scripting_core::bindings::function::namespace::NamespaceBuilder::<
            ::uuid::Uuid,
        >::new(world)
            .register_documented(
                "as_u128",
                |_self: Ref<::uuid::Uuid>| {
                    let output: u128 = {
                        {
                            let output: u128 = ::uuid::Uuid::as_u128(&_self).into();
                            output
                        }
                    };
                    output
                },
                " Returns a 128bit value containing the value.\n The bytes in the UUID will be packed directly into a `u128`.\n # Examples\n ```\n # use uuid::Uuid;\n # fn main() -> Result<(), uuid::Error> {\n let uuid = Uuid::parse_str(\"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\")?;\n assert_eq!(\n     uuid.as_u128(),\n     0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8,\n );\n # Ok(())\n # }\n ```",
                &["_self"],
            )
            .register_documented(
                "as_u64_pair",
                |_self: Ref<::uuid::Uuid>| {
                    let output: (u64, u64) = {
                        {
                            let output: (u64, u64) = ::uuid::Uuid::as_u64_pair(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns two 64bit values containing the value.\n The bytes in the UUID will be split into two `u64`.\n The first u64 represents the 64 most significant bits,\n the second one represents the 64 least significant.\n # Examples\n ```\n # use uuid::Uuid;\n # fn main() -> Result<(), uuid::Error> {\n let uuid = Uuid::parse_str(\"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\")?;\n assert_eq!(\n     uuid.as_u64_pair(),\n     (0xa1a2a3a4b1b2c1c2, 0xd1d2d3d4d5d6d7d8),\n );\n # Ok(())\n # }\n ```",
                &["_self"],
            )
            .register_documented(
                "assert_receiver_is_total_eq",
                |_self: Ref<::uuid::Uuid>| {
                    let output: () = {
                        {
                            let output: () = <::uuid::Uuid as ::core::cmp::Eq>::assert_receiver_is_total_eq(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "clone",
                |_self: Ref<::uuid::Uuid>| {
                    let output: Val<::uuid::Uuid> = {
                        {
                            let output: Val<::uuid::Uuid> = <::uuid::Uuid as bevy::reflect::erased_serde::__private::serde::__private::Clone>::clone(
                                    &_self,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self"],
            )
            .register_documented(
                "encode_buffer",
                || {
                    let output: [u8; 45] = {
                        {
                            let output: [u8; 45] = ::uuid::Uuid::encode_buffer().into();
                            output
                        }
                    };
                    output
                },
                " A buffer that can be used for `encode_...` calls, that is\n guaranteed to be long enough for any of the format adapters.\n # Examples\n ```\n # use uuid::Uuid;\n let uuid = Uuid::nil();\n assert_eq!(\n     uuid.simple().encode_lower(&mut Uuid::encode_buffer()),\n     \"00000000000000000000000000000000\"\n );\n assert_eq!(\n     uuid.hyphenated()\n         .encode_lower(&mut Uuid::encode_buffer()),\n     \"00000000-0000-0000-0000-000000000000\"\n );\n assert_eq!(\n     uuid.urn().encode_lower(&mut Uuid::encode_buffer()),\n     \"urn:uuid:00000000-0000-0000-0000-000000000000\"\n );\n ```",
                &[],
            )
            .register_documented(
                "eq",
                |_self: Ref<::uuid::Uuid>, other: Ref<::uuid::Uuid>| {
                    let output: bool = {
                        {
                            let output: bool = <::uuid::Uuid as ::core::cmp::PartialEq<
                                ::uuid::Uuid,
                            >>::eq(&_self, &other)
                                .into();
                            output
                        }
                    };
                    output
                },
                "",
                &["_self", "other"],
            )
            .register_documented(
                "from_bytes",
                |bytes: [u8; 16]| {
                    let output: Val<::uuid::Uuid> = {
                        {
                            let output: Val<::uuid::Uuid> = ::uuid::Uuid::from_bytes(
                                    bytes,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a UUID using the supplied bytes.\n # Examples\n Basic usage:\n ```\n # fn main() -> Result<(), uuid::Error> {\n # use uuid::Uuid;\n let bytes = [\n     0xa1, 0xa2, 0xa3, 0xa4,\n     0xb1, 0xb2,\n     0xc1, 0xc2,\n     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n ];\n let uuid = Uuid::from_bytes(bytes);\n assert_eq!(\n     uuid.hyphenated().to_string(),\n     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\"\n );\n # Ok(())\n # }\n ```",
                &["bytes"],
            )
            .register_documented(
                "from_bytes_le",
                |b: [u8; 16]| {
                    let output: Val<::uuid::Uuid> = {
                        {
                            let output: Val<::uuid::Uuid> = ::uuid::Uuid::from_bytes_le(
                                    b,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a UUID using the supplied bytes in little endian order.\n The individual fields encoded in the buffer will be flipped.\n # Examples\n Basic usage:\n ```\n # fn main() -> Result<(), uuid::Error> {\n # use uuid::Uuid;\n let bytes = [\n     0xa1, 0xa2, 0xa3, 0xa4,\n     0xb1, 0xb2,\n     0xc1, 0xc2,\n     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n ];\n let uuid = Uuid::from_bytes_le(bytes);\n assert_eq!(\n     \"a4a3a2a1-b2b1-c2c1-d1d2-d3d4d5d6d7d8\",\n     uuid.hyphenated().to_string(),\n );\n # Ok(())\n # }\n ```",
                &["b"],
            )
            .register_documented(
                "from_u128",
                |v: u128| {
                    let output: Val<::uuid::Uuid> = {
                        {
                            let output: Val<::uuid::Uuid> = ::uuid::Uuid::from_u128(v)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a UUID from a 128bit value.\n # Examples\n Basic usage:\n ```\n # use uuid::Uuid;\n let v = 0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8u128;\n let uuid = Uuid::from_u128(v);\n assert_eq!(\n     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\",\n     uuid.hyphenated().to_string(),\n );\n ```",
                &["v"],
            )
            .register_documented(
                "from_u128_le",
                |v: u128| {
                    let output: Val<::uuid::Uuid> = {
                        {
                            let output: Val<::uuid::Uuid> = ::uuid::Uuid::from_u128_le(v)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a UUID from a 128bit value in little-endian order.\n The entire value will be flipped to convert into big-endian order.\n This is based on the endianness of the UUID, rather than the target\n environment so bytes will be flipped on both big and little endian\n machines.\n # Examples\n Basic usage:\n ```\n # use uuid::Uuid;\n let v = 0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8u128;\n let uuid = Uuid::from_u128_le(v);\n assert_eq!(\n     \"d8d7d6d5-d4d3-d2d1-c2c1-b2b1a4a3a2a1\",\n     uuid.hyphenated().to_string(),\n );\n ```",
                &["v"],
            )
            .register_documented(
                "from_u64_pair",
                |high_bits: u64, low_bits: u64| {
                    let output: Val<::uuid::Uuid> = {
                        {
                            let output: Val<::uuid::Uuid> = ::uuid::Uuid::from_u64_pair(
                                    high_bits,
                                    low_bits,
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a UUID from two 64bit values.\n # Examples\n Basic usage:\n ```\n # use uuid::Uuid;\n let hi = 0xa1a2a3a4b1b2c1c2u64;\n let lo = 0xd1d2d3d4d5d6d7d8u64;\n let uuid = Uuid::from_u64_pair(hi, lo);\n assert_eq!(\n     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\",\n     uuid.hyphenated().to_string(),\n );\n ```",
                &["high_bits", "low_bits"],
            )
            .register_documented(
                "get_node_id",
                |_self: Ref<::uuid::Uuid>| {
                    let output: bevy::reflect::erased_serde::__private::serde::__private::Option<
                        [u8; 6],
                    > = {
                        {
                            let output: bevy::reflect::erased_serde::__private::serde::__private::Option<
                                [u8; 6],
                            > = ::uuid::Uuid::get_node_id(&_self).into();
                            output
                        }
                    };
                    output
                },
                " If the UUID is the correct version (v1, or v6) this will return the\n node value as a 6-byte array. For other versions this will return `None`.",
                &["_self"],
            )
            .register_documented(
                "get_version_num",
                |_self: Ref<::uuid::Uuid>| {
                    let output: usize = {
                        {
                            let output: usize = ::uuid::Uuid::get_version_num(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the version number of the UUID.\n This represents the algorithm used to generate the value.\n This method is the future-proof alternative to [`Uuid::get_version`].\n # Examples\n Basic usage:\n ```\n # use uuid::Uuid;\n # fn main() -> Result<(), uuid::Error> {\n let my_uuid = Uuid::parse_str(\"02f09a3f-1624-3b1d-8409-44eff7708208\")?;\n assert_eq!(3, my_uuid.get_version_num());\n # Ok(())\n # }\n ```\n # References\n * [Version Field in RFC 9562](https://www.ietf.org/rfc/rfc9562.html#section-4.2)",
                &["_self"],
            )
            .register_documented(
                "into_bytes",
                |_self: Val<::uuid::Uuid>| {
                    let output: [u8; 16] = {
                        {
                            let output: [u8; 16] = ::uuid::Uuid::into_bytes(
                                    _self.into_inner(),
                                )
                                .into();
                            output
                        }
                    };
                    output
                },
                " Consumes self and returns the underlying byte value of the UUID.\n # Examples\n ```\n # use uuid::Uuid;\n let bytes = [\n     0xa1, 0xa2, 0xa3, 0xa4,\n     0xb1, 0xb2,\n     0xc1, 0xc2,\n     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n ];\n let uuid = Uuid::from_bytes(bytes);\n assert_eq!(bytes, uuid.into_bytes());\n ```",
                &["_self"],
            )
            .register_documented(
                "is_max",
                |_self: Ref<::uuid::Uuid>| {
                    let output: bool = {
                        {
                            let output: bool = ::uuid::Uuid::is_max(&_self).into();
                            output
                        }
                    };
                    output
                },
                " Tests if the UUID is max (all ones).",
                &["_self"],
            )
            .register_documented(
                "is_nil",
                |_self: Ref<::uuid::Uuid>| {
                    let output: bool = {
                        {
                            let output: bool = ::uuid::Uuid::is_nil(&_self).into();
                            output
                        }
                    };
                    output
                },
                " Tests if the UUID is nil (all zeros).",
                &["_self"],
            )
            .register_documented(
                "max",
                || {
                    let output: Val<::uuid::Uuid> = {
                        {
                            let output: Val<::uuid::Uuid> = ::uuid::Uuid::max().into();
                            output
                        }
                    };
                    output
                },
                " The 'max UUID' (all ones).\n The max UUID is a special form of UUID that is specified to have all\n 128 bits set to one.\n # References\n * [Max UUID in RFC 9562](https://www.ietf.org/rfc/rfc9562.html#section-5.10)\n # Examples\n Basic usage:\n ```\n # use uuid::Uuid;\n let uuid = Uuid::max();\n assert_eq!(\n     \"ffffffff-ffff-ffff-ffff-ffffffffffff\",\n     uuid.hyphenated().to_string(),\n );\n ```",
                &[],
            )
            .register_documented(
                "new_v4",
                || {
                    let output: Val<::uuid::Uuid> = {
                        {
                            let output: Val<::uuid::Uuid> = ::uuid::Uuid::new_v4()
                                .into();
                            output
                        }
                    };
                    output
                },
                " Creates a random UUID.\n This uses the [`getrandom`] crate to utilise the operating system's RNG\n as the source of random numbers. If you'd like to use a custom\n generator, don't use this method: generate random bytes using your\n custom generator and pass them to the\n [`uuid::Builder::from_random_bytes`][from_random_bytes] function\n instead.\n Note that usage of this method requires the `v4` feature of this crate\n to be enabled.\n # Examples\n Basic usage:\n ```\n # use uuid::{Uuid, Version};\n let uuid = Uuid::new_v4();\n assert_eq!(Some(Version::Random), uuid.get_version());\n ```\n # References\n * [UUID Version 4 in RFC 9562](https://www.ietf.org/rfc/rfc9562.html#section-5.4)\n [`getrandom`]: https://crates.io/crates/getrandom\n [from_random_bytes]: struct.Builder.html#method.from_random_bytes",
                &[],
            )
            .register_documented(
                "nil",
                || {
                    let output: Val<::uuid::Uuid> = {
                        {
                            let output: Val<::uuid::Uuid> = ::uuid::Uuid::nil().into();
                            output
                        }
                    };
                    output
                },
                " The 'nil UUID' (all zeros).\n The nil UUID is a special form of UUID that is specified to have all\n 128 bits set to zero.\n # References\n * [Nil UUID in RFC 9562](https://www.ietf.org/rfc/rfc9562.html#section-5.9)\n # Examples\n Basic usage:\n ```\n # use uuid::Uuid;\n let uuid = Uuid::nil();\n assert_eq!(\n     \"00000000-0000-0000-0000-000000000000\",\n     uuid.hyphenated().to_string(),\n );\n ```",
                &[],
            )
            .register_documented(
                "to_bytes_le",
                |_self: Ref<::uuid::Uuid>| {
                    let output: [u8; 16] = {
                        {
                            let output: [u8; 16] = ::uuid::Uuid::to_bytes_le(&_self)
                                .into();
                            output
                        }
                    };
                    output
                },
                " Returns the bytes of the UUID in little-endian order.\n The bytes will be flipped to convert into little-endian order. This is\n based on the endianness of the UUID, rather than the target environment\n so bytes will be flipped on both big and little endian machines.\n # Examples\n ```\n use uuid::Uuid;\n # fn main() -> Result<(), uuid::Error> {\n let uuid = Uuid::parse_str(\"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\")?;\n assert_eq!(\n     uuid.to_bytes_le(),\n     ([\n         0xa4, 0xa3, 0xa2, 0xa1, 0xb2, 0xb1, 0xc2, 0xc1, 0xd1, 0xd2,\n         0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8\n     ])\n );\n # Ok(())\n # }\n ```",
                &["_self"],
            )
            .register_documented(
                "to_u128_le",
                |_self: Ref<::uuid::Uuid>| {
                    let output: u128 = {
                        {
                            let output: u128 = ::uuid::Uuid::to_u128_le(&_self).into();
                            output
                        }
                    };
                    output
                },
                " Returns a 128bit little-endian value containing the value.\n The bytes in the `u128` will be flipped to convert into big-endian\n order. This is based on the endianness of the UUID, rather than the\n target environment so bytes will be flipped on both big and little\n endian machines.\n Note that this will produce a different result than\n [`Uuid::to_fields_le`], because the entire UUID is reversed, rather\n than reversing the individual fields in-place.\n # Examples\n ```\n # use uuid::Uuid;\n # fn main() -> Result<(), uuid::Error> {\n let uuid = Uuid::parse_str(\"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\")?;\n assert_eq!(\n     uuid.to_u128_le(),\n     0xd8d7d6d5d4d3d2d1c2c1b2b1a4a3a2a1,\n );\n # Ok(())\n # }\n ```",
                &["_self"],
            );
        let registry = world
            .get_resource_or_init::<bevy::ecs::reflect::AppTypeRegistry>();
        let mut registry = registry.write();
        registry
            .register_type_data::<
                ::uuid::Uuid,
                bevy_mod_scripting_core::bindings::MarkAsGenerated,
            >();
    }
    impl ::bevy::app::Plugin for BevyReflectScriptingPlugin {
        fn build(&self, app: &mut ::bevy::prelude::App) {
            let mut world = app.world_mut();
            register_atomic_bool_functions(&mut world);
            register_atomic_i_16_functions(&mut world);
            register_atomic_i_32_functions(&mut world);
            register_atomic_i_64_functions(&mut world);
            register_atomic_i_8_functions(&mut world);
            register_atomic_isize_functions(&mut world);
            register_atomic_u_16_functions(&mut world);
            register_atomic_u_32_functions(&mut world);
            register_atomic_u_64_functions(&mut world);
            register_atomic_u_8_functions(&mut world);
            register_atomic_usize_functions(&mut world);
            register_duration_functions(&mut world);
            register_instant_functions(&mut world);
            register_range_full_functions(&mut world);
            register_type_id_functions(&mut world);
            register_quat_functions(&mut world);
            register_vec_3_functions(&mut world);
            register_socket_addr_functions(&mut world);
            register_i_vec_2_functions(&mut world);
            register_i_vec_3_functions(&mut world);
            register_i_vec_4_functions(&mut world);
            register_i_8_vec_2_functions(&mut world);
            register_i_8_vec_3_functions(&mut world);
            register_i_8_vec_4_functions(&mut world);
            register_i_16_vec_2_functions(&mut world);
            register_i_16_vec_3_functions(&mut world);
            register_i_16_vec_4_functions(&mut world);
            register_i_64_vec_2_functions(&mut world);
            register_i_64_vec_3_functions(&mut world);
            register_i_64_vec_4_functions(&mut world);
            register_u_vec_2_functions(&mut world);
            register_u_vec_3_functions(&mut world);
            register_u_vec_4_functions(&mut world);
            register_u_8_vec_2_functions(&mut world);
            register_u_8_vec_3_functions(&mut world);
            register_u_8_vec_4_functions(&mut world);
            register_u_16_vec_2_functions(&mut world);
            register_u_16_vec_3_functions(&mut world);
            register_u_16_vec_4_functions(&mut world);
            register_u_64_vec_2_functions(&mut world);
            register_u_64_vec_3_functions(&mut world);
            register_u_64_vec_4_functions(&mut world);
            register_vec_2_functions(&mut world);
            register_vec_3_a_functions(&mut world);
            register_vec_4_functions(&mut world);
            register_b_vec_2_functions(&mut world);
            register_b_vec_3_functions(&mut world);
            register_b_vec_4_functions(&mut world);
            register_d_vec_2_functions(&mut world);
            register_d_vec_3_functions(&mut world);
            register_d_vec_4_functions(&mut world);
            register_mat_2_functions(&mut world);
            register_mat_3_functions(&mut world);
            register_mat_3_a_functions(&mut world);
            register_mat_4_functions(&mut world);
            register_d_mat_2_functions(&mut world);
            register_d_mat_3_functions(&mut world);
            register_d_mat_4_functions(&mut world);
            register_affine_2_functions(&mut world);
            register_affine_3_a_functions(&mut world);
            register_d_affine_2_functions(&mut world);
            register_d_affine_3_functions(&mut world);
            register_d_quat_functions(&mut world);
            register_euler_rot_functions(&mut world);
            register_b_vec_3_a_functions(&mut world);
            register_b_vec_4_a_functions(&mut world);
            register_smol_str_functions(&mut world);
            register_uuid_functions(&mut world);
        }
    }