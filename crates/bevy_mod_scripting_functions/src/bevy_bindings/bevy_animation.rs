// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use bevy_mod_scripting_core::{
    bindings::{
        ReflectReference, 
        function::{from::{Ref, Mut, Val}, namespace::{NamespaceBuilder}}
    }
};

use bevy_mod_scripting_derive::script_bindings;


use crate::*;







pub struct BevyAnimationScriptingPlugin;


#[script_bindings(
    remote,
    name = "animation_node_type_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::animation::graph::AnimationNodeType {


    
    fn clone (_self:Ref<bevy::animation::graph::AnimationNodeType>,) -> Val<bevy::animation::graph::AnimationNodeType> {
        let output: Val<bevy::animation::graph::AnimationNodeType> =<bevy::animation::graph::AnimationNodeType as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "animation_graph_handle_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::animation::graph::AnimationGraphHandle {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::animation::graph::AnimationGraphHandle>,) -> () {
        let output: () =<bevy::animation::graph::AnimationGraphHandle as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::animation::graph::AnimationGraphHandle>,) -> Val<bevy::animation::graph::AnimationGraphHandle> {
        let output: Val<bevy::animation::graph::AnimationGraphHandle> =<bevy::animation::graph::AnimationGraphHandle as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::animation::graph::AnimationGraphHandle>,other:Ref<bevy::animation::graph::AnimationGraphHandle>,) -> bool {
        let output: bool =<bevy::animation::graph::AnimationGraphHandle as ::std::cmp::PartialEq::<bevy::animation::graph::AnimationGraphHandle>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "threaded_animation_graphs_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::animation::graph::ThreadedAnimationGraphs {
     
}

#[script_bindings(
    remote,
    name = "animation_clip_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::animation::prelude::AnimationClip {


    
    fn clone (_self:Ref<bevy::animation::prelude::AnimationClip>,) -> Val<bevy::animation::prelude::AnimationClip> {
        let output: Val<bevy::animation::prelude::AnimationClip> =<bevy::animation::prelude::AnimationClip as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Duration of the clip, represented in seconds.
    
    fn duration (_self:Ref<bevy::animation::prelude::AnimationClip>,) -> f32 {
        let output: f32 =bevy::animation::prelude::AnimationClip::duration(&_self,).into();
        output
    }


    
    ///  Set the duration of the clip in seconds.
    
    fn set_duration (mut _self:Mut<bevy::animation::prelude::AnimationClip>,duration_sec:f32,) -> () {
        let output: () =bevy::animation::prelude::AnimationClip::set_duration(&mut _self,duration_sec,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "animation_player_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::animation::prelude::AnimationPlayer {


    
    ///  Check if all playing animations have finished, according to the repetition behavior.
    
    fn all_finished (_self:Ref<bevy::animation::prelude::AnimationPlayer>,) -> bool {
        let output: bool =bevy::animation::prelude::AnimationPlayer::all_finished(&_self,).into();
        output
    }


    
    ///  Check if all playing animations are paused.
    
    fn all_paused (_self:Ref<bevy::animation::prelude::AnimationPlayer>,) -> bool {
        let output: bool =bevy::animation::prelude::AnimationPlayer::all_paused(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::animation::prelude::AnimationPlayer>,) -> Val<bevy::animation::prelude::AnimationPlayer> {
        let output: Val<bevy::animation::prelude::AnimationPlayer> =<bevy::animation::prelude::AnimationPlayer as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn clone_from (mut _self:Mut<bevy::animation::prelude::AnimationPlayer>,source:Ref<bevy::animation::prelude::AnimationPlayer>,) -> () {
        let output: () =<bevy::animation::prelude::AnimationPlayer as ::std::clone::Clone>::clone_from(&mut _self,&source,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "animation_graph_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::animation::graph::AnimationGraph {


    
    ///  Adds an animation target (bone) to the mask group with the given ID.
    
    ///  Calling this method multiple times with the same animation target but
    
    ///  different mask groups will result in that target being added to all of
    
    ///  the specified groups.
    
    fn add_target_to_mask_group (mut _self:Mut<bevy::animation::graph::AnimationGraph>,target:Val<bevy::animation::AnimationTargetId>,mask_group:u32,) -> () {
        let output: () =bevy::animation::graph::AnimationGraph::add_target_to_mask_group(&mut _self,target.into_inner(),mask_group,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::animation::graph::AnimationGraph>,) -> Val<bevy::animation::graph::AnimationGraph> {
        let output: Val<bevy::animation::graph::AnimationGraph> =<bevy::animation::graph::AnimationGraph as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new animation graph with a root node and no other nodes.
    
    fn new () -> Val<bevy::animation::graph::AnimationGraph> {
        let output: Val<bevy::animation::graph::AnimationGraph> =bevy::animation::graph::AnimationGraph::new().into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "animation_transitions_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::animation::transition::AnimationTransitions {


    
    fn clone (_self:Ref<bevy::animation::transition::AnimationTransitions>,) -> Val<bevy::animation::transition::AnimationTransitions> {
        let output: Val<bevy::animation::transition::AnimationTransitions> =<bevy::animation::transition::AnimationTransitions as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn clone_from (mut _self:Mut<bevy::animation::transition::AnimationTransitions>,source:Ref<bevy::animation::transition::AnimationTransitions>,) -> () {
        let output: () =<bevy::animation::transition::AnimationTransitions as ::std::clone::Clone>::clone_from(&mut _self,&source,).into();
        output
    }


    
    ///  Creates a new [`AnimationTransitions`] component, ready to be added to
    
    ///  an entity with an [`AnimationPlayer`].
    
    fn new () -> Val<bevy::animation::transition::AnimationTransitions> {
        let output: Val<bevy::animation::transition::AnimationTransitions> =bevy::animation::transition::AnimationTransitions::new().into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "animation_target_id_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::animation::AnimationTargetId {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::animation::AnimationTargetId>,) -> () {
        let output: () =<bevy::animation::AnimationTargetId as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::animation::AnimationTargetId>,) -> Val<bevy::animation::AnimationTargetId> {
        let output: Val<bevy::animation::AnimationTargetId> =<bevy::animation::AnimationTargetId as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::animation::AnimationTargetId>,other:Ref<bevy::animation::AnimationTargetId>,) -> bool {
        let output: bool =<bevy::animation::AnimationTargetId as ::std::cmp::PartialEq::<bevy::animation::AnimationTargetId>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Creates a new [`AnimationTargetId`] by hashing a single name.
    
    fn from_name (name:Ref<bevy::ecs::name::Name>,) -> Val<bevy::animation::AnimationTargetId> {
        let output: Val<bevy::animation::AnimationTargetId> =bevy::animation::AnimationTargetId::from_name(&name,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "animation_target_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::animation::AnimationTarget {


    
    fn clone (_self:Ref<bevy::animation::AnimationTarget>,) -> Val<bevy::animation::AnimationTarget> {
        let output: Val<bevy::animation::AnimationTarget> =<bevy::animation::AnimationTarget as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "repeat_animation_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::animation::RepeatAnimation {


    
    fn assert_receiver_is_total_eq (_self:Ref<bevy::animation::RepeatAnimation>,) -> () {
        let output: () =<bevy::animation::RepeatAnimation as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self:Ref<bevy::animation::RepeatAnimation>,) -> Val<bevy::animation::RepeatAnimation> {
        let output: Val<bevy::animation::RepeatAnimation> =<bevy::animation::RepeatAnimation as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self:Ref<bevy::animation::RepeatAnimation>,other:Ref<bevy::animation::RepeatAnimation>,) -> bool {
        let output: bool =<bevy::animation::RepeatAnimation as ::std::cmp::PartialEq::<bevy::animation::RepeatAnimation>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "active_animation_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::animation::ActiveAnimation {


    
    fn clone (_self:Ref<bevy::animation::ActiveAnimation>,) -> Val<bevy::animation::ActiveAnimation> {
        let output: Val<bevy::animation::ActiveAnimation> =<bevy::animation::ActiveAnimation as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Returns the number of times this animation has completed.
    
    fn completions (_self:Ref<bevy::animation::ActiveAnimation>,) -> u32 {
        let output: u32 =bevy::animation::ActiveAnimation::completions(&_self,).into();
        output
    }


    
    ///  Returns the amount of time the animation has been playing.
    
    fn elapsed (_self:Ref<bevy::animation::ActiveAnimation>,) -> f32 {
        let output: f32 =bevy::animation::ActiveAnimation::elapsed(&_self,).into();
        output
    }


    
    ///  Check if the animation has finished, based on its repetition behavior and the number of times it has repeated.
    
    ///  Note: An animation with `RepeatAnimation::Forever` will never finish.
    
    fn is_finished (_self:Ref<bevy::animation::ActiveAnimation>,) -> bool {
        let output: bool =bevy::animation::ActiveAnimation::is_finished(&_self,).into();
        output
    }


    
    ///  Returns true if this animation is currently paused.
    
    ///  Note that paused animations are still [`ActiveAnimation`]s.
    
    fn is_paused (_self:Ref<bevy::animation::ActiveAnimation>,) -> bool {
        let output: bool =bevy::animation::ActiveAnimation::is_paused(&_self,).into();
        output
    }


    
    ///  Returns true if the animation is playing in reverse.
    
    fn is_playback_reversed (_self:Ref<bevy::animation::ActiveAnimation>,) -> bool {
        let output: bool =bevy::animation::ActiveAnimation::is_playback_reversed(&_self,).into();
        output
    }


    
    ///  Returns the repeat mode assigned to this active animation.
    
    fn repeat_mode (_self:Ref<bevy::animation::ActiveAnimation>,) -> Val<bevy::animation::RepeatAnimation> {
        let output: Val<bevy::animation::RepeatAnimation> =bevy::animation::ActiveAnimation::repeat_mode(&_self,).into();
        output
    }


    
    ///  Reset back to the initial state as if no time has elapsed.
    
    fn replay (mut _self:Mut<bevy::animation::ActiveAnimation>,) -> () {
        let output: () =bevy::animation::ActiveAnimation::replay(&mut _self,).into();
        output
    }


    
    ///  Returns the seek time of the animation.
    
    ///  This is nonnegative and no more than the clip duration.
    
    fn seek_time (_self:Ref<bevy::animation::ActiveAnimation>,) -> f32 {
        let output: f32 =bevy::animation::ActiveAnimation::seek_time(&_self,).into();
        output
    }


    
    ///  Returns the speed of the animation playback.
    
    fn speed (_self:Ref<bevy::animation::ActiveAnimation>,) -> f32 {
        let output: f32 =bevy::animation::ActiveAnimation::speed(&_self,).into();
        output
    }


    
    ///  Returns the current weight of this animation.
    
    fn weight (_self:Ref<bevy::animation::ActiveAnimation>,) -> f32 {
        let output: f32 =bevy::animation::ActiveAnimation::weight(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "weights_curve_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::animation::gltf_curves::WeightsCurve {


    
    fn clone (_self:Ref<bevy::animation::gltf_curves::WeightsCurve>,) -> Val<bevy::animation::gltf_curves::WeightsCurve> {
        let output: Val<bevy::animation::gltf_curves::WeightsCurve> =<bevy::animation::gltf_curves::WeightsCurve as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cubic_rotation_curve_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::animation::gltf_curves::CubicRotationCurve {


    
    fn clone (_self:Ref<bevy::animation::gltf_curves::CubicRotationCurve>,) -> Val<bevy::animation::gltf_curves::CubicRotationCurve> {
        let output: Val<bevy::animation::gltf_curves::CubicRotationCurve> =<bevy::animation::gltf_curves::CubicRotationCurve as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "animation_graph_node_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::animation::graph::AnimationGraphNode {


    
    fn clone (_self:Ref<bevy::animation::graph::AnimationGraphNode>,) -> Val<bevy::animation::graph::AnimationGraphNode> {
        let output: Val<bevy::animation::graph::AnimationGraphNode> =<bevy::animation::graph::AnimationGraphNode as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "threaded_animation_graph_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::animation::graph::ThreadedAnimationGraph {
     
}

#[script_bindings(
    remote,
    name = "animation_transition_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl bevy::animation::transition::AnimationTransition {


    
    fn clone (_self:Ref<bevy::animation::transition::AnimationTransition>,) -> Val<bevy::animation::transition::AnimationTransition> {
        let output: Val<bevy::animation::transition::AnimationTransition> =<bevy::animation::transition::AnimationTransition as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}


impl ::bevy::app::Plugin for BevyAnimationScriptingPlugin {
    fn build(&self, app: &mut ::bevy::prelude::App) {
        let mut world = app.world_mut();

        
            register_animation_node_type_functions(&mut world);
        
            register_animation_graph_handle_functions(&mut world);
        
            register_threaded_animation_graphs_functions(&mut world);
        
            register_animation_clip_functions(&mut world);
        
            register_animation_player_functions(&mut world);
        
            register_animation_graph_functions(&mut world);
        
            register_animation_transitions_functions(&mut world);
        
            register_animation_target_id_functions(&mut world);
        
            register_animation_target_functions(&mut world);
        
            register_repeat_animation_functions(&mut world);
        
            register_active_animation_functions(&mut world);
        
            register_weights_curve_functions(&mut world);
        
            register_cubic_rotation_curve_functions(&mut world);
        
            register_animation_graph_node_functions(&mut world);
        
            register_threaded_animation_graph_functions(&mut world);
        
            register_animation_transition_functions(&mut world);
        
    }
}
