// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use bevy_mod_scripting_core::{
    bindings::{
        ReflectReference, 
        function::{from::{Ref, Mut, Val}, namespace::{NamespaceBuilder}}
    }
};
use bevy_ecs::{prelude::*};


use bevy_mod_scripting_derive::script_bindings;


use crate::*;







pub struct BevyAnimationScriptingPlugin;


#[script_bindings(
    remote,
    name = "animation_node_type_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_animation::graph::AnimationNodeType {


    
    fn clone (_self: Ref<::bevy_animation::graph::AnimationNodeType>,) -> Val<::bevy_animation::graph::AnimationNodeType> {
        let output: Val<::bevy_animation::graph::AnimationNodeType> =<::bevy_animation::graph::AnimationNodeType as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "animation_graph_handle_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_animation::graph::AnimationGraphHandle {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_animation::graph::AnimationGraphHandle>,) -> () {
        let output: () =<::bevy_animation::graph::AnimationGraphHandle as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_animation::graph::AnimationGraphHandle>,) -> Val<::bevy_animation::graph::AnimationGraphHandle> {
        let output: Val<::bevy_animation::graph::AnimationGraphHandle> =<::bevy_animation::graph::AnimationGraphHandle as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_animation::graph::AnimationGraphHandle>,other: Ref<::bevy_animation::graph::AnimationGraphHandle>,) -> bool {
        let output: bool =<::bevy_animation::graph::AnimationGraphHandle as ::std::cmp::PartialEq::<::bevy_animation::graph::AnimationGraphHandle>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "threaded_animation_graphs_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_animation::graph::ThreadedAnimationGraphs {
     
}

#[script_bindings(
    remote,
    name = "animation_clip_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_animation::prelude::AnimationClip {


    
    fn clone (_self: Ref<::bevy_animation::prelude::AnimationClip>,) -> Val<::bevy_animation::prelude::AnimationClip> {
        let output: Val<::bevy_animation::prelude::AnimationClip> =<::bevy_animation::prelude::AnimationClip as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Duration of the clip, represented in seconds.
    
    fn duration (_self: Ref<::bevy_animation::prelude::AnimationClip>,) -> f32 {
        let output: f32 =::bevy_animation::prelude::AnimationClip::duration(&_self,).into();
        output
    }


    
    ///  Set the duration of the clip in seconds.
    
    fn set_duration (mut _self: Mut<::bevy_animation::prelude::AnimationClip>,duration_sec: f32,) -> () {
        let output: () =::bevy_animation::prelude::AnimationClip::set_duration(&mut _self,duration_sec,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "animation_player_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_animation::prelude::AnimationPlayer {


    
    ///  Check if all playing animations have finished, according to the repetition behavior.
    
    fn all_finished (_self: Ref<::bevy_animation::prelude::AnimationPlayer>,) -> bool {
        let output: bool =::bevy_animation::prelude::AnimationPlayer::all_finished(&_self,).into();
        output
    }


    
    ///  Check if all playing animations are paused.
    
    fn all_paused (_self: Ref<::bevy_animation::prelude::AnimationPlayer>,) -> bool {
        let output: bool =::bevy_animation::prelude::AnimationPlayer::all_paused(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_animation::prelude::AnimationPlayer>,) -> Val<::bevy_animation::prelude::AnimationPlayer> {
        let output: Val<::bevy_animation::prelude::AnimationPlayer> =<::bevy_animation::prelude::AnimationPlayer as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn clone_from (mut _self: Mut<::bevy_animation::prelude::AnimationPlayer>,source: Ref<::bevy_animation::prelude::AnimationPlayer>,) -> () {
        let output: () =<::bevy_animation::prelude::AnimationPlayer as ::std::clone::Clone>::clone_from(&mut _self,&source,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "animation_graph_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_animation::graph::AnimationGraph {


    
    ///  Adds an animation target (bone) to the mask group with the given ID.
    
    ///  Calling this method multiple times with the same animation target but
    
    ///  different mask groups will result in that target being added to all of
    
    ///  the specified groups.
    
    fn add_target_to_mask_group (mut _self: Mut<::bevy_animation::graph::AnimationGraph>,target: Val<::bevy_animation::AnimationTargetId>,mask_group: u32,) -> () {
        let output: () =::bevy_animation::graph::AnimationGraph::add_target_to_mask_group(&mut _self,target.into_inner(),mask_group,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_animation::graph::AnimationGraph>,) -> Val<::bevy_animation::graph::AnimationGraph> {
        let output: Val<::bevy_animation::graph::AnimationGraph> =<::bevy_animation::graph::AnimationGraph as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Creates a new animation graph with a root node and no other nodes.
    
    fn new () -> Val<::bevy_animation::graph::AnimationGraph> {
        let output: Val<::bevy_animation::graph::AnimationGraph> =::bevy_animation::graph::AnimationGraph::new().into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "animation_transitions_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_animation::transition::AnimationTransitions {


    
    fn clone (_self: Ref<::bevy_animation::transition::AnimationTransitions>,) -> Val<::bevy_animation::transition::AnimationTransitions> {
        let output: Val<::bevy_animation::transition::AnimationTransitions> =<::bevy_animation::transition::AnimationTransitions as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn clone_from (mut _self: Mut<::bevy_animation::transition::AnimationTransitions>,source: Ref<::bevy_animation::transition::AnimationTransitions>,) -> () {
        let output: () =<::bevy_animation::transition::AnimationTransitions as ::std::clone::Clone>::clone_from(&mut _self,&source,).into();
        output
    }


    
    ///  Creates a new [`AnimationTransitions`] component, ready to be added to
    
    ///  an entity with an [`AnimationPlayer`].
    
    fn new () -> Val<::bevy_animation::transition::AnimationTransitions> {
        let output: Val<::bevy_animation::transition::AnimationTransitions> =::bevy_animation::transition::AnimationTransitions::new().into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "animation_target_id_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_animation::AnimationTargetId {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_animation::AnimationTargetId>,) -> () {
        let output: () =<::bevy_animation::AnimationTargetId as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_animation::AnimationTargetId>,) -> Val<::bevy_animation::AnimationTargetId> {
        let output: Val<::bevy_animation::AnimationTargetId> =<::bevy_animation::AnimationTargetId as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_animation::AnimationTargetId>,other: Ref<::bevy_animation::AnimationTargetId>,) -> bool {
        let output: bool =<::bevy_animation::AnimationTargetId as ::std::cmp::PartialEq::<::bevy_animation::AnimationTargetId>>::eq(&_self,&other,).into();
        output
    }


    
    ///  Creates a new [`AnimationTargetId`] by hashing a single name.
    
    fn from_name (name: Ref<::bevy_ecs::name::Name>,) -> Val<::bevy_animation::AnimationTargetId> {
        let output: Val<::bevy_animation::AnimationTargetId> =::bevy_animation::AnimationTargetId::from_name(&name,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "animation_target_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_animation::AnimationTarget {


    
    fn clone (_self: Ref<::bevy_animation::AnimationTarget>,) -> Val<::bevy_animation::AnimationTarget> {
        let output: Val<::bevy_animation::AnimationTarget> =<::bevy_animation::AnimationTarget as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "repeat_animation_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_animation::RepeatAnimation {


    
    fn assert_receiver_is_total_eq (_self: Ref<::bevy_animation::RepeatAnimation>,) -> () {
        let output: () =<::bevy_animation::RepeatAnimation as ::std::cmp::Eq>::assert_receiver_is_total_eq(&_self,).into();
        output
    }


    
    fn clone (_self: Ref<::bevy_animation::RepeatAnimation>,) -> Val<::bevy_animation::RepeatAnimation> {
        let output: Val<::bevy_animation::RepeatAnimation> =<::bevy_animation::RepeatAnimation as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    fn eq (_self: Ref<::bevy_animation::RepeatAnimation>,other: Ref<::bevy_animation::RepeatAnimation>,) -> bool {
        let output: bool =<::bevy_animation::RepeatAnimation as ::std::cmp::PartialEq::<::bevy_animation::RepeatAnimation>>::eq(&_self,&other,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "active_animation_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_animation::ActiveAnimation {


    
    fn clone (_self: Ref<::bevy_animation::ActiveAnimation>,) -> Val<::bevy_animation::ActiveAnimation> {
        let output: Val<::bevy_animation::ActiveAnimation> =<::bevy_animation::ActiveAnimation as ::std::clone::Clone>::clone(&_self,).into();
        output
    }


    
    ///  Returns the number of times this animation has completed.
    
    fn completions (_self: Ref<::bevy_animation::ActiveAnimation>,) -> u32 {
        let output: u32 =::bevy_animation::ActiveAnimation::completions(&_self,).into();
        output
    }


    
    ///  Returns the amount of time the animation has been playing.
    
    fn elapsed (_self: Ref<::bevy_animation::ActiveAnimation>,) -> f32 {
        let output: f32 =::bevy_animation::ActiveAnimation::elapsed(&_self,).into();
        output
    }


    
    ///  Check if the animation has finished, based on its repetition behavior and the number of times it has repeated.
    
    ///  Note: An animation with `RepeatAnimation::Forever` will never finish.
    
    fn is_finished (_self: Ref<::bevy_animation::ActiveAnimation>,) -> bool {
        let output: bool =::bevy_animation::ActiveAnimation::is_finished(&_self,).into();
        output
    }


    
    ///  Returns true if this animation is currently paused.
    
    ///  Note that paused animations are still [`ActiveAnimation`]s.
    
    fn is_paused (_self: Ref<::bevy_animation::ActiveAnimation>,) -> bool {
        let output: bool =::bevy_animation::ActiveAnimation::is_paused(&_self,).into();
        output
    }


    
    ///  Returns true if the animation is playing in reverse.
    
    fn is_playback_reversed (_self: Ref<::bevy_animation::ActiveAnimation>,) -> bool {
        let output: bool =::bevy_animation::ActiveAnimation::is_playback_reversed(&_self,).into();
        output
    }


    
    ///  Returns the repeat mode assigned to this active animation.
    
    fn repeat_mode (_self: Ref<::bevy_animation::ActiveAnimation>,) -> Val<::bevy_animation::RepeatAnimation> {
        let output: Val<::bevy_animation::RepeatAnimation> =::bevy_animation::ActiveAnimation::repeat_mode(&_self,).into();
        output
    }


    
    ///  Reset back to the initial state as if no time has elapsed.
    
    fn replay (mut _self: Mut<::bevy_animation::ActiveAnimation>,) -> () {
        let output: () =::bevy_animation::ActiveAnimation::replay(&mut _self,).into();
        output
    }


    
    ///  Returns the seek time of the animation.
    
    ///  This is nonnegative and no more than the clip duration.
    
    fn seek_time (_self: Ref<::bevy_animation::ActiveAnimation>,) -> f32 {
        let output: f32 =::bevy_animation::ActiveAnimation::seek_time(&_self,).into();
        output
    }


    
    ///  Returns the speed of the animation playback.
    
    fn speed (_self: Ref<::bevy_animation::ActiveAnimation>,) -> f32 {
        let output: f32 =::bevy_animation::ActiveAnimation::speed(&_self,).into();
        output
    }


    
    ///  Returns the current weight of this animation.
    
    fn weight (_self: Ref<::bevy_animation::ActiveAnimation>,) -> f32 {
        let output: f32 =::bevy_animation::ActiveAnimation::weight(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "weights_curve_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_animation::gltf_curves::WeightsCurve {


    
    fn clone (_self: Ref<::bevy_animation::gltf_curves::WeightsCurve>,) -> Val<::bevy_animation::gltf_curves::WeightsCurve> {
        let output: Val<::bevy_animation::gltf_curves::WeightsCurve> =<::bevy_animation::gltf_curves::WeightsCurve as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "cubic_rotation_curve_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_animation::gltf_curves::CubicRotationCurve {


    
    fn clone (_self: Ref<::bevy_animation::gltf_curves::CubicRotationCurve>,) -> Val<::bevy_animation::gltf_curves::CubicRotationCurve> {
        let output: Val<::bevy_animation::gltf_curves::CubicRotationCurve> =<::bevy_animation::gltf_curves::CubicRotationCurve as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "animation_graph_node_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_animation::graph::AnimationGraphNode {


    
    fn clone (_self: Ref<::bevy_animation::graph::AnimationGraphNode>,) -> Val<::bevy_animation::graph::AnimationGraphNode> {
        let output: Val<::bevy_animation::graph::AnimationGraphNode> =<::bevy_animation::graph::AnimationGraphNode as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}

#[script_bindings(
    remote,
    name = "threaded_animation_graph_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_animation::graph::ThreadedAnimationGraph {
     
}

#[script_bindings(
    remote,
    name = "animation_transition_functions",
    bms_core_path="bevy_mod_scripting_core",
    generated
)]
impl ::bevy_animation::transition::AnimationTransition {


    
    fn clone (_self: Ref<::bevy_animation::transition::AnimationTransition>,) -> Val<::bevy_animation::transition::AnimationTransition> {
        let output: Val<::bevy_animation::transition::AnimationTransition> =<::bevy_animation::transition::AnimationTransition as ::std::clone::Clone>::clone(&_self,).into();
        output
    }
     
}


impl Plugin for BevyAnimationScriptingPlugin {
    fn build(&self, app: &mut App) {
        let mut world = app.world_mut();

        
            register_animation_node_type_functions(&mut world);
        
            register_animation_graph_handle_functions(&mut world);
        
            register_threaded_animation_graphs_functions(&mut world);
        
            register_animation_clip_functions(&mut world);
        
            register_animation_player_functions(&mut world);
        
            register_animation_graph_functions(&mut world);
        
            register_animation_transitions_functions(&mut world);
        
            register_animation_target_id_functions(&mut world);
        
            register_animation_target_functions(&mut world);
        
            register_repeat_animation_functions(&mut world);
        
            register_active_animation_functions(&mut world);
        
            register_weights_curve_functions(&mut world);
        
            register_cubic_rotation_curve_functions(&mut world);
        
            register_animation_graph_node_functions(&mut world);
        
            register_threaded_animation_graph_functions(&mut world);
        
            register_animation_transition_functions(&mut world);
        
    }
}
