// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use super::bevy_ecs::*;
use super::bevy_reflect::*;
use super::bevy_math::*;
extern crate self as bevy_script_api;
use bevy_script_api::{
    lua::RegisterForeignLuaType, ReflectedValue, common::bevy::GetWorld,
};
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::prelude::CursorEntered",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::CursorEntered) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::prelude::CursorEntered;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct CursorEntered {
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::prelude::CursorIcon",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::prelude::CursorIcon;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &cursor::CursorIcon) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct CursorIcon {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::prelude::CursorLeft",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::CursorLeft) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::prelude::CursorLeft;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct CursorLeft {
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::prelude::CursorMoved",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::prelude::CursorMoved;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::CursorMoved) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct CursorMoved {
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
    #[lua(output(proxy))]
    position: bevy::math::Vec2,
    delta: ReflectedValue,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::prelude::FileDragAndDrop",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::prelude::FileDragAndDrop;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::FileDragAndDrop) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct FileDragAndDrop {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::prelude::Ime",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::Ime) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::prelude::Ime;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct Ime {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::prelude::MonitorSelection",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &window::MonitorSelection) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::prelude::MonitorSelection;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct MonitorSelection {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::prelude::ReceivedCharacter",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::prelude::ReceivedCharacter;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::ReceivedCharacter) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct ReceivedCharacter {
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
    #[lua(output(proxy))]
    char: smol_str::SmolStr,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::prelude::Window",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::prelude::Window;

"#,
    r#"
/// Setting to true will attempt to maximize the window.
/// Setting to false will attempt to un-maximize the window.

    #[lua(kind = "MutatingMethod")]
    fn set_maximized(&mut self, maximized: bool) -> ();

"#,
    r#"
/// Setting to true will attempt to minimize the window.
/// Setting to false will attempt to un-minimize the window.

    #[lua(kind = "MutatingMethod")]
    fn set_minimized(&mut self, minimized: bool) -> ();

"#,
    r#"
/// The window's client area width in logical pixels.
/// See [`WindowResolution`] for an explanation about logical/physical sizes.

    #[lua(kind = "Method")]
    fn width(&self) -> f32;

"#,
    r#"
/// The window's client area height in logical pixels.
/// See [`WindowResolution`] for an explanation about logical/physical sizes.

    #[lua(kind = "Method")]
    fn height(&self) -> f32;

"#,
    r#"
/// The window's client size in logical pixels
/// See [`WindowResolution`] for an explanation about logical/physical sizes.

    #[lua(kind = "Method", output(proxy))]
    fn size(&self) -> bevy::math::Vec2;

"#,
    r#"
/// The window's client area width in physical pixels.
/// See [`WindowResolution`] for an explanation about logical/physical sizes.

    #[lua(kind = "Method")]
    fn physical_width(&self) -> u32;

"#,
    r#"
/// The window's client area height in physical pixels.
/// See [`WindowResolution`] for an explanation about logical/physical sizes.

    #[lua(kind = "Method")]
    fn physical_height(&self) -> u32;

"#,
    r#"
/// The window's client size in physical pixels
/// See [`WindowResolution`] for an explanation about logical/physical sizes.

    #[lua(kind = "Method", output(proxy))]
    fn physical_size(&self) -> bevy::math::UVec2;

"#,
    r#"
/// The window's scale factor.
/// Ratio of physical size to logical size, see [`WindowResolution`].

    #[lua(kind = "Method")]
    fn scale_factor(&self) -> f32;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct Window {
    #[lua(output(proxy))]
    cursor: bevy::window::Cursor,
    #[lua(output(proxy))]
    present_mode: bevy::window::PresentMode,
    #[lua(output(proxy))]
    mode: bevy::window::WindowMode,
    #[lua(output(proxy))]
    position: bevy::window::prelude::WindowPosition,
    #[lua(output(proxy))]
    resolution: bevy::window::WindowResolution,
    title: std::string::String,
    name: std::option::Option<std::string::String>,
    #[lua(output(proxy))]
    composite_alpha_mode: bevy::window::CompositeAlphaMode,
    #[lua(output(proxy))]
    resize_constraints: bevy::window::prelude::WindowResizeConstraints,
    resizable: bool,
    #[lua(output(proxy))]
    enabled_buttons: bevy::window::EnabledButtons,
    decorations: bool,
    transparent: bool,
    focused: bool,
    #[lua(output(proxy))]
    window_level: bevy::window::WindowLevel,
    canvas: std::option::Option<std::string::String>,
    fit_canvas_to_parent: bool,
    prevent_default_event_handling: bool,
    #[lua(output(proxy))]
    internal: bevy::window::InternalWindowState,
    ime_enabled: bool,
    #[lua(output(proxy))]
    ime_position: bevy::math::Vec2,
    window_theme: ReflectedValue,
    visible: bool,
    skip_taskbar: bool,
    desired_maximum_frame_latency: ReflectedValue,
    recognize_pinch_gesture: bool,
    recognize_rotation_gesture: bool,
    recognize_doubletap_gesture: bool,
    recognize_pan_gesture: ReflectedValue,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::prelude::WindowMoved",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::WindowMoved) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::prelude::WindowMoved;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowMoved {
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
    #[lua(output(proxy))]
    position: bevy::math::IVec2,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::prelude::WindowPosition",
    functions[r#"
/// Creates a new [`WindowPosition`] at a position.

    #[lua(kind = "Function", output(proxy))]
    fn new(
        #[proxy]
        position: bevy::math::IVec2,
    ) -> bevy::window::prelude::WindowPosition;

"#,
    r#"
/// Set the position to a specific point.

    #[lua(kind = "MutatingMethod")]
    fn set(&mut self, #[proxy] position: bevy::math::IVec2) -> ();

"#,
    r#"
/// Set the window to a specific monitor.

    #[lua(kind = "MutatingMethod")]
    fn center(
        &mut self,
        #[proxy]
        monitor: bevy::window::prelude::MonitorSelection,
    ) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::prelude::WindowPosition;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &window::WindowPosition) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowPosition {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::prelude::WindowResizeConstraints",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &window::WindowResizeConstraints) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::prelude::WindowResizeConstraints;

"#,
    r#"
/// Checks if the constraints are valid.
/// Will output warnings if it isn't.

    #[lua(kind = "Method", output(proxy))]
    fn check_constraints(&self) -> bevy::window::prelude::WindowResizeConstraints;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowResizeConstraints {
    min_width: f32,
    min_height: f32,
    max_width: f32,
    max_height: f32,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::WindowResized",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::WindowResized) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::WindowResized;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowResized {
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
    width: f32,
    height: f32,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::WindowCreated",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::WindowCreated;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::WindowCreated) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowCreated {
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::WindowClosing",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::WindowClosing) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::WindowClosing;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowClosing {
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::WindowClosed",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::WindowClosed;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::WindowClosed) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowClosed {
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::WindowCloseRequested",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::WindowCloseRequested;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::WindowCloseRequested) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowCloseRequested {
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::WindowDestroyed",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::WindowDestroyed;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::WindowDestroyed) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowDestroyed {
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::RequestRedraw",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::RequestRedraw;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::RequestRedraw) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct RequestRedraw {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::WindowFocused",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::WindowFocused;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::WindowFocused) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowFocused {
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
    focused: bool,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::WindowOccluded",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::WindowOccluded;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::WindowOccluded) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowOccluded {
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
    occluded: bool,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::WindowScaleFactorChanged",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::WindowScaleFactorChanged;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::WindowScaleFactorChanged) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowScaleFactorChanged {
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
    scale_factor: f64,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::WindowBackendScaleFactorChanged",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::WindowBackendScaleFactorChanged;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::WindowBackendScaleFactorChanged) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowBackendScaleFactorChanged {
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
    scale_factor: f64,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::WindowThemeChanged",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::WindowThemeChanged) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::WindowThemeChanged;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowThemeChanged {
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
    #[lua(output(proxy))]
    theme: bevy::window::WindowTheme,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::AppLifecycle",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::AppLifecycle;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &event::AppLifecycle) -> bool;

"#,
    r#"
/// Return `true` if the app can be updated.

    #[lua(kind = "Method")]
    fn is_active(&self) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct AppLifecycle {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::PrimaryWindow",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &window::PrimaryWindow) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::PrimaryWindow;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct PrimaryWindow {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::WindowTheme",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::WindowTheme;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &window::WindowTheme) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowTheme {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::WindowRef",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::WindowRef;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowRef {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::NormalizedWindowRef",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
/// Fetch the entity of this window reference

    #[lua(kind = "Method", output(proxy))]
    fn entity(&self) -> bevy::ecs::entity::Entity;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &window::NormalizedWindowRef) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::NormalizedWindowRef;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct NormalizedWindowRef();
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::Cursor",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::Cursor;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct Cursor {
    #[lua(output(proxy))]
    icon: bevy::window::prelude::CursorIcon,
    visible: bool,
    #[lua(output(proxy))]
    grab_mode: bevy::window::CursorGrabMode,
    hit_test: bool,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::PresentMode",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &window::PresentMode) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::PresentMode;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct PresentMode {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::WindowMode",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::WindowMode;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &window::WindowMode) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowMode {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::WindowResolution",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::WindowResolution;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &window::WindowResolution) -> bool;

"#,
    r#"
/// Creates a new [`WindowResolution`].

    #[lua(kind = "Function", output(proxy))]
    fn new(physical_width: f32, physical_height: f32) -> bevy::window::WindowResolution;

"#,
    r#"
/// Builder method for adding a scale factor override to the resolution.

    #[lua(kind = "Method", output(proxy))]
    fn with_scale_factor_override(
        self,
        scale_factor_override: f32,
    ) -> bevy::window::WindowResolution;

"#,
    r#"
/// The window's client area width in logical pixels.

    #[lua(kind = "Method")]
    fn width(&self) -> f32;

"#,
    r#"
/// The window's client area height in logical pixels.

    #[lua(kind = "Method")]
    fn height(&self) -> f32;

"#,
    r#"
/// The window's client size in logical pixels

    #[lua(kind = "Method", output(proxy))]
    fn size(&self) -> bevy::math::Vec2;

"#,
    r#"
/// The window's client area width in physical pixels.

    #[lua(kind = "Method")]
    fn physical_width(&self) -> u32;

"#,
    r#"
/// The window's client area height in physical pixels.

    #[lua(kind = "Method")]
    fn physical_height(&self) -> u32;

"#,
    r#"
/// The window's client size in physical pixels

    #[lua(kind = "Method", output(proxy))]
    fn physical_size(&self) -> bevy::math::UVec2;

"#,
    r#"
/// The ratio of physical pixels to logical pixels.
/// `physical_pixels = logical_pixels * scale_factor`

    #[lua(kind = "Method")]
    fn scale_factor(&self) -> f32;

"#,
    r#"
/// The window scale factor as reported by the window backend.
/// This value is unaffected by [`WindowResolution::scale_factor_override`].

    #[lua(kind = "Method")]
    fn base_scale_factor(&self) -> f32;

"#,
    r#"
/// The scale factor set with [`WindowResolution::set_scale_factor_override`].
/// This value may be different from the scale factor reported by the window backend.

    #[lua(kind = "Method")]
    fn scale_factor_override(&self) -> std::option::Option<f32>;

"#,
    r#"
/// Set the window's logical resolution.

    #[lua(kind = "MutatingMethod")]
    fn set(&mut self, width: f32, height: f32) -> ();

"#,
    r#"
/// Set the window's physical resolution.
/// This will ignore the scale factor setting, so most of the time you should
/// prefer to use [`WindowResolution::set`].

    #[lua(kind = "MutatingMethod")]
    fn set_physical_resolution(&mut self, width: u32, height: u32) -> ();

"#,
    r#"
/// Set the window's scale factor, this may get overridden by the backend.

    #[lua(kind = "MutatingMethod")]
    fn set_scale_factor(&mut self, scale_factor: f32) -> ();

"#,
    r#"
/// Set the window's scale factor, and apply it to the currently known physical size.
/// This may get overridden by the backend. This is mostly useful on window creation,
/// so that the window is created with the expected size instead of waiting for a resize
/// event after its creation.

    #[lua(kind = "MutatingMethod")]
    fn set_scale_factor_and_apply_to_physical_size(&mut self, scale_factor: f32) -> ();

"#,
    r#"
/// Set the window's scale factor, this will be used over what the backend decides.
/// This can change the logical and physical sizes if the resulting physical
/// size is not within the limits.

    #[lua(kind = "MutatingMethod")]
    fn set_scale_factor_override(
        &mut self,
        scale_factor_override: std::option::Option<f32>,
    ) -> ();

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowResolution {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::CompositeAlphaMode",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::CompositeAlphaMode;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &window::CompositeAlphaMode) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct CompositeAlphaMode {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::EnabledButtons",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::EnabledButtons;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &window::EnabledButtons) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct EnabledButtons {
    minimize: bool,
    maximize: bool,
    close: bool,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::WindowLevel",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::WindowLevel;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &window::WindowLevel) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct WindowLevel {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::InternalWindowState",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::InternalWindowState;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &window::InternalWindowState) -> bool;

"#,
    r#"
/// Consumes the current maximize request, if it exists. This should only be called by window backends.

    #[lua(kind = "MutatingMethod")]
    fn take_maximize_request(&mut self) -> std::option::Option<bool>;

"#,
    r#"
/// Consumes the current minimize request, if it exists. This should only be called by window backends.

    #[lua(kind = "MutatingMethod")]
    fn take_minimize_request(&mut self) -> std::option::Option<bool>;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct InternalWindowState {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::window::CursorGrabMode",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::window::CursorGrabMode;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &window::CursorGrabMode) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct CursorGrabMode {}
#[derive(Default)]
pub(crate) struct Globals;
impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<
        'lua,
        T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>,
    >(self, instances: &mut T) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
        instances
            .add_instance(
                "WindowPosition",
                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<
                    LuaWindowPosition,
                >::new,
            )?;
        instances
            .add_instance(
                "WindowResolution",
                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<
                    LuaWindowResolution,
                >::new,
            )?;
        Ok(())
    }
}
pub struct BevyWindowAPIProvider;
impl bevy_mod_scripting_core::hosts::APIProvider for BevyWindowAPIProvider {
    type APITarget = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
    type ScriptContext = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
    type DocTarget = bevy_mod_scripting_lua::docs::LuaDocFragment;
    fn attach_api(
        &mut self,
        ctx: &mut Self::APITarget,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        let ctx = ctx.get_mut().expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| bevy_mod_scripting_core::error::ScriptError::Other(
                e.to_string(),
            ))
    }
    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(
            bevy_mod_scripting_lua::docs::LuaDocFragment::new(
                "BevyWindowAPI",
                |tw| {
                    tw.document_global_instance::<Globals>()
                        .expect("Something went wrong documenting globals")
                        .process_type::<LuaCursorEntered>()
                        .process_type::<LuaCursorIcon>()
                        .process_type::<LuaCursorLeft>()
                        .process_type::<LuaCursorMoved>()
                        .process_type::<LuaFileDragAndDrop>()
                        .process_type::<LuaIme>()
                        .process_type::<LuaMonitorSelection>()
                        .process_type::<LuaReceivedCharacter>()
                        .process_type::<LuaWindow>()
                        .process_type::<LuaWindowMoved>()
                        .process_type::<LuaWindowPosition>()
                        .process_type::<
                            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<
                                LuaWindowPosition,
                            >,
                        >()
                        .process_type::<LuaWindowResizeConstraints>()
                        .process_type::<LuaWindowResized>()
                        .process_type::<LuaWindowCreated>()
                        .process_type::<LuaWindowClosing>()
                        .process_type::<LuaWindowClosed>()
                        .process_type::<LuaWindowCloseRequested>()
                        .process_type::<LuaWindowDestroyed>()
                        .process_type::<LuaRequestRedraw>()
                        .process_type::<LuaWindowFocused>()
                        .process_type::<LuaWindowOccluded>()
                        .process_type::<LuaWindowScaleFactorChanged>()
                        .process_type::<LuaWindowBackendScaleFactorChanged>()
                        .process_type::<LuaWindowThemeChanged>()
                        .process_type::<LuaAppLifecycle>()
                        .process_type::<LuaPrimaryWindow>()
                        .process_type::<LuaWindowTheme>()
                        .process_type::<LuaWindowRef>()
                        .process_type::<LuaNormalizedWindowRef>()
                        .process_type::<LuaCursor>()
                        .process_type::<LuaPresentMode>()
                        .process_type::<LuaWindowMode>()
                        .process_type::<LuaWindowResolution>()
                        .process_type::<
                            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<
                                LuaWindowResolution,
                            >,
                        >()
                        .process_type::<LuaCompositeAlphaMode>()
                        .process_type::<LuaEnabledButtons>()
                        .process_type::<LuaWindowLevel>()
                        .process_type::<LuaInternalWindowState>()
                        .process_type::<LuaCursorGrabMode>()
                },
            ),
        )
    }
    fn setup_script(
        &mut self,
        script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }
    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }
    fn register_with_app(&self, app: &mut bevy::app::App) {
        app.register_foreign_lua_type::<bevy::window::prelude::CursorEntered>();
        app.register_foreign_lua_type::<bevy::window::prelude::CursorIcon>();
        app.register_foreign_lua_type::<bevy::window::prelude::CursorLeft>();
        app.register_foreign_lua_type::<bevy::window::prelude::CursorMoved>();
        app.register_foreign_lua_type::<bevy::window::prelude::FileDragAndDrop>();
        app.register_foreign_lua_type::<bevy::window::prelude::Ime>();
        app.register_foreign_lua_type::<bevy::window::prelude::MonitorSelection>();
        app.register_foreign_lua_type::<bevy::window::prelude::ReceivedCharacter>();
        app.register_foreign_lua_type::<bevy::window::prelude::Window>();
        app.register_foreign_lua_type::<bevy::window::prelude::WindowMoved>();
        app.register_foreign_lua_type::<bevy::window::prelude::WindowPosition>();
        app.register_foreign_lua_type::<
                bevy::window::prelude::WindowResizeConstraints,
            >();
        app.register_foreign_lua_type::<bevy::window::WindowResized>();
        app.register_foreign_lua_type::<bevy::window::WindowCreated>();
        app.register_foreign_lua_type::<bevy::window::WindowClosing>();
        app.register_foreign_lua_type::<bevy::window::WindowClosed>();
        app.register_foreign_lua_type::<bevy::window::WindowCloseRequested>();
        app.register_foreign_lua_type::<bevy::window::WindowDestroyed>();
        app.register_foreign_lua_type::<bevy::window::RequestRedraw>();
        app.register_foreign_lua_type::<bevy::window::WindowFocused>();
        app.register_foreign_lua_type::<bevy::window::WindowOccluded>();
        app.register_foreign_lua_type::<bevy::window::WindowScaleFactorChanged>();
        app.register_foreign_lua_type::<bevy::window::WindowBackendScaleFactorChanged>();
        app.register_foreign_lua_type::<bevy::window::WindowThemeChanged>();
        app.register_foreign_lua_type::<bevy::window::AppLifecycle>();
        app.register_foreign_lua_type::<bevy::window::PrimaryWindow>();
        app.register_foreign_lua_type::<bevy::window::WindowTheme>();
        app.register_foreign_lua_type::<bevy::window::WindowRef>();
        app.register_foreign_lua_type::<bevy::window::NormalizedWindowRef>();
        app.register_foreign_lua_type::<bevy::window::Cursor>();
        app.register_foreign_lua_type::<bevy::window::PresentMode>();
        app.register_foreign_lua_type::<bevy::window::WindowMode>();
        app.register_foreign_lua_type::<bevy::window::WindowResolution>();
        app.register_foreign_lua_type::<bevy::window::CompositeAlphaMode>();
        app.register_foreign_lua_type::<bevy::window::EnabledButtons>();
        app.register_foreign_lua_type::<bevy::window::WindowLevel>();
        app.register_foreign_lua_type::<bevy::window::InternalWindowState>();
        app.register_foreign_lua_type::<bevy::window::CursorGrabMode>();
    }
}
