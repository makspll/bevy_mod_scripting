// @generated by cargo bevy-api-gen generate, modify the templates not this file
#![allow(clippy::all)]
#![allow(unused, deprecated, dead_code)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use super::bevy_ecs::*;
use super::bevy_reflect::*;
use super::bevy_math::*;
extern crate self as bevy_script_api;
use bevy_script_api::{
    lua::RegisterForeignLuaType, ReflectedValue, common::bevy::GetWorld,
};
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(),
    remote = "bevy::input::gamepad::Gamepad",
    functions[r#"
/// Returns the USB vendor ID as assigned by the USB-IF, if available.

    #[lua(kind = "Method")]
    fn vendor_id(&self) -> std::option::Option<u16>;

"#,
    r#"
/// Returns the USB product ID as assigned by the [vendor], if available.
/// [vendor]: Self::vendor_id

    #[lua(kind = "Method")]
    fn product_id(&self) -> std::option::Option<u16>;

"#,
    r#"
/// Returns the left stick as a [`Vec2`]

    #[lua(kind = "Method", output(proxy))]
    fn left_stick(&self) -> bevy::math::Vec2;

"#,
    r#"
/// Returns the right stick as a [`Vec2`]

    #[lua(kind = "Method", output(proxy))]
    fn right_stick(&self) -> bevy::math::Vec2;

"#,
    r#"
/// Returns the directional pad as a [`Vec2`]

    #[lua(kind = "Method", output(proxy))]
    fn dpad(&self) -> bevy::math::Vec2;

"#,
    r#"
/// Returns `true` if the [`GamepadButton`] has been pressed.

    #[lua(kind = "Method")]
    fn pressed(&self, #[proxy] button_type: bevy::input::gamepad::GamepadButton) -> bool;

"#,
    r#"
/// Returns `true` if the [`GamepadButton`] has been pressed during the current frame.
/// Note: This function does not imply information regarding the current state of [`ButtonInput::pressed`] or [`ButtonInput::just_released`].

    #[lua(kind = "Method")]
    fn just_pressed(
        &self,
        #[proxy]
        button_type: bevy::input::gamepad::GamepadButton,
    ) -> bool;

"#,
    r#"
/// Returns `true` if the [`GamepadButton`] has been released during the current frame.
/// Note: This function does not imply information regarding the current state of [`ButtonInput::pressed`] or [`ButtonInput::just_pressed`].

    #[lua(kind = "Method")]
    fn just_released(
        &self,
        #[proxy]
        button_type: bevy::input::gamepad::GamepadButton,
    ) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct Gamepad {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::GamepadAxis",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::GamepadAxis;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gamepad::GamepadAxis) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct GamepadAxis {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::GamepadButton",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gamepad::GamepadButton) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::GamepadButton;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct GamepadButton {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::GamepadSettings",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::GamepadSettings;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct GamepadSettings {
    #[lua(output(proxy))]
    default_button_settings: bevy::input::gamepad::ButtonSettings,
    #[lua(output(proxy))]
    default_axis_settings: bevy::input::gamepad::AxisSettings,
    #[lua(output(proxy))]
    default_button_axis_settings: bevy::input::gamepad::ButtonAxisSettings,
    button_settings: ReflectedValue,
    axis_settings: ReflectedValue,
    button_axis_settings: ReflectedValue,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::keyboard::KeyCode",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::keyboard::KeyCode;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &keyboard::KeyCode) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct KeyCode {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::mouse::MouseButton",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::mouse::MouseButton;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &mouse::MouseButton) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct MouseButton {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::touch::TouchInput",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::touch::TouchInput;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &touch::TouchInput) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct TouchInput {
    #[lua(output(proxy))]
    phase: bevy::input::touch::TouchPhase,
    #[lua(output(proxy))]
    position: bevy::math::Vec2,
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
    force: ReflectedValue,
    id: u64,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::keyboard::KeyboardFocusLost",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::keyboard::KeyboardFocusLost;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &keyboard::KeyboardFocusLost) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct KeyboardFocusLost {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::keyboard::KeyboardInput",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::keyboard::KeyboardInput;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &keyboard::KeyboardInput) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct KeyboardInput {
    #[lua(output(proxy))]
    key_code: bevy::input::keyboard::KeyCode,
    #[lua(output(proxy))]
    logical_key: bevy::input::keyboard::Key,
    #[lua(output(proxy))]
    state: bevy::input::ButtonState,
    repeat: bool,
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::mouse::AccumulatedMouseMotion",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::mouse::AccumulatedMouseMotion;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &mouse::AccumulatedMouseMotion) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct AccumulatedMouseMotion {
    #[lua(output(proxy))]
    delta: bevy::math::Vec2,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::mouse::AccumulatedMouseScroll",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::mouse::AccumulatedMouseScroll;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &mouse::AccumulatedMouseScroll) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct AccumulatedMouseScroll {
    #[lua(output(proxy))]
    unit: bevy::input::mouse::MouseScrollUnit,
    #[lua(output(proxy))]
    delta: bevy::math::Vec2,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::mouse::MouseButtonInput",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &mouse::MouseButtonInput) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::mouse::MouseButtonInput;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct MouseButtonInput {
    #[lua(output(proxy))]
    button: bevy::input::mouse::MouseButton,
    #[lua(output(proxy))]
    state: bevy::input::ButtonState,
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::mouse::MouseMotion",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &mouse::MouseMotion) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::mouse::MouseMotion;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct MouseMotion {
    #[lua(output(proxy))]
    delta: bevy::math::Vec2,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::mouse::MouseWheel",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::mouse::MouseWheel;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &mouse::MouseWheel) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct MouseWheel {
    #[lua(output(proxy))]
    unit: bevy::input::mouse::MouseScrollUnit,
    x: f32,
    y: f32,
    #[lua(output(proxy))]
    window: bevy::ecs::entity::Entity,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::GamepadAxisChangedEvent",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::GamepadAxisChangedEvent;

"#,
    r#"
/// Creates a new [`GamepadAxisChangedEvent`]

    #[lua(kind = "Function", output(proxy))]
    fn new(
        #[proxy]
        entity: bevy::ecs::entity::Entity,
        #[proxy]
        axis: bevy::input::gamepad::GamepadAxis,
        value: f32,
    ) -> bevy::input::gamepad::GamepadAxisChangedEvent;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gamepad::GamepadAxisChangedEvent) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct GamepadAxisChangedEvent {
    #[lua(output(proxy))]
    entity: bevy::ecs::entity::Entity,
    #[lua(output(proxy))]
    axis: bevy::input::gamepad::GamepadAxis,
    value: f32,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::GamepadButtonChangedEvent",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gamepad::GamepadButtonChangedEvent) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::GamepadButtonChangedEvent;

"#,
    r#"
/// Creates a new [`GamepadButtonChangedEvent`]

    #[lua(kind = "Function", output(proxy))]
    fn new(
        #[proxy]
        entity: bevy::ecs::entity::Entity,
        #[proxy]
        button: bevy::input::gamepad::GamepadButton,
        #[proxy]
        state: bevy::input::ButtonState,
        value: f32,
    ) -> bevy::input::gamepad::GamepadButtonChangedEvent;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct GamepadButtonChangedEvent {
    #[lua(output(proxy))]
    entity: bevy::ecs::entity::Entity,
    #[lua(output(proxy))]
    button: bevy::input::gamepad::GamepadButton,
    #[lua(output(proxy))]
    state: bevy::input::ButtonState,
    value: f32,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::GamepadButtonStateChangedEvent",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gamepad::GamepadButtonStateChangedEvent) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::GamepadButtonStateChangedEvent;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
/// Creates a new [`GamepadButtonStateChangedEvent`]

    #[lua(kind = "Function", output(proxy))]
    fn new(
        #[proxy]
        entity: bevy::ecs::entity::Entity,
        #[proxy]
        button: bevy::input::gamepad::GamepadButton,
        #[proxy]
        state: bevy::input::ButtonState,
    ) -> bevy::input::gamepad::GamepadButtonStateChangedEvent;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct GamepadButtonStateChangedEvent {
    #[lua(output(proxy))]
    entity: bevy::ecs::entity::Entity,
    #[lua(output(proxy))]
    button: bevy::input::gamepad::GamepadButton,
    #[lua(output(proxy))]
    state: bevy::input::ButtonState,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::GamepadConnection",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gamepad::GamepadConnection) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::GamepadConnection;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct GamepadConnection {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::GamepadConnectionEvent",
    functions[r#"
/// Creates a [`GamepadConnectionEvent`].

    #[lua(kind = "Function", output(proxy))]
    fn new(
        #[proxy]
        gamepad: bevy::ecs::entity::Entity,
        #[proxy]
        connection: bevy::input::gamepad::GamepadConnection,
    ) -> bevy::input::gamepad::GamepadConnectionEvent;

"#,
    r#"
/// Is the gamepad connected?

    #[lua(kind = "Method")]
    fn connected(&self) -> bool;

"#,
    r#"
/// Is the gamepad disconnected?

    #[lua(kind = "Method")]
    fn disconnected(&self) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::GamepadConnectionEvent;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gamepad::GamepadConnectionEvent) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct GamepadConnectionEvent {
    #[lua(output(proxy))]
    gamepad: bevy::ecs::entity::Entity,
    #[lua(output(proxy))]
    connection: bevy::input::gamepad::GamepadConnection,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::GamepadEvent",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gamepad::GamepadEvent) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::GamepadEvent;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct GamepadEvent {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::GamepadInfo",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gamepad::GamepadInfo) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::GamepadInfo;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct GamepadInfo {
    name: std::string::String,
    vendor_id: std::option::Option<u16>,
    product_id: std::option::Option<u16>,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::GamepadInput",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::GamepadInput;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gamepad::GamepadInput) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct GamepadInput {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::GamepadRumbleRequest",
    functions[r#"
/// Get the [`Entity`] associated with this request.

    #[lua(kind = "Method", output(proxy))]
    fn gamepad(&self) -> bevy::ecs::entity::Entity;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::GamepadRumbleRequest;

"#]
)]
struct GamepadRumbleRequest {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::RawGamepadAxisChangedEvent",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::RawGamepadAxisChangedEvent;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gamepad::RawGamepadAxisChangedEvent) -> bool;

"#,
    r#"
/// Creates a [`RawGamepadAxisChangedEvent`].

    #[lua(kind = "Function", output(proxy))]
    fn new(
        #[proxy]
        gamepad: bevy::ecs::entity::Entity,
        #[proxy]
        axis_type: bevy::input::gamepad::GamepadAxis,
        value: f32,
    ) -> bevy::input::gamepad::RawGamepadAxisChangedEvent;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct RawGamepadAxisChangedEvent {
    #[lua(output(proxy))]
    gamepad: bevy::ecs::entity::Entity,
    #[lua(output(proxy))]
    axis: bevy::input::gamepad::GamepadAxis,
    value: f32,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::RawGamepadButtonChangedEvent",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::RawGamepadButtonChangedEvent;

"#,
    r#"
/// Creates a [`RawGamepadButtonChangedEvent`].

    #[lua(kind = "Function", output(proxy))]
    fn new(
        #[proxy]
        gamepad: bevy::ecs::entity::Entity,
        #[proxy]
        button_type: bevy::input::gamepad::GamepadButton,
        value: f32,
    ) -> bevy::input::gamepad::RawGamepadButtonChangedEvent;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gamepad::RawGamepadButtonChangedEvent) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct RawGamepadButtonChangedEvent {
    #[lua(output(proxy))]
    gamepad: bevy::ecs::entity::Entity,
    #[lua(output(proxy))]
    button: bevy::input::gamepad::GamepadButton,
    value: f32,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::RawGamepadEvent",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::RawGamepadEvent;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gamepad::RawGamepadEvent) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct RawGamepadEvent {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gestures::PinchGesture",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gestures::PinchGesture;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gestures::PinchGesture) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct PinchGesture(f32);
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gestures::RotationGesture",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gestures::RotationGesture;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gestures::RotationGesture) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct RotationGesture(f32);
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gestures::DoubleTapGesture",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gestures::DoubleTapGesture;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gestures::DoubleTapGesture) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct DoubleTapGesture {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gestures::PanGesture",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gestures::PanGesture) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gestures::PanGesture;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct PanGesture(#[lua(output(proxy))] bevy::math::Vec2);
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::ButtonState",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::ButtonState;

"#,
    r#"
/// Is this button pressed?

    #[lua(kind = "Method")]
    fn is_pressed(&self) -> bool;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ButtonState) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct ButtonState {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::ButtonSettings",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::ButtonSettings;

"#,
    r#"
/// Returns `true` if the button is pressed.
/// A button is considered pressed if the `value` passed is greater than or equal to the press threshold.

    #[lua(kind = "Method")]
    fn is_pressed(&self, value: f32) -> bool;

"#,
    r#"
/// Returns `true` if the button is released.
/// A button is considered released if the `value` passed is lower than or equal to the release threshold.

    #[lua(kind = "Method")]
    fn is_released(&self, value: f32) -> bool;

"#,
    r#"
/// Get the button input threshold above which the button is considered pressed.

    #[lua(kind = "Method")]
    fn press_threshold(&self) -> f32;

"#,
    r#"
/// Try to set the button input threshold above which the button is considered pressed.
/// If the value passed is outside the range [release threshold..=1.0], the value will not be changed.
/// Returns the new value of the press threshold.

    #[lua(kind = "MutatingMethod")]
    fn set_press_threshold(&mut self, value: f32) -> f32;

"#,
    r#"
/// Get the button input threshold below which the button is considered released.

    #[lua(kind = "Method")]
    fn release_threshold(&self) -> f32;

"#,
    r#"
/// Try to set the button input threshold below which the button is considered released. If the
/// value passed is outside the range [0.0..=press threshold], the value will not be changed.
/// Returns the new value of the release threshold.

    #[lua(kind = "MutatingMethod")]
    fn set_release_threshold(&mut self, value: f32) -> f32;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gamepad::ButtonSettings) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct ButtonSettings {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::AxisSettings",
    functions[r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gamepad::AxisSettings) -> bool;

"#,
    r#"
/// Get the value above which inputs will be rounded up to 1.0.

    #[lua(kind = "Method")]
    fn livezone_upperbound(&self) -> f32;

"#,
    r#"
/// Try to set the value above which inputs will be rounded up to 1.0.
/// If the value passed is negative or less than `deadzone_upperbound`,
/// the value will not be changed.
/// Returns the new value of `livezone_upperbound`.

    #[lua(kind = "MutatingMethod")]
    fn set_livezone_upperbound(&mut self, value: f32) -> f32;

"#,
    r#"
/// Get the value below which positive inputs will be rounded down to 0.0.

    #[lua(kind = "Method")]
    fn deadzone_upperbound(&self) -> f32;

"#,
    r#"
/// Try to set the value below which positive inputs will be rounded down to 0.0.
/// If the value passed is negative or greater than `livezone_upperbound`,
/// the value will not be changed.
/// Returns the new value of `deadzone_upperbound`.

    #[lua(kind = "MutatingMethod")]
    fn set_deadzone_upperbound(&mut self, value: f32) -> f32;

"#,
    r#"
/// Get the value below which negative inputs will be rounded down to -1.0.

    #[lua(kind = "Method")]
    fn livezone_lowerbound(&self) -> f32;

"#,
    r#"
/// Try to set the value below which negative inputs will be rounded down to -1.0.
/// If the value passed is positive or greater than `deadzone_lowerbound`,
/// the value will not be changed.
/// Returns the new value of `livezone_lowerbound`.

    #[lua(kind = "MutatingMethod")]
    fn set_livezone_lowerbound(&mut self, value: f32) -> f32;

"#,
    r#"
/// Get the value above which inputs will be rounded up to 0.0.

    #[lua(kind = "Method")]
    fn deadzone_lowerbound(&self) -> f32;

"#,
    r#"
/// Try to set the value above which inputs will be rounded up to 0.0.
/// If the value passed is less than -1.0 or less than `livezone_lowerbound`,
/// the value will not be changed.
/// Returns the new value of `deadzone_lowerbound`.

    #[lua(kind = "MutatingMethod")]
    fn set_deadzone_lowerbound(&mut self, value: f32) -> f32;

"#,
    r#"
/// Get the minimum value by which input must change before the change is registered.

    #[lua(kind = "Method")]
    fn threshold(&self) -> f32;

"#,
    r#"
/// Try to set the minimum value by which input must change before the changes will be applied.
/// If the value passed is not within [0.0..=2.0], the value will not be changed.
/// Returns the new value of threshold.

    #[lua(kind = "MutatingMethod")]
    fn set_threshold(&mut self, value: f32) -> f32;

"#,
    r#"
/// Clamps the `raw_value` according to the `AxisSettings`.

    #[lua(kind = "Method")]
    fn clamp(&self, new_value: f32) -> f32;

"#,
    r#"
/// Filters the `new_value` based on the `old_value`, according to the [`AxisSettings`].
/// Returns the clamped `new_value` if the change exceeds the settings threshold,
/// and `None` otherwise.

    #[lua(kind = "Method")]
    fn filter(
        &self,
        new_value: f32,
        old_value: std::option::Option<f32>,
    ) -> std::option::Option<f32>;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::AxisSettings;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct AxisSettings {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::ButtonAxisSettings",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::ButtonAxisSettings;

"#,
    r#"
/// Filters the `new_value` based on the `old_value`, according to the [`ButtonAxisSettings`].
/// Returns the clamped `new_value`, according to the [`ButtonAxisSettings`], if the change
/// exceeds the settings threshold, and `None` otherwise.

    #[lua(kind = "Method")]
    fn filter(
        &self,
        new_value: f32,
        old_value: std::option::Option<f32>,
    ) -> std::option::Option<f32>;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct ButtonAxisSettings {
    high: f32,
    low: f32,
    threshold: f32,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::gamepad::GamepadRumbleIntensity",
    functions[r#"
/// Creates a new rumble intensity with weak motor intensity set to the given value.
/// Clamped within the `0.0` to `1.0` range.

    #[lua(kind = "Function", output(proxy))]
    fn weak_motor(intensity: f32) -> bevy::input::gamepad::GamepadRumbleIntensity;

"#,
    r#"
/// Creates a new rumble intensity with strong motor intensity set to the given value.
/// Clamped within the `0.0` to `1.0` range.

    #[lua(kind = "Function", output(proxy))]
    fn strong_motor(intensity: f32) -> bevy::input::gamepad::GamepadRumbleIntensity;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &gamepad::GamepadRumbleIntensity) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::gamepad::GamepadRumbleIntensity;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct GamepadRumbleIntensity {
    strong_motor: f32,
    weak_motor: f32,
}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::keyboard::Key",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::keyboard::Key;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &keyboard::Key) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct Key {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::keyboard::NativeKeyCode",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::keyboard::NativeKeyCode;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &keyboard::NativeKeyCode) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct NativeKeyCode {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::keyboard::NativeKey",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &keyboard::NativeKey) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::keyboard::NativeKey;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct NativeKey {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::mouse::MouseScrollUnit",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &mouse::MouseScrollUnit) -> bool;

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::mouse::MouseScrollUnit;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct MouseScrollUnit {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::touch::TouchPhase",
    functions[r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
    r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::touch::TouchPhase;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &touch::TouchPhase) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct TouchPhase {}
#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
    derive(clone),
    remote = "bevy::input::touch::ForceTouch",
    functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::input::touch::ForceTouch;

"#,
    r#"

    #[lua(
        as_trait = "std::cmp::PartialEq",
        kind = "MetaFunction",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &touch::ForceTouch) -> bool;

"#,
    r#"
#[lua(kind="MetaMethod", metamethod="ToString")]
fn index(&self) -> String {
    format!("{:?}", _self)
}
"#]
)]
struct ForceTouch {}
#[derive(Default)]
pub(crate) struct Globals;
impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<
        'lua,
        T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>,
    >(self, instances: &mut T) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
        instances
            .add_instance(
                "GamepadAxisChangedEvent",
                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<
                    LuaGamepadAxisChangedEvent,
                >::new,
            )?;
        instances
            .add_instance(
                "GamepadButtonChangedEvent",
                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<
                    LuaGamepadButtonChangedEvent,
                >::new,
            )?;
        instances
            .add_instance(
                "GamepadButtonStateChangedEvent",
                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<
                    LuaGamepadButtonStateChangedEvent,
                >::new,
            )?;
        instances
            .add_instance(
                "GamepadConnectionEvent",
                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<
                    LuaGamepadConnectionEvent,
                >::new,
            )?;
        instances
            .add_instance(
                "RawGamepadAxisChangedEvent",
                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<
                    LuaRawGamepadAxisChangedEvent,
                >::new,
            )?;
        instances
            .add_instance(
                "RawGamepadButtonChangedEvent",
                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<
                    LuaRawGamepadButtonChangedEvent,
                >::new,
            )?;
        instances
            .add_instance(
                "GamepadRumbleIntensity",
                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<
                    LuaGamepadRumbleIntensity,
                >::new,
            )?;
        Ok(())
    }
}
pub struct BevyInputAPIProvider;
impl bevy_mod_scripting_core::hosts::APIProvider for BevyInputAPIProvider {
    type APITarget = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
    type ScriptContext = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
    type DocTarget = bevy_mod_scripting_lua::docs::LuaDocFragment;
    fn attach_api(
        &mut self,
        ctx: &mut Self::APITarget,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        let ctx = ctx.get_mut().expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| bevy_mod_scripting_core::error::ScriptError::Other(
                e.to_string(),
            ))
    }
    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(
            bevy_mod_scripting_lua::docs::LuaDocFragment::new(
                "BevyInputAPI",
                |tw| {
                    tw.document_global_instance::<Globals>()
                        .expect("Something went wrong documenting globals")
                        .process_type::<LuaGamepad>()
                        .process_type::<LuaGamepadAxis>()
                        .process_type::<LuaGamepadButton>()
                        .process_type::<LuaGamepadSettings>()
                        .process_type::<LuaKeyCode>()
                        .process_type::<LuaMouseButton>()
                        .process_type::<LuaTouchInput>()
                        .process_type::<LuaKeyboardFocusLost>()
                        .process_type::<LuaKeyboardInput>()
                        .process_type::<LuaAccumulatedMouseMotion>()
                        .process_type::<LuaAccumulatedMouseScroll>()
                        .process_type::<LuaMouseButtonInput>()
                        .process_type::<LuaMouseMotion>()
                        .process_type::<LuaMouseWheel>()
                        .process_type::<LuaGamepadAxisChangedEvent>()
                        .process_type::<
                            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<
                                LuaGamepadAxisChangedEvent,
                            >,
                        >()
                        .process_type::<LuaGamepadButtonChangedEvent>()
                        .process_type::<
                            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<
                                LuaGamepadButtonChangedEvent,
                            >,
                        >()
                        .process_type::<LuaGamepadButtonStateChangedEvent>()
                        .process_type::<
                            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<
                                LuaGamepadButtonStateChangedEvent,
                            >,
                        >()
                        .process_type::<LuaGamepadConnection>()
                        .process_type::<LuaGamepadConnectionEvent>()
                        .process_type::<
                            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<
                                LuaGamepadConnectionEvent,
                            >,
                        >()
                        .process_type::<LuaGamepadEvent>()
                        .process_type::<LuaGamepadInfo>()
                        .process_type::<LuaGamepadInput>()
                        .process_type::<LuaGamepadRumbleRequest>()
                        .process_type::<LuaRawGamepadAxisChangedEvent>()
                        .process_type::<
                            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<
                                LuaRawGamepadAxisChangedEvent,
                            >,
                        >()
                        .process_type::<LuaRawGamepadButtonChangedEvent>()
                        .process_type::<
                            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<
                                LuaRawGamepadButtonChangedEvent,
                            >,
                        >()
                        .process_type::<LuaRawGamepadEvent>()
                        .process_type::<LuaPinchGesture>()
                        .process_type::<LuaRotationGesture>()
                        .process_type::<LuaDoubleTapGesture>()
                        .process_type::<LuaPanGesture>()
                        .process_type::<LuaButtonState>()
                        .process_type::<LuaButtonSettings>()
                        .process_type::<LuaAxisSettings>()
                        .process_type::<LuaButtonAxisSettings>()
                        .process_type::<LuaGamepadRumbleIntensity>()
                        .process_type::<
                            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<
                                LuaGamepadRumbleIntensity,
                            >,
                        >()
                        .process_type::<LuaKey>()
                        .process_type::<LuaNativeKeyCode>()
                        .process_type::<LuaNativeKey>()
                        .process_type::<LuaMouseScrollUnit>()
                        .process_type::<LuaTouchPhase>()
                        .process_type::<LuaForceTouch>()
                },
            ),
        )
    }
    fn setup_script(
        &mut self,
        script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }
    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }
    fn register_with_app(&self, app: &mut bevy::app::App) {
        app.register_foreign_lua_type::<bevy::input::gamepad::Gamepad>();
        app.register_foreign_lua_type::<bevy::input::gamepad::GamepadAxis>();
        app.register_foreign_lua_type::<bevy::input::gamepad::GamepadButton>();
        app.register_foreign_lua_type::<bevy::input::gamepad::GamepadSettings>();
        app.register_foreign_lua_type::<bevy::input::keyboard::KeyCode>();
        app.register_foreign_lua_type::<bevy::input::mouse::MouseButton>();
        app.register_foreign_lua_type::<bevy::input::touch::TouchInput>();
        app.register_foreign_lua_type::<bevy::input::keyboard::KeyboardFocusLost>();
        app.register_foreign_lua_type::<bevy::input::keyboard::KeyboardInput>();
        app.register_foreign_lua_type::<bevy::input::mouse::AccumulatedMouseMotion>();
        app.register_foreign_lua_type::<bevy::input::mouse::AccumulatedMouseScroll>();
        app.register_foreign_lua_type::<bevy::input::mouse::MouseButtonInput>();
        app.register_foreign_lua_type::<bevy::input::mouse::MouseMotion>();
        app.register_foreign_lua_type::<bevy::input::mouse::MouseWheel>();
        app.register_foreign_lua_type::<bevy::input::gamepad::GamepadAxisChangedEvent>();
        app.register_foreign_lua_type::<
                bevy::input::gamepad::GamepadButtonChangedEvent,
            >();
        app.register_foreign_lua_type::<
                bevy::input::gamepad::GamepadButtonStateChangedEvent,
            >();
        app.register_foreign_lua_type::<bevy::input::gamepad::GamepadConnection>();
        app.register_foreign_lua_type::<bevy::input::gamepad::GamepadConnectionEvent>();
        app.register_foreign_lua_type::<bevy::input::gamepad::GamepadEvent>();
        app.register_foreign_lua_type::<bevy::input::gamepad::GamepadInfo>();
        app.register_foreign_lua_type::<bevy::input::gamepad::GamepadInput>();
        app.register_foreign_lua_type::<bevy::input::gamepad::GamepadRumbleRequest>();
        app.register_foreign_lua_type::<
                bevy::input::gamepad::RawGamepadAxisChangedEvent,
            >();
        app.register_foreign_lua_type::<
                bevy::input::gamepad::RawGamepadButtonChangedEvent,
            >();
        app.register_foreign_lua_type::<bevy::input::gamepad::RawGamepadEvent>();
        app.register_foreign_lua_type::<bevy::input::gestures::PinchGesture>();
        app.register_foreign_lua_type::<bevy::input::gestures::RotationGesture>();
        app.register_foreign_lua_type::<bevy::input::gestures::DoubleTapGesture>();
        app.register_foreign_lua_type::<bevy::input::gestures::PanGesture>();
        app.register_foreign_lua_type::<bevy::input::ButtonState>();
        app.register_foreign_lua_type::<bevy::input::gamepad::ButtonSettings>();
        app.register_foreign_lua_type::<bevy::input::gamepad::AxisSettings>();
        app.register_foreign_lua_type::<bevy::input::gamepad::ButtonAxisSettings>();
        app.register_foreign_lua_type::<bevy::input::gamepad::GamepadRumbleIntensity>();
        app.register_foreign_lua_type::<bevy::input::keyboard::Key>();
        app.register_foreign_lua_type::<bevy::input::keyboard::NativeKeyCode>();
        app.register_foreign_lua_type::<bevy::input::keyboard::NativeKey>();
        app.register_foreign_lua_type::<bevy::input::mouse::MouseScrollUnit>();
        app.register_foreign_lua_type::<bevy::input::touch::TouchPhase>();
        app.register_foreign_lua_type::<bevy::input::touch::ForceTouch>();
    }
}
