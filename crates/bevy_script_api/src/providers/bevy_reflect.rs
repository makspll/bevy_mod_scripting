#![allow(clippy::all, unused_imports, deprecated, dead_code)]
// @generated by cargo bevy-api-gen generate, modify the templates not this file






extern crate self as bevy_script_api;
use crate::lua::RegisterForeignLuaType;





    
/// A type that can represent owned, mutable platform-native strings, but is

/// cheaply inter-convertible with Rust strings.

/// The need for this type arises from the fact that:

/// * On Unix systems, strings are often arbitrary sequences of non-zero

///   bytes, in many cases interpreted as UTF-8.

/// * On Windows, strings are often arbitrary sequences of non-zero 16-bit

///   values, interpreted as UTF-16 when it is valid to do so.

/// * In Rust, strings are always valid UTF-8, which may contain zeros.

/// `OsString` and [`OsStr`] bridge this gap by simultaneously representing Rust

/// and platform-native string values, and in particular allowing a Rust string

/// to be converted into an "OS" string with no cost if possible. A consequence

/// of this is that `OsString` instances are *not* `NUL` terminated; in order

/// to pass to e.g., Unix system call, you should create a [`CStr`].

/// `OsString` is to <code>&[OsStr]</code> as [`String`] is to <code>&[str]</code>: the former

/// in each pair are owned strings; the latter are borrowed

/// references.

/// Note, `OsString` and [`OsStr`] internally do not necessarily hold strings in

/// the form native to the platform; While on Unix, strings are stored as a

/// sequence of 8-bit values, on Windows, where strings are 16-bit value based

/// as just discussed, strings are also actually stored as a sequence of 8-bit

/// values, encoded in a less-strict variant of UTF-8. This is useful to

/// understand when handling capacity and length values.

/// # Capacity of `OsString`

/// Capacity uses units of UTF-8 bytes for OS strings which were created from valid unicode, and

/// uses units of bytes in an unspecified encoding for other contents. On a given target, all

/// `OsString` and `OsStr` values use the same units for capacity, so the following will work:

/// ```

/// use std::ffi::{OsStr, OsString};

/// fn concat_os_strings(a: &OsStr, b: &OsStr) -> OsString {

///     let mut ret = OsString::with_capacity(a.len() + b.len()); // This will allocate

///     ret.push(a); // This will not allocate further

///     ret.push(b); // This will not allocate further

///     ret

/// }

/// ```

/// # Creating an `OsString`

/// **From a Rust string**: `OsString` implements

/// <code>[From]<[String]></code>, so you can use <code>my_string.[into]\()</code> to

/// create an `OsString` from a normal Rust string.

/// **From slices:** Just like you can start with an empty Rust

/// [`String`] and then [`String::push_str`] some <code>&[str]</code>

/// sub-string slices into it, you can create an empty `OsString` with

/// the [`OsString::new`] method and then push string slices into it with the

/// [`OsString::push`] method.

/// # Extracting a borrowed reference to the whole OS string

/// You can use the [`OsString::as_os_str`] method to get an <code>&[OsStr]</code> from

/// an `OsString`; this is effectively a borrowed reference to the

/// whole string.

/// # Conversions

/// See the [module's toplevel documentation about conversions][conversions] for a discussion on

/// the traits which `OsString` implements for [conversions] from/to native representations.

/// [`CStr`]: crate::ffi::CStr

/// [conversions]: super#conversions

/// [into]: Into::into


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::ffi::OsString",
functions[r#"
/// Constructs a new empty `OsString`.
/// # Examples
/// ```
/// use std::ffi::OsString;
/// let os_string = OsString::new();
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn new() -> std::ffi::OsString;

"#,
			r#"
/// Converts bytes to an `OsString` without checking that the bytes contains
/// valid [`OsStr`]-encoded data.
/// The byte encoding is an unspecified, platform-specific, self-synchronizing superset of UTF-8.
/// By being a self-synchronizing superset of UTF-8, this encoding is also a superset of 7-bit
/// ASCII.
/// See the [module's toplevel documentation about conversions][conversions] for safe,
/// cross-platform [conversions] from/to native representations.
/// # Safety
/// As the encoding is unspecified, callers must pass in bytes that originated as a mixture of
/// validated UTF-8 and bytes from [`OsStr::as_encoded_bytes`] from within the same rust version
/// built for the same target platform.  For example, reconstructing an `OsString` from bytes sent
/// over the network or stored in a file will likely violate these safety rules.
/// Due to the encoding being self-synchronizing, the bytes from [`OsStr::as_encoded_bytes`] can be
/// split either immediately before or immediately after any valid non-empty UTF-8 substring.
/// # Example
/// ```
/// use std::ffi::OsStr;
/// let os_str = OsStr::new("Mary had a little lamb");
/// let bytes = os_str.as_encoded_bytes();
/// let words = bytes.split(|b| *b == b' ');
/// let words: Vec<&OsStr> = words.map(|word| {
///     // SAFETY:
///     // - Each `word` only contains content that originated from `OsStr::as_encoded_bytes`
///     // - Only split with ASCII whitespace which is a non-empty UTF-8 substring
///     unsafe { OsStr::from_encoded_bytes_unchecked(word) }
/// }).collect();
/// ```
/// [conversions]: super#conversions

    #[lua(kind = "Function", output(proxy))]
    fn from_encoded_bytes_unchecked(
        bytes: bevy::reflect::erased_serde::__private::serde::__private::Vec<
            u8std::alloc::Global,
        >,
    ) -> std::ffi::OsString;

"#,
			r#"
/// Converts the `OsString` into a byte slice.  To convert the byte slice back into an
/// `OsString`, use the [`OsStr::from_encoded_bytes_unchecked`] function.
/// The byte encoding is an unspecified, platform-specific, self-synchronizing superset of UTF-8.
/// By being a self-synchronizing superset of UTF-8, this encoding is also a superset of 7-bit
/// ASCII.
/// Note: As the encoding is unspecified, any sub-slice of bytes that is not valid UTF-8 should
/// be treated as opaque and only comparable within the same rust version built for the same
/// target platform.  For example, sending the bytes over the network or storing it in a file
/// will likely result in incompatible data.  See [`OsString`] for more encoding details
/// and [`std::ffi`] for platform-specific, specified conversions.
/// [`std::ffi`]: crate::ffi

    #[lua(kind = "Method")]
    fn into_encoded_bytes(
        self,
    ) -> bevy::reflect::erased_serde::__private::serde::__private::Vec<
        u8std::alloc::Global,
    >;

"#,
			r#"
/// Creates a new `OsString` with at least the given capacity.
/// The string will be able to hold at least `capacity` length units of other
/// OS strings without reallocating. This method is allowed to allocate for
/// more units than `capacity`. If `capacity` is 0, the string will not
/// allocate.
/// See the main `OsString` documentation information about encoding and capacity units.
/// # Examples
/// ```
/// use std::ffi::OsString;
/// let mut os_string = OsString::with_capacity(10);
/// let capacity = os_string.capacity();
/// // This push is done without reallocating
/// os_string.push("foo");
/// assert_eq!(capacity, os_string.capacity());
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn with_capacity(capacity: usize) -> std::ffi::OsString;

"#,
			r#"
/// Truncates the `OsString` to zero length.
/// # Examples
/// ```
/// use std::ffi::OsString;
/// let mut os_string = OsString::from("foo");
/// assert_eq!(&os_string, "foo");
/// os_string.clear();
/// assert_eq!(&os_string, "");
/// ```

    #[lua(kind = "MutatingMethod")]
    fn clear(&mut self) -> ();

"#,
			r#"
/// Returns the capacity this `OsString` can hold without reallocating.
/// See the main `OsString` documentation information about encoding and capacity units.
/// # Examples
/// ```
/// use std::ffi::OsString;
/// let os_string = OsString::with_capacity(10);
/// assert!(os_string.capacity() >= 10);
/// ```

    #[lua(kind = "Method")]
    fn capacity(&self) -> usize;

"#,
			r#"
/// Reserves capacity for at least `additional` more capacity to be inserted
/// in the given `OsString`. Does nothing if the capacity is
/// already sufficient.
/// The collection may reserve more space to speculatively avoid frequent reallocations.
/// See the main `OsString` documentation information about encoding and capacity units.
/// # Examples
/// ```
/// use std::ffi::OsString;
/// let mut s = OsString::new();
/// s.reserve(10);
/// assert!(s.capacity() >= 10);
/// ```

    #[lua(kind = "MutatingMethod")]
    fn reserve(&mut self, additional: usize) -> ();

"#,
			r#"
/// Reserves the minimum capacity for at least `additional` more capacity to
/// be inserted in the given `OsString`. Does nothing if the capacity is
/// already sufficient.
/// Note that the allocator may give the collection more space than it
/// requests. Therefore, capacity can not be relied upon to be precisely
/// minimal. Prefer [`reserve`] if future insertions are expected.
/// [`reserve`]: OsString::reserve
/// See the main `OsString` documentation information about encoding and capacity units.
/// # Examples
/// ```
/// use std::ffi::OsString;
/// let mut s = OsString::new();
/// s.reserve_exact(10);
/// assert!(s.capacity() >= 10);
/// ```

    #[lua(kind = "MutatingMethod")]
    fn reserve_exact(&mut self, additional: usize) -> ();

"#,
			r#"
/// Shrinks the capacity of the `OsString` to match its length.
/// See the main `OsString` documentation information about encoding and capacity units.
/// # Examples
/// ```
/// use std::ffi::OsString;
/// let mut s = OsString::from("foo");
/// s.reserve(100);
/// assert!(s.capacity() >= 100);
/// s.shrink_to_fit();
/// assert_eq!(3, s.capacity());
/// ```

    #[lua(kind = "MutatingMethod")]
    fn shrink_to_fit(&mut self) -> ();

"#,
			r#"
/// Shrinks the capacity of the `OsString` with a lower bound.
/// The capacity will remain at least as large as both the length
/// and the supplied value.
/// If the current capacity is less than the lower limit, this is a no-op.
/// See the main `OsString` documentation information about encoding and capacity units.
/// # Examples
/// ```
/// use std::ffi::OsString;
/// let mut s = OsString::from("foo");
/// s.reserve(100);
/// assert!(s.capacity() >= 100);
/// s.shrink_to(10);
/// assert!(s.capacity() >= 10);
/// s.shrink_to(0);
/// assert!(s.capacity() >= 3);
/// ```

    #[lua(kind = "MutatingMethod")]
    fn shrink_to(&mut self, min_capacity: usize) -> ();

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "Method",
        output(proxy),
    )]
    fn clone(&self) -> std::ffi::OsString;

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "MutatingMethod",
    )]
    fn clone_from(&mut self, #[proxy] source: &std::ffi::OsString) -> ();

"#]
)]




pub struct OsString{
    
    
        
    
    
}

    
/// An owned, mutable path (akin to [`String`]).

/// This type provides methods like [`push`] and [`set_extension`] that mutate

/// the path in place. It also implements [`Deref`] to [`Path`], meaning that

/// all methods on [`Path`] slices are available on `PathBuf` values as well.

/// [`push`]: PathBuf::push

/// [`set_extension`]: PathBuf::set_extension

/// More details about the overall approach can be found in

/// the [module documentation](self).

/// # Examples

/// You can use [`push`] to build up a `PathBuf` from

/// components:

/// ```

/// use std::path::PathBuf;

/// let mut path = PathBuf::new();

/// path.push(r"C:\");

/// path.push("windows");

/// path.push("system32");

/// path.set_extension("dll");

/// ```

/// However, [`push`] is best used for dynamic situations. This is a better way

/// to do this when you know all of the components ahead of time:

/// ```

/// use std::path::PathBuf;

/// let path: PathBuf = [r"C:\", "windows", "system32.dll"].iter().collect();

/// ```

/// We can still do better than this! Since these are all strings, we can use

/// `From::from`:

/// ```

/// use std::path::PathBuf;

/// let path = PathBuf::from(r"C:\windows\system32.dll");

/// ```

/// Which method works best depends on what kind of situation you're in.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::path::PathBuf",
functions[r#"
/// Allocates an empty `PathBuf`.
/// # Examples
/// ```
/// use std::path::PathBuf;
/// let path = PathBuf::new();
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn new() -> std::path::PathBuf;

"#,
			r#"
/// Creates a new `PathBuf` with a given capacity used to create the
/// internal [`OsString`]. See [`with_capacity`] defined on [`OsString`].
/// # Examples
/// ```
/// use std::path::PathBuf;
/// let mut path = PathBuf::with_capacity(10);
/// let capacity = path.capacity();
/// // This push is done without reallocating
/// path.push(r"C:\");
/// assert_eq!(capacity, path.capacity());
/// ```
/// [`with_capacity`]: OsString::with_capacity

    #[lua(kind = "Function", output(proxy))]
    fn with_capacity(capacity: usize) -> std::path::PathBuf;

"#,
			r#"
/// Truncates `self` to [`self.parent`].
/// Returns `false` and does nothing if [`self.parent`] is [`None`].
/// Otherwise, returns `true`.
/// [`self.parent`]: Path::parent
/// # Examples
/// ```
/// use std::path::{Path, PathBuf};
/// let mut p = PathBuf::from("/spirited/away.rs");
/// p.pop();
/// assert_eq!(Path::new("/spirited"), p);
/// p.pop();
/// assert_eq!(Path::new("/"), p);
/// ```

    #[lua(kind = "MutatingMethod")]
    fn pop(&mut self) -> bool;

"#,
			r#"
/// Consumes the `PathBuf`, yielding its internal [`OsString`] storage.
/// # Examples
/// ```
/// use std::path::PathBuf;
/// let p = PathBuf::from("/the/head");
/// let os_str = p.into_os_string();
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn into_os_string(self) -> std::ffi::OsString;

"#,
			r#"
/// Invokes [`capacity`] on the underlying instance of [`OsString`].
/// [`capacity`]: OsString::capacity

    #[lua(kind = "Method")]
    fn capacity(&self) -> usize;

"#,
			r#"
/// Invokes [`clear`] on the underlying instance of [`OsString`].
/// [`clear`]: OsString::clear

    #[lua(kind = "MutatingMethod")]
    fn clear(&mut self) -> ();

"#,
			r#"
/// Invokes [`reserve`] on the underlying instance of [`OsString`].
/// [`reserve`]: OsString::reserve

    #[lua(kind = "MutatingMethod")]
    fn reserve(&mut self, additional: usize) -> ();

"#,
			r#"
/// Invokes [`reserve_exact`] on the underlying instance of [`OsString`].
/// [`reserve_exact`]: OsString::reserve_exact

    #[lua(kind = "MutatingMethod")]
    fn reserve_exact(&mut self, additional: usize) -> ();

"#,
			r#"
/// Invokes [`shrink_to_fit`] on the underlying instance of [`OsString`].
/// [`shrink_to_fit`]: OsString::shrink_to_fit

    #[lua(kind = "MutatingMethod")]
    fn shrink_to_fit(&mut self) -> ();

"#,
			r#"
/// Invokes [`shrink_to`] on the underlying instance of [`OsString`].
/// [`shrink_to`]: OsString::shrink_to

    #[lua(kind = "MutatingMethod")]
    fn shrink_to(&mut self, min_capacity: usize) -> ();

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "Method",
        output(proxy),
    )]
    fn clone(&self) -> std::path::PathBuf;

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "MutatingMethod",
    )]
    fn clone_from(&mut self, #[proxy] source: &std::path::PathBuf) -> ();

"#]
)]




pub struct PathBuf{
    
    
        
    
    
}

    
/// A UTF-8â€“encoded, growable string.

/// The `String` type is the most common string type that has ownership over the

/// contents of the string. It has a close relationship with its borrowed

/// counterpart, the primitive [`str`].

/// # Examples

/// You can create a `String` from [a literal string][`&str`] with [`String::from`]:

/// [`String::from`]: From::from

/// ```

/// let hello = String::from("Hello, world!");

/// ```

/// You can append a [`char`] to a `String` with the [`push`] method, and

/// append a [`&str`] with the [`push_str`] method:

/// ```

/// let mut hello = String::from("Hello, ");

/// hello.push('w');

/// hello.push_str("orld!");

/// ```

/// [`push`]: String::push

/// [`push_str`]: String::push_str

/// If you have a vector of UTF-8 bytes, you can create a `String` from it with

/// the [`from_utf8`] method:

/// ```

/// // some bytes, in a vector

/// let sparkle_heart = vec![240, 159, 146, 150];

/// // We know these bytes are valid, so we'll use `unwrap()`.

/// let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();

/// assert_eq!("ðŸ’–", sparkle_heart);

/// ```

/// [`from_utf8`]: String::from_utf8

/// # UTF-8

/// `String`s are always valid UTF-8. If you need a non-UTF-8 string, consider

/// [`OsString`]. It is similar, but without the UTF-8 constraint. Because UTF-8

/// is a variable width encoding, `String`s are typically smaller than an array of

/// the same `chars`:

/// ```

/// use std::mem;

/// // `s` is ASCII which represents each `char` as one byte

/// let s = "hello";

/// assert_eq!(s.len(), 5);

/// // A `char` array with the same contents would be longer because

/// // every `char` is four bytes

/// let s = ['h', 'e', 'l', 'l', 'o'];

/// let size: usize = s.into_iter().map(|c| mem::size_of_val(&c)).sum();

/// assert_eq!(size, 20);

/// // However, for non-ASCII strings, the difference will be smaller

/// // and sometimes they are the same

/// let s = "ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–";

/// assert_eq!(s.len(), 20);

/// let s = ['ðŸ’–', 'ðŸ’–', 'ðŸ’–', 'ðŸ’–', 'ðŸ’–'];

/// let size: usize = s.into_iter().map(|c| mem::size_of_val(&c)).sum();

/// assert_eq!(size, 20);

/// ```

/// This raises interesting questions as to how `s[i]` should work.

/// What should `i` be here? Several options include byte indices and

/// `char` indices but, because of UTF-8 encoding, only byte indices

/// would provide constant time indexing. Getting the `i`th `char`, for

/// example, is available using [`chars`]:

/// ```

/// let s = "hello";

/// let third_character = s.chars().nth(2);

/// assert_eq!(third_character, Some('l'));

/// let s = "ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–";

/// let third_character = s.chars().nth(2);

/// assert_eq!(third_character, Some('ðŸ’–'));

/// ```

/// Next, what should `s[i]` return? Because indexing returns a reference

/// to underlying data it could be `&u8`, `&[u8]`, or something else similar.

/// Since we're only providing one index, `&u8` makes the most sense but that

/// might not be what the user expects and can be explicitly achieved with

/// [`as_bytes()`]:

/// ```

/// // The first byte is 104 - the byte value of `'h'`

/// let s = "hello";

/// assert_eq!(s.as_bytes()[0], 104);

/// // or

/// assert_eq!(s.as_bytes()[0], b'h');

/// // The first byte is 240 which isn't obviously useful

/// let s = "ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–";

/// assert_eq!(s.as_bytes()[0], 240);

/// ```

/// Due to these ambiguities/restrictions, indexing with a `usize` is simply

/// forbidden:

/// ```compile_fail,E0277

/// let s = "hello";

/// // The following will not compile!

/// println!("The first letter of s is {}", s[0]);

/// ```

/// It is more clear, however, how `&s[i..j]` should work (that is,

/// indexing with a range). It should accept byte indices (to be constant-time)

/// and return a `&str` which is UTF-8 encoded. This is also called "string slicing".

/// Note this will panic if the byte indices provided are not character

/// boundaries - see [`is_char_boundary`] for more details. See the implementations

/// for [`SliceIndex<str>`] for more details on string slicing. For a non-panicking

/// version of string slicing, see [`get`].

/// [`OsString`]: ../../std/ffi/struct.OsString.html "ffi::OsString"

/// [`SliceIndex<str>`]: core::slice::SliceIndex

/// [`as_bytes()`]: str::as_bytes

/// [`get`]: str::get

/// [`is_char_boundary`]: str::is_char_boundary

/// The [`bytes`] and [`chars`] methods return iterators over the bytes and

/// codepoints of the string, respectively. To iterate over codepoints along

/// with byte indices, use [`char_indices`].

/// [`bytes`]: str::bytes

/// [`chars`]: str::chars

/// [`char_indices`]: str::char_indices

/// # Deref

/// `String` implements <code>[Deref]<Target = [str]></code>, and so inherits all of [`str`]'s

/// methods. In addition, this means that you can pass a `String` to a

/// function which takes a [`&str`] by using an ampersand (`&`):

/// ```

/// fn takes_str(s: &str) { }

/// let s = String::from("Hello");

/// takes_str(&s);

/// ```

/// This will create a [`&str`] from the `String` and pass it in. This

/// conversion is very inexpensive, and so generally, functions will accept

/// [`&str`]s as arguments unless they need a `String` for some specific

/// reason.

/// In certain cases Rust doesn't have enough information to make this

/// conversion, known as [`Deref`] coercion. In the following example a string

/// slice [`&'a str`][`&str`] implements the trait `TraitExample`, and the function

/// `example_func` takes anything that implements the trait. In this case Rust

/// would need to make two implicit conversions, which Rust doesn't have the

/// means to do. For that reason, the following example will not compile.

/// ```compile_fail,E0277

/// trait TraitExample {}

/// impl<'a> TraitExample for &'a str {}

/// fn example_func<A: TraitExample>(example_arg: A) {}

/// let example_string = String::from("example_string");

/// example_func(&example_string);

/// ```

/// There are two options that would work instead. The first would be to

/// change the line `example_func(&example_string);` to

/// `example_func(example_string.as_str());`, using the method [`as_str()`]

/// to explicitly extract the string slice containing the string. The second

/// way changes `example_func(&example_string);` to

/// `example_func(&*example_string);`. In this case we are dereferencing a

/// `String` to a [`str`], then referencing the [`str`] back to

/// [`&str`]. The second way is more idiomatic, however both work to do the

/// conversion explicitly rather than relying on the implicit conversion.

/// # Representation

/// A `String` is made up of three components: a pointer to some bytes, a

/// length, and a capacity. The pointer points to an internal buffer `String`

/// uses to store its data. The length is the number of bytes currently stored

/// in the buffer, and the capacity is the size of the buffer in bytes. As such,

/// the length will always be less than or equal to the capacity.

/// This buffer is always stored on the heap.

/// You can look at these with the [`as_ptr`], [`len`], and [`capacity`]

/// methods:

/// ```

/// use std::mem;

/// let story = String::from("Once upon a time...");

/// // Prevent automatically dropping the String's data

/// let mut story = mem::ManuallyDrop::new(story);

/// let ptr = story.as_mut_ptr();

/// let len = story.len();

/// let capacity = story.capacity();

/// // story has nineteen bytes

/// assert_eq!(19, len);

/// // We can re-build a String out of ptr, len, and capacity. This is all

/// // unsafe because we are responsible for making sure the components are

/// // valid:

/// let s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;

/// assert_eq!(String::from("Once upon a time..."), s);

/// ```

/// [`as_ptr`]: str::as_ptr

/// [`len`]: String::len

/// [`capacity`]: String::capacity

/// If a `String` has enough capacity, adding elements to it will not

/// re-allocate. For example, consider this program:

/// ```

/// let mut s = String::new();

/// println!("{}", s.capacity());

/// for _ in 0..5 {

///     s.push_str("hello");

///     println!("{}", s.capacity());

/// }

/// ```

/// This will output the following:

/// ```text

/// 0

/// 8

/// 16

/// 16

/// 32

/// 32

/// ```

/// At first, we have no memory allocated at all, but as we append to the

/// string, it increases its capacity appropriately. If we instead use the

/// [`with_capacity`] method to allocate the correct capacity initially:

/// ```

/// let mut s = String::with_capacity(25);

/// println!("{}", s.capacity());

/// for _ in 0..5 {

///     s.push_str("hello");

///     println!("{}", s.capacity());

/// }

/// ```

/// [`with_capacity`]: String::with_capacity

/// We end up with a different output:

/// ```text

/// 25

/// 25

/// 25

/// 25

/// 25

/// 25

/// ```

/// Here, there's no need to allocate more memory inside the loop.

/// [str]: prim@str "str"

/// [`str`]: prim@str "str"

/// [`&str`]: prim@str "&str"

/// [Deref]: core::ops::Deref "ops::Deref"

/// [`Deref`]: core::ops::Deref "ops::Deref"

/// [`as_str()`]: String::as_str


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::string::String",
functions[r#"
/// Creates a new empty `String`.
/// Given that the `String` is empty, this will not allocate any initial
/// buffer. While that means that this initial operation is very
/// inexpensive, it may cause excessive allocation later when you add
/// data. If you have an idea of how much data the `String` will hold,
/// consider the [`with_capacity`] method to prevent excessive
/// re-allocation.
/// [`with_capacity`]: String::with_capacity
/// # Examples
/// ```
/// let s = String::new();
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn new() -> std::string::String;

"#,
			r#"
/// Creates a new empty `String` with at least the specified capacity.
/// `String`s have an internal buffer to hold their data. The capacity is
/// the length of that buffer, and can be queried with the [`capacity`]
/// method. This method creates an empty `String`, but one with an initial
/// buffer that can hold at least `capacity` bytes. This is useful when you
/// may be appending a bunch of data to the `String`, reducing the number of
/// reallocations it needs to do.
/// [`capacity`]: String::capacity
/// If the given capacity is `0`, no allocation will occur, and this method
/// is identical to the [`new`] method.
/// [`new`]: String::new
/// # Examples
/// ```
/// let mut s = String::with_capacity(10);
/// // The String contains no chars, even though it has capacity for more
/// assert_eq!(s.len(), 0);
/// // These are all done without reallocating...
/// let cap = s.capacity();
/// for _ in 0..10 {
///     s.push('a');
/// }
/// assert_eq!(s.capacity(), cap);
/// // ...but this may make the string reallocate
/// s.push('a');
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn with_capacity(capacity: usize) -> std::string::String;

"#,
			r#"
/// Converts a vector of bytes to a `String` without checking that the
/// string contains valid UTF-8.
/// See the safe version, [`from_utf8`], for more details.
/// [`from_utf8`]: String::from_utf8
/// # Safety
/// This function is unsafe because it does not check that the bytes passed
/// to it are valid UTF-8. If this constraint is violated, it may cause
/// memory unsafety issues with future users of the `String`, as the rest of
/// the standard library assumes that `String`s are valid UTF-8.
/// # Examples
/// ```
/// // some bytes, in a vector
/// let sparkle_heart = vec![240, 159, 146, 150];
/// let sparkle_heart = unsafe {
///     String::from_utf8_unchecked(sparkle_heart)
/// };
/// assert_eq!("ðŸ’–", sparkle_heart);
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn from_utf8_unchecked(
        bytes: bevy::reflect::erased_serde::__private::serde::__private::Vec<
            u8std::alloc::Global,
        >,
    ) -> std::string::String;

"#,
			r#"
/// Converts a `String` into a byte vector.
/// This consumes the `String`, so we do not need to copy its contents.
/// # Examples
/// ```
/// let s = String::from("hello");
/// let bytes = s.into_bytes();
/// assert_eq!(&[104, 101, 108, 108, 111][..], &bytes[..]);
/// ```

    #[lua(kind = "Method")]
    fn into_bytes(
        self,
    ) -> bevy::reflect::erased_serde::__private::serde::__private::Vec<
        u8std::alloc::Global,
    >;

"#,
			r#"
/// Returns this `String`'s capacity, in bytes.
/// # Examples
/// ```
/// let s = String::with_capacity(10);
/// assert!(s.capacity() >= 10);
/// ```

    #[lua(kind = "Method")]
    fn capacity(&self) -> usize;

"#,
			r#"
/// Reserves capacity for at least `additional` bytes more than the
/// current length. The allocator may reserve more space to speculatively
/// avoid frequent allocations. After calling `reserve`,
/// capacity will be greater than or equal to `self.len() + additional`.
/// Does nothing if capacity is already sufficient.
/// # Panics
/// Panics if the new capacity overflows [`usize`].
/// # Examples
/// Basic usage:
/// ```
/// let mut s = String::new();
/// s.reserve(10);
/// assert!(s.capacity() >= 10);
/// ```
/// This might not actually increase the capacity:
/// ```
/// let mut s = String::with_capacity(10);
/// s.push('a');
/// s.push('b');
/// // s now has a length of 2 and a capacity of at least 10
/// let capacity = s.capacity();
/// assert_eq!(2, s.len());
/// assert!(capacity >= 10);
/// // Since we already have at least an extra 8 capacity, calling this...
/// s.reserve(8);
/// // ... doesn't actually increase.
/// assert_eq!(capacity, s.capacity());
/// ```

    #[lua(kind = "MutatingMethod")]
    fn reserve(&mut self, additional: usize) -> ();

"#,
			r#"
/// Reserves the minimum capacity for at least `additional` bytes more than
/// the current length. Unlike [`reserve`], this will not
/// deliberately over-allocate to speculatively avoid frequent allocations.
/// After calling `reserve_exact`, capacity will be greater than or equal to
/// `self.len() + additional`. Does nothing if the capacity is already
/// sufficient.
/// [`reserve`]: String::reserve
/// # Panics
/// Panics if the new capacity overflows [`usize`].
/// # Examples
/// Basic usage:
/// ```
/// let mut s = String::new();
/// s.reserve_exact(10);
/// assert!(s.capacity() >= 10);
/// ```
/// This might not actually increase the capacity:
/// ```
/// let mut s = String::with_capacity(10);
/// s.push('a');
/// s.push('b');
/// // s now has a length of 2 and a capacity of at least 10
/// let capacity = s.capacity();
/// assert_eq!(2, s.len());
/// assert!(capacity >= 10);
/// // Since we already have at least an extra 8 capacity, calling this...
/// s.reserve_exact(8);
/// // ... doesn't actually increase.
/// assert_eq!(capacity, s.capacity());
/// ```

    #[lua(kind = "MutatingMethod")]
    fn reserve_exact(&mut self, additional: usize) -> ();

"#,
			r#"
/// Shrinks the capacity of this `String` to match its length.
/// # Examples
/// ```
/// let mut s = String::from("foo");
/// s.reserve(100);
/// assert!(s.capacity() >= 100);
/// s.shrink_to_fit();
/// assert_eq!(3, s.capacity());
/// ```

    #[lua(kind = "MutatingMethod")]
    fn shrink_to_fit(&mut self) -> ();

"#,
			r#"
/// Shrinks the capacity of this `String` with a lower bound.
/// The capacity will remain at least as large as both the length
/// and the supplied value.
/// If the current capacity is less than the lower limit, this is a no-op.
/// # Examples
/// ```
/// let mut s = String::from("foo");
/// s.reserve(100);
/// assert!(s.capacity() >= 100);
/// s.shrink_to(10);
/// assert!(s.capacity() >= 10);
/// s.shrink_to(0);
/// assert!(s.capacity() >= 3);
/// ```

    #[lua(kind = "MutatingMethod")]
    fn shrink_to(&mut self, min_capacity: usize) -> ();

"#,
			r#"
/// Shortens this `String` to the specified length.
/// If `new_len` is greater than the string's current length, this has no
/// effect.
/// Note that this method has no effect on the allocated capacity
/// of the string
/// # Panics
/// Panics if `new_len` does not lie on a [`char`] boundary.
/// # Examples
/// ```
/// let mut s = String::from("hello");
/// s.truncate(2);
/// assert_eq!("he", s);
/// ```

    #[lua(kind = "MutatingMethod")]
    fn truncate(&mut self, new_len: usize) -> ();

"#,
			r#"
/// Returns the length of this `String`, in bytes, not [`char`]s or
/// graphemes. In other words, it might not be what a human considers the
/// length of the string.
/// # Examples
/// ```
/// let a = String::from("foo");
/// assert_eq!(a.len(), 3);
/// let fancy_f = String::from("Æ’oo");
/// assert_eq!(fancy_f.len(), 4);
/// assert_eq!(fancy_f.chars().count(), 3);
/// ```

    #[lua(kind = "Method")]
    fn len(&self) -> usize;

"#,
			r#"
/// Returns `true` if this `String` has a length of zero, and `false` otherwise.
/// # Examples
/// ```
/// let mut v = String::new();
/// assert!(v.is_empty());
/// v.push('a');
/// assert!(!v.is_empty());
/// ```

    #[lua(kind = "Method")]
    fn is_empty(&self) -> bool;

"#,
			r#"
/// Splits the string into two at the given byte index.
/// Returns a newly allocated `String`. `self` contains bytes `[0, at)`, and
/// the returned `String` contains bytes `[at, len)`. `at` must be on the
/// boundary of a UTF-8 code point.
/// Note that the capacity of `self` does not change.
/// # Panics
/// Panics if `at` is not on a `UTF-8` code point boundary, or if it is beyond the last
/// code point of the string.
/// # Examples
/// ```
/// # fn main() {
/// let mut hello = String::from("Hello, World!");
/// let world = hello.split_off(7);
/// assert_eq!(hello, "Hello, ");
/// assert_eq!(world, "World!");
/// # }
/// ```

    #[lua(kind = "MutatingMethod", output(proxy))]
    fn split_off(&mut self, at: usize) -> std::string::String;

"#,
			r#"
/// Truncates this `String`, removing all contents.
/// While this means the `String` will have a length of zero, it does not
/// touch its capacity.
/// # Examples
/// ```
/// let mut s = String::from("foo");
/// s.clear();
/// assert!(s.is_empty());
/// assert_eq!(0, s.len());
/// assert_eq!(3, s.capacity());
/// ```

    #[lua(kind = "MutatingMethod")]
    fn clear(&mut self) -> ();

"#,
			r#"
/// Converts this `String` into a <code>[Box]<[str]></code>.
/// This will drop any excess capacity.
/// [str]: prim@str "str"
/// # Examples
/// ```
/// let s = String::from("hello");
/// let b = s.into_boxed_str();
/// ```

    #[lua(kind = "Method")]
    fn into_boxed_str(self) -> std::boxed::Box<strstd::alloc::Global>;

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "Method",
        output(proxy),
    )]
    fn clone(&self) -> std::string::String;

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "MutatingMethod",
    )]
    fn clone_from(&mut self, #[proxy] source: &std::string::String) -> ();

"#,
			r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::ToString",
        kind = "Method",
        output(proxy),
    )]
    fn to_string(&self) -> std::string::String;

"#]
)]




pub struct String{
    
    
        
    
    
}

    
/// A measurement of a monotonically nondecreasing clock.

/// Opaque and useful only with [`Duration`].

/// Instants are always guaranteed, barring [platform bugs], to be no less than any previously

/// measured instant when created, and are often useful for tasks such as measuring

/// benchmarks or timing how long an operation takes.

/// Note, however, that instants are **not** guaranteed to be **steady**. In other

/// words, each tick of the underlying clock might not be the same length (e.g.

/// some seconds may be longer than others). An instant may jump forwards or

/// experience time dilation (slow down or speed up), but it will never go

/// backwards.

/// As part of this non-guarantee it is also not specified whether system suspends count as

/// elapsed time or not. The behavior varies across platforms and rust versions.

/// Instants are opaque types that can only be compared to one another. There is

/// no method to get "the number of seconds" from an instant. Instead, it only

/// allows measuring the duration between two instants (or comparing two

/// instants).

/// The size of an `Instant` struct may vary depending on the target operating

/// system.

/// Example:

/// ```no_run

/// use std::time::{Duration, Instant};

/// use std::thread::sleep;

/// fn main() {

///    let now = Instant::now();

///    // we sleep for 2 seconds

///    sleep(Duration::new(2, 0));

///    // it prints '2'

///    println!("{}", now.elapsed().as_secs());

/// }

/// ```

/// [platform bugs]: Instant#monotonicity

/// # OS-specific behaviors

/// An `Instant` is a wrapper around system-specific types and it may behave

/// differently depending on the underlying operating system. For example,

/// the following snippet is fine on Linux but panics on macOS:

/// ```no_run

/// use std::time::{Instant, Duration};

/// let now = Instant::now();

/// let max_seconds = u64::MAX / 1_000_000_000;

/// let duration = Duration::new(max_seconds, 0);

/// println!("{:?}", now + duration);

/// ```

/// # Underlying System calls

/// The following system calls are [currently] being used by `now()` to find out

/// the current time:

/// |  Platform |               System call                                            |

/// |-----------|----------------------------------------------------------------------|

/// | SGX       | [`insecure_time` usercall]. More information on [timekeeping in SGX] |

/// | UNIX      | [clock_gettime (Monotonic Clock)]                                    |

/// | Darwin    | [clock_gettime (Monotonic Clock)]                                    |

/// | VXWorks   | [clock_gettime (Monotonic Clock)]                                    |

/// | SOLID     | `get_tim`                                                            |

/// | WASI      | [__wasi_clock_time_get (Monotonic Clock)]                            |

/// | Windows   | [QueryPerformanceCounter]                                            |

/// [currently]: crate::io#platform-specific-behavior

/// [QueryPerformanceCounter]: https://docs.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter

/// [`insecure_time` usercall]: https://edp.fortanix.com/docs/api/fortanix_sgx_abi/struct.Usercalls.html#method.insecure_time

/// [timekeeping in SGX]: https://edp.fortanix.com/docs/concepts/rust-std/#codestdtimecode

/// [__wasi_clock_time_get (Monotonic Clock)]: https://github.com/WebAssembly/WASI/blob/main/legacy/preview1/docs.md#clock_time_get

/// [clock_gettime (Monotonic Clock)]: https://linux.die.net/man/3/clock_gettime

/// **Disclaimer:** These system calls might change over time.

/// > Note: mathematical operations like [`add`] may panic if the underlying

/// > structure cannot represent the new point in time.

/// [`add`]: Instant::add

/// ## Monotonicity

/// On all platforms `Instant` will try to use an OS API that guarantees monotonic behavior

/// if available, which is the case for all [tier 1] platforms.

/// In practice such guarantees are â€“ under rare circumstances â€“ broken by hardware, virtualization

/// or operating system bugs. To work around these bugs and platforms not offering monotonic clocks

/// [`duration_since`], [`elapsed`] and [`sub`] saturate to zero. In older Rust versions this

/// lead to a panic instead. [`checked_duration_since`] can be used to detect and handle situations

/// where monotonicity is violated, or `Instant`s are subtracted in the wrong order.

/// This workaround obscures programming errors where earlier and later instants are accidentally

/// swapped. For this reason future rust versions may reintroduce panics.

/// [tier 1]: https://doc.rust-lang.org/rustc/platform-support.html

/// [`duration_since`]: Instant::duration_since

/// [`elapsed`]: Instant::elapsed

/// [`sub`]: Instant::sub

/// [`checked_duration_since`]: Instant::checked_duration_since


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="bevy::utils::Instant",
functions[r#"
/// Returns an instant corresponding to "now".
/// # Examples
/// ```
/// use std::time::Instant;
/// let now = Instant::now();
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn now() -> bevy::utils::Instant;

"#,
			r#"
/// Returns the amount of time elapsed from another instant to this one,
/// or zero duration if that instant is later than this one.
/// # Panics
/// Previous rust versions panicked when `earlier` was later than `self`. Currently this
/// method saturates. Future versions may reintroduce the panic in some circumstances.
/// See [Monotonicity].
/// [Monotonicity]: Instant#monotonicity
/// # Examples
/// ```no_run
/// use std::time::{Duration, Instant};
/// use std::thread::sleep;
/// let now = Instant::now();
/// sleep(Duration::new(1, 0));
/// let new_now = Instant::now();
/// println!("{:?}", new_now.duration_since(now));
/// println!("{:?}", now.duration_since(new_now)); // 0ns
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn duration_since(
        &self,
        #[proxy]
        earlier: bevy::utils::Instant,
    ) -> bevy::utils::Duration;

"#,
			r#"
/// Returns the amount of time elapsed from another instant to this one,
/// or zero duration if that instant is later than this one.
/// # Examples
/// ```no_run
/// use std::time::{Duration, Instant};
/// use std::thread::sleep;
/// let now = Instant::now();
/// sleep(Duration::new(1, 0));
/// let new_now = Instant::now();
/// println!("{:?}", new_now.saturating_duration_since(now));
/// println!("{:?}", now.saturating_duration_since(new_now)); // 0ns
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_duration_since(
        &self,
        #[proxy]
        earlier: bevy::utils::Instant,
    ) -> bevy::utils::Duration;

"#,
			r#"
/// Returns the amount of time elapsed since this instant.
/// # Panics
/// Previous rust versions panicked when the current time was earlier than self. Currently this
/// method returns a Duration of zero in that case. Future versions may reintroduce the panic.
/// See [Monotonicity].
/// [Monotonicity]: Instant#monotonicity
/// # Examples
/// ```no_run
/// use std::thread::sleep;
/// use std::time::{Duration, Instant};
/// let instant = Instant::now();
/// let three_secs = Duration::from_secs(3);
/// sleep(three_secs);
/// assert!(instant.elapsed() >= three_secs);
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn elapsed(&self) -> bevy::utils::Duration;

"#,
			r#"
/// # Panics
/// This function may panic if the resulting point in time cannot be represented by the
/// underlying data structure. See [`Instant::checked_add`] for a version without panic.

    #[lua(
        as_trait = "std::ops::Add",
        kind = "Function",
        output(proxy),
        composite = "add",
        metamethod = "Add",
    )]
    fn add(self, #[proxy] other: bevy::utils::Duration) -> bevy::utils::Instant;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Function", composite = "eq")]
    fn eq(&self, #[proxy] other: &bevy_utils::Instant) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "Method",
        output(proxy),
    )]
    fn clone(&self) -> bevy::utils::Instant;

"#,
			r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]



pub struct Instant(
    
    
        
    
    
);

    
/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroU8>` is the same size as `u8`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroU8>>(), size_of::<u8>());

/// ```

/// # Layout

///`NonZeroU8` is guaranteed to have the same layout and bit validity as `u8`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroU8>` is guaranteed to be compatible with `u8`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroU8` and `Option<NonZeroU8>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroU8;

///assert_eq!(size_of::<NonZeroU8>(), size_of::<Option<NonZeroU8>>());

///assert_eq!(align_of::<NonZeroU8>(), align_of::<Option<NonZeroU8>>());

/// ```

/// [null pointer optimization]: crate::option#representation


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroU8",
functions[r#"
/// Creates a non-zero without checking whether the value is non-zero.
/// This results in undefined behaviour if the value is zero.
/// # Safety
/// The value must not be zero.

    #[lua(kind = "Function", output(proxy))]
    fn new_unchecked(n: u8) -> std::num::NonZeroU8;

"#,
			r#"
/// Returns the value as a primitive type.

    #[lua(kind = "Method")]
    fn get(self) -> u8;

"#,
			r#"
/// Returns the number of leading zeros in the binary representation of `self`.
/// On many architectures, this function can perform better than `leading_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroU8::new(u8::MAX).unwrap();
/// assert_eq!(n.leading_zeros(), 0);
/// ```

    #[lua(kind = "Method")]
    fn leading_zeros(self) -> u32;

"#,
			r#"
/// Returns the number of trailing zeros in the binary representation
/// of `self`.
/// On many architectures, this function can perform better than `trailing_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroU8::new(0b0101000).unwrap();
/// assert_eq!(n.trailing_zeros(), 3);
/// ```

    #[lua(kind = "Method")]
    fn trailing_zeros(self) -> u32;

"#,
			r#"
/// Adds an unsigned integer to a non-zero value.
///Return [`NonZeroU8::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroU8;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let one = NonZeroU8::new(1)?;
///let two = NonZeroU8::new(2)?;
///let max = NonZeroU8::new(u8::MAX)?;
/// assert_eq!(two, one.saturating_add(1));
/// assert_eq!(max, max.saturating_add(1));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_add(self, other: u8) -> std::num::NonZeroU8;

"#,
			r#"
/// Adds an unsigned integer to a non-zero value,
/// assuming overflow cannot occur.
/// Overflow is unchecked, and it is undefined behaviour to overflow
/// *even if the result would wrap to a non-zero value*.
/// The behaviour is undefined as soon as
///`self + rhs > u8::MAX`.
/// # Examples
/// ```
/// #![feature(nonzero_ops)]
///# use std::num::NonZeroU8;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let one = NonZeroU8::new(1)?;
///let two = NonZeroU8::new(2)?;
/// assert_eq!(two, unsafe { one.unchecked_add(1) });
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unchecked_add(self, other: u8) -> std::num::NonZeroU8;

"#,
			r#"
/// Returns the base 2 logarithm of the number, rounded down.
/// This is the same operation as
///[`u8::ilog2`],
/// except that it has no failure cases to worry about
/// since this value can never be zero.
/// # Examples
/// ```
///# use std::num::NonZeroU8;
///assert_eq!(NonZeroU8::new(7).unwrap().ilog2(), 2);
///assert_eq!(NonZeroU8::new(8).unwrap().ilog2(), 3);
///assert_eq!(NonZeroU8::new(9).unwrap().ilog2(), 3);
/// ```

    #[lua(kind = "Method")]
    fn ilog2(self) -> u32;

"#,
			r#"
/// Returns the base 10 logarithm of the number, rounded down.
/// This is the same operation as
///[`u8::ilog10`],
/// except that it has no failure cases to worry about
/// since this value can never be zero.
/// # Examples
/// ```
///# use std::num::NonZeroU8;
///assert_eq!(NonZeroU8::new(99).unwrap().ilog10(), 1);
///assert_eq!(NonZeroU8::new(100).unwrap().ilog10(), 2);
///assert_eq!(NonZeroU8::new(101).unwrap().ilog10(), 2);
/// ```

    #[lua(kind = "Method")]
    fn ilog10(self) -> u32;

"#,
			r#"
/// Calculates the middle point of `self` and `rhs`.
/// `midpoint(a, b)` is `(a + b) >> 1` as if it were performed in a
/// sufficiently-large signed integral type. This implies that the result is
/// always rounded towards negative infinity and that no overflow will ever occur.
/// # Examples
/// ```
/// #![feature(num_midpoint)]
///# use std::num::NonZeroU8;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let one = NonZeroU8::new(1)?;
///let two = NonZeroU8::new(2)?;
///let four = NonZeroU8::new(4)?;
/// assert_eq!(one.midpoint(four), two);
/// assert_eq!(four.midpoint(one), two);
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn midpoint(self, #[proxy] rhs: std::num::NonZeroU8) -> std::num::NonZeroU8;

"#,
			r#"
/// Returns `true` if and only if `self == (1 << k)` for some `k`.
/// On many architectures, this function can perform better than `is_power_of_two()`
/// on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let eight = std::num::NonZeroU8::new(8).unwrap();
/// assert!(eight.is_power_of_two());
///let ten = std::num::NonZeroU8::new(10).unwrap();
/// assert!(!ten.is_power_of_two());
/// ```

    #[lua(kind = "Method")]
    fn is_power_of_two(self) -> bool;

"#,
			r#"
/// Multiplies two non-zero integers together.
///Return [`NonZeroU8::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroU8;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroU8::new(2)?;
///let four = NonZeroU8::new(4)?;
///let max = NonZeroU8::new(u8::MAX)?;
/// assert_eq!(four, two.saturating_mul(two));
/// assert_eq!(max, four.saturating_mul(max));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_mul(self, #[proxy] other: std::num::NonZeroU8) -> std::num::NonZeroU8;

"#,
			r#"
/// Multiplies two non-zero integers together,
/// assuming overflow cannot occur.
/// Overflow is unchecked, and it is undefined behaviour to overflow
/// *even if the result would wrap to a non-zero value*.
/// The behaviour is undefined as soon as
///`self * rhs > u8::MAX`.
/// # Examples
/// ```
/// #![feature(nonzero_ops)]
///# use std::num::NonZeroU8;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroU8::new(2)?;
///let four = NonZeroU8::new(4)?;
/// assert_eq!(four, unsafe { two.unchecked_mul(two) });
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unchecked_mul(self, #[proxy] other: std::num::NonZeroU8) -> std::num::NonZeroU8;

"#,
			r#"
/// Raise non-zero value to an integer power.
///Return [`NonZeroU8::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroU8;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let three = NonZeroU8::new(3)?;
///let twenty_seven = NonZeroU8::new(27)?;
///let max = NonZeroU8::new(u8::MAX)?;
/// assert_eq!(twenty_seven, three.saturating_pow(3));
/// assert_eq!(max, max.saturating_pow(3));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_pow(self, other: u32) -> std::num::NonZeroU8;

"#,
			r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "Method",
        output(proxy),
    )]
    fn clone(&self) -> std::num::NonZeroU8;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Function", composite = "eq")]
    fn eq(&self, #[proxy] other: &std::num::NonZeroU8) -> bool;

"#]
)]



pub struct NonZeroU8(
    
    
        
    
    
);

    
/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroU16>` is the same size as `u16`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroU16>>(), size_of::<u16>());

/// ```

/// # Layout

///`NonZeroU16` is guaranteed to have the same layout and bit validity as `u16`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroU16>` is guaranteed to be compatible with `u16`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroU16` and `Option<NonZeroU16>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroU16;

///assert_eq!(size_of::<NonZeroU16>(), size_of::<Option<NonZeroU16>>());

///assert_eq!(align_of::<NonZeroU16>(), align_of::<Option<NonZeroU16>>());

/// ```

/// [null pointer optimization]: crate::option#representation


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroU16",
functions[r#"
/// Creates a non-zero without checking whether the value is non-zero.
/// This results in undefined behaviour if the value is zero.
/// # Safety
/// The value must not be zero.

    #[lua(kind = "Function", output(proxy))]
    fn new_unchecked(n: u16) -> std::num::NonZeroU16;

"#,
			r#"
/// Returns the value as a primitive type.

    #[lua(kind = "Method")]
    fn get(self) -> u16;

"#,
			r#"
/// Returns the number of leading zeros in the binary representation of `self`.
/// On many architectures, this function can perform better than `leading_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroU16::new(u16::MAX).unwrap();
/// assert_eq!(n.leading_zeros(), 0);
/// ```

    #[lua(kind = "Method")]
    fn leading_zeros(self) -> u32;

"#,
			r#"
/// Returns the number of trailing zeros in the binary representation
/// of `self`.
/// On many architectures, this function can perform better than `trailing_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroU16::new(0b0101000).unwrap();
/// assert_eq!(n.trailing_zeros(), 3);
/// ```

    #[lua(kind = "Method")]
    fn trailing_zeros(self) -> u32;

"#,
			r#"
/// Adds an unsigned integer to a non-zero value.
///Return [`NonZeroU16::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroU16;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let one = NonZeroU16::new(1)?;
///let two = NonZeroU16::new(2)?;
///let max = NonZeroU16::new(u16::MAX)?;
/// assert_eq!(two, one.saturating_add(1));
/// assert_eq!(max, max.saturating_add(1));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_add(self, other: u16) -> std::num::NonZeroU16;

"#,
			r#"
/// Adds an unsigned integer to a non-zero value,
/// assuming overflow cannot occur.
/// Overflow is unchecked, and it is undefined behaviour to overflow
/// *even if the result would wrap to a non-zero value*.
/// The behaviour is undefined as soon as
///`self + rhs > u16::MAX`.
/// # Examples
/// ```
/// #![feature(nonzero_ops)]
///# use std::num::NonZeroU16;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let one = NonZeroU16::new(1)?;
///let two = NonZeroU16::new(2)?;
/// assert_eq!(two, unsafe { one.unchecked_add(1) });
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unchecked_add(self, other: u16) -> std::num::NonZeroU16;

"#,
			r#"
/// Returns the base 2 logarithm of the number, rounded down.
/// This is the same operation as
///[`u16::ilog2`],
/// except that it has no failure cases to worry about
/// since this value can never be zero.
/// # Examples
/// ```
///# use std::num::NonZeroU16;
///assert_eq!(NonZeroU16::new(7).unwrap().ilog2(), 2);
///assert_eq!(NonZeroU16::new(8).unwrap().ilog2(), 3);
///assert_eq!(NonZeroU16::new(9).unwrap().ilog2(), 3);
/// ```

    #[lua(kind = "Method")]
    fn ilog2(self) -> u32;

"#,
			r#"
/// Returns the base 10 logarithm of the number, rounded down.
/// This is the same operation as
///[`u16::ilog10`],
/// except that it has no failure cases to worry about
/// since this value can never be zero.
/// # Examples
/// ```
///# use std::num::NonZeroU16;
///assert_eq!(NonZeroU16::new(99).unwrap().ilog10(), 1);
///assert_eq!(NonZeroU16::new(100).unwrap().ilog10(), 2);
///assert_eq!(NonZeroU16::new(101).unwrap().ilog10(), 2);
/// ```

    #[lua(kind = "Method")]
    fn ilog10(self) -> u32;

"#,
			r#"
/// Calculates the middle point of `self` and `rhs`.
/// `midpoint(a, b)` is `(a + b) >> 1` as if it were performed in a
/// sufficiently-large signed integral type. This implies that the result is
/// always rounded towards negative infinity and that no overflow will ever occur.
/// # Examples
/// ```
/// #![feature(num_midpoint)]
///# use std::num::NonZeroU16;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let one = NonZeroU16::new(1)?;
///let two = NonZeroU16::new(2)?;
///let four = NonZeroU16::new(4)?;
/// assert_eq!(one.midpoint(four), two);
/// assert_eq!(four.midpoint(one), two);
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn midpoint(self, #[proxy] rhs: std::num::NonZeroU16) -> std::num::NonZeroU16;

"#,
			r#"
/// Returns `true` if and only if `self == (1 << k)` for some `k`.
/// On many architectures, this function can perform better than `is_power_of_two()`
/// on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let eight = std::num::NonZeroU16::new(8).unwrap();
/// assert!(eight.is_power_of_two());
///let ten = std::num::NonZeroU16::new(10).unwrap();
/// assert!(!ten.is_power_of_two());
/// ```

    #[lua(kind = "Method")]
    fn is_power_of_two(self) -> bool;

"#,
			r#"
/// Multiplies two non-zero integers together.
///Return [`NonZeroU16::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroU16;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroU16::new(2)?;
///let four = NonZeroU16::new(4)?;
///let max = NonZeroU16::new(u16::MAX)?;
/// assert_eq!(four, two.saturating_mul(two));
/// assert_eq!(max, four.saturating_mul(max));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_mul(
        self,
        #[proxy]
        other: std::num::NonZeroU16,
    ) -> std::num::NonZeroU16;

"#,
			r#"
/// Multiplies two non-zero integers together,
/// assuming overflow cannot occur.
/// Overflow is unchecked, and it is undefined behaviour to overflow
/// *even if the result would wrap to a non-zero value*.
/// The behaviour is undefined as soon as
///`self * rhs > u16::MAX`.
/// # Examples
/// ```
/// #![feature(nonzero_ops)]
///# use std::num::NonZeroU16;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroU16::new(2)?;
///let four = NonZeroU16::new(4)?;
/// assert_eq!(four, unsafe { two.unchecked_mul(two) });
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unchecked_mul(self, #[proxy] other: std::num::NonZeroU16) -> std::num::NonZeroU16;

"#,
			r#"
/// Raise non-zero value to an integer power.
///Return [`NonZeroU16::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroU16;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let three = NonZeroU16::new(3)?;
///let twenty_seven = NonZeroU16::new(27)?;
///let max = NonZeroU16::new(u16::MAX)?;
/// assert_eq!(twenty_seven, three.saturating_pow(3));
/// assert_eq!(max, max.saturating_pow(3));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_pow(self, other: u32) -> std::num::NonZeroU16;

"#,
			r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "Method",
        output(proxy),
    )]
    fn clone(&self) -> std::num::NonZeroU16;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Function", composite = "eq")]
    fn eq(&self, #[proxy] other: &std::num::NonZeroU16) -> bool;

"#]
)]



pub struct NonZeroU16(
    
    
        
    
    
);

    
/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroU32>` is the same size as `u32`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroU32>>(), size_of::<u32>());

/// ```

/// # Layout

///`NonZeroU32` is guaranteed to have the same layout and bit validity as `u32`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroU32>` is guaranteed to be compatible with `u32`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroU32` and `Option<NonZeroU32>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroU32;

///assert_eq!(size_of::<NonZeroU32>(), size_of::<Option<NonZeroU32>>());

///assert_eq!(align_of::<NonZeroU32>(), align_of::<Option<NonZeroU32>>());

/// ```

/// [null pointer optimization]: crate::option#representation


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroU32",
functions[r#"
/// Creates a non-zero without checking whether the value is non-zero.
/// This results in undefined behaviour if the value is zero.
/// # Safety
/// The value must not be zero.

    #[lua(kind = "Function", output(proxy))]
    fn new_unchecked(n: u32) -> std::num::NonZeroU32;

"#,
			r#"
/// Returns the value as a primitive type.

    #[lua(kind = "Method")]
    fn get(self) -> u32;

"#,
			r#"
/// Returns the number of leading zeros in the binary representation of `self`.
/// On many architectures, this function can perform better than `leading_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroU32::new(u32::MAX).unwrap();
/// assert_eq!(n.leading_zeros(), 0);
/// ```

    #[lua(kind = "Method")]
    fn leading_zeros(self) -> u32;

"#,
			r#"
/// Returns the number of trailing zeros in the binary representation
/// of `self`.
/// On many architectures, this function can perform better than `trailing_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroU32::new(0b0101000).unwrap();
/// assert_eq!(n.trailing_zeros(), 3);
/// ```

    #[lua(kind = "Method")]
    fn trailing_zeros(self) -> u32;

"#,
			r#"
/// Adds an unsigned integer to a non-zero value.
///Return [`NonZeroU32::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroU32;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let one = NonZeroU32::new(1)?;
///let two = NonZeroU32::new(2)?;
///let max = NonZeroU32::new(u32::MAX)?;
/// assert_eq!(two, one.saturating_add(1));
/// assert_eq!(max, max.saturating_add(1));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_add(self, other: u32) -> std::num::NonZeroU32;

"#,
			r#"
/// Adds an unsigned integer to a non-zero value,
/// assuming overflow cannot occur.
/// Overflow is unchecked, and it is undefined behaviour to overflow
/// *even if the result would wrap to a non-zero value*.
/// The behaviour is undefined as soon as
///`self + rhs > u32::MAX`.
/// # Examples
/// ```
/// #![feature(nonzero_ops)]
///# use std::num::NonZeroU32;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let one = NonZeroU32::new(1)?;
///let two = NonZeroU32::new(2)?;
/// assert_eq!(two, unsafe { one.unchecked_add(1) });
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unchecked_add(self, other: u32) -> std::num::NonZeroU32;

"#,
			r#"
/// Returns the base 2 logarithm of the number, rounded down.
/// This is the same operation as
///[`u32::ilog2`],
/// except that it has no failure cases to worry about
/// since this value can never be zero.
/// # Examples
/// ```
///# use std::num::NonZeroU32;
///assert_eq!(NonZeroU32::new(7).unwrap().ilog2(), 2);
///assert_eq!(NonZeroU32::new(8).unwrap().ilog2(), 3);
///assert_eq!(NonZeroU32::new(9).unwrap().ilog2(), 3);
/// ```

    #[lua(kind = "Method")]
    fn ilog2(self) -> u32;

"#,
			r#"
/// Returns the base 10 logarithm of the number, rounded down.
/// This is the same operation as
///[`u32::ilog10`],
/// except that it has no failure cases to worry about
/// since this value can never be zero.
/// # Examples
/// ```
///# use std::num::NonZeroU32;
///assert_eq!(NonZeroU32::new(99).unwrap().ilog10(), 1);
///assert_eq!(NonZeroU32::new(100).unwrap().ilog10(), 2);
///assert_eq!(NonZeroU32::new(101).unwrap().ilog10(), 2);
/// ```

    #[lua(kind = "Method")]
    fn ilog10(self) -> u32;

"#,
			r#"
/// Calculates the middle point of `self` and `rhs`.
/// `midpoint(a, b)` is `(a + b) >> 1` as if it were performed in a
/// sufficiently-large signed integral type. This implies that the result is
/// always rounded towards negative infinity and that no overflow will ever occur.
/// # Examples
/// ```
/// #![feature(num_midpoint)]
///# use std::num::NonZeroU32;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let one = NonZeroU32::new(1)?;
///let two = NonZeroU32::new(2)?;
///let four = NonZeroU32::new(4)?;
/// assert_eq!(one.midpoint(four), two);
/// assert_eq!(four.midpoint(one), two);
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn midpoint(self, #[proxy] rhs: std::num::NonZeroU32) -> std::num::NonZeroU32;

"#,
			r#"
/// Returns `true` if and only if `self == (1 << k)` for some `k`.
/// On many architectures, this function can perform better than `is_power_of_two()`
/// on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let eight = std::num::NonZeroU32::new(8).unwrap();
/// assert!(eight.is_power_of_two());
///let ten = std::num::NonZeroU32::new(10).unwrap();
/// assert!(!ten.is_power_of_two());
/// ```

    #[lua(kind = "Method")]
    fn is_power_of_two(self) -> bool;

"#,
			r#"
/// Multiplies two non-zero integers together.
///Return [`NonZeroU32::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroU32;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroU32::new(2)?;
///let four = NonZeroU32::new(4)?;
///let max = NonZeroU32::new(u32::MAX)?;
/// assert_eq!(four, two.saturating_mul(two));
/// assert_eq!(max, four.saturating_mul(max));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_mul(
        self,
        #[proxy]
        other: std::num::NonZeroU32,
    ) -> std::num::NonZeroU32;

"#,
			r#"
/// Multiplies two non-zero integers together,
/// assuming overflow cannot occur.
/// Overflow is unchecked, and it is undefined behaviour to overflow
/// *even if the result would wrap to a non-zero value*.
/// The behaviour is undefined as soon as
///`self * rhs > u32::MAX`.
/// # Examples
/// ```
/// #![feature(nonzero_ops)]
///# use std::num::NonZeroU32;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroU32::new(2)?;
///let four = NonZeroU32::new(4)?;
/// assert_eq!(four, unsafe { two.unchecked_mul(two) });
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unchecked_mul(self, #[proxy] other: std::num::NonZeroU32) -> std::num::NonZeroU32;

"#,
			r#"
/// Raise non-zero value to an integer power.
///Return [`NonZeroU32::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroU32;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let three = NonZeroU32::new(3)?;
///let twenty_seven = NonZeroU32::new(27)?;
///let max = NonZeroU32::new(u32::MAX)?;
/// assert_eq!(twenty_seven, three.saturating_pow(3));
/// assert_eq!(max, max.saturating_pow(3));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_pow(self, other: u32) -> std::num::NonZeroU32;

"#,
			r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "Method",
        output(proxy),
    )]
    fn clone(&self) -> std::num::NonZeroU32;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Function", composite = "eq")]
    fn eq(&self, #[proxy] other: &std::num::NonZeroU32) -> bool;

"#]
)]



pub struct NonZeroU32(
    
    
        
    
    
);

    
/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroU64>` is the same size as `u64`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroU64>>(), size_of::<u64>());

/// ```

/// # Layout

///`NonZeroU64` is guaranteed to have the same layout and bit validity as `u64`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroU64>` is guaranteed to be compatible with `u64`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroU64` and `Option<NonZeroU64>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroU64;

///assert_eq!(size_of::<NonZeroU64>(), size_of::<Option<NonZeroU64>>());

///assert_eq!(align_of::<NonZeroU64>(), align_of::<Option<NonZeroU64>>());

/// ```

/// [null pointer optimization]: crate::option#representation


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroU64",
functions[r#"
/// Creates a non-zero without checking whether the value is non-zero.
/// This results in undefined behaviour if the value is zero.
/// # Safety
/// The value must not be zero.

    #[lua(kind = "Function", output(proxy))]
    fn new_unchecked(n: u64) -> std::num::NonZeroU64;

"#,
			r#"
/// Returns the value as a primitive type.

    #[lua(kind = "Method")]
    fn get(self) -> u64;

"#,
			r#"
/// Returns the number of leading zeros in the binary representation of `self`.
/// On many architectures, this function can perform better than `leading_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroU64::new(u64::MAX).unwrap();
/// assert_eq!(n.leading_zeros(), 0);
/// ```

    #[lua(kind = "Method")]
    fn leading_zeros(self) -> u32;

"#,
			r#"
/// Returns the number of trailing zeros in the binary representation
/// of `self`.
/// On many architectures, this function can perform better than `trailing_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroU64::new(0b0101000).unwrap();
/// assert_eq!(n.trailing_zeros(), 3);
/// ```

    #[lua(kind = "Method")]
    fn trailing_zeros(self) -> u32;

"#,
			r#"
/// Adds an unsigned integer to a non-zero value.
///Return [`NonZeroU64::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroU64;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let one = NonZeroU64::new(1)?;
///let two = NonZeroU64::new(2)?;
///let max = NonZeroU64::new(u64::MAX)?;
/// assert_eq!(two, one.saturating_add(1));
/// assert_eq!(max, max.saturating_add(1));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_add(self, other: u64) -> std::num::NonZeroU64;

"#,
			r#"
/// Adds an unsigned integer to a non-zero value,
/// assuming overflow cannot occur.
/// Overflow is unchecked, and it is undefined behaviour to overflow
/// *even if the result would wrap to a non-zero value*.
/// The behaviour is undefined as soon as
///`self + rhs > u64::MAX`.
/// # Examples
/// ```
/// #![feature(nonzero_ops)]
///# use std::num::NonZeroU64;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let one = NonZeroU64::new(1)?;
///let two = NonZeroU64::new(2)?;
/// assert_eq!(two, unsafe { one.unchecked_add(1) });
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unchecked_add(self, other: u64) -> std::num::NonZeroU64;

"#,
			r#"
/// Returns the base 2 logarithm of the number, rounded down.
/// This is the same operation as
///[`u64::ilog2`],
/// except that it has no failure cases to worry about
/// since this value can never be zero.
/// # Examples
/// ```
///# use std::num::NonZeroU64;
///assert_eq!(NonZeroU64::new(7).unwrap().ilog2(), 2);
///assert_eq!(NonZeroU64::new(8).unwrap().ilog2(), 3);
///assert_eq!(NonZeroU64::new(9).unwrap().ilog2(), 3);
/// ```

    #[lua(kind = "Method")]
    fn ilog2(self) -> u32;

"#,
			r#"
/// Returns the base 10 logarithm of the number, rounded down.
/// This is the same operation as
///[`u64::ilog10`],
/// except that it has no failure cases to worry about
/// since this value can never be zero.
/// # Examples
/// ```
///# use std::num::NonZeroU64;
///assert_eq!(NonZeroU64::new(99).unwrap().ilog10(), 1);
///assert_eq!(NonZeroU64::new(100).unwrap().ilog10(), 2);
///assert_eq!(NonZeroU64::new(101).unwrap().ilog10(), 2);
/// ```

    #[lua(kind = "Method")]
    fn ilog10(self) -> u32;

"#,
			r#"
/// Calculates the middle point of `self` and `rhs`.
/// `midpoint(a, b)` is `(a + b) >> 1` as if it were performed in a
/// sufficiently-large signed integral type. This implies that the result is
/// always rounded towards negative infinity and that no overflow will ever occur.
/// # Examples
/// ```
/// #![feature(num_midpoint)]
///# use std::num::NonZeroU64;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let one = NonZeroU64::new(1)?;
///let two = NonZeroU64::new(2)?;
///let four = NonZeroU64::new(4)?;
/// assert_eq!(one.midpoint(four), two);
/// assert_eq!(four.midpoint(one), two);
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn midpoint(self, #[proxy] rhs: std::num::NonZeroU64) -> std::num::NonZeroU64;

"#,
			r#"
/// Returns `true` if and only if `self == (1 << k)` for some `k`.
/// On many architectures, this function can perform better than `is_power_of_two()`
/// on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let eight = std::num::NonZeroU64::new(8).unwrap();
/// assert!(eight.is_power_of_two());
///let ten = std::num::NonZeroU64::new(10).unwrap();
/// assert!(!ten.is_power_of_two());
/// ```

    #[lua(kind = "Method")]
    fn is_power_of_two(self) -> bool;

"#,
			r#"
/// Multiplies two non-zero integers together.
///Return [`NonZeroU64::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroU64;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroU64::new(2)?;
///let four = NonZeroU64::new(4)?;
///let max = NonZeroU64::new(u64::MAX)?;
/// assert_eq!(four, two.saturating_mul(two));
/// assert_eq!(max, four.saturating_mul(max));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_mul(
        self,
        #[proxy]
        other: std::num::NonZeroU64,
    ) -> std::num::NonZeroU64;

"#,
			r#"
/// Multiplies two non-zero integers together,
/// assuming overflow cannot occur.
/// Overflow is unchecked, and it is undefined behaviour to overflow
/// *even if the result would wrap to a non-zero value*.
/// The behaviour is undefined as soon as
///`self * rhs > u64::MAX`.
/// # Examples
/// ```
/// #![feature(nonzero_ops)]
///# use std::num::NonZeroU64;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroU64::new(2)?;
///let four = NonZeroU64::new(4)?;
/// assert_eq!(four, unsafe { two.unchecked_mul(two) });
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unchecked_mul(self, #[proxy] other: std::num::NonZeroU64) -> std::num::NonZeroU64;

"#,
			r#"
/// Raise non-zero value to an integer power.
///Return [`NonZeroU64::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroU64;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let three = NonZeroU64::new(3)?;
///let twenty_seven = NonZeroU64::new(27)?;
///let max = NonZeroU64::new(u64::MAX)?;
/// assert_eq!(twenty_seven, three.saturating_pow(3));
/// assert_eq!(max, max.saturating_pow(3));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_pow(self, other: u32) -> std::num::NonZeroU64;

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "Method",
        output(proxy),
    )]
    fn clone(&self) -> std::num::NonZeroU64;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Function", composite = "eq")]
    fn eq(&self, #[proxy] other: &std::num::NonZeroU64) -> bool;

"#,
			r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]



pub struct NonZeroU64(
    
    
        
    
    
);

    
/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroU128>` is the same size as `u128`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroU128>>(), size_of::<u128>());

/// ```

/// # Layout

///`NonZeroU128` is guaranteed to have the same layout and bit validity as `u128`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroU128>` is guaranteed to be compatible with `u128`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroU128` and `Option<NonZeroU128>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroU128;

///assert_eq!(size_of::<NonZeroU128>(), size_of::<Option<NonZeroU128>>());

///assert_eq!(align_of::<NonZeroU128>(), align_of::<Option<NonZeroU128>>());

/// ```

/// [null pointer optimization]: crate::option#representation


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroU128",
functions[r#"
/// Creates a non-zero without checking whether the value is non-zero.
/// This results in undefined behaviour if the value is zero.
/// # Safety
/// The value must not be zero.

    #[lua(kind = "Function", output(proxy))]
    fn new_unchecked(n: u128) -> std::num::NonZeroU128;

"#,
			r#"
/// Returns the value as a primitive type.

    #[lua(kind = "Method")]
    fn get(self) -> u128;

"#,
			r#"
/// Returns the number of leading zeros in the binary representation of `self`.
/// On many architectures, this function can perform better than `leading_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroU128::new(u128::MAX).unwrap();
/// assert_eq!(n.leading_zeros(), 0);
/// ```

    #[lua(kind = "Method")]
    fn leading_zeros(self) -> u32;

"#,
			r#"
/// Returns the number of trailing zeros in the binary representation
/// of `self`.
/// On many architectures, this function can perform better than `trailing_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroU128::new(0b0101000).unwrap();
/// assert_eq!(n.trailing_zeros(), 3);
/// ```

    #[lua(kind = "Method")]
    fn trailing_zeros(self) -> u32;

"#,
			r#"
/// Adds an unsigned integer to a non-zero value.
///Return [`NonZeroU128::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroU128;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let one = NonZeroU128::new(1)?;
///let two = NonZeroU128::new(2)?;
///let max = NonZeroU128::new(u128::MAX)?;
/// assert_eq!(two, one.saturating_add(1));
/// assert_eq!(max, max.saturating_add(1));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_add(self, other: u128) -> std::num::NonZeroU128;

"#,
			r#"
/// Adds an unsigned integer to a non-zero value,
/// assuming overflow cannot occur.
/// Overflow is unchecked, and it is undefined behaviour to overflow
/// *even if the result would wrap to a non-zero value*.
/// The behaviour is undefined as soon as
///`self + rhs > u128::MAX`.
/// # Examples
/// ```
/// #![feature(nonzero_ops)]
///# use std::num::NonZeroU128;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let one = NonZeroU128::new(1)?;
///let two = NonZeroU128::new(2)?;
/// assert_eq!(two, unsafe { one.unchecked_add(1) });
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unchecked_add(self, other: u128) -> std::num::NonZeroU128;

"#,
			r#"
/// Returns the base 2 logarithm of the number, rounded down.
/// This is the same operation as
///[`u128::ilog2`],
/// except that it has no failure cases to worry about
/// since this value can never be zero.
/// # Examples
/// ```
///# use std::num::NonZeroU128;
///assert_eq!(NonZeroU128::new(7).unwrap().ilog2(), 2);
///assert_eq!(NonZeroU128::new(8).unwrap().ilog2(), 3);
///assert_eq!(NonZeroU128::new(9).unwrap().ilog2(), 3);
/// ```

    #[lua(kind = "Method")]
    fn ilog2(self) -> u32;

"#,
			r#"
/// Returns the base 10 logarithm of the number, rounded down.
/// This is the same operation as
///[`u128::ilog10`],
/// except that it has no failure cases to worry about
/// since this value can never be zero.
/// # Examples
/// ```
///# use std::num::NonZeroU128;
///assert_eq!(NonZeroU128::new(99).unwrap().ilog10(), 1);
///assert_eq!(NonZeroU128::new(100).unwrap().ilog10(), 2);
///assert_eq!(NonZeroU128::new(101).unwrap().ilog10(), 2);
/// ```

    #[lua(kind = "Method")]
    fn ilog10(self) -> u32;

"#,
			r#"
/// Calculates the middle point of `self` and `rhs`.
/// `midpoint(a, b)` is `(a + b) >> 1` as if it were performed in a
/// sufficiently-large signed integral type. This implies that the result is
/// always rounded towards negative infinity and that no overflow will ever occur.
/// # Examples
/// ```
/// #![feature(num_midpoint)]
///# use std::num::NonZeroU128;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let one = NonZeroU128::new(1)?;
///let two = NonZeroU128::new(2)?;
///let four = NonZeroU128::new(4)?;
/// assert_eq!(one.midpoint(four), two);
/// assert_eq!(four.midpoint(one), two);
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn midpoint(self, #[proxy] rhs: std::num::NonZeroU128) -> std::num::NonZeroU128;

"#,
			r#"
/// Returns `true` if and only if `self == (1 << k)` for some `k`.
/// On many architectures, this function can perform better than `is_power_of_two()`
/// on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let eight = std::num::NonZeroU128::new(8).unwrap();
/// assert!(eight.is_power_of_two());
///let ten = std::num::NonZeroU128::new(10).unwrap();
/// assert!(!ten.is_power_of_two());
/// ```

    #[lua(kind = "Method")]
    fn is_power_of_two(self) -> bool;

"#,
			r#"
/// Multiplies two non-zero integers together.
///Return [`NonZeroU128::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroU128;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroU128::new(2)?;
///let four = NonZeroU128::new(4)?;
///let max = NonZeroU128::new(u128::MAX)?;
/// assert_eq!(four, two.saturating_mul(two));
/// assert_eq!(max, four.saturating_mul(max));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_mul(
        self,
        #[proxy]
        other: std::num::NonZeroU128,
    ) -> std::num::NonZeroU128;

"#,
			r#"
/// Multiplies two non-zero integers together,
/// assuming overflow cannot occur.
/// Overflow is unchecked, and it is undefined behaviour to overflow
/// *even if the result would wrap to a non-zero value*.
/// The behaviour is undefined as soon as
///`self * rhs > u128::MAX`.
/// # Examples
/// ```
/// #![feature(nonzero_ops)]
///# use std::num::NonZeroU128;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroU128::new(2)?;
///let four = NonZeroU128::new(4)?;
/// assert_eq!(four, unsafe { two.unchecked_mul(two) });
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unchecked_mul(
        self,
        #[proxy]
        other: std::num::NonZeroU128,
    ) -> std::num::NonZeroU128;

"#,
			r#"
/// Raise non-zero value to an integer power.
///Return [`NonZeroU128::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroU128;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let three = NonZeroU128::new(3)?;
///let twenty_seven = NonZeroU128::new(27)?;
///let max = NonZeroU128::new(u128::MAX)?;
/// assert_eq!(twenty_seven, three.saturating_pow(3));
/// assert_eq!(max, max.saturating_pow(3));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_pow(self, other: u32) -> std::num::NonZeroU128;

"#,
			r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "Method",
        output(proxy),
    )]
    fn clone(&self) -> std::num::NonZeroU128;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Function", composite = "eq")]
    fn eq(&self, #[proxy] other: &std::num::NonZeroU128) -> bool;

"#]
)]



pub struct NonZeroU128(
    
    
        
    
    
);

    
/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroUsize>` is the same size as `usize`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroUsize>>(), size_of::<usize>());

/// ```

/// # Layout

///`NonZeroUsize` is guaranteed to have the same layout and bit validity as `usize`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroUsize>` is guaranteed to be compatible with `usize`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroUsize` and `Option<NonZeroUsize>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroUsize;

///assert_eq!(size_of::<NonZeroUsize>(), size_of::<Option<NonZeroUsize>>());

///assert_eq!(align_of::<NonZeroUsize>(), align_of::<Option<NonZeroUsize>>());

/// ```

/// [null pointer optimization]: crate::option#representation


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroUsize",
functions[r#"
/// Creates a non-zero without checking whether the value is non-zero.
/// This results in undefined behaviour if the value is zero.
/// # Safety
/// The value must not be zero.

    #[lua(kind = "Function", output(proxy))]
    fn new_unchecked(n: usize) -> std::num::NonZeroUsize;

"#,
			r#"
/// Returns the value as a primitive type.

    #[lua(kind = "Method")]
    fn get(self) -> usize;

"#,
			r#"
/// Returns the number of leading zeros in the binary representation of `self`.
/// On many architectures, this function can perform better than `leading_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroUsize::new(usize::MAX).unwrap();
/// assert_eq!(n.leading_zeros(), 0);
/// ```

    #[lua(kind = "Method")]
    fn leading_zeros(self) -> u32;

"#,
			r#"
/// Returns the number of trailing zeros in the binary representation
/// of `self`.
/// On many architectures, this function can perform better than `trailing_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroUsize::new(0b0101000).unwrap();
/// assert_eq!(n.trailing_zeros(), 3);
/// ```

    #[lua(kind = "Method")]
    fn trailing_zeros(self) -> u32;

"#,
			r#"
/// Adds an unsigned integer to a non-zero value.
///Return [`NonZeroUsize::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroUsize;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let one = NonZeroUsize::new(1)?;
///let two = NonZeroUsize::new(2)?;
///let max = NonZeroUsize::new(usize::MAX)?;
/// assert_eq!(two, one.saturating_add(1));
/// assert_eq!(max, max.saturating_add(1));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_add(self, other: usize) -> std::num::NonZeroUsize;

"#,
			r#"
/// Adds an unsigned integer to a non-zero value,
/// assuming overflow cannot occur.
/// Overflow is unchecked, and it is undefined behaviour to overflow
/// *even if the result would wrap to a non-zero value*.
/// The behaviour is undefined as soon as
///`self + rhs > usize::MAX`.
/// # Examples
/// ```
/// #![feature(nonzero_ops)]
///# use std::num::NonZeroUsize;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let one = NonZeroUsize::new(1)?;
///let two = NonZeroUsize::new(2)?;
/// assert_eq!(two, unsafe { one.unchecked_add(1) });
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unchecked_add(self, other: usize) -> std::num::NonZeroUsize;

"#,
			r#"
/// Returns the base 2 logarithm of the number, rounded down.
/// This is the same operation as
///[`usize::ilog2`],
/// except that it has no failure cases to worry about
/// since this value can never be zero.
/// # Examples
/// ```
///# use std::num::NonZeroUsize;
///assert_eq!(NonZeroUsize::new(7).unwrap().ilog2(), 2);
///assert_eq!(NonZeroUsize::new(8).unwrap().ilog2(), 3);
///assert_eq!(NonZeroUsize::new(9).unwrap().ilog2(), 3);
/// ```

    #[lua(kind = "Method")]
    fn ilog2(self) -> u32;

"#,
			r#"
/// Returns the base 10 logarithm of the number, rounded down.
/// This is the same operation as
///[`usize::ilog10`],
/// except that it has no failure cases to worry about
/// since this value can never be zero.
/// # Examples
/// ```
///# use std::num::NonZeroUsize;
///assert_eq!(NonZeroUsize::new(99).unwrap().ilog10(), 1);
///assert_eq!(NonZeroUsize::new(100).unwrap().ilog10(), 2);
///assert_eq!(NonZeroUsize::new(101).unwrap().ilog10(), 2);
/// ```

    #[lua(kind = "Method")]
    fn ilog10(self) -> u32;

"#,
			r#"
/// Calculates the middle point of `self` and `rhs`.
/// `midpoint(a, b)` is `(a + b) >> 1` as if it were performed in a
/// sufficiently-large signed integral type. This implies that the result is
/// always rounded towards negative infinity and that no overflow will ever occur.
/// # Examples
/// ```
/// #![feature(num_midpoint)]
///# use std::num::NonZeroUsize;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let one = NonZeroUsize::new(1)?;
///let two = NonZeroUsize::new(2)?;
///let four = NonZeroUsize::new(4)?;
/// assert_eq!(one.midpoint(four), two);
/// assert_eq!(four.midpoint(one), two);
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn midpoint(self, #[proxy] rhs: std::num::NonZeroUsize) -> std::num::NonZeroUsize;

"#,
			r#"
/// Returns `true` if and only if `self == (1 << k)` for some `k`.
/// On many architectures, this function can perform better than `is_power_of_two()`
/// on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let eight = std::num::NonZeroUsize::new(8).unwrap();
/// assert!(eight.is_power_of_two());
///let ten = std::num::NonZeroUsize::new(10).unwrap();
/// assert!(!ten.is_power_of_two());
/// ```

    #[lua(kind = "Method")]
    fn is_power_of_two(self) -> bool;

"#,
			r#"
/// Multiplies two non-zero integers together.
///Return [`NonZeroUsize::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroUsize;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroUsize::new(2)?;
///let four = NonZeroUsize::new(4)?;
///let max = NonZeroUsize::new(usize::MAX)?;
/// assert_eq!(four, two.saturating_mul(two));
/// assert_eq!(max, four.saturating_mul(max));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_mul(
        self,
        #[proxy]
        other: std::num::NonZeroUsize,
    ) -> std::num::NonZeroUsize;

"#,
			r#"
/// Multiplies two non-zero integers together,
/// assuming overflow cannot occur.
/// Overflow is unchecked, and it is undefined behaviour to overflow
/// *even if the result would wrap to a non-zero value*.
/// The behaviour is undefined as soon as
///`self * rhs > usize::MAX`.
/// # Examples
/// ```
/// #![feature(nonzero_ops)]
///# use std::num::NonZeroUsize;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroUsize::new(2)?;
///let four = NonZeroUsize::new(4)?;
/// assert_eq!(four, unsafe { two.unchecked_mul(two) });
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unchecked_mul(
        self,
        #[proxy]
        other: std::num::NonZeroUsize,
    ) -> std::num::NonZeroUsize;

"#,
			r#"
/// Raise non-zero value to an integer power.
///Return [`NonZeroUsize::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroUsize;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let three = NonZeroUsize::new(3)?;
///let twenty_seven = NonZeroUsize::new(27)?;
///let max = NonZeroUsize::new(usize::MAX)?;
/// assert_eq!(twenty_seven, three.saturating_pow(3));
/// assert_eq!(max, max.saturating_pow(3));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_pow(self, other: u32) -> std::num::NonZeroUsize;

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "Method",
        output(proxy),
    )]
    fn clone(&self) -> std::num::NonZeroUsize;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Function", composite = "eq")]
    fn eq(&self, #[proxy] other: &std::num::NonZeroUsize) -> bool;

"#,
			r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]



pub struct NonZeroUsize(
    
    
        
    
    
);

    
/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroI8>` is the same size as `i8`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroI8>>(), size_of::<i8>());

/// ```

/// # Layout

///`NonZeroI8` is guaranteed to have the same layout and bit validity as `i8`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroI8>` is guaranteed to be compatible with `i8`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroI8` and `Option<NonZeroI8>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroI8;

///assert_eq!(size_of::<NonZeroI8>(), size_of::<Option<NonZeroI8>>());

///assert_eq!(align_of::<NonZeroI8>(), align_of::<Option<NonZeroI8>>());

/// ```

/// [null pointer optimization]: crate::option#representation


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroI8",
functions[r#"
/// Creates a non-zero without checking whether the value is non-zero.
/// This results in undefined behaviour if the value is zero.
/// # Safety
/// The value must not be zero.

    #[lua(kind = "Function", output(proxy))]
    fn new_unchecked(n: i8) -> std::num::NonZeroI8;

"#,
			r#"
/// Returns the value as a primitive type.

    #[lua(kind = "Method")]
    fn get(self) -> i8;

"#,
			r#"
/// Returns the number of leading zeros in the binary representation of `self`.
/// On many architectures, this function can perform better than `leading_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroI8::new(-1i8).unwrap();
/// assert_eq!(n.leading_zeros(), 0);
/// ```

    #[lua(kind = "Method")]
    fn leading_zeros(self) -> u32;

"#,
			r#"
/// Returns the number of trailing zeros in the binary representation
/// of `self`.
/// On many architectures, this function can perform better than `trailing_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroI8::new(0b0101000).unwrap();
/// assert_eq!(n.trailing_zeros(), 3);
/// ```

    #[lua(kind = "Method")]
    fn trailing_zeros(self) -> u32;

"#,
			r#"
/// Computes the absolute value of self.
///See [`i8::abs`]
/// for documentation on overflow behaviour.
/// # Example
/// ```
///# use std::num::NonZeroI8;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos = NonZeroI8::new(1)?;
///let neg = NonZeroI8::new(-1)?;
/// assert_eq!(pos, pos.abs());
/// assert_eq!(pos, neg.abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn abs(self) -> std::num::NonZeroI8;

"#,
			r#"
/// Saturating absolute value, see
///[`i8::saturating_abs`].
/// # Example
/// ```
///# use std::num::NonZeroI8;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos = NonZeroI8::new(1)?;
///let neg = NonZeroI8::new(-1)?;
///let min = NonZeroI8::new(i8::MIN)?;
///let min_plus = NonZeroI8::new(i8::MIN + 1)?;
///let max = NonZeroI8::new(i8::MAX)?;
/// assert_eq!(pos, pos.saturating_abs());
/// assert_eq!(pos, neg.saturating_abs());
/// assert_eq!(max, min.saturating_abs());
/// assert_eq!(max, min_plus.saturating_abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_abs(self) -> std::num::NonZeroI8;

"#,
			r#"
/// Wrapping absolute value, see
///[`i8::wrapping_abs`].
/// # Example
/// ```
///# use std::num::NonZeroI8;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos = NonZeroI8::new(1)?;
///let neg = NonZeroI8::new(-1)?;
///let min = NonZeroI8::new(i8::MIN)?;
///# let max = NonZeroI8::new(i8::MAX)?;
/// assert_eq!(pos, pos.wrapping_abs());
/// assert_eq!(pos, neg.wrapping_abs());
/// assert_eq!(min, min.wrapping_abs());
/// assert_eq!(max, (-max).wrapping_abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn wrapping_abs(self) -> std::num::NonZeroI8;

"#,
			r#"
/// Computes the absolute value of self
/// without any wrapping or panicking.
/// # Example
/// ```
///# use std::num::NonZeroI8;
///# use std::num::NonZeroU8;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let u_pos = NonZeroU8::new(1)?;
///let i_pos = NonZeroI8::new(1)?;
///let i_neg = NonZeroI8::new(-1)?;
///let i_min = NonZeroI8::new(i8::MIN)?;
///let u_max = NonZeroU8::new(u8::MAX / 2 + 1)?;
/// assert_eq!(u_pos, i_pos.unsigned_abs());
/// assert_eq!(u_pos, i_neg.unsigned_abs());
/// assert_eq!(u_max, i_min.unsigned_abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unsigned_abs(self) -> std::num::NonZeroU8;

"#,
			r#"
/// Returns `true` if `self` is positive and `false` if the
/// number is negative.
/// # Example
/// ```
///# use std::num::NonZeroI8;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI8::new(5)?;
///let neg_five = NonZeroI8::new(-5)?;
/// assert!(pos_five.is_positive());
/// assert!(!neg_five.is_positive());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method")]
    fn is_positive(self) -> bool;

"#,
			r#"
/// Returns `true` if `self` is negative and `false` if the
/// number is positive.
/// # Example
/// ```
///# use std::num::NonZeroI8;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI8::new(5)?;
///let neg_five = NonZeroI8::new(-5)?;
/// assert!(neg_five.is_negative());
/// assert!(!pos_five.is_negative());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method")]
    fn is_negative(self) -> bool;

"#,
			r#"
/// Saturating negation. Computes `-self`,
///returning [`NonZeroI8::MAX`]
///if `self == NonZeroI8::MIN`
/// instead of overflowing.
/// # Example
/// ```
///# use std::num::NonZeroI8;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI8::new(5)?;
///let neg_five = NonZeroI8::new(-5)?;
///let min = NonZeroI8::new(i8::MIN)?;
///let min_plus_one = NonZeroI8::new(i8::MIN + 1)?;
///let max = NonZeroI8::new(i8::MAX)?;
/// assert_eq!(pos_five.saturating_neg(), neg_five);
/// assert_eq!(min.saturating_neg(), max);
/// assert_eq!(max.saturating_neg(), min_plus_one);
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_neg(self) -> std::num::NonZeroI8;

"#,
			r#"
/// Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary
/// of the type.
///See [`i8::wrapping_neg`]
/// for documentation on overflow behaviour.
/// # Example
/// ```
///# use std::num::NonZeroI8;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI8::new(5)?;
///let neg_five = NonZeroI8::new(-5)?;
///let min = NonZeroI8::new(i8::MIN)?;
/// assert_eq!(pos_five.wrapping_neg(), neg_five);
/// assert_eq!(min.wrapping_neg(), min);
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn wrapping_neg(self) -> std::num::NonZeroI8;

"#,
			r#"
/// Multiplies two non-zero integers together.
///Return [`NonZeroI8::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroI8;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroI8::new(2)?;
///let four = NonZeroI8::new(4)?;
///let max = NonZeroI8::new(i8::MAX)?;
/// assert_eq!(four, two.saturating_mul(two));
/// assert_eq!(max, four.saturating_mul(max));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_mul(self, #[proxy] other: std::num::NonZeroI8) -> std::num::NonZeroI8;

"#,
			r#"
/// Multiplies two non-zero integers together,
/// assuming overflow cannot occur.
/// Overflow is unchecked, and it is undefined behaviour to overflow
/// *even if the result would wrap to a non-zero value*.
/// The behaviour is undefined as soon as
///`self * rhs > i8::MAX`, or `self * rhs < i8::MIN`.
/// # Examples
/// ```
/// #![feature(nonzero_ops)]
///# use std::num::NonZeroI8;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroI8::new(2)?;
///let four = NonZeroI8::new(4)?;
/// assert_eq!(four, unsafe { two.unchecked_mul(two) });
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unchecked_mul(self, #[proxy] other: std::num::NonZeroI8) -> std::num::NonZeroI8;

"#,
			r#"
/// Raise non-zero value to an integer power.
///Return [`NonZeroI8::MIN`] or [`NonZeroI8::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroI8;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let three = NonZeroI8::new(3)?;
///let twenty_seven = NonZeroI8::new(27)?;
///let max = NonZeroI8::new(i8::MAX)?;
/// assert_eq!(twenty_seven, three.saturating_pow(3));
/// assert_eq!(max, max.saturating_pow(3));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_pow(self, other: u32) -> std::num::NonZeroI8;

"#,
			r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(
        as_trait = "std::ops::Neg",
        kind = "Function",
        output(proxy),
        composite = "neg",
        metamethod = "Unm",
    )]
    fn neg(self) -> std::num::NonZeroI8;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Function", composite = "eq")]
    fn eq(&self, #[proxy] other: &std::num::NonZeroI8) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "Method",
        output(proxy),
    )]
    fn clone(&self) -> std::num::NonZeroI8;

"#]
)]



pub struct NonZeroI8(
    
    
        
    
    
);

    
/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroI16>` is the same size as `i16`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroI16>>(), size_of::<i16>());

/// ```

/// # Layout

///`NonZeroI16` is guaranteed to have the same layout and bit validity as `i16`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroI16>` is guaranteed to be compatible with `i16`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroI16` and `Option<NonZeroI16>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroI16;

///assert_eq!(size_of::<NonZeroI16>(), size_of::<Option<NonZeroI16>>());

///assert_eq!(align_of::<NonZeroI16>(), align_of::<Option<NonZeroI16>>());

/// ```

/// [null pointer optimization]: crate::option#representation


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroI16",
functions[r#"
/// Creates a non-zero without checking whether the value is non-zero.
/// This results in undefined behaviour if the value is zero.
/// # Safety
/// The value must not be zero.

    #[lua(kind = "Function", output(proxy))]
    fn new_unchecked(n: i16) -> std::num::NonZeroI16;

"#,
			r#"
/// Returns the value as a primitive type.

    #[lua(kind = "Method")]
    fn get(self) -> i16;

"#,
			r#"
/// Returns the number of leading zeros in the binary representation of `self`.
/// On many architectures, this function can perform better than `leading_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroI16::new(-1i16).unwrap();
/// assert_eq!(n.leading_zeros(), 0);
/// ```

    #[lua(kind = "Method")]
    fn leading_zeros(self) -> u32;

"#,
			r#"
/// Returns the number of trailing zeros in the binary representation
/// of `self`.
/// On many architectures, this function can perform better than `trailing_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroI16::new(0b0101000).unwrap();
/// assert_eq!(n.trailing_zeros(), 3);
/// ```

    #[lua(kind = "Method")]
    fn trailing_zeros(self) -> u32;

"#,
			r#"
/// Computes the absolute value of self.
///See [`i16::abs`]
/// for documentation on overflow behaviour.
/// # Example
/// ```
///# use std::num::NonZeroI16;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos = NonZeroI16::new(1)?;
///let neg = NonZeroI16::new(-1)?;
/// assert_eq!(pos, pos.abs());
/// assert_eq!(pos, neg.abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn abs(self) -> std::num::NonZeroI16;

"#,
			r#"
/// Saturating absolute value, see
///[`i16::saturating_abs`].
/// # Example
/// ```
///# use std::num::NonZeroI16;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos = NonZeroI16::new(1)?;
///let neg = NonZeroI16::new(-1)?;
///let min = NonZeroI16::new(i16::MIN)?;
///let min_plus = NonZeroI16::new(i16::MIN + 1)?;
///let max = NonZeroI16::new(i16::MAX)?;
/// assert_eq!(pos, pos.saturating_abs());
/// assert_eq!(pos, neg.saturating_abs());
/// assert_eq!(max, min.saturating_abs());
/// assert_eq!(max, min_plus.saturating_abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_abs(self) -> std::num::NonZeroI16;

"#,
			r#"
/// Wrapping absolute value, see
///[`i16::wrapping_abs`].
/// # Example
/// ```
///# use std::num::NonZeroI16;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos = NonZeroI16::new(1)?;
///let neg = NonZeroI16::new(-1)?;
///let min = NonZeroI16::new(i16::MIN)?;
///# let max = NonZeroI16::new(i16::MAX)?;
/// assert_eq!(pos, pos.wrapping_abs());
/// assert_eq!(pos, neg.wrapping_abs());
/// assert_eq!(min, min.wrapping_abs());
/// assert_eq!(max, (-max).wrapping_abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn wrapping_abs(self) -> std::num::NonZeroI16;

"#,
			r#"
/// Computes the absolute value of self
/// without any wrapping or panicking.
/// # Example
/// ```
///# use std::num::NonZeroI16;
///# use std::num::NonZeroU16;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let u_pos = NonZeroU16::new(1)?;
///let i_pos = NonZeroI16::new(1)?;
///let i_neg = NonZeroI16::new(-1)?;
///let i_min = NonZeroI16::new(i16::MIN)?;
///let u_max = NonZeroU16::new(u16::MAX / 2 + 1)?;
/// assert_eq!(u_pos, i_pos.unsigned_abs());
/// assert_eq!(u_pos, i_neg.unsigned_abs());
/// assert_eq!(u_max, i_min.unsigned_abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unsigned_abs(self) -> std::num::NonZeroU16;

"#,
			r#"
/// Returns `true` if `self` is positive and `false` if the
/// number is negative.
/// # Example
/// ```
///# use std::num::NonZeroI16;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI16::new(5)?;
///let neg_five = NonZeroI16::new(-5)?;
/// assert!(pos_five.is_positive());
/// assert!(!neg_five.is_positive());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method")]
    fn is_positive(self) -> bool;

"#,
			r#"
/// Returns `true` if `self` is negative and `false` if the
/// number is positive.
/// # Example
/// ```
///# use std::num::NonZeroI16;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI16::new(5)?;
///let neg_five = NonZeroI16::new(-5)?;
/// assert!(neg_five.is_negative());
/// assert!(!pos_five.is_negative());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method")]
    fn is_negative(self) -> bool;

"#,
			r#"
/// Saturating negation. Computes `-self`,
///returning [`NonZeroI16::MAX`]
///if `self == NonZeroI16::MIN`
/// instead of overflowing.
/// # Example
/// ```
///# use std::num::NonZeroI16;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI16::new(5)?;
///let neg_five = NonZeroI16::new(-5)?;
///let min = NonZeroI16::new(i16::MIN)?;
///let min_plus_one = NonZeroI16::new(i16::MIN + 1)?;
///let max = NonZeroI16::new(i16::MAX)?;
/// assert_eq!(pos_five.saturating_neg(), neg_five);
/// assert_eq!(min.saturating_neg(), max);
/// assert_eq!(max.saturating_neg(), min_plus_one);
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_neg(self) -> std::num::NonZeroI16;

"#,
			r#"
/// Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary
/// of the type.
///See [`i16::wrapping_neg`]
/// for documentation on overflow behaviour.
/// # Example
/// ```
///# use std::num::NonZeroI16;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI16::new(5)?;
///let neg_five = NonZeroI16::new(-5)?;
///let min = NonZeroI16::new(i16::MIN)?;
/// assert_eq!(pos_five.wrapping_neg(), neg_five);
/// assert_eq!(min.wrapping_neg(), min);
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn wrapping_neg(self) -> std::num::NonZeroI16;

"#,
			r#"
/// Multiplies two non-zero integers together.
///Return [`NonZeroI16::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroI16;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroI16::new(2)?;
///let four = NonZeroI16::new(4)?;
///let max = NonZeroI16::new(i16::MAX)?;
/// assert_eq!(four, two.saturating_mul(two));
/// assert_eq!(max, four.saturating_mul(max));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_mul(
        self,
        #[proxy]
        other: std::num::NonZeroI16,
    ) -> std::num::NonZeroI16;

"#,
			r#"
/// Multiplies two non-zero integers together,
/// assuming overflow cannot occur.
/// Overflow is unchecked, and it is undefined behaviour to overflow
/// *even if the result would wrap to a non-zero value*.
/// The behaviour is undefined as soon as
///`self * rhs > i16::MAX`, or `self * rhs < i16::MIN`.
/// # Examples
/// ```
/// #![feature(nonzero_ops)]
///# use std::num::NonZeroI16;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroI16::new(2)?;
///let four = NonZeroI16::new(4)?;
/// assert_eq!(four, unsafe { two.unchecked_mul(two) });
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unchecked_mul(self, #[proxy] other: std::num::NonZeroI16) -> std::num::NonZeroI16;

"#,
			r#"
/// Raise non-zero value to an integer power.
///Return [`NonZeroI16::MIN`] or [`NonZeroI16::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroI16;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let three = NonZeroI16::new(3)?;
///let twenty_seven = NonZeroI16::new(27)?;
///let max = NonZeroI16::new(i16::MAX)?;
/// assert_eq!(twenty_seven, three.saturating_pow(3));
/// assert_eq!(max, max.saturating_pow(3));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_pow(self, other: u32) -> std::num::NonZeroI16;

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "Method",
        output(proxy),
    )]
    fn clone(&self) -> std::num::NonZeroI16;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Function", composite = "eq")]
    fn eq(&self, #[proxy] other: &std::num::NonZeroI16) -> bool;

"#,
			r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(
        as_trait = "std::ops::Neg",
        kind = "Function",
        output(proxy),
        composite = "neg",
        metamethod = "Unm",
    )]
    fn neg(self) -> std::num::NonZeroI16;

"#]
)]



pub struct NonZeroI16(
    
    
        
    
    
);

    
/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroI32>` is the same size as `i32`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroI32>>(), size_of::<i32>());

/// ```

/// # Layout

///`NonZeroI32` is guaranteed to have the same layout and bit validity as `i32`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroI32>` is guaranteed to be compatible with `i32`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroI32` and `Option<NonZeroI32>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroI32;

///assert_eq!(size_of::<NonZeroI32>(), size_of::<Option<NonZeroI32>>());

///assert_eq!(align_of::<NonZeroI32>(), align_of::<Option<NonZeroI32>>());

/// ```

/// [null pointer optimization]: crate::option#representation


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroI32",
functions[r#"
/// Creates a non-zero without checking whether the value is non-zero.
/// This results in undefined behaviour if the value is zero.
/// # Safety
/// The value must not be zero.

    #[lua(kind = "Function", output(proxy))]
    fn new_unchecked(n: i32) -> std::num::NonZeroI32;

"#,
			r#"
/// Returns the value as a primitive type.

    #[lua(kind = "Method")]
    fn get(self) -> i32;

"#,
			r#"
/// Returns the number of leading zeros in the binary representation of `self`.
/// On many architectures, this function can perform better than `leading_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroI32::new(-1i32).unwrap();
/// assert_eq!(n.leading_zeros(), 0);
/// ```

    #[lua(kind = "Method")]
    fn leading_zeros(self) -> u32;

"#,
			r#"
/// Returns the number of trailing zeros in the binary representation
/// of `self`.
/// On many architectures, this function can perform better than `trailing_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroI32::new(0b0101000).unwrap();
/// assert_eq!(n.trailing_zeros(), 3);
/// ```

    #[lua(kind = "Method")]
    fn trailing_zeros(self) -> u32;

"#,
			r#"
/// Computes the absolute value of self.
///See [`i32::abs`]
/// for documentation on overflow behaviour.
/// # Example
/// ```
///# use std::num::NonZeroI32;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos = NonZeroI32::new(1)?;
///let neg = NonZeroI32::new(-1)?;
/// assert_eq!(pos, pos.abs());
/// assert_eq!(pos, neg.abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn abs(self) -> std::num::NonZeroI32;

"#,
			r#"
/// Saturating absolute value, see
///[`i32::saturating_abs`].
/// # Example
/// ```
///# use std::num::NonZeroI32;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos = NonZeroI32::new(1)?;
///let neg = NonZeroI32::new(-1)?;
///let min = NonZeroI32::new(i32::MIN)?;
///let min_plus = NonZeroI32::new(i32::MIN + 1)?;
///let max = NonZeroI32::new(i32::MAX)?;
/// assert_eq!(pos, pos.saturating_abs());
/// assert_eq!(pos, neg.saturating_abs());
/// assert_eq!(max, min.saturating_abs());
/// assert_eq!(max, min_plus.saturating_abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_abs(self) -> std::num::NonZeroI32;

"#,
			r#"
/// Wrapping absolute value, see
///[`i32::wrapping_abs`].
/// # Example
/// ```
///# use std::num::NonZeroI32;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos = NonZeroI32::new(1)?;
///let neg = NonZeroI32::new(-1)?;
///let min = NonZeroI32::new(i32::MIN)?;
///# let max = NonZeroI32::new(i32::MAX)?;
/// assert_eq!(pos, pos.wrapping_abs());
/// assert_eq!(pos, neg.wrapping_abs());
/// assert_eq!(min, min.wrapping_abs());
/// assert_eq!(max, (-max).wrapping_abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn wrapping_abs(self) -> std::num::NonZeroI32;

"#,
			r#"
/// Computes the absolute value of self
/// without any wrapping or panicking.
/// # Example
/// ```
///# use std::num::NonZeroI32;
///# use std::num::NonZeroU32;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let u_pos = NonZeroU32::new(1)?;
///let i_pos = NonZeroI32::new(1)?;
///let i_neg = NonZeroI32::new(-1)?;
///let i_min = NonZeroI32::new(i32::MIN)?;
///let u_max = NonZeroU32::new(u32::MAX / 2 + 1)?;
/// assert_eq!(u_pos, i_pos.unsigned_abs());
/// assert_eq!(u_pos, i_neg.unsigned_abs());
/// assert_eq!(u_max, i_min.unsigned_abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unsigned_abs(self) -> std::num::NonZeroU32;

"#,
			r#"
/// Returns `true` if `self` is positive and `false` if the
/// number is negative.
/// # Example
/// ```
///# use std::num::NonZeroI32;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI32::new(5)?;
///let neg_five = NonZeroI32::new(-5)?;
/// assert!(pos_five.is_positive());
/// assert!(!neg_five.is_positive());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method")]
    fn is_positive(self) -> bool;

"#,
			r#"
/// Returns `true` if `self` is negative and `false` if the
/// number is positive.
/// # Example
/// ```
///# use std::num::NonZeroI32;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI32::new(5)?;
///let neg_five = NonZeroI32::new(-5)?;
/// assert!(neg_five.is_negative());
/// assert!(!pos_five.is_negative());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method")]
    fn is_negative(self) -> bool;

"#,
			r#"
/// Saturating negation. Computes `-self`,
///returning [`NonZeroI32::MAX`]
///if `self == NonZeroI32::MIN`
/// instead of overflowing.
/// # Example
/// ```
///# use std::num::NonZeroI32;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI32::new(5)?;
///let neg_five = NonZeroI32::new(-5)?;
///let min = NonZeroI32::new(i32::MIN)?;
///let min_plus_one = NonZeroI32::new(i32::MIN + 1)?;
///let max = NonZeroI32::new(i32::MAX)?;
/// assert_eq!(pos_five.saturating_neg(), neg_five);
/// assert_eq!(min.saturating_neg(), max);
/// assert_eq!(max.saturating_neg(), min_plus_one);
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_neg(self) -> std::num::NonZeroI32;

"#,
			r#"
/// Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary
/// of the type.
///See [`i32::wrapping_neg`]
/// for documentation on overflow behaviour.
/// # Example
/// ```
///# use std::num::NonZeroI32;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI32::new(5)?;
///let neg_five = NonZeroI32::new(-5)?;
///let min = NonZeroI32::new(i32::MIN)?;
/// assert_eq!(pos_five.wrapping_neg(), neg_five);
/// assert_eq!(min.wrapping_neg(), min);
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn wrapping_neg(self) -> std::num::NonZeroI32;

"#,
			r#"
/// Multiplies two non-zero integers together.
///Return [`NonZeroI32::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroI32;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroI32::new(2)?;
///let four = NonZeroI32::new(4)?;
///let max = NonZeroI32::new(i32::MAX)?;
/// assert_eq!(four, two.saturating_mul(two));
/// assert_eq!(max, four.saturating_mul(max));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_mul(
        self,
        #[proxy]
        other: std::num::NonZeroI32,
    ) -> std::num::NonZeroI32;

"#,
			r#"
/// Multiplies two non-zero integers together,
/// assuming overflow cannot occur.
/// Overflow is unchecked, and it is undefined behaviour to overflow
/// *even if the result would wrap to a non-zero value*.
/// The behaviour is undefined as soon as
///`self * rhs > i32::MAX`, or `self * rhs < i32::MIN`.
/// # Examples
/// ```
/// #![feature(nonzero_ops)]
///# use std::num::NonZeroI32;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroI32::new(2)?;
///let four = NonZeroI32::new(4)?;
/// assert_eq!(four, unsafe { two.unchecked_mul(two) });
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unchecked_mul(self, #[proxy] other: std::num::NonZeroI32) -> std::num::NonZeroI32;

"#,
			r#"
/// Raise non-zero value to an integer power.
///Return [`NonZeroI32::MIN`] or [`NonZeroI32::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroI32;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let three = NonZeroI32::new(3)?;
///let twenty_seven = NonZeroI32::new(27)?;
///let max = NonZeroI32::new(i32::MAX)?;
/// assert_eq!(twenty_seven, three.saturating_pow(3));
/// assert_eq!(max, max.saturating_pow(3));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_pow(self, other: u32) -> std::num::NonZeroI32;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Function", composite = "eq")]
    fn eq(&self, #[proxy] other: &std::num::NonZeroI32) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "Method",
        output(proxy),
    )]
    fn clone(&self) -> std::num::NonZeroI32;

"#,
			r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(
        as_trait = "std::ops::Neg",
        kind = "Function",
        output(proxy),
        composite = "neg",
        metamethod = "Unm",
    )]
    fn neg(self) -> std::num::NonZeroI32;

"#]
)]



pub struct NonZeroI32(
    
    
        
    
    
);

    
/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroI64>` is the same size as `i64`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroI64>>(), size_of::<i64>());

/// ```

/// # Layout

///`NonZeroI64` is guaranteed to have the same layout and bit validity as `i64`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroI64>` is guaranteed to be compatible with `i64`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroI64` and `Option<NonZeroI64>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroI64;

///assert_eq!(size_of::<NonZeroI64>(), size_of::<Option<NonZeroI64>>());

///assert_eq!(align_of::<NonZeroI64>(), align_of::<Option<NonZeroI64>>());

/// ```

/// [null pointer optimization]: crate::option#representation


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroI64",
functions[r#"
/// Creates a non-zero without checking whether the value is non-zero.
/// This results in undefined behaviour if the value is zero.
/// # Safety
/// The value must not be zero.

    #[lua(kind = "Function", output(proxy))]
    fn new_unchecked(n: i64) -> std::num::NonZeroI64;

"#,
			r#"
/// Returns the value as a primitive type.

    #[lua(kind = "Method")]
    fn get(self) -> i64;

"#,
			r#"
/// Returns the number of leading zeros in the binary representation of `self`.
/// On many architectures, this function can perform better than `leading_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroI64::new(-1i64).unwrap();
/// assert_eq!(n.leading_zeros(), 0);
/// ```

    #[lua(kind = "Method")]
    fn leading_zeros(self) -> u32;

"#,
			r#"
/// Returns the number of trailing zeros in the binary representation
/// of `self`.
/// On many architectures, this function can perform better than `trailing_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroI64::new(0b0101000).unwrap();
/// assert_eq!(n.trailing_zeros(), 3);
/// ```

    #[lua(kind = "Method")]
    fn trailing_zeros(self) -> u32;

"#,
			r#"
/// Computes the absolute value of self.
///See [`i64::abs`]
/// for documentation on overflow behaviour.
/// # Example
/// ```
///# use std::num::NonZeroI64;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos = NonZeroI64::new(1)?;
///let neg = NonZeroI64::new(-1)?;
/// assert_eq!(pos, pos.abs());
/// assert_eq!(pos, neg.abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn abs(self) -> std::num::NonZeroI64;

"#,
			r#"
/// Saturating absolute value, see
///[`i64::saturating_abs`].
/// # Example
/// ```
///# use std::num::NonZeroI64;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos = NonZeroI64::new(1)?;
///let neg = NonZeroI64::new(-1)?;
///let min = NonZeroI64::new(i64::MIN)?;
///let min_plus = NonZeroI64::new(i64::MIN + 1)?;
///let max = NonZeroI64::new(i64::MAX)?;
/// assert_eq!(pos, pos.saturating_abs());
/// assert_eq!(pos, neg.saturating_abs());
/// assert_eq!(max, min.saturating_abs());
/// assert_eq!(max, min_plus.saturating_abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_abs(self) -> std::num::NonZeroI64;

"#,
			r#"
/// Wrapping absolute value, see
///[`i64::wrapping_abs`].
/// # Example
/// ```
///# use std::num::NonZeroI64;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos = NonZeroI64::new(1)?;
///let neg = NonZeroI64::new(-1)?;
///let min = NonZeroI64::new(i64::MIN)?;
///# let max = NonZeroI64::new(i64::MAX)?;
/// assert_eq!(pos, pos.wrapping_abs());
/// assert_eq!(pos, neg.wrapping_abs());
/// assert_eq!(min, min.wrapping_abs());
/// assert_eq!(max, (-max).wrapping_abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn wrapping_abs(self) -> std::num::NonZeroI64;

"#,
			r#"
/// Computes the absolute value of self
/// without any wrapping or panicking.
/// # Example
/// ```
///# use std::num::NonZeroI64;
///# use std::num::NonZeroU64;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let u_pos = NonZeroU64::new(1)?;
///let i_pos = NonZeroI64::new(1)?;
///let i_neg = NonZeroI64::new(-1)?;
///let i_min = NonZeroI64::new(i64::MIN)?;
///let u_max = NonZeroU64::new(u64::MAX / 2 + 1)?;
/// assert_eq!(u_pos, i_pos.unsigned_abs());
/// assert_eq!(u_pos, i_neg.unsigned_abs());
/// assert_eq!(u_max, i_min.unsigned_abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unsigned_abs(self) -> std::num::NonZeroU64;

"#,
			r#"
/// Returns `true` if `self` is positive and `false` if the
/// number is negative.
/// # Example
/// ```
///# use std::num::NonZeroI64;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI64::new(5)?;
///let neg_five = NonZeroI64::new(-5)?;
/// assert!(pos_five.is_positive());
/// assert!(!neg_five.is_positive());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method")]
    fn is_positive(self) -> bool;

"#,
			r#"
/// Returns `true` if `self` is negative and `false` if the
/// number is positive.
/// # Example
/// ```
///# use std::num::NonZeroI64;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI64::new(5)?;
///let neg_five = NonZeroI64::new(-5)?;
/// assert!(neg_five.is_negative());
/// assert!(!pos_five.is_negative());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method")]
    fn is_negative(self) -> bool;

"#,
			r#"
/// Saturating negation. Computes `-self`,
///returning [`NonZeroI64::MAX`]
///if `self == NonZeroI64::MIN`
/// instead of overflowing.
/// # Example
/// ```
///# use std::num::NonZeroI64;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI64::new(5)?;
///let neg_five = NonZeroI64::new(-5)?;
///let min = NonZeroI64::new(i64::MIN)?;
///let min_plus_one = NonZeroI64::new(i64::MIN + 1)?;
///let max = NonZeroI64::new(i64::MAX)?;
/// assert_eq!(pos_five.saturating_neg(), neg_five);
/// assert_eq!(min.saturating_neg(), max);
/// assert_eq!(max.saturating_neg(), min_plus_one);
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_neg(self) -> std::num::NonZeroI64;

"#,
			r#"
/// Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary
/// of the type.
///See [`i64::wrapping_neg`]
/// for documentation on overflow behaviour.
/// # Example
/// ```
///# use std::num::NonZeroI64;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI64::new(5)?;
///let neg_five = NonZeroI64::new(-5)?;
///let min = NonZeroI64::new(i64::MIN)?;
/// assert_eq!(pos_five.wrapping_neg(), neg_five);
/// assert_eq!(min.wrapping_neg(), min);
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn wrapping_neg(self) -> std::num::NonZeroI64;

"#,
			r#"
/// Multiplies two non-zero integers together.
///Return [`NonZeroI64::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroI64;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroI64::new(2)?;
///let four = NonZeroI64::new(4)?;
///let max = NonZeroI64::new(i64::MAX)?;
/// assert_eq!(four, two.saturating_mul(two));
/// assert_eq!(max, four.saturating_mul(max));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_mul(
        self,
        #[proxy]
        other: std::num::NonZeroI64,
    ) -> std::num::NonZeroI64;

"#,
			r#"
/// Multiplies two non-zero integers together,
/// assuming overflow cannot occur.
/// Overflow is unchecked, and it is undefined behaviour to overflow
/// *even if the result would wrap to a non-zero value*.
/// The behaviour is undefined as soon as
///`self * rhs > i64::MAX`, or `self * rhs < i64::MIN`.
/// # Examples
/// ```
/// #![feature(nonzero_ops)]
///# use std::num::NonZeroI64;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroI64::new(2)?;
///let four = NonZeroI64::new(4)?;
/// assert_eq!(four, unsafe { two.unchecked_mul(two) });
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unchecked_mul(self, #[proxy] other: std::num::NonZeroI64) -> std::num::NonZeroI64;

"#,
			r#"
/// Raise non-zero value to an integer power.
///Return [`NonZeroI64::MIN`] or [`NonZeroI64::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroI64;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let three = NonZeroI64::new(3)?;
///let twenty_seven = NonZeroI64::new(27)?;
///let max = NonZeroI64::new(i64::MAX)?;
/// assert_eq!(twenty_seven, three.saturating_pow(3));
/// assert_eq!(max, max.saturating_pow(3));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_pow(self, other: u32) -> std::num::NonZeroI64;

"#,
			r#"

    #[lua(
        as_trait = "std::ops::Neg",
        kind = "Function",
        output(proxy),
        composite = "neg",
        metamethod = "Unm",
    )]
    fn neg(self) -> std::num::NonZeroI64;

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "Method",
        output(proxy),
    )]
    fn clone(&self) -> std::num::NonZeroI64;

"#,
			r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Function", composite = "eq")]
    fn eq(&self, #[proxy] other: &std::num::NonZeroI64) -> bool;

"#]
)]



pub struct NonZeroI64(
    
    
        
    
    
);

    
/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroI128>` is the same size as `i128`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroI128>>(), size_of::<i128>());

/// ```

/// # Layout

///`NonZeroI128` is guaranteed to have the same layout and bit validity as `i128`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroI128>` is guaranteed to be compatible with `i128`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroI128` and `Option<NonZeroI128>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroI128;

///assert_eq!(size_of::<NonZeroI128>(), size_of::<Option<NonZeroI128>>());

///assert_eq!(align_of::<NonZeroI128>(), align_of::<Option<NonZeroI128>>());

/// ```

/// [null pointer optimization]: crate::option#representation


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroI128",
functions[r#"
/// Creates a non-zero without checking whether the value is non-zero.
/// This results in undefined behaviour if the value is zero.
/// # Safety
/// The value must not be zero.

    #[lua(kind = "Function", output(proxy))]
    fn new_unchecked(n: i128) -> std::num::NonZeroI128;

"#,
			r#"
/// Returns the value as a primitive type.

    #[lua(kind = "Method")]
    fn get(self) -> i128;

"#,
			r#"
/// Returns the number of leading zeros in the binary representation of `self`.
/// On many architectures, this function can perform better than `leading_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroI128::new(-1i128).unwrap();
/// assert_eq!(n.leading_zeros(), 0);
/// ```

    #[lua(kind = "Method")]
    fn leading_zeros(self) -> u32;

"#,
			r#"
/// Returns the number of trailing zeros in the binary representation
/// of `self`.
/// On many architectures, this function can perform better than `trailing_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroI128::new(0b0101000).unwrap();
/// assert_eq!(n.trailing_zeros(), 3);
/// ```

    #[lua(kind = "Method")]
    fn trailing_zeros(self) -> u32;

"#,
			r#"
/// Computes the absolute value of self.
///See [`i128::abs`]
/// for documentation on overflow behaviour.
/// # Example
/// ```
///# use std::num::NonZeroI128;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos = NonZeroI128::new(1)?;
///let neg = NonZeroI128::new(-1)?;
/// assert_eq!(pos, pos.abs());
/// assert_eq!(pos, neg.abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn abs(self) -> std::num::NonZeroI128;

"#,
			r#"
/// Saturating absolute value, see
///[`i128::saturating_abs`].
/// # Example
/// ```
///# use std::num::NonZeroI128;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos = NonZeroI128::new(1)?;
///let neg = NonZeroI128::new(-1)?;
///let min = NonZeroI128::new(i128::MIN)?;
///let min_plus = NonZeroI128::new(i128::MIN + 1)?;
///let max = NonZeroI128::new(i128::MAX)?;
/// assert_eq!(pos, pos.saturating_abs());
/// assert_eq!(pos, neg.saturating_abs());
/// assert_eq!(max, min.saturating_abs());
/// assert_eq!(max, min_plus.saturating_abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_abs(self) -> std::num::NonZeroI128;

"#,
			r#"
/// Wrapping absolute value, see
///[`i128::wrapping_abs`].
/// # Example
/// ```
///# use std::num::NonZeroI128;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos = NonZeroI128::new(1)?;
///let neg = NonZeroI128::new(-1)?;
///let min = NonZeroI128::new(i128::MIN)?;
///# let max = NonZeroI128::new(i128::MAX)?;
/// assert_eq!(pos, pos.wrapping_abs());
/// assert_eq!(pos, neg.wrapping_abs());
/// assert_eq!(min, min.wrapping_abs());
/// assert_eq!(max, (-max).wrapping_abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn wrapping_abs(self) -> std::num::NonZeroI128;

"#,
			r#"
/// Computes the absolute value of self
/// without any wrapping or panicking.
/// # Example
/// ```
///# use std::num::NonZeroI128;
///# use std::num::NonZeroU128;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let u_pos = NonZeroU128::new(1)?;
///let i_pos = NonZeroI128::new(1)?;
///let i_neg = NonZeroI128::new(-1)?;
///let i_min = NonZeroI128::new(i128::MIN)?;
///let u_max = NonZeroU128::new(u128::MAX / 2 + 1)?;
/// assert_eq!(u_pos, i_pos.unsigned_abs());
/// assert_eq!(u_pos, i_neg.unsigned_abs());
/// assert_eq!(u_max, i_min.unsigned_abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unsigned_abs(self) -> std::num::NonZeroU128;

"#,
			r#"
/// Returns `true` if `self` is positive and `false` if the
/// number is negative.
/// # Example
/// ```
///# use std::num::NonZeroI128;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI128::new(5)?;
///let neg_five = NonZeroI128::new(-5)?;
/// assert!(pos_five.is_positive());
/// assert!(!neg_five.is_positive());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method")]
    fn is_positive(self) -> bool;

"#,
			r#"
/// Returns `true` if `self` is negative and `false` if the
/// number is positive.
/// # Example
/// ```
///# use std::num::NonZeroI128;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI128::new(5)?;
///let neg_five = NonZeroI128::new(-5)?;
/// assert!(neg_five.is_negative());
/// assert!(!pos_five.is_negative());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method")]
    fn is_negative(self) -> bool;

"#,
			r#"
/// Saturating negation. Computes `-self`,
///returning [`NonZeroI128::MAX`]
///if `self == NonZeroI128::MIN`
/// instead of overflowing.
/// # Example
/// ```
///# use std::num::NonZeroI128;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI128::new(5)?;
///let neg_five = NonZeroI128::new(-5)?;
///let min = NonZeroI128::new(i128::MIN)?;
///let min_plus_one = NonZeroI128::new(i128::MIN + 1)?;
///let max = NonZeroI128::new(i128::MAX)?;
/// assert_eq!(pos_five.saturating_neg(), neg_five);
/// assert_eq!(min.saturating_neg(), max);
/// assert_eq!(max.saturating_neg(), min_plus_one);
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_neg(self) -> std::num::NonZeroI128;

"#,
			r#"
/// Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary
/// of the type.
///See [`i128::wrapping_neg`]
/// for documentation on overflow behaviour.
/// # Example
/// ```
///# use std::num::NonZeroI128;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroI128::new(5)?;
///let neg_five = NonZeroI128::new(-5)?;
///let min = NonZeroI128::new(i128::MIN)?;
/// assert_eq!(pos_five.wrapping_neg(), neg_five);
/// assert_eq!(min.wrapping_neg(), min);
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn wrapping_neg(self) -> std::num::NonZeroI128;

"#,
			r#"
/// Multiplies two non-zero integers together.
///Return [`NonZeroI128::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroI128;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroI128::new(2)?;
///let four = NonZeroI128::new(4)?;
///let max = NonZeroI128::new(i128::MAX)?;
/// assert_eq!(four, two.saturating_mul(two));
/// assert_eq!(max, four.saturating_mul(max));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_mul(
        self,
        #[proxy]
        other: std::num::NonZeroI128,
    ) -> std::num::NonZeroI128;

"#,
			r#"
/// Multiplies two non-zero integers together,
/// assuming overflow cannot occur.
/// Overflow is unchecked, and it is undefined behaviour to overflow
/// *even if the result would wrap to a non-zero value*.
/// The behaviour is undefined as soon as
///`self * rhs > i128::MAX`, or `self * rhs < i128::MIN`.
/// # Examples
/// ```
/// #![feature(nonzero_ops)]
///# use std::num::NonZeroI128;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroI128::new(2)?;
///let four = NonZeroI128::new(4)?;
/// assert_eq!(four, unsafe { two.unchecked_mul(two) });
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unchecked_mul(
        self,
        #[proxy]
        other: std::num::NonZeroI128,
    ) -> std::num::NonZeroI128;

"#,
			r#"
/// Raise non-zero value to an integer power.
///Return [`NonZeroI128::MIN`] or [`NonZeroI128::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroI128;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let three = NonZeroI128::new(3)?;
///let twenty_seven = NonZeroI128::new(27)?;
///let max = NonZeroI128::new(i128::MAX)?;
/// assert_eq!(twenty_seven, three.saturating_pow(3));
/// assert_eq!(max, max.saturating_pow(3));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_pow(self, other: u32) -> std::num::NonZeroI128;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Function", composite = "eq")]
    fn eq(&self, #[proxy] other: &std::num::NonZeroI128) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "Method",
        output(proxy),
    )]
    fn clone(&self) -> std::num::NonZeroI128;

"#,
			r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(
        as_trait = "std::ops::Neg",
        kind = "Function",
        output(proxy),
        composite = "neg",
        metamethod = "Unm",
    )]
    fn neg(self) -> std::num::NonZeroI128;

"#]
)]



pub struct NonZeroI128(
    
    
        
    
    
);

    
/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroIsize>` is the same size as `isize`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroIsize>>(), size_of::<isize>());

/// ```

/// # Layout

///`NonZeroIsize` is guaranteed to have the same layout and bit validity as `isize`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroIsize>` is guaranteed to be compatible with `isize`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroIsize` and `Option<NonZeroIsize>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroIsize;

///assert_eq!(size_of::<NonZeroIsize>(), size_of::<Option<NonZeroIsize>>());

///assert_eq!(align_of::<NonZeroIsize>(), align_of::<Option<NonZeroIsize>>());

/// ```

/// [null pointer optimization]: crate::option#representation


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroIsize",
functions[r#"
/// Creates a non-zero without checking whether the value is non-zero.
/// This results in undefined behaviour if the value is zero.
/// # Safety
/// The value must not be zero.

    #[lua(kind = "Function", output(proxy))]
    fn new_unchecked(n: isize) -> std::num::NonZeroIsize;

"#,
			r#"
/// Returns the value as a primitive type.

    #[lua(kind = "Method")]
    fn get(self) -> isize;

"#,
			r#"
/// Returns the number of leading zeros in the binary representation of `self`.
/// On many architectures, this function can perform better than `leading_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroIsize::new(-1isize).unwrap();
/// assert_eq!(n.leading_zeros(), 0);
/// ```

    #[lua(kind = "Method")]
    fn leading_zeros(self) -> u32;

"#,
			r#"
/// Returns the number of trailing zeros in the binary representation
/// of `self`.
/// On many architectures, this function can perform better than `trailing_zeros()` on the underlying integer type, as special handling of zero can be avoided.
/// # Examples
/// Basic usage:
/// ```
///let n = std::num::NonZeroIsize::new(0b0101000).unwrap();
/// assert_eq!(n.trailing_zeros(), 3);
/// ```

    #[lua(kind = "Method")]
    fn trailing_zeros(self) -> u32;

"#,
			r#"
/// Computes the absolute value of self.
///See [`isize::abs`]
/// for documentation on overflow behaviour.
/// # Example
/// ```
///# use std::num::NonZeroIsize;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos = NonZeroIsize::new(1)?;
///let neg = NonZeroIsize::new(-1)?;
/// assert_eq!(pos, pos.abs());
/// assert_eq!(pos, neg.abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn abs(self) -> std::num::NonZeroIsize;

"#,
			r#"
/// Saturating absolute value, see
///[`isize::saturating_abs`].
/// # Example
/// ```
///# use std::num::NonZeroIsize;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos = NonZeroIsize::new(1)?;
///let neg = NonZeroIsize::new(-1)?;
///let min = NonZeroIsize::new(isize::MIN)?;
///let min_plus = NonZeroIsize::new(isize::MIN + 1)?;
///let max = NonZeroIsize::new(isize::MAX)?;
/// assert_eq!(pos, pos.saturating_abs());
/// assert_eq!(pos, neg.saturating_abs());
/// assert_eq!(max, min.saturating_abs());
/// assert_eq!(max, min_plus.saturating_abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_abs(self) -> std::num::NonZeroIsize;

"#,
			r#"
/// Wrapping absolute value, see
///[`isize::wrapping_abs`].
/// # Example
/// ```
///# use std::num::NonZeroIsize;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos = NonZeroIsize::new(1)?;
///let neg = NonZeroIsize::new(-1)?;
///let min = NonZeroIsize::new(isize::MIN)?;
///# let max = NonZeroIsize::new(isize::MAX)?;
/// assert_eq!(pos, pos.wrapping_abs());
/// assert_eq!(pos, neg.wrapping_abs());
/// assert_eq!(min, min.wrapping_abs());
/// assert_eq!(max, (-max).wrapping_abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn wrapping_abs(self) -> std::num::NonZeroIsize;

"#,
			r#"
/// Computes the absolute value of self
/// without any wrapping or panicking.
/// # Example
/// ```
///# use std::num::NonZeroIsize;
///# use std::num::NonZeroUsize;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let u_pos = NonZeroUsize::new(1)?;
///let i_pos = NonZeroIsize::new(1)?;
///let i_neg = NonZeroIsize::new(-1)?;
///let i_min = NonZeroIsize::new(isize::MIN)?;
///let u_max = NonZeroUsize::new(usize::MAX / 2 + 1)?;
/// assert_eq!(u_pos, i_pos.unsigned_abs());
/// assert_eq!(u_pos, i_neg.unsigned_abs());
/// assert_eq!(u_max, i_min.unsigned_abs());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unsigned_abs(self) -> std::num::NonZeroUsize;

"#,
			r#"
/// Returns `true` if `self` is positive and `false` if the
/// number is negative.
/// # Example
/// ```
///# use std::num::NonZeroIsize;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroIsize::new(5)?;
///let neg_five = NonZeroIsize::new(-5)?;
/// assert!(pos_five.is_positive());
/// assert!(!neg_five.is_positive());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method")]
    fn is_positive(self) -> bool;

"#,
			r#"
/// Returns `true` if `self` is negative and `false` if the
/// number is positive.
/// # Example
/// ```
///# use std::num::NonZeroIsize;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroIsize::new(5)?;
///let neg_five = NonZeroIsize::new(-5)?;
/// assert!(neg_five.is_negative());
/// assert!(!pos_five.is_negative());
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method")]
    fn is_negative(self) -> bool;

"#,
			r#"
/// Saturating negation. Computes `-self`,
///returning [`NonZeroIsize::MAX`]
///if `self == NonZeroIsize::MIN`
/// instead of overflowing.
/// # Example
/// ```
///# use std::num::NonZeroIsize;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroIsize::new(5)?;
///let neg_five = NonZeroIsize::new(-5)?;
///let min = NonZeroIsize::new(isize::MIN)?;
///let min_plus_one = NonZeroIsize::new(isize::MIN + 1)?;
///let max = NonZeroIsize::new(isize::MAX)?;
/// assert_eq!(pos_five.saturating_neg(), neg_five);
/// assert_eq!(min.saturating_neg(), max);
/// assert_eq!(max.saturating_neg(), min_plus_one);
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_neg(self) -> std::num::NonZeroIsize;

"#,
			r#"
/// Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary
/// of the type.
///See [`isize::wrapping_neg`]
/// for documentation on overflow behaviour.
/// # Example
/// ```
///# use std::num::NonZeroIsize;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let pos_five = NonZeroIsize::new(5)?;
///let neg_five = NonZeroIsize::new(-5)?;
///let min = NonZeroIsize::new(isize::MIN)?;
/// assert_eq!(pos_five.wrapping_neg(), neg_five);
/// assert_eq!(min.wrapping_neg(), min);
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn wrapping_neg(self) -> std::num::NonZeroIsize;

"#,
			r#"
/// Multiplies two non-zero integers together.
///Return [`NonZeroIsize::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroIsize;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroIsize::new(2)?;
///let four = NonZeroIsize::new(4)?;
///let max = NonZeroIsize::new(isize::MAX)?;
/// assert_eq!(four, two.saturating_mul(two));
/// assert_eq!(max, four.saturating_mul(max));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_mul(
        self,
        #[proxy]
        other: std::num::NonZeroIsize,
    ) -> std::num::NonZeroIsize;

"#,
			r#"
/// Multiplies two non-zero integers together,
/// assuming overflow cannot occur.
/// Overflow is unchecked, and it is undefined behaviour to overflow
/// *even if the result would wrap to a non-zero value*.
/// The behaviour is undefined as soon as
///`self * rhs > isize::MAX`, or `self * rhs < isize::MIN`.
/// # Examples
/// ```
/// #![feature(nonzero_ops)]
///# use std::num::NonZeroIsize;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let two = NonZeroIsize::new(2)?;
///let four = NonZeroIsize::new(4)?;
/// assert_eq!(four, unsafe { two.unchecked_mul(two) });
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn unchecked_mul(
        self,
        #[proxy]
        other: std::num::NonZeroIsize,
    ) -> std::num::NonZeroIsize;

"#,
			r#"
/// Raise non-zero value to an integer power.
///Return [`NonZeroIsize::MIN`] or [`NonZeroIsize::MAX`] on overflow.
/// # Examples
/// ```
///# use std::num::NonZeroIsize;
/// # fn main() { test().unwrap(); }
/// # fn test() -> Option<()> {
///let three = NonZeroIsize::new(3)?;
///let twenty_seven = NonZeroIsize::new(27)?;
///let max = NonZeroIsize::new(isize::MAX)?;
/// assert_eq!(twenty_seven, three.saturating_pow(3));
/// assert_eq!(max, max.saturating_pow(3));
/// # Some(())
/// # }
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_pow(self, other: u32) -> std::num::NonZeroIsize;

"#,
			r#"

    #[lua(
        as_trait = "std::ops::Neg",
        kind = "Function",
        output(proxy),
        composite = "neg",
        metamethod = "Unm",
    )]
    fn neg(self) -> std::num::NonZeroIsize;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Function", composite = "eq")]
    fn eq(&self, #[proxy] other: &std::num::NonZeroIsize) -> bool;

"#,
			r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "Method",
        output(proxy),
    )]
    fn clone(&self) -> std::num::NonZeroIsize;

"#]
)]



pub struct NonZeroIsize(
    
    
        
    
    
);

    
/// An unbounded range (`..`).

/// `RangeFull` is primarily used as a [slicing index], its shorthand is `..`.

/// It cannot serve as an [`Iterator`] because it doesn't have a starting point.

/// # Examples

/// The `..` syntax is a `RangeFull`:

/// ```

/// assert_eq!(.., std::ops::RangeFull);

/// ```

/// It does not have an [`IntoIterator`] implementation, so you can't use it in

/// a `for` loop directly. This won't compile:

/// ```compile_fail,E0277

/// for i in .. {

///     // ...

/// }

/// ```

/// Used as a [slicing index], `RangeFull` produces the full array as a slice.

/// ```

/// let arr = [0, 1, 2, 3, 4];

/// assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]); // This is the `RangeFull`

/// assert_eq!(arr[ .. 3], [0, 1, 2      ]);

/// assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);

/// assert_eq!(arr[1..  ], [   1, 2, 3, 4]);

/// assert_eq!(arr[1.. 3], [   1, 2      ]);

/// assert_eq!(arr[1..=3], [   1, 2, 3   ]);

/// ```

/// [slicing index]: crate::slice::SliceIndex


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::ops::RangeFull",
functions[r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "Method",
        output(proxy),
    )]
    fn clone(&self) -> std::ops::RangeFull;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Function", composite = "eq")]
    fn eq(&self, #[proxy] other: &std::ops::RangeFull) -> bool;

"#,
			r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]




pub struct RangeFull{
    
    
    
}

    
/// A `Duration` type to represent a span of time, typically used for system

/// timeouts.

/// Each `Duration` is composed of a whole number of seconds and a fractional part

/// represented in nanoseconds. If the underlying system does not support

/// nanosecond-level precision, APIs binding a system timeout will typically round up

/// the number of nanoseconds.

/// [`Duration`]s implement many common traits, including [`Add`], [`Sub`], and other

/// [`ops`] traits. It implements [`Default`] by returning a zero-length `Duration`.

/// [`ops`]: crate::ops

/// # Examples

/// ```

/// use std::time::Duration;

/// let five_seconds = Duration::new(5, 0);

/// let five_seconds_and_five_nanos = five_seconds + Duration::new(0, 5);

/// assert_eq!(five_seconds_and_five_nanos.as_secs(), 5);

/// assert_eq!(five_seconds_and_five_nanos.subsec_nanos(), 5);

/// let ten_millis = Duration::from_millis(10);

/// ```

/// # Formatting `Duration` values

/// `Duration` intentionally does not have a `Display` impl, as there are a

/// variety of ways to format spans of time for human readability. `Duration`

/// provides a `Debug` impl that shows the full precision of the value.

/// The `Debug` output uses the non-ASCII "Âµs" suffix for microseconds. If your

/// program output may appear in contexts that cannot rely on full Unicode

/// compatibility, you may wish to format `Duration` objects yourself or use a

/// crate to do so.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="bevy::utils::Duration",
functions[r#"
/// Creates a new `Duration` from the specified number of whole seconds and
/// additional nanoseconds.
/// If the number of nanoseconds is greater than 1 billion (the number of
/// nanoseconds in a second), then it will carry over into the seconds provided.
/// # Panics
/// This constructor will panic if the carry from the nanoseconds overflows
/// the seconds counter.
/// # Examples
/// ```
/// use std::time::Duration;
/// let five_seconds = Duration::new(5, 0);
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn new(secs: u64, nanos: u32) -> bevy::utils::Duration;

"#,
			r#"
/// Creates a new `Duration` from the specified number of whole seconds.
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::from_secs(5);
/// assert_eq!(5, duration.as_secs());
/// assert_eq!(0, duration.subsec_nanos());
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn from_secs(secs: u64) -> bevy::utils::Duration;

"#,
			r#"
/// Creates a new `Duration` from the specified number of milliseconds.
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::from_millis(2569);
/// assert_eq!(2, duration.as_secs());
/// assert_eq!(569_000_000, duration.subsec_nanos());
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn from_millis(millis: u64) -> bevy::utils::Duration;

"#,
			r#"
/// Creates a new `Duration` from the specified number of microseconds.
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::from_micros(1_000_002);
/// assert_eq!(1, duration.as_secs());
/// assert_eq!(2000, duration.subsec_nanos());
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn from_micros(micros: u64) -> bevy::utils::Duration;

"#,
			r#"
/// Creates a new `Duration` from the specified number of nanoseconds.
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::from_nanos(1_000_000_123);
/// assert_eq!(1, duration.as_secs());
/// assert_eq!(123, duration.subsec_nanos());
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn from_nanos(nanos: u64) -> bevy::utils::Duration;

"#,
			r#"
/// Returns true if this `Duration` spans no time.
/// # Examples
/// ```
/// use std::time::Duration;
/// assert!(Duration::ZERO.is_zero());
/// assert!(Duration::new(0, 0).is_zero());
/// assert!(Duration::from_nanos(0).is_zero());
/// assert!(Duration::from_secs(0).is_zero());
/// assert!(!Duration::new(1, 1).is_zero());
/// assert!(!Duration::from_nanos(1).is_zero());
/// assert!(!Duration::from_secs(1).is_zero());
/// ```

    #[lua(kind = "Method")]
    fn is_zero(&self) -> bool;

"#,
			r#"
/// Returns the number of _whole_ seconds contained by this `Duration`.
/// The returned value does not include the fractional (nanosecond) part of the
/// duration, which can be obtained using [`subsec_nanos`].
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::new(5, 730023852);
/// assert_eq!(duration.as_secs(), 5);
/// ```
/// To determine the total number of seconds represented by the `Duration`
/// including the fractional part, use [`as_secs_f64`] or [`as_secs_f32`]
/// [`as_secs_f64`]: Duration::as_secs_f64
/// [`as_secs_f32`]: Duration::as_secs_f32
/// [`subsec_nanos`]: Duration::subsec_nanos

    #[lua(kind = "Method")]
    fn as_secs(&self) -> u64;

"#,
			r#"
/// Returns the fractional part of this `Duration`, in whole milliseconds.
/// This method does **not** return the length of the duration when
/// represented by milliseconds. The returned number always represents a
/// fractional portion of a second (i.e., it is less than one thousand).
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::from_millis(5432);
/// assert_eq!(duration.as_secs(), 5);
/// assert_eq!(duration.subsec_millis(), 432);
/// ```

    #[lua(kind = "Method")]
    fn subsec_millis(&self) -> u32;

"#,
			r#"
/// Returns the fractional part of this `Duration`, in whole microseconds.
/// This method does **not** return the length of the duration when
/// represented by microseconds. The returned number always represents a
/// fractional portion of a second (i.e., it is less than one million).
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::from_micros(1_234_567);
/// assert_eq!(duration.as_secs(), 1);
/// assert_eq!(duration.subsec_micros(), 234_567);
/// ```

    #[lua(kind = "Method")]
    fn subsec_micros(&self) -> u32;

"#,
			r#"
/// Returns the fractional part of this `Duration`, in nanoseconds.
/// This method does **not** return the length of the duration when
/// represented by nanoseconds. The returned number always represents a
/// fractional portion of a second (i.e., it is less than one billion).
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::from_millis(5010);
/// assert_eq!(duration.as_secs(), 5);
/// assert_eq!(duration.subsec_nanos(), 10_000_000);
/// ```

    #[lua(kind = "Method")]
    fn subsec_nanos(&self) -> u32;

"#,
			r#"
/// Returns the total number of whole milliseconds contained by this `Duration`.
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::new(5, 730023852);
/// assert_eq!(duration.as_millis(), 5730);
/// ```

    #[lua(kind = "Method")]
    fn as_millis(&self) -> u128;

"#,
			r#"
/// Returns the total number of whole microseconds contained by this `Duration`.
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::new(5, 730023852);
/// assert_eq!(duration.as_micros(), 5730023);
/// ```

    #[lua(kind = "Method")]
    fn as_micros(&self) -> u128;

"#,
			r#"
/// Returns the total number of nanoseconds contained by this `Duration`.
/// # Examples
/// ```
/// use std::time::Duration;
/// let duration = Duration::new(5, 730023852);
/// assert_eq!(duration.as_nanos(), 5730023852);
/// ```

    #[lua(kind = "Method")]
    fn as_nanos(&self) -> u128;

"#,
			r#"
/// Computes the absolute difference between `self` and `other`.
/// # Examples
/// Basic usage:
/// ```
/// #![feature(duration_abs_diff)]
/// use std::time::Duration;
/// assert_eq!(Duration::new(100, 0).abs_diff(Duration::new(80, 0)), Duration::new(20, 0));
/// assert_eq!(Duration::new(100, 400_000_000).abs_diff(Duration::new(110, 0)), Duration::new(9, 600_000_000));
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn abs_diff(self, #[proxy] other: bevy::utils::Duration) -> bevy::utils::Duration;

"#,
			r#"
/// Saturating `Duration` addition. Computes `self + other`, returning [`Duration::MAX`]
/// if overflow occurred.
/// # Examples
/// ```
/// #![feature(duration_constants)]
/// use std::time::Duration;
/// assert_eq!(Duration::new(0, 0).saturating_add(Duration::new(0, 1)), Duration::new(0, 1));
/// assert_eq!(Duration::new(1, 0).saturating_add(Duration::new(u64::MAX, 0)), Duration::MAX);
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_add(
        self,
        #[proxy]
        rhs: bevy::utils::Duration,
    ) -> bevy::utils::Duration;

"#,
			r#"
/// Saturating `Duration` subtraction. Computes `self - other`, returning [`Duration::ZERO`]
/// if the result would be negative or if overflow occurred.
/// # Examples
/// ```
/// use std::time::Duration;
/// assert_eq!(Duration::new(0, 1).saturating_sub(Duration::new(0, 0)), Duration::new(0, 1));
/// assert_eq!(Duration::new(0, 0).saturating_sub(Duration::new(0, 1)), Duration::ZERO);
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_sub(
        self,
        #[proxy]
        rhs: bevy::utils::Duration,
    ) -> bevy::utils::Duration;

"#,
			r#"
/// Saturating `Duration` multiplication. Computes `self * other`, returning
/// [`Duration::MAX`] if overflow occurred.
/// # Examples
/// ```
/// #![feature(duration_constants)]
/// use std::time::Duration;
/// assert_eq!(Duration::new(0, 500_000_001).saturating_mul(2), Duration::new(1, 2));
/// assert_eq!(Duration::new(u64::MAX - 1, 0).saturating_mul(2), Duration::MAX);
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn saturating_mul(self, rhs: u32) -> bevy::utils::Duration;

"#,
			r#"
/// Returns the number of seconds contained by this `Duration` as `f64`.
/// The returned value does include the fractional (nanosecond) part of the duration.
/// # Examples
/// ```
/// use std::time::Duration;
/// let dur = Duration::new(2, 700_000_000);
/// assert_eq!(dur.as_secs_f64(), 2.7);
/// ```

    #[lua(kind = "Method")]
    fn as_secs_f64(&self) -> f64;

"#,
			r#"
/// Returns the number of seconds contained by this `Duration` as `f32`.
/// The returned value does include the fractional (nanosecond) part of the duration.
/// # Examples
/// ```
/// use std::time::Duration;
/// let dur = Duration::new(2, 700_000_000);
/// assert_eq!(dur.as_secs_f32(), 2.7);
/// ```

    #[lua(kind = "Method")]
    fn as_secs_f32(&self) -> f32;

"#,
			r#"
/// Creates a new `Duration` from the specified number of seconds represented
/// as `f64`.
/// # Panics
/// This constructor will panic if `secs` is negative, overflows `Duration` or not finite.
/// # Examples
/// ```
/// use std::time::Duration;
/// let res = Duration::from_secs_f64(0.0);
/// assert_eq!(res, Duration::new(0, 0));
/// let res = Duration::from_secs_f64(1e-20);
/// assert_eq!(res, Duration::new(0, 0));
/// let res = Duration::from_secs_f64(4.2e-7);
/// assert_eq!(res, Duration::new(0, 420));
/// let res = Duration::from_secs_f64(2.7);
/// assert_eq!(res, Duration::new(2, 700_000_000));
/// let res = Duration::from_secs_f64(3e10);
/// assert_eq!(res, Duration::new(30_000_000_000, 0));
/// // subnormal float
/// let res = Duration::from_secs_f64(f64::from_bits(1));
/// assert_eq!(res, Duration::new(0, 0));
/// // conversion uses rounding
/// let res = Duration::from_secs_f64(0.999e-9);
/// assert_eq!(res, Duration::new(0, 1));
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn from_secs_f64(secs: f64) -> bevy::utils::Duration;

"#,
			r#"
/// Creates a new `Duration` from the specified number of seconds represented
/// as `f32`.
/// # Panics
/// This constructor will panic if `secs` is negative, overflows `Duration` or not finite.
/// # Examples
/// ```
/// use std::time::Duration;
/// let res = Duration::from_secs_f32(0.0);
/// assert_eq!(res, Duration::new(0, 0));
/// let res = Duration::from_secs_f32(1e-20);
/// assert_eq!(res, Duration::new(0, 0));
/// let res = Duration::from_secs_f32(4.2e-7);
/// assert_eq!(res, Duration::new(0, 420));
/// let res = Duration::from_secs_f32(2.7);
/// assert_eq!(res, Duration::new(2, 700_000_048));
/// let res = Duration::from_secs_f32(3e10);
/// assert_eq!(res, Duration::new(30_000_001_024, 0));
/// // subnormal float
/// let res = Duration::from_secs_f32(f32::from_bits(1));
/// assert_eq!(res, Duration::new(0, 0));
/// // conversion uses rounding
/// let res = Duration::from_secs_f32(0.999e-9);
/// assert_eq!(res, Duration::new(0, 1));
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn from_secs_f32(secs: f32) -> bevy::utils::Duration;

"#,
			r#"
/// Multiplies `Duration` by `f64`.
/// # Panics
/// This method will panic if result is negative, overflows `Duration` or not finite.
/// # Examples
/// ```
/// use std::time::Duration;
/// let dur = Duration::new(2, 700_000_000);
/// assert_eq!(dur.mul_f64(3.14), Duration::new(8, 478_000_000));
/// assert_eq!(dur.mul_f64(3.14e5), Duration::new(847_800, 0));
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn mul_f64(self, rhs: f64) -> bevy::utils::Duration;

"#,
			r#"
/// Multiplies `Duration` by `f32`.
/// # Panics
/// This method will panic if result is negative, overflows `Duration` or not finite.
/// # Examples
/// ```
/// use std::time::Duration;
/// let dur = Duration::new(2, 700_000_000);
/// assert_eq!(dur.mul_f32(3.14), Duration::new(8, 478_000_641));
/// assert_eq!(dur.mul_f32(3.14e5), Duration::new(847800, 0));
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn mul_f32(self, rhs: f32) -> bevy::utils::Duration;

"#,
			r#"
/// Divide `Duration` by `f64`.
/// # Panics
/// This method will panic if result is negative, overflows `Duration` or not finite.
/// # Examples
/// ```
/// use std::time::Duration;
/// let dur = Duration::new(2, 700_000_000);
/// assert_eq!(dur.div_f64(3.14), Duration::new(0, 859_872_611));
/// assert_eq!(dur.div_f64(3.14e5), Duration::new(0, 8_599));
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn div_f64(self, rhs: f64) -> bevy::utils::Duration;

"#,
			r#"
/// Divide `Duration` by `f32`.
/// # Panics
/// This method will panic if result is negative, overflows `Duration` or not finite.
/// # Examples
/// ```
/// use std::time::Duration;
/// let dur = Duration::new(2, 700_000_000);
/// // note that due to rounding errors result is slightly
/// // different from 0.859_872_611
/// assert_eq!(dur.div_f32(3.14), Duration::new(0, 859_872_580));
/// assert_eq!(dur.div_f32(3.14e5), Duration::new(0, 8_599));
/// ```

    #[lua(kind = "Method", output(proxy))]
    fn div_f32(self, rhs: f32) -> bevy::utils::Duration;

"#,
			r#"
/// Divide `Duration` by `Duration` and return `f64`.
/// # Examples
/// ```
/// #![feature(div_duration)]
/// use std::time::Duration;
/// let dur1 = Duration::new(2, 700_000_000);
/// let dur2 = Duration::new(5, 400_000_000);
/// assert_eq!(dur1.div_duration_f64(dur2), 0.5);
/// ```

    #[lua(kind = "Method")]
    fn div_duration_f64(self, #[proxy] rhs: bevy::utils::Duration) -> f64;

"#,
			r#"
/// Divide `Duration` by `Duration` and return `f32`.
/// # Examples
/// ```
/// #![feature(div_duration)]
/// use std::time::Duration;
/// let dur1 = Duration::new(2, 700_000_000);
/// let dur2 = Duration::new(5, 400_000_000);
/// assert_eq!(dur1.div_duration_f32(dur2), 0.5);
/// ```

    #[lua(kind = "Method")]
    fn div_duration_f32(self, #[proxy] rhs: bevy::utils::Duration) -> f32;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Function", composite = "eq")]
    fn eq(&self, #[proxy] other: &bevy_utils::Duration) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::ops::Mul",
        kind = "Function",
        output(proxy),
        composite = "mul",
        metamethod = "Mul",
    )]
    fn mul(self, rhs: u32) -> bevy::utils::Duration;

"#,
			r#"

    #[lua(
        as_trait = "std::ops::Div",
        kind = "Function",
        output(proxy),
        composite = "div",
        metamethod = "Div",
    )]
    fn div(self, rhs: u32) -> bevy::utils::Duration;

"#,
			r#"

    #[lua(
        as_trait = "bevy::reflect::erased_serde::__private::serde::__private::Clone",
        kind = "Method",
        output(proxy),
    )]
    fn clone(&self) -> bevy::utils::Duration;

"#,
			r#"

    #[lua(
        as_trait = "std::ops::Add",
        kind = "Function",
        output(proxy),
        composite = "add",
        metamethod = "Add",
    )]
    fn add(self, #[proxy] rhs: bevy::utils::Duration) -> bevy::utils::Duration;

"#,
			r#"

    #[lua(as_trait = "std::cmp::Eq", kind = "Method")]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(
        as_trait = "std::ops::Sub",
        kind = "Function",
        output(proxy),
        composite = "sub",
        metamethod = "Sub",
    )]
    fn sub(self, #[proxy] rhs: bevy::utils::Duration) -> bevy::utils::Duration;

"#]
)]




pub struct Duration{
    
    
        
    
        
    
    
}




crate::impl_tealr_generic!(pub(crate) struct T);


#[derive(Default)]
pub(crate) struct Globals;

impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
         
            
                instances.add_instance("LuaOsString", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaOsString>::new)?;
            
         
            
                instances.add_instance("LuaPathBuf", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaPathBuf>::new)?;
            
         
            
                instances.add_instance("LuaString", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaString>::new)?;
            
         
            
                instances.add_instance("LuaInstant", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaInstant>::new)?;
            
         
            
                instances.add_instance("LuaNonZeroU8", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaNonZeroU8>::new)?;
            
         
            
                instances.add_instance("LuaNonZeroU16", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaNonZeroU16>::new)?;
            
         
            
                instances.add_instance("LuaNonZeroU32", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaNonZeroU32>::new)?;
            
         
            
                instances.add_instance("LuaNonZeroU64", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaNonZeroU64>::new)?;
            
         
            
                instances.add_instance("LuaNonZeroU128", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaNonZeroU128>::new)?;
            
         
            
                instances.add_instance("LuaNonZeroUsize", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaNonZeroUsize>::new)?;
            
         
            
                instances.add_instance("LuaNonZeroI8", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaNonZeroI8>::new)?;
            
         
            
                instances.add_instance("LuaNonZeroI16", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaNonZeroI16>::new)?;
            
         
            
                instances.add_instance("LuaNonZeroI32", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaNonZeroI32>::new)?;
            
         
            
                instances.add_instance("LuaNonZeroI64", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaNonZeroI64>::new)?;
            
         
            
                instances.add_instance("LuaNonZeroI128", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaNonZeroI128>::new)?;
            
         
            
                instances.add_instance("LuaNonZeroIsize", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaNonZeroIsize>::new)?;
            
         
            
         
            
                instances.add_instance("LuaDuration", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaDuration>::new)?;
            
        
        Ok(())
    }
}

pub struct BevyReflectAPIProvider;

impl bevy_mod_scripting_core::hosts::APIProvider for BevyReflectAPIProvider {
        type APITarget = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type ScriptContext = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type DocTarget = bevy_mod_scripting_lua::docs::LuaDocFragment;

    fn attach_api(&mut self, ctx: &mut Self::APITarget) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| bevy_mod_scripting_core::error::ScriptError::Other(e.to_string()))
    }

    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(bevy_mod_scripting_lua::docs::LuaDocFragment::new("BevyReflectAPI", |tw| {
            tw
                .document_global_instance::<Globals>().expect("Something went wrong documenting globals")
            
                .process_type::<LuaOsString>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaOsString>>()
                
            
                .process_type::<LuaPathBuf>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaPathBuf>>()
                
            
                .process_type::<LuaString>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaString>>()
                
            
                .process_type::<LuaInstant>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaInstant>>()
                
            
                .process_type::<LuaNonZeroU8>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaNonZeroU8>>()
                
            
                .process_type::<LuaNonZeroU16>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaNonZeroU16>>()
                
            
                .process_type::<LuaNonZeroU32>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaNonZeroU32>>()
                
            
                .process_type::<LuaNonZeroU64>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaNonZeroU64>>()
                
            
                .process_type::<LuaNonZeroU128>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaNonZeroU128>>()
                
            
                .process_type::<LuaNonZeroUsize>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaNonZeroUsize>>()
                
            
                .process_type::<LuaNonZeroI8>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaNonZeroI8>>()
                
            
                .process_type::<LuaNonZeroI16>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaNonZeroI16>>()
                
            
                .process_type::<LuaNonZeroI32>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaNonZeroI32>>()
                
            
                .process_type::<LuaNonZeroI64>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaNonZeroI64>>()
                
            
                .process_type::<LuaNonZeroI128>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaNonZeroI128>>()
                
            
                .process_type::<LuaNonZeroIsize>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaNonZeroIsize>>()
                
            
                .process_type::<LuaRangeFull>()
                
            
                .process_type::<LuaDuration>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaDuration>>()
                
            
            }
        ))
    }

    fn setup_script(
        &mut self,
        script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn register_with_app(&self, app: &mut bevy::app::App) {
        
        app.register_foreign_lua_type::<std::ffi::OsString>();
        
        app.register_foreign_lua_type::<std::path::PathBuf>();
        
        app.register_foreign_lua_type::<std::string::String>();
        
        app.register_foreign_lua_type::<bevy::utils::Instant>();
        
        app.register_foreign_lua_type::<std::num::NonZeroU8>();
        
        app.register_foreign_lua_type::<std::num::NonZeroU16>();
        
        app.register_foreign_lua_type::<std::num::NonZeroU32>();
        
        app.register_foreign_lua_type::<std::num::NonZeroU64>();
        
        app.register_foreign_lua_type::<std::num::NonZeroU128>();
        
        app.register_foreign_lua_type::<std::num::NonZeroUsize>();
        
        app.register_foreign_lua_type::<std::num::NonZeroI8>();
        
        app.register_foreign_lua_type::<std::num::NonZeroI16>();
        
        app.register_foreign_lua_type::<std::num::NonZeroI32>();
        
        app.register_foreign_lua_type::<std::num::NonZeroI64>();
        
        app.register_foreign_lua_type::<std::num::NonZeroI128>();
        
        app.register_foreign_lua_type::<std::num::NonZeroIsize>();
        
        app.register_foreign_lua_type::<std::ops::RangeFull>();
        
        app.register_foreign_lua_type::<bevy::utils::Duration>();
        
    }
}