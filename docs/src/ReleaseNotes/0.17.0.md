# 0.17.0 - Lua declaration files & Asset references

## Lua declaration files!

On top of the ability to plug into mdbook docs, you can now generate Lua declaration files for use with the [lua language server](https://luals.github.io/wiki/definition-files/).

You can do this by simply adding the generation plugin to your app:

```rust
    // this example is used to drive the generated docs on the official BMS book
    app.add_plugins(BMSPlugin.set::<ScriptingFilesGenerationPlugin>(
        ScriptingFilesGenerationPlugin::new(
            true, // enabled, you can use a compilation feature to disable this here
            PathBuf::from("assets").join("definitions"),
            Some(PathBuf::from("bindings.lad.json")), // do also save the ladfile itself
            "Core BMS framework bindings",
            true,
            true,
        ),
    ));
```

The definitions will be generated on startup!

While the generated files are not currently perfect, and not everything is yet supported, they should already make development much smoother with basic type hints and inline docs.

## Improved path reflection and dictionary/set direct access!

We have decided to drop using the native Bevy reflection paths, and switched them out with custom `ReferencePath` and `ReferencePart` structures.

This works around previous limitations of not being able to reflect and modify into dictionaries as well as reference into (but not modify sets, this one is due to limitations in the native rust type).

This should also give us some minor performance benefits.

## Registered Callbacks

You can now register callbacks dynamically from your scripts like so:

```lua
function on_script_loaded()
    register_callback("on_test", dynamic_on_test)
end

function dynamic_on_test()
    register_callback("on_test_last", dynamic_on_test_last)
    return "on test: I am dynamically registered from a normal callback!"
end
```

This has many benefits, including allowing registering different callbacks from withing a shared global script context (where different functions are in scope depending on the last loaded script, but are predictable during loads), finally making those fully usable!

## Expansion of reflection to include Asset References

The reflection system now supports a new base kind, i.e. `ReflectBase::Asset`

allowing us to create and send back asset references to scripts seamlessly, as well as use two new bindings (given an existing handle):

`get_asset(handle_reference, registration)` - Retrieves an asset by handle

`has_asset(handle_reference)` - Checks if an asset exists

## Addition of `ScriptPipelineState`

A new utility has been added to allow you to check on the current batch of scripts being loaded easilly. Check it out in the new loading bar [example](https://github.com/makspll/bevy_mod_scripting/blob/main/examples/script_loading.rs)

## ScriptPath in `FunctionCallContext`

You can now access the last loaded script path in a script context via the `FunctionCallContext::location` method.

This is a lua only feature due to limitations in Rhai.



