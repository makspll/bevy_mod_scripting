# Migration Guide: 0.14 to 0.15

The most important changes to be aware of in this release are:

- BMS now uses `Handle<ScriptAsset>` as its principle means of referring to
  scripts as opposed to the `ScriptId` that was used previously.
  
- BMS exposes many more choices for deciding how scripts are associated with the
  contexts in which they run.
  
- `script_id` is replaced with `script_asset` which now has a type of `Handle<ScriptAsset>`.

## Handles

The use of handles for scripts is perhaps the biggest user-facing change. It makes BMS asset usage follow Bevy's conventions. It requires less configuration. It is more idiomatic.

### `ScriptComponent` Change

In prior versions, `ScriptComponent` accepted a vector of `ScriptId`s, which was a type alias for `Cow<'static, str>`.
```diff
-pub struct ScriptComponent(pub Vec<Cow<'static, str>>);
+pub struct ScriptComponent(pub Vec<Handle<ScriptAsset>>);
```
Because `ScriptComponent` accepts handles, it is no longer necessary to store the handles somewhere to prevent the script from unloading. Nor is it necessary to configure an asset path to script id mapper.
```rust,ignore
ScriptComponent(vec![asset_server.load("foo.lua")])
```

It is still beneficial to retain script assets in memory, for certain features to work. For example,
`script_asset` will not be able to retrieve the asset path of the script if it's not retained.

### `ScriptId` Change

The `ScriptId` has changed from being a string to being an asset ID.

```diff
-type ScriptId = Cow<'static, str>
+type ScriptId = AssetId<ScriptAsset>
```

### No Evaluation on Load

In prior versions, BMS would immediately evaluate a `ScriptAsset` when it was loaded, and if multiple script assets were loaded, they would be evaluated in non-deterministic order. (See [issue #426](https://github.com/makspll/bevy_mod_scripting/issues/426).) Script assets no longer evaluate immediately. Script assets are only evaluated when their handles are added to a `ScriptComponent` or they are added to `StaticScripts`.

In addition when a `ScriptComponent` loads its scripts, it loads them sequentially.

### `ScriptAssetSettings` Removed

The `ScriptAssetSettings` has been removed. Let us address each of its fields in turn.

#### `script_id_mapper`

See `AssetPathToScriptIdMapper` section.

#### `extension_to_language_map` and `supported_extensions`
This is now represented by the `LanguageExtensions` resource, which can be configured directly during initialization
```rust,ignore
pub struct LanguageExtensions(HashMap<&'static str, Language>);
```
or by the `ConfigureScriptAssetSettings` trait:
```rust,ignore
app.add_supported_script_extensions(&["p8lua"], Language::Lua);
```
In addition one can configure the language of an asset when it is loaded:
```rust,ignore
asset_server.load_with_settings("hello.p8lua", |settings: &mut ScriptSettings| {
   settings.language = Some(Language::Lua);
});
```
or when it is created:
```rust,ignore
let content = String::from("x = 0");
let mut script = ScriptAsset::from(content);
script.language = Language::Lua;
```
### `ScriptMetadata` and `ScriptMetadataStore` Removed

These were present to associate the previous `ScriptId` with the asset ID and language.
That is no longer necessary as the `ScriptAsset` knows its own language.

```rust,ignore
pub struct ScriptAsset {
    /// The body of the script
    pub content: Box<[u8]>,
    /// The language of the script
    pub language: Language,
}
```
### `AssetPathToScriptIdMapper` Removed

No mapper is necessary between a script and a script ID. If you have a script handle, you have its script ID

```rust,ignore
let handle: Handle<ScriptAsset> = ...;
let script_id: ScriptId = handle.id(); // ScriptId = AssetId<ScriptAsset>
```
and vice versa.

```rust,ignore
let script_id: ScriptId = ...;
let handle: Handle<ScriptAsset> = Handle::Weak(script_id);
```
## Contexts 
Choosing how scripts run is a big policy decision. Previously BMS had two options:
- Each script ran in its own context.
- All scripts ran in one context.

This was controlled by the `enable_context_sharing()` method on
`ConfigureScriptPlugin`. That function is now deprecated. Instead use the `set_context_policy` method:

```rust,ignore
app.add_plugins(LuaScriptingPlugin::default().set_context_policy(
    ContextPolicy::shared(),
));
```
The reason for this change is there are many more choices than before, namely:

- `ContextPolicy::shared()`
- `ContextPolicy::per_script()`
- `ContextPolicy::per_entity()`
- `ContextPolicy::per_entity_and_script()`

See [Contexts](../Summary/Contexts.md) for more information.

### `ContextKey` Added
Previously BMS used a `ScriptId` and sometimes an `Entity` to refer to a
context. If there was no entity then `Entity::from_raw(0)` was used. Instead BMS
now uses this `ContextKey` to look up contexts.

```rust,ignore
pub struct ContextKey {
    /// Entity if there is one.
    pub entity: Option<Entity>,
    /// Script ID if there is one.
    pub script_id: Option<Handle<ScriptAsset>>
}
```

This change affects the parameters for the `context_pre_handling_initializers`
```diff
- context_pre_handling_initializers: vec![|script_id, entity, context| {
+ context_pre_handling_initializers: vec![|context_key, context| {
```
and `context_initializers`:
```diff
- context_initializers: vec![|script_id, context| {
+ context_initializers: vec![|context_key, context| {
```
