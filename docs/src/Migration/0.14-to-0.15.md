# Migration Guide: 0.14 to 0.15

The most important changes to be aware of in this release are:

- BMS now uses `Handle<ScriptAsset>` as its principle means of referring to
  scripts as opposed to the `ScriptId` that was used previously.
  
- BMS exposes many more choices for deciding how scripts are associated with the
  contexts in which they run.
  
- Domains represent a new means of controlling how scripts may be grouped into
  contexts.
  
## Handles

The use of handles for scripts is perhaps the biggest user-facing change. It makes BMS asset usage follow Bevy's conventions. It requires less configuration. It is more idiomatic.

### `ScriptComponent` Change

In prior versions, `ScriptComponent` accepted a vector of `ScriptId`s, which was a type alias for `Cow<'static, str>`.
```diff
-pub struct ScriptComponent(pub Vec<Cow<'static, str>>);
+pub struct ScriptComponent(pub Vec<Handle<ScriptAsset>>);
```
Because `ScriptComponent` accepts handles, it is no longer necessary to store the handles somewhere to prevent the script from unloading. Nor is it necessary to configure an asset path to script id mapper.
```rust,ignore
ScriptComponent(vec![asset_server.load("foo.lua")])
```

### `ScriptId` Change

The `ScriptId` has changed from being a string to being an asset ID.

```diff
-type ScriptId = Cow<'static, str>
+type ScriptId = AssetId<ScriptAsset>
```

### No Evaluation on Load

In prior versions, BMS would immediately evaluate a `ScriptAsset` when it was loaded, and if multiple script assets were loaded, they would be evaluated in non-deterministic order. (See [issue #426](https://github.com/makspll/bevy_mod_scripting/issues/426).) Script assets no longer evaluate immediately. Script assets are only evaluated when their handles are added to a `ScriptComponent` or they are added to `StaticScripts`.

In addition when a `ScriptComponent` loads its scripts, it loads them sequentially.

### `ScriptAssetSettings` Removed

The `ScriptAssetSettings` has been removed. Let us address each of its fields in turn.

#### `script_id_mapper`

See `AssetPathToScriptIdMapper` section.

#### `extension_to_language_map` and `supported_extensions`
This is now represented by the `LanguageExtensions` resource, which can be configured directly during initialization
```rust,ignore
pub struct LanguageExtensions(HashMap<&'static str, Language>);
```
or by the `ConfigureScriptAssetSettings` trait:
```rust,ignore
app.add_supported_script_extensions(&["p8lua"], Language::Lua);
```
In addition one can configure the language of an asset when it is loaded:
```rust,ignore
asset_server.load_with_settings("hello.p8lua", |settings: &mut ScriptSettings| {
   settings.language = Some(Language::Lua);
});
```
or when it is created:
```rust,ignore
let content = String::from("x = 0");
let mut script = ScriptAsset::from(content);
script.language = Language::Lua;
```
### `ScriptMetadata` and `ScriptMetadataStore` Removed

These were present to associate the previous `ScriptId` with the asset ID and language.
That is no longer necessary as the `ScriptAsset` knows its own language.

```rust,ignore
pub struct ScriptAsset {
    /// The body of the script
    pub content: Box<[u8]>,
    /// The language of the script
    pub language: Language,
}
```
### `AssetPathToScriptIdMapper` Removed

No mapper is necessary between a script and a script ID. If you have a script handle, you have its script ID

```rust,ignore
let handle: Handle<ScriptAsset> = ...;
let script_id: ScriptId = handle.id(); // ScriptId = AssetId<ScriptAsset>
```
and vice versa.

```rust,ignore
let script_id: ScriptId = ...;
let handle: Handle<ScriptAsset> = Handle::Weak(script_id);
```
## Contexts 
Choosing how scripts run is a big policy decision. Previously BMS had two options:
- Each script ran in its own context.
- All scripts ran in one context.

This was controlled by the `enable_context_sharing()` method on
`ConfigureScriptPlugin`. That function is now deprecated. Instead BMS encourages
users to do the following to use a shared context:

```rust,ignore
app.insert_resource(ScriptContext::<LuaScriptingPlugin>::new(ContextPolicy::shared()));
```
The reason for this change is there are many more choices than before, namely:

- `ContextPolicy::shared()`
- `ContextPolicy::per_script()`
- `ContextPolicy::per_entity()`
- `ContextPolicy::per_entity_and_script()`

See [Contexts](../Summary/Contexts.md) for more information.

In addition each of the above can have domains enabled with a `.with_domains()`
call. Domains are a new concept within BMS. They represent a kind of ad-hoc
context grouping mechanism. See the [domains
section](../Summary/Contexts.md#domains) for more information.

### No Context Removal on Unload by Default

Prior versions of BMS would immediately remove a context once all the strong
handles for a script were dropped. The script handles were a proxy for
controlling the contexts. This made sense when the script handles to contexts
were a 1-to-1 relationship, but now BMS allows for many different kinds of
relations between contexts and scripts.

To restore that previous behavior, one can add the following system:
```rust,ignore
app.add_systems(PostUpdate, remove_context_on_script_removal);
```
To manually initiate context removal, do the following:
```rust,ignore
commands.queue(DeleteScript::<LuaScriptingPlugin>::new(script_handle));
```

### `ContextKey` Added
Previously BMS used a `ScriptId` and sometimes an `Entity` to refer to a
context. If there was no entity then `Entity::from_raw(0)` was used. Instead BMS
now uses this `ContextKey` to look up contexts.

```rust,ignore
pub struct ContextKey {
    /// Entity if there is one.
    pub entity: Option<Entity>,
    /// Script ID if there is one.
    pub script_id: Option<Handle<ScriptAsset>>,
    /// Domain if there is one.
    pub domain: Option<Domain>,
}
```
This change affects the parameters for the `context_pre_handling_instructions`
```diff
- context_pre_handling_initializers: vec![|script_id, entity, context| {
+ context_pre_handling_initializers: vec![|context_key, context| {
```
and `context_initializers`:
```diff
- context_initializers: vec![|script_id, context| {
+ context_initializers: vec![|context_key, context| {
```
