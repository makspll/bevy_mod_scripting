// This file is generated by `bevy_mod_scripting_derive/main.rs` change the template not this file
use bevy_mod_scripting_derive::impl_lua_newtype;
use std::ops::*;
use crate::ReflectPtr;
use crate::{RegisterForeignLuaType,LuaProxyable,ScriptRef,ScriptRefBase,ReflectedValue, api::ValueIndex, APIProvider, LuaDocFragment};
use std::sync::{Arc, Mutex};
use crate::util::impl_tealr_type;
use tealr::{mlu::{mlua,mlua::{prelude::*,MetaMethod,Value}},create_union_mlua};
use bevy::reflect::Reflect;
use bevy::prelude::App;
use bevy::ui::AlignContent;
use bevy::ui::AlignItems;
use bevy::ui::AlignSelf;
use bevy::ui::Direction;
use bevy::ui::FlexDirection;
use bevy::ui::FlexWrap;
use bevy::ui::FocusPolicy;
use bevy::ui::Interaction;
use bevy::ui::JustifyContent;
use bevy::ui::Overflow;
use bevy::ui::PositionType;
use bevy::ui::Val;
use bevy::ui::CalculatedClip;
use bevy::ui::CalculatedSize;
use bevy::ui::Node;
use bevy::ui::Style;
use bevy::ui::UiColor;
use bevy::ui::UiImage;
use bevy::ui::widget::Button;
use bevy::ui::widget::ImageMode;
use bevy::ui::Display;
use bevy::animation::AnimationPlayer;
use bevy::core::Name;
use bevy::gltf::GltfExtras;
use bevy::hierarchy::Children;
use bevy::hierarchy::Parent;
use bevy::hierarchy::PreviousParent;
use bevy::text::Text2dBounds;
use bevy::text::Text2dSize;
use bevy::text::Text;
use bevy::text::TextAlignment;
use bevy::text::TextSection;
use bevy::text::TextStyle;
use bevy::text::HorizontalAlign;
use bevy::text::VerticalAlign;
use bevy::time::Stopwatch;
use bevy::time::Timer;
use bevy::ecs::entity::Entity;
use bevy::transform::components::Transform;
use bevy::transform::components::GlobalTransform;
use bevy::pbr::AmbientLight;
use bevy::pbr::CubemapVisibleEntities;
use bevy::pbr::DirectionalLight;
use bevy::pbr::DirectionalLightShadowMap;
use bevy::pbr::NotShadowCaster;
use bevy::pbr::NotShadowReceiver;
use bevy::pbr::PointLight;
use bevy::pbr::PointLightShadowMap;
use bevy::pbr::AlphaMode;
use bevy::pbr::wireframe::Wireframe;
use bevy::pbr::wireframe::WireframeConfig;
use bevy::core_pipeline::core_3d::Camera3dDepthLoadOp;
use bevy::core_pipeline::clear_color::ClearColor;
use bevy::core_pipeline::clear_color::ClearColorConfig;
use bevy::core_pipeline::core_2d::Camera2d;
use bevy::core_pipeline::core_3d::Camera3d;
use bevy::sprite::Anchor;
use bevy::sprite::Mesh2dHandle;
use bevy::sprite::TextureAtlasSprite;
use bevy::sprite::Sprite;
use bevy::sprite::Rect;
use bevy::render::view::visibility::RenderLayers;
use bevy::render::view::visibility::Visibility;
use bevy::render::view::visibility::VisibleEntities;
use bevy::render::view::visibility::ComputedVisibility;
use bevy::render::mesh::skinning::SkinnedMesh;
use bevy::render::camera::ScalingMode;
use bevy::render::camera::WindowOrigin;
use bevy::render::color::Color;
use bevy::render::primitives::Aabb;
use bevy::render::primitives::CubemapFrusta;
use bevy::render::primitives::Frustum;
use bevy::render::view::Msaa;
use bevy::render::camera::Camera;
use bevy::render::camera::RenderTarget;
use bevy::render::camera::Viewport;
use bevy::render::camera::Projection;
use bevy::render::camera::OrthographicProjection;
use bevy::render::camera::PerspectiveProjection;
use bevy::render::camera::DepthCalculation;
use bevy::render::camera::CameraRenderGraph;
use bevy::asset::AssetPathId;
use bevy::asset::LabelId;
use bevy::asset::SourcePathId;
use bevy::asset::HandleId;
use bevy::math::f32::Vec2;
use bevy::math::f32::Vec3;
use bevy::math::f32::Vec3A;
use bevy::math::f32::Vec4;
use bevy::math::bool::BVec2;
use bevy::math::bool::BVec3;
use bevy::math::bool::BVec4;
use bevy::math::bool::BVec3A;
use bevy::math::bool::BVec4A;
use bevy::math::f64::DVec2;
use bevy::math::f64::DVec3;
use bevy::math::f64::DVec4;
use bevy::math::i32::IVec2;
use bevy::math::i32::IVec3;
use bevy::math::i32::IVec4;
use bevy::math::u32::UVec2;
use bevy::math::u32::UVec3;
use bevy::math::u32::UVec4;
use bevy::math::f32::Mat3;
use bevy::math::f32::Mat2;
use bevy::math::f32::Mat3A;
use bevy::math::f32::Mat4;
use bevy::math::f64::DMat2;
use bevy::math::f64::DMat3;
use bevy::math::f64::DMat4;
use bevy::math::f32::Affine2;
use bevy::math::f32::Affine3A;
use bevy::math::f64::DAffine2;
use bevy::math::f64::DAffine3;
use bevy::math::f32::Quat;
use bevy::math::f64::DQuat;
use bevy::math::EulerRot;
use bevy::render::camera::CameraProjection;
impl_lua_newtype!{
	///Defines how each line is aligned within the flexbox.
	///
	///It only applies if [`FlexWrap::Wrap`] is present and if there are multiple lines of items.
	bevy_ui::AlignContent : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///How items are aligned according to the cross axis
	bevy_ui::AlignItems : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Works like [`AlignItems`] but applies only to a single item
	bevy_ui::AlignSelf : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Defines the text direction
	///
	///For example English is written LTR (left-to-right) while Arabic is written RTL (right-to-left).
	bevy_ui::Direction : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Defines how flexbox items are ordered within a flexbox
	bevy_ui::FlexDirection : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Defines if flexbox items appear on a single line or on multiple lines
	bevy_ui::FlexWrap : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Describes whether the node should block interactions with lower nodes
	bevy_ui::FocusPolicy : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Describes what type of input interaction has occurred for a UI node.
	///
	///This is commonly queried with a `Changed<Interaction>` filter.
	bevy_ui::Interaction : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Defines how items are aligned according to the main axis
	bevy_ui::JustifyContent : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Whether to show or hide overflowing items
	bevy_ui::Overflow : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///The strategy used to position this node
	bevy_ui::PositionType : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///An enum that describes possible types of value in flexbox layout options
	bevy_ui::Val : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
		self Add f32 -> LuaVal,
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///The calculated clip of the node
	bevy_ui::CalculatedClip : Value
	: Fields
	(
		/// The rect of the clip
		clip: ReflectedValue,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///The calculated size of the node
	bevy_ui::CalculatedSize : Value
	: Fields
	(
		/// The size of the node
		size: ReflectedValue,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Describes the size of a UI node
	bevy_ui::Node : Value
	: Fields
	(
		/// The size of the node as width and height in pixels
		size: LuaVec2,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Describes the style of a UI node
	///
	///It uses the [Flexbox](https://cssreference.io/flexbox/) system.
	///
	///**Note:** Bevy's UI is upside down compared to how Flexbox normally works, to stay consistent with engine paradigms about layouting from
	///the upper left corner of the display
	bevy_ui::Style : Value
	: Fields
	(
		/// Whether to arrange this node and its children with flexbox layout
		display: LuaDisplay,
		/// Whether to arrange this node relative to other nodes, or positioned absolutely
		position_type: LuaPositionType,
		/// Which direction the content of this node should go
		direction: LuaDirection,
		/// Whether to use column or row layout
		flex_direction: LuaFlexDirection,
		/// How to wrap nodes
		flex_wrap: LuaFlexWrap,
		/// How items are aligned according to the cross axis
		align_items: LuaAlignItems,
		/// Like align_items but for only this item
		align_self: LuaAlignSelf,
		/// How to align each line, only applies if flex_wrap is set to
		/// [`FlexWrap::Wrap`] and there are multiple lines of items
		align_content: LuaAlignContent,
		/// How items align according to the main axis
		justify_content: LuaJustifyContent,
		/// The position of the node as descrided by its Rect
		position: ReflectedValue,
		/// The margin of the node
		margin: ReflectedValue,
		/// The padding of the node
		padding: ReflectedValue,
		/// The border of the node
		border: ReflectedValue,
		/// Defines how much a flexbox item should grow if there's space available
		flex_grow: f32,
		/// How to shrink if there's not enough space available
		flex_shrink: f32,
		/// The initial size of the item
		flex_basis: LuaVal,
		/// The size of the flexbox
		size: ReflectedValue,
		/// The minimum size of the flexbox
		min_size: ReflectedValue,
		/// The maximum size of the flexbox
		max_size: ReflectedValue,
		/// The aspect ratio of the flexbox
		aspect_ratio: ReflectedValue,
		/// How to handle overflow
		overflow: LuaOverflow,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///The color of the node
	bevy_ui::UiColor : Value
	: Fields
	(
		0: LuaColor,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///The image of the node
	bevy_ui::UiImage : Value
	: Fields
	(
		0: ReflectedValue,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Marker struct for buttons
	bevy_ui::widget::Button : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Describes how to resize the Image node
	bevy_ui::widget::ImageMode : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Whether to use Flexbox layout
	bevy_ui::Display : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Animation controls
	bevy_animation::AnimationPlayer : Value
	: Fields
	(
	)
	+ AutoMethods
	(
		///Is the animation paused
		is_paused(&self) -> bool,

		///Speed of the animation playback
		speed(&self) -> f32,

		///Time elapsed playing the animation
		elapsed(&self) -> f32,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Component used to identify an entity. Stores a hash for faster comparisons
	///The hash is eagerly re-computed upon each update to the name.
	///
	///[`Name`] should not be treated as a globally unique identifier for entities,
	///as multiple entities can have the same name.  [`bevy_ecs::entity::Entity`] should be
	///used instead as the default unique identifier.
	bevy_core::Name : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_gltf::GltfExtras : Value
	: Fields
	(
		value: ReflectedValue,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Contains references to the child entities of this entity
	bevy_hierarchy::Children : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Holds a reference to the parent entity of this entity.
	///This component should only be present on entities that actually have a parent entity.
	bevy_hierarchy::Parent : Value
	: Fields
	(
		0: LuaEntity,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Component that holds the [`Parent`] this entity had previously
	bevy_hierarchy::PreviousParent : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///The maximum width and height of text. The text will wrap according to the specified size.
	///Characters out of the bounds after wrapping will be truncated. Text is aligned according to the
	///specified `TextAlignment`.
	///
	///Note: only characters that are completely out of the bounds will be truncated, so this is not a
	///reliable limit if it is necessary to contain the text strictly in the bounds. Currently this
	///component is mainly useful for text wrapping only.
	bevy_text::Text2dBounds : Value
	: Fields
	(
		size: LuaVec2,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///The calculated size of text drawn in 2D scene.
	bevy_text::Text2dSize : Value
	: Fields
	(
		size: LuaVec2,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_text::Text : Value
	: Fields
	(
		sections: ReflectedValue,
		alignment: LuaTextAlignment,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_text::TextAlignment : Value
	: Fields
	(
		vertical: LuaVerticalAlign,
		horizontal: LuaHorizontalAlign,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_text::TextSection : Value
	: Fields
	(
		value: ReflectedValue,
		style: LuaTextStyle,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_text::TextStyle : Value
	: Fields
	(
		font: ReflectedValue,
		font_size: f32,
		color: LuaColor,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Describes horizontal alignment preference for positioning & bounds.
	bevy_text::HorizontalAlign : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Describes vertical alignment preference for positioning & bounds. Currently a placeholder
	///for future functionality.
	bevy_text::VerticalAlign : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///A Stopwatch is a struct that track elapsed time when started.
	///
	///# Examples
	///
	///```
	///# use bevy_time::*;
	///use std::time::Duration;
	///let mut stopwatch = Stopwatch::new();
	///assert_eq!(stopwatch.elapsed_secs(), 0.0);
	///
	///stopwatch.tick(Duration::from_secs_f32(1.0)); // tick one second
	///assert_eq!(stopwatch.elapsed_secs(), 1.0);
	///
	///stopwatch.pause();
	///stopwatch.tick(Duration::from_secs_f32(1.0)); // paused stopwatches don't tick
	///assert_eq!(stopwatch.elapsed_secs(), 1.0);
	///
	///stopwatch.reset(); // reset the stopwatch
	///assert!(stopwatch.paused());
	///assert_eq!(stopwatch.elapsed_secs(), 0.0);
	///```
	bevy_time::Stopwatch : Value
	: Fields
	(
	)
	+ AutoMethods
	(
		///Create a new unpaused `Stopwatch` with no elapsed time.
		///
		///# Examples
		///```
		///# use bevy_time::*;
		///let stopwatch = Stopwatch::new();
		///assert_eq!(stopwatch.elapsed_secs(), 0.0);
		///assert_eq!(stopwatch.paused(), false);
		///```
		new() -> LuaStopwatch,

		///Returns the elapsed time since the last [`reset`](Stopwatch::reset)
		///of the stopwatch, in seconds.
		///
		///# Examples
		///```
		///# use bevy_time::*;
		///use std::time::Duration;
		///let mut stopwatch = Stopwatch::new();
		///stopwatch.tick(Duration::from_secs(1));
		///assert_eq!(stopwatch.elapsed_secs(), 1.0);
		///```
		///
		///# See Also
		///
		///[`elapsed`](Stopwatch::elapsed) - if a `Duration` is desirable instead.
		elapsed_secs(&self) -> f32,

		///Returns `true` if the stopwatch is paused.
		///
		///# Examples
		///```
		///# use bevy_time::*;
		///let mut stopwatch = Stopwatch::new();
		///assert!(!stopwatch.paused());
		///stopwatch.pause();
		///assert!(stopwatch.paused());
		///stopwatch.unpause();
		///assert!(!stopwatch.paused());
		///```
		paused(&self) -> bool,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Tracks elapsed time. Enters the finished state once `duration` is reached.
	///
	///Non repeating timers will stop tracking and stay in the finished state until reset.
	///Repeating timers will only be in the finished state on each tick `duration` is reached or
	///exceeded, and can still be reset at any given point.
	///
	///Paused timers will not have elapsed time increased.
	bevy_time::Timer : Value
	: Fields
	(
	)
	+ AutoMethods
	(
		///Creates a new timer with a given duration in seconds.
		///
		///# Example
		///```
		///# use bevy_time::*;
		///let mut timer = Timer::from_seconds(1.0, false);
		///```
		from_seconds(f32,bool) -> LuaTimer,

		///Returns `true` if the timer has reached its duration.
		///
		///# Examples
		///```
		///# use bevy_time::*;
		///use std::time::Duration;
		///let mut timer = Timer::from_seconds(1.0, false);
		///timer.tick(Duration::from_secs_f32(1.5));
		///assert!(timer.finished());
		///timer.tick(Duration::from_secs_f32(0.5));
		///assert!(timer.finished());
		///```
		finished(&self) -> bool,

		///Returns `true` only on the tick the timer reached its duration.
		///
		///# Examples
		///```
		///# use bevy_time::*;
		///use std::time::Duration;
		///let mut timer = Timer::from_seconds(1.0, false);
		///timer.tick(Duration::from_secs_f32(1.5));
		///assert!(timer.just_finished());
		///timer.tick(Duration::from_secs_f32(0.5));
		///assert!(!timer.just_finished());
		///```
		just_finished(&self) -> bool,

		///Returns the time elapsed on the timer as a `f32`.
		///See also [`Timer::elapsed`](Timer::elapsed).
		elapsed_secs(&self) -> f32,

		///Returns `true` if the timer is repeating.
		///
		///# Examples
		///```
		///# use bevy_time::*;
		///let mut timer = Timer::from_seconds(1.0, true);
		///assert!(timer.repeating());
		///```
		repeating(&self) -> bool,

		///Returns `true` if the timer is paused.
		///
		///See also [`Stopwatch::paused`](Stopwatch::paused).
		///
		///# Examples
		///```
		///# use bevy_time::*;
		///let mut timer = Timer::from_seconds(1.0, false);
		///assert!(!timer.paused());
		///timer.pause();
		///assert!(timer.paused());
		///timer.unpause();
		///assert!(!timer.paused());
		///```
		paused(&self) -> bool,

		///Returns the percentage of the timer elapsed time (goes from 0.0 to 1.0).
		///
		///# Examples
		///```
		///# use bevy_time::*;
		///use std::time::Duration;
		///let mut timer = Timer::from_seconds(2.0, false);
		///timer.tick(Duration::from_secs_f32(0.5));
		///assert_eq!(timer.percent(), 0.25);
		///```
		percent(&self) -> f32,

		///Returns the percentage of the timer remaining time (goes from 0.0 to 1.0).
		///
		///# Examples
		///```
		///# use bevy_time::*;
		///use std::time::Duration;
		///let mut timer = Timer::from_seconds(2.0, false);
		///timer.tick(Duration::from_secs_f32(0.5));
		///assert_eq!(timer.percent_left(), 0.75);
		///```
		percent_left(&self) -> f32,

		///Returns the number of times a repeating timer
		///finished during the last [`tick`](Timer<T>::tick) call.
		///
		///For non repeating-timers, this method will only ever
		///return 0 or 1.
		///
		///# Examples
		///```
		///# use bevy_time::*;
		///use std::time::Duration;
		///let mut timer = Timer::from_seconds(1.0, true);
		///timer.tick(Duration::from_secs_f32(6.0));
		///assert_eq!(timer.times_finished_this_tick(), 6);
		///timer.tick(Duration::from_secs_f32(2.0));
		///assert_eq!(timer.times_finished_this_tick(), 2);
		///timer.tick(Duration::from_secs_f32(0.5));
		///assert_eq!(timer.times_finished_this_tick(), 0);
		///```
		times_finished_this_tick(&self) -> u32,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Lightweight identifier of an [entity](crate::entity).
	///
	///The identifier is implemented using a [generational index]: a combination of an ID and a generation.
	///This allows fast insertion after data removal in an array while minimizing loss of spatial locality.
	///
	///[generational index]: https://lucassardois.medium.com/generational-indices-guide-8e3c5f7fd594
	///
	///# Usage
	///
	///This data type is returned by iterating a `Query` that has `Entity` as part of its query fetch type parameter ([learn more]).
	///It can also be obtained by calling [`EntityCommands::id`] or [`EntityMut::id`].
	///
	///```
	///# use bevy_ecs::prelude::*;
	///#
	///fn setup(mut commands: Commands) {
	///    // Calling `spawn` returns `EntityCommands`.
	///    let entity = commands.spawn().id();
	///}
	///
	///fn exclusive_system(world: &mut World) {
	///    // Calling `spawn` returns `EntityMut`.
	///    let entity = world.spawn().id();
	///}
	///#
	///# bevy_ecs::system::assert_is_system(setup);
	///# bevy_ecs::system::IntoExclusiveSystem::exclusive_system(exclusive_system);
	///```
	///
	///It can be used to refer to a specific entity to apply [`EntityCommands`], or to call [`Query::get`] (or similar methods) to access its components.
	///
	///```
	///# use bevy_ecs::prelude::*;
	///#
	///# #[derive(Component)]
	///# struct Expired;
	///#
	///fn dispose_expired_food(mut commands: Commands, query: Query<Entity, With<Expired>>) {
	///    for food_entity in query.iter() {
	///        commands.entity(food_entity).despawn();
	///    }
	///}
	///#
	///# bevy_ecs::system::assert_is_system(dispose_expired_food);
	///```
	///
	///[learn more]: crate::system::Query#entity-id-access
	///[`EntityCommands::id`]: crate::system::EntityCommands::id
	///[`EntityMut::id`]: crate::world::EntityMut::id
	///[`EntityCommands`]: crate::system::EntityCommands
	///[`Query::get`]: crate::system::Query::get
	bevy_ecs::entity::Entity : Value
	: Fields
	(
	)
	+ AutoMethods
	(
		///Creates a new entity reference with the specified `id` and a generation of 0.
		///
		///# Note
		///
		///Spawning a specific `entity` value is __rarely the right choice__. Most apps should favor
		///[`Commands::spawn`](crate::system::Commands::spawn). This method should generally
		///only be used for sharing entities across apps, and only when they have a scheme
		///worked out to share an ID space (which doesn't happen by default).
		///
		///In general, one should not try to synchronize the ECS by attempting to ensure that
		///`Entity` lines up between instances, but instead insert a secondary identifier as
		///a component.
		///
		///There are still some use cases where it might be appropriate to use this function
		///externally.
		///
		///## Examples
		///
		///Initializing a collection (e.g. `array` or `Vec`) with a known size:
		///
		///```no_run
		///# use bevy_ecs::prelude::*;
		///// Create a new array of size 10 and initialize it with (invalid) entities.
		///let mut entities: [Entity; 10] = [Entity::from_raw(0); 10];
		///
		///// ... replace the entities with valid ones.
		///```
		///
		///Deriving `Reflect` for a component that has an `Entity` field:
		///
		///```no_run
		///# use bevy_ecs::{prelude::*, component::*};
		///# use bevy_reflect::Reflect;
		///#[derive(Reflect, Component)]
		///#[reflect(Component)]
		///pub struct MyStruct {
		///    pub entity: Entity,
		///}
		///
		///impl FromWorld for MyStruct {
		///    fn from_world(_world: &mut World) -> Self {
		///        Self {
		///            entity: Entity::from_raw(u32::MAX),
		///        }
		///    }
		///}
		///```
		from_raw(u32) -> LuaEntity,

		///Convert to a form convenient for passing outside of rust.
		///
		///Only useful for identifying entities within the same instance of an application. Do not use
		///for serialization between runs.
		///
		///No particular structure is guaranteed for the returned bits.
		to_bits(self) -> u64,

		///Reconstruct an `Entity` previously destructured with [`Entity::to_bits`].
		///
		///Only useful when applied to results from `to_bits` in the same instance of an application.
		from_bits(u64) -> LuaEntity,

		///Return a transiently unique identifier.
		///
		///No two simultaneously-live entities share the same ID, but dead entities' IDs may collide
		///with both live and dead entities. Useful for compactly representing entities within a
		///specific snapshot of the world, such as when serializing.
		id(self) -> u32,

		///Returns the generation of this Entity's id. The generation is incremented each time an
		///entity with a given id is despawned. This serves as a "count" of the number of times a
		///given id has been reused (id, generation) pairs uniquely identify a given Entity.
		generation(self) -> u32,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Describe the position of an entity. If the entity has a parent, the position is relative
	///to its parent position.
	///
	///* To place or move an entity, you should set its [`Transform`].
	///* To get the global position of an entity, you should get its [`GlobalTransform`].
	///* To be displayed, an entity must have both a [`Transform`] and a [`GlobalTransform`].
	///  * You may use the [`TransformBundle`](crate::TransformBundle) to guarantee this.
	///
	///## [`Transform`] and [`GlobalTransform`]
	///
	///[`Transform`] is the position of an entity relative to its parent position, or the reference
	///frame if it doesn't have a [`Parent`](bevy_hierarchy::Parent).
	///
	///[`GlobalTransform`] is the position of an entity relative to the reference frame.
	///
	///[`GlobalTransform`] is updated from [`Transform`] in the system
	///[`transform_propagate_system`](crate::transform_propagate_system).
	///
	///This system runs in stage [`CoreStage::PostUpdate`](crate::CoreStage::PostUpdate). If you
	///update the[`Transform`] of an entity in this stage or after, you will notice a 1 frame lag
	///before the [`GlobalTransform`] is updated.
	bevy_transform::components::Transform : Value
	: Fields
	(
		/// Position of the entity. In 2d, the last value of the `Vec3` is used for z-ordering.
		translation: LuaVec3,
		/// Rotation of the entity.
		rotation: LuaQuat,
		/// Scale of the entity.
		scale: LuaVec3,
	)
	+ AutoMethods
	(
		///Creates a new [`Transform`] at the position `(x, y, z)`. In 2d, the `z` component
		///is used for z-ordering elements: higher `z`-value will be in front of lower
		///`z`-value.
		from_xyz(f32,f32,f32) -> LuaTransform,

		///Creates a new identity [`Transform`], with no translation, rotation, and a scale of 1 on
		///all axes.
		identity() -> LuaTransform,

		///Extracts the translation, rotation, and scale from `matrix`. It must be a 3d affine
		///transformation matrix.
		from_matrix(LuaMat4) -> LuaTransform,

		///Creates a new [`Transform`], with `translation`. Rotation will be 0 and scale 1 on
		///all axes.
		from_translation(LuaVec3) -> LuaTransform,

		///Creates a new [`Transform`], with `rotation`. Translation will be 0 and scale 1 on
		///all axes.
		from_rotation(LuaQuat) -> LuaTransform,

		///Creates a new [`Transform`], with `scale`. Translation will be 0 and rotation 0 on
		///all axes.
		from_scale(LuaVec3) -> LuaTransform,

		///Updates and returns this [`Transform`] by rotating it so that its unit vector in the
		///local z direction is toward `target` and its unit vector in the local y direction
		///is toward `up`.
		looking_at(self,LuaVec3,LuaVec3) -> LuaTransform,

		///Returns this [`Transform`] with a new translation.
		with_translation(self,LuaVec3) -> LuaTransform,

		///Returns this [`Transform`] with a new rotation.
		with_rotation(self,LuaQuat) -> LuaTransform,

		///Returns this [`Transform`] with a new scale.
		with_scale(self,LuaVec3) -> LuaTransform,

		///Returns the 3d affine transformation matrix from this transforms translation,
		///rotation, and scale.
		compute_matrix(&self) -> LuaMat4,

		///Get the unit vector in the local x direction.
		local_x(&self) -> LuaVec3,

		///Equivalent to [`-local_x()`][Transform::local_x()]
		left(&self) -> LuaVec3,

		///Equivalent to [`local_x()`][Transform::local_x()]
		right(&self) -> LuaVec3,

		///Get the unit vector in the local y direction.
		local_y(&self) -> LuaVec3,

		///Equivalent to [`local_y()`][Transform::local_y]
		up(&self) -> LuaVec3,

		///Equivalent to [`-local_y()`][Transform::local_y]
		down(&self) -> LuaVec3,

		///Get the unit vector in the local z direction.
		local_z(&self) -> LuaVec3,

		///Equivalent to [`-local_z()`][Transform::local_z]
		forward(&self) -> LuaVec3,

		///Equivalent to [`local_z()`][Transform::local_z]
		back(&self) -> LuaVec3,

		///Multiplies `self` with `transform` component by component, returning the
		///resulting [`Transform`]
		mul_transform(&self,LuaTransform) -> LuaTransform,

		///Returns a [`Vec3`] of this [`Transform`] applied to `value`.
		mul_vec3(&self,LuaVec3) -> LuaVec3,

	)
	+ BinOps
	(
		self Mul LuaTransform -> LuaTransform,
		self Mul LuaVec3 -> LuaVec3,
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Describe the position of an entity relative to the reference frame.
	///
	///* To place or move an entity, you should set its [`Transform`].
	///* To get the global position of an entity, you should get its [`GlobalTransform`].
	///* For transform hierarchies to work correctly, you must have both a [`Transform`] and a [`GlobalTransform`].
	///  * You may use the [`TransformBundle`](crate::TransformBundle) to guarantee this.
	///
	///## [`Transform`] and [`GlobalTransform`]
	///
	///[`Transform`] is the position of an entity relative to its parent position, or the reference
	///frame if it doesn't have a [`Parent`](bevy_hierarchy::Parent).
	///
	///[`GlobalTransform`] is the position of an entity relative to the reference frame.
	///
	///[`GlobalTransform`] is updated from [`Transform`] in the system
	///[`transform_propagate_system`](crate::transform_propagate_system).
	///
	///This system runs in stage [`CoreStage::PostUpdate`](crate::CoreStage::PostUpdate). If you
	///update the[`Transform`] of an entity in this stage or after, you will notice a 1 frame lag
	///before the [`GlobalTransform`] is updated.
	bevy_transform::components::GlobalTransform : Value
	: Fields
	(
		/// The position of the global transform
		translation: LuaVec3,
		/// The rotation of the global transform
		rotation: LuaQuat,
		/// The scale of the global transform
		scale: LuaVec3,
	)
	+ AutoMethods
	(
		///Creates a new identity [`GlobalTransform`], with no translation, rotation, and a scale of 1
		///on all axes.
		identity() -> LuaGlobalTransform,

		///Returns the 3d affine transformation matrix from this transforms translation,
		///rotation, and scale.
		compute_matrix(&self) -> LuaMat4,

		///Returns the 3d affine transformation from this transforms translation,
		///rotation, and scale.
		compute_affine(&self) -> LuaAffine3A,

		///Get the unit vector in the local x direction
		local_x(&self) -> LuaVec3,

		///Equivalent to [`-local_x()`][GlobalTransform::local_x]
		left(&self) -> LuaVec3,

		///Equivalent to [`local_x()`][GlobalTransform::local_x]
		right(&self) -> LuaVec3,

		///Get the unit vector in the local y direction
		local_y(&self) -> LuaVec3,

		///Equivalent to [`local_y()`][GlobalTransform::local_y]
		up(&self) -> LuaVec3,

		///Equivalent to [`-local_y()`][GlobalTransform::local_y]
		down(&self) -> LuaVec3,

		///Get the unit vector in the local z direction
		local_z(&self) -> LuaVec3,

		///Equivalent to [`-local_z()`][GlobalTransform::local_z]
		forward(&self) -> LuaVec3,

		///Equivalent to [`local_z()`][GlobalTransform::local_z]
		back(&self) -> LuaVec3,

		///Multiplies `self` with `transform` component by component, returning the
		///resulting [`GlobalTransform`]
		mul_transform(&self,LuaTransform) -> LuaGlobalTransform,

		///Returns a [`Vec3`] of this [`Transform`] applied to `value`.
		mul_vec3(&self,LuaVec3) -> LuaVec3,

	)
	+ BinOps
	(
		self Mul LuaGlobalTransform -> LuaGlobalTransform,
		self Mul LuaTransform -> LuaGlobalTransform,
		self Mul LuaVec3 -> LuaVec3,
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///An ambient light, which lights the entire scene equally.
	bevy_pbr::AmbientLight : Value
	: Fields
	(
		color: LuaColor,
		/// A direct scale factor multiplied with `color` before being passed to the shader.
		brightness: f32,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_pbr::CubemapVisibleEntities : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///A Directional light.
	///
	///Directional lights don't exist in reality but they are a good
	///approximation for light sources VERY far away, like the sun or
	///the moon.
	///
	///Valid values for `illuminance` are:
	///
	///| Illuminance (lux) | Surfaces illuminated by                        |
	///|-------------------|------------------------------------------------|
	///| 0.0001            | Moonless, overcast night sky (starlight)       |
	///| 0.002             | Moonless clear night sky with airglow          |
	///| 0.05–0.3          | Full moon on a clear night                     |
	///| 3.4               | Dark limit of civil twilight under a clear sky |
	///| 20–50             | Public areas with dark surroundings            |
	///| 50                | Family living room lights                      |
	///| 80                | Office building hallway/toilet lighting        |
	///| 100               | Very dark overcast day                         |
	///| 150               | Train station platforms                        |
	///| 320–500           | Office lighting                                |
	///| 400               | Sunrise or sunset on a clear day.              |
	///| 1000              | Overcast day; typical TV studio lighting       |
	///| 10,000–25,000     | Full daylight (not direct sun)                 |
	///| 32,000–100,000    | Direct sunlight                                |
	///
	///Source: [Wikipedia](https://en.wikipedia.org/wiki/Lux)
	bevy_pbr::DirectionalLight : Value
	: Fields
	(
		color: LuaColor,
		/// Illuminance in lux
		illuminance: f32,
		shadows_enabled: bool,
		shadow_projection: LuaOrthographicProjection,
		shadow_depth_bias: f32,
		/// A bias applied along the direction of the fragment's surface normal. It is scaled to the
		/// shadow map's texel size so that it is automatically adjusted to the orthographic projection.
		shadow_normal_bias: f32,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_pbr::DirectionalLightShadowMap : Value
	: Fields
	(
		size: usize,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Add this component to make a [`Mesh`](bevy_render::mesh::Mesh) not cast shadows.
	bevy_pbr::NotShadowCaster : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Add this component to make a [`Mesh`](bevy_render::mesh::Mesh) not receive shadows.
	bevy_pbr::NotShadowReceiver : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///A light that emits light in all directions from a central point.
	///
	///Real-world values for `intensity` (luminous power in lumens) based on the electrical power
	///consumption of the type of real-world light are:
	///
	///| Luminous Power (lumen) (i.e. the intensity member) | Incandescent non-halogen (Watts) | Incandescent halogen (Watts) | Compact fluorescent (Watts) | LED (Watts |
	///|------|-----|----|--------|-------|
	///| 200  | 25  |    | 3-5    | 3     |
	///| 450  | 40  | 29 | 9-11   | 5-8   |
	///| 800  | 60  |    | 13-15  | 8-12  |
	///| 1100 | 75  | 53 | 18-20  | 10-16 |
	///| 1600 | 100 | 72 | 24-28  | 14-17 |
	///| 2400 | 150 |    | 30-52  | 24-30 |
	///| 3100 | 200 |    | 49-75  | 32    |
	///| 4000 | 300 |    | 75-100 | 40.5  |
	///
	///Source: [Wikipedia](https://en.wikipedia.org/wiki/Lumen_(unit)#Lighting)
	bevy_pbr::PointLight : Value
	: Fields
	(
		color: LuaColor,
		intensity: f32,
		range: f32,
		radius: f32,
		shadows_enabled: bool,
		shadow_depth_bias: f32,
		/// A bias applied along the direction of the fragment's surface normal. It is scaled to the
		/// shadow map's texel size so that it can be small close to the camera and gets larger further
		/// away.
		shadow_normal_bias: f32,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_pbr::PointLightShadowMap : Value
	: Fields
	(
		size: usize,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Alpha mode
	bevy_pbr::AlphaMode : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Controls whether an entity should rendered in wireframe-mode if the [`WireframePlugin`] is enabled
	bevy_pbr::wireframe::Wireframe : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_pbr::wireframe::WireframeConfig : Value
	: Fields
	(
		/// Whether to show wireframes for all meshes. If `false`, only meshes with a [Wireframe] component will be rendered.
		global: bool,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///The depth clear operation to perform for the main 3d pass.
	bevy_core_pipeline::core_3d::Camera3dDepthLoadOp : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///When used as a resource, sets the color that is used to clear the screen between frames.
	///
	///This color appears as the "background" color for simple apps, when
	///there are portions of the screen with nothing rendered.
	bevy_core_pipeline::clear_color::ClearColor : Value
	: Fields
	(
		0: LuaColor,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_core_pipeline::clear_color::ClearColorConfig : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_core_pipeline::core_2d::Camera2d : Value
	: Fields
	(
		clear_color: LuaClearColorConfig,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Configuration for the "main 3d render graph".
	bevy_core_pipeline::core_3d::Camera3d : Value
	: Fields
	(
		/// The clear color operation to perform for the main 3d pass.
		clear_color: LuaClearColorConfig,
		/// The depth clear operation to perform for the main 3d pass.
		depth_load_op: LuaCamera3dDepthLoadOp,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///How a sprite is positioned relative to its [`Transform`](bevy_transform::components::Transform).
	///It defaults to `Anchor::Center`.
	bevy_sprite::Anchor : Value
	: Fields
	(
	)
	+ AutoMethods
	(
		as_vec(&self) -> LuaVec2,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Component for rendering with meshes in the 2d pipeline, usually with a [2d material](crate::Material2d) such as [`ColorMaterial`](crate::ColorMaterial).
	///
	///It wraps a [`Handle<Mesh>`] to differentiate from the 3d pipelines which use the handles directly as components
	bevy_sprite::Mesh2dHandle : Value
	: Fields
	(
		0: ReflectedValue,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_sprite::TextureAtlasSprite : Value
	: Fields
	(
		color: LuaColor,
		index: usize,
		flip_x: bool,
		flip_y: bool,
		/// An optional custom size for the sprite that will be used when rendering, instead of the size
		/// of the sprite's image in the atlas
		custom_size: ReflectedValue,
		anchor: LuaAnchor,
	)
	+ AutoMethods
	(
		new(usize) -> LuaTextureAtlasSprite,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_sprite::Sprite : Value
	: Fields
	(
		/// The sprite's color tint
		color: LuaColor,
		/// Flip the sprite along the X axis
		flip_x: bool,
		/// Flip the sprite along the Y axis
		flip_y: bool,
		/// An optional custom size for the sprite that will be used when rendering, instead of the size
		/// of the sprite's image
		custom_size: ReflectedValue,
		/// [`Anchor`] point of the sprite in the world
		anchor: LuaAnchor,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///A rectangle defined by two points. There is no defined origin, so 0,0 could be anywhere
	///(top-left, bottom-left, etc)
	bevy_sprite::Rect : Value
	: Fields
	(
		/// The beginning point of the rect
		min: LuaVec2,
		/// The ending point of the rect
		max: LuaVec2,
	)
	+ AutoMethods
	(
		width(&self) -> f32,

		height(&self) -> f32,

		size(&self) -> LuaVec2,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Describes which rendering layers an entity belongs to.
	///
	///Cameras with this component will only render entities with intersecting
	///layers.
	///
	///There are 32 layers numbered `0` - [`TOTAL_LAYERS`](RenderLayers::TOTAL_LAYERS). Entities may
	///belong to one or more layers, or no layer at all.
	///
	///The [`Default`] instance of `RenderLayers` contains layer `0`, the first layer.
	///
	///An entity with this component without any layers is invisible.
	///
	///Entities without this component belong to layer `0`.
	bevy_render::view::visibility::RenderLayers : Value
	: Fields
	(
	)
	+ AutoMethods
	(
		///Create a new `RenderLayers` that belongs to all layers.
		all() -> LuaRenderLayers,

		///Create a new `RenderLayers` that belongs to no layers.
		none() -> LuaRenderLayers,

		///Determine if a `RenderLayers` intersects another.
		///
		///`RenderLayers`s intersect if they share any common layers.
		///
		///A `RenderLayers` with no layers will not match any other
		///`RenderLayers`, even another with no layers.
		intersects(&self,&LuaRenderLayers) -> bool,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///User indication of whether an entity is visible
	bevy_render::view::visibility::Visibility : Value
	: Fields
	(
		is_visible: bool,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Collection of entities visible from the current view.
	///
	///This component contains all entities which are visible from the currently
	///rendered view. The collection is updated automatically by the [`check_visibility()`]
	///system, and renderers can use it to optimize rendering of a particular view, to
	///prevent drawing items not visible from that view.
	///
	///This component is intended to be attached to the same entity as the [`Camera`] and
	///the [`Frustum`] defining the view.
	///
	///Currently this component is ignored by the sprite renderer, so sprite rendering
	///is not optimized per view.
	bevy_render::view::visibility::VisibleEntities : Value
	: Fields
	(
	)
	+ AutoMethods
	(
		len(&self) -> usize,

		is_empty(&self) -> bool,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Algorithmically-computed indication of whether an entity is visible and should be extracted for rendering
	bevy_render::view::visibility::ComputedVisibility : Value
	: Fields
	(
		is_visible: bool,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_render::mesh::skinning::SkinnedMesh : Value
	: Fields
	(
		inverse_bindposes: ReflectedValue,
		joints: ReflectedValue,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_render::camera::ScalingMode : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_render::camera::WindowOrigin : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_render::color::Color : Value
	: Fields
	(
	)
	+ AutoMethods
	(
		///New `Color` from sRGB colorspace.
		rgb(f32,f32,f32) -> LuaColor,

		///New `Color` from sRGB colorspace.
		rgba(f32,f32,f32,f32) -> LuaColor,

		///New `Color` from linear RGB colorspace.
		rgb_linear(f32,f32,f32) -> LuaColor,

		///New `Color` from linear RGB colorspace.
		rgba_linear(f32,f32,f32,f32) -> LuaColor,

		///New `Color` with HSL representation in sRGB colorspace.
		hsl(f32,f32,f32) -> LuaColor,

		///New `Color` with HSL representation in sRGB colorspace.
		hsla(f32,f32,f32,f32) -> LuaColor,

		///New `Color` from sRGB colorspace.
		rgb_u8(u8,u8,u8) -> LuaColor,

		///New `Color` from sRGB colorspace.
		rgba_u8(u8,u8,u8,u8) -> LuaColor,

		///Get red in sRGB colorspace.
		r(&self) -> f32,

		///Get green in sRGB colorspace.
		g(&self) -> f32,

		///Get blue in sRGB colorspace.
		b(&self) -> f32,

		///Get alpha.
		a(&self) -> f32,

		///Converts a `Color` to variant `Color::Rgba`
		as_rgba(&LuaColor) -> LuaColor,

		///Converts a `Color` to variant `Color::RgbaLinear`
		as_rgba_linear(&LuaColor) -> LuaColor,

		///Converts a `Color` to variant `Color::Hsla`
		as_hsla(&LuaColor) -> LuaColor,

		///Converts Color to a u32 from sRGB colorspace.
		///
		///Maps the RGBA channels in RGBA order to a little-endian byte array (GPUs are little-endian).
		///A will be the most significant byte and R the least significant.
		as_rgba_u32(LuaColor) -> u32,

		///Converts Color to a u32 from linear RGB colorspace.
		///
		///Maps the RGBA channels in RGBA order to a little-endian byte array (GPUs are little-endian).
		///A will be the most significant byte and R the least significant.
		as_linear_rgba_u32(LuaColor) -> u32,

	)
	+ BinOps
	(
		self Add LuaColor -> LuaColor,
		self Add LuaVec4 -> LuaColor,
		self Mul f32 -> LuaColor,
		self Mul LuaVec4 -> LuaColor,
		self Mul LuaVec3 -> LuaColor,
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///An Axis-Aligned Bounding Box
	bevy_render::primitives::Aabb : Value
	: Fields
	(
		center: LuaVec3A,
		half_extents: LuaVec3A,
	)
	+ AutoMethods
	(
		from_min_max(LuaVec3,LuaVec3) -> LuaAabb,

		min(&self) -> LuaVec3A,

		max(&self) -> LuaVec3A,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_render::primitives::CubemapFrusta : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///A frustum defined by the 6 containing planes
	///Planes are ordered left, right, top, bottom, near, far
	///Normals point into the contained volume
	bevy_render::primitives::Frustum : Value
	: Fields
	(
	)
	+ AutoMethods
	(
		from_view_projection(&LuaMat4,&LuaVec3,&LuaVec3,f32) -> LuaFrustum,

		intersects_obb(&self,&LuaAabb,&LuaMat4,bool) -> bool,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Configuration resource for [Multi-Sample Anti-Aliasing](https://en.wikipedia.org/wiki/Multisample_anti-aliasing).
	///
	///# Example
	///```
	///# use bevy_app::prelude::App;
	///# use bevy_render::prelude::Msaa;
	///App::new()
	///    .insert_resource(Msaa { samples: 4 })
	///    .run();
	///```
	bevy_render::view::Msaa : Value
	: Fields
	(
		/// The number of samples to run for Multi-Sample Anti-Aliasing. Higher numbers result in
		/// smoother edges.
		/// Defaults to 4.
		/// 
		/// Note that WGPU currently only supports 1 or 4 samples.
		/// Ultimately we plan on supporting whatever is natively supported on a given device.
		/// Check out this issue for more info: <https://github.com/gfx-rs/wgpu/issues/1832>
		samples: u32,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_render::camera::Camera : Value
	: Fields
	(
		/// If set, this camera will render to the given [`Viewport`] rectangle within the configured [`RenderTarget`].
		viewport: ReflectedValue,
		/// Cameras with a lower priority will be rendered before cameras with a higher priority.
		priority: isize,
		/// If this is set to true, this camera will be rendered to its specified [`RenderTarget`]. If false, this
		/// camera will not be rendered.
		is_active: bool,
		/// The method used to calculate this camera's depth. This will be used for projections and visibility.
		depth_calculation: LuaDepthCalculation,
		/// The "target" that this camera will render to.
		target: LuaRenderTarget,
	)
	+ AutoMethods
	(
		///The projection matrix computed using this camera's [`CameraProjection`].
		projection_matrix(&self) -> LuaMat4,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///The "target" that a [`Camera`] will render to. For example, this could be a [`Window`](bevy_window::Window)
	///swapchain or an [`Image`].
	bevy_render::camera::RenderTarget : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Render viewport configuration for the [`Camera`] component.
	///
	///The viewport defines the area on the render target to which the camera renders its image.
	///You can overlay multiple cameras in a single window using viewports to create effects like
	///split screen, minimaps, and character viewers.
	bevy_render::camera::Viewport : Value
	: Fields
	(
		/// The physical position to render this viewport to within the [`RenderTarget`] of this [`Camera`].
		/// (0,0) corresponds to the top-left corner
		physical_position: LuaUVec2,
		/// The physical size of the viewport rectangle to render to within the [`RenderTarget`] of this [`Camera`].
		/// The origin of the rectangle is in the top-left corner.
		physical_size: LuaUVec2,
		/// The minimum and maximum depth to render (on a scale from 0.0 to 1.0).
		depth: ReflectedValue,
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///A configurable [`CameraProjection`] that can select its projection type at runtime.
	bevy_render::camera::Projection : Value
	: Fields
	(
	)
	+ AutoMethods
	(
		get_projection_matrix(&self) -> LuaMat4,

		depth_calculation(&self) -> LuaDepthCalculation,

		far(&self) -> f32,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_render::camera::OrthographicProjection : Value
	: Fields
	(
		left: f32,
		right: f32,
		bottom: f32,
		top: f32,
		near: f32,
		far: f32,
		window_origin: LuaWindowOrigin,
		scaling_mode: LuaScalingMode,
		scale: f32,
		depth_calculation: LuaDepthCalculation,
	)
	+ AutoMethods
	(
		get_projection_matrix(&self) -> LuaMat4,

		depth_calculation(&self) -> LuaDepthCalculation,

		far(&self) -> f32,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_render::camera::PerspectiveProjection : Value
	: Fields
	(
		fov: f32,
		aspect_ratio: f32,
		near: f32,
		far: f32,
	)
	+ AutoMethods
	(
		get_projection_matrix(&self) -> LuaMat4,

		depth_calculation(&self) -> LuaDepthCalculation,

		far(&self) -> f32,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_render::camera::DepthCalculation : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Configures the [`RenderGraph`](crate::render_graph::RenderGraph) name assigned to be run for a given [`Camera`] entity.
	bevy_render::camera::CameraRenderGraph : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_asset::AssetPathId : Value
	: Fields
	(
	)
	+ AutoMethods
	(
		source_path_id(&self) -> LuaSourcePathId,

		label_id(&self) -> LuaLabelId,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_asset::LabelId : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	bevy_asset::SourcePathId : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///A unique, stable asset id
	bevy_asset::HandleId : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///A 2-dimensional vector.
	glam::f32::vec2::Vec2 : Value
	: Fields
	(
		x: f32,
		y: f32,
	)
	+ AutoMethods
	(
		///Creates a new vector.
		new(f32,f32) -> LuaVec2,

		///Creates a vector with all elements set to `v`.
		splat(f32) -> LuaVec2,

		///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
		///for each element of `self`.
		///
		///A true element in the mask uses the corresponding element from `if_true`, and false
		///uses the element from `if_false`.
		select(LuaBVec2,LuaVec2,LuaVec2) -> LuaVec2,

		///Creates a 3D vector from `self` and the given `z` value.
		extend(self,f32) -> LuaVec3,

		///Computes the dot product of `self` and `rhs`.
		dot(self,LuaVec2) -> f32,

		///Returns a vector containing the minimum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
		min(self,LuaVec2) -> LuaVec2,

		///Returns a vector containing the maximum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
		max(self,LuaVec2) -> LuaVec2,

		///Component-wise clamping of values, similar to [`f32::clamp`].
		///
		///Each element in `min` must be less-or-equal to the corresponding element in `max`.
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp(self,LuaVec2,LuaVec2) -> LuaVec2,

		///Returns the horizontal minimum of `self`.
		///
		///In other words this computes `min(x, y, ..)`.
		min_element(self) -> f32,

		///Returns the horizontal maximum of `self`.
		///
		///In other words this computes `max(x, y, ..)`.
		max_element(self) -> f32,

		///Returns a vector mask containing the result of a `==` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
		///elements.
		cmpeq(self,LuaVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `!=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
		///elements.
		cmpne(self,LuaVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `>=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
		///elements.
		cmpge(self,LuaVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `>` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
		///elements.
		cmpgt(self,LuaVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `<=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
		///elements.
		cmple(self,LuaVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `<` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
		///elements.
		cmplt(self,LuaVec2) -> LuaBVec2,

		///Returns a vector containing the absolute value of each element of `self`.
		abs(self) -> LuaVec2,

		///Returns a vector with elements representing the sign of `self`.
		///
		///- `1.0` if the number is positive, `+0.0` or `INFINITY`
		///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
		///- `NAN` if the number is `NAN`
		signum(self) -> LuaVec2,

		///Returns `true` if, and only if, all elements are finite.  If any element is either
		///`NaN`, positive or negative infinity, this will return `false`.
		is_finite(self) -> bool,

		///Returns `true` if any elements are `NaN`.
		is_nan(self) -> bool,

		///Performs `is_nan` on each element of self, returning a vector mask of the results.
		///
		///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
		is_nan_mask(self) -> LuaBVec2,

		///Computes the length of `self`.
		length(self) -> f32,

		///Computes the squared length of `self`.
		///
		///This is faster than `length()` as it avoids a square root operation.
		length_squared(self) -> f32,

		///Computes `1.0 / length()`.
		///
		///For valid results, `self` must _not_ be of length zero.
		length_recip(self) -> f32,

		///Computes the Euclidean distance between two points in space.
		distance(self,LuaVec2) -> f32,

		///Compute the squared euclidean distance between two points in space.
		distance_squared(self,LuaVec2) -> f32,

		///Returns `self` normalized to length 1.0.
		///
		///For valid results, `self` must _not_ be of length zero, nor very close to zero.
		///
		///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
		///
		///Panics
		///
		///Will panic if `self` is zero length when `glam_assert` is enabled.
		normalize(self) -> LuaVec2,

		///Returns `self` normalized to length 1.0 if possible, else returns zero.
		///
		///In particular, if the input is zero (or very close to zero), or non-finite,
		///the result of this operation will be zero.
		///
		///See also [`Self::try_normalize`].
		normalize_or_zero(self) -> LuaVec2,

		///Returns whether `self` is length `1.0` or not.
		///
		///Uses a precision threshold of `1e-6`.
		is_normalized(self) -> bool,

		///Returns the vector projection of `self` onto `rhs`.
		///
		///`rhs` must be of non-zero length.
		///
		///# Panics
		///
		///Will panic if `rhs` is zero length when `glam_assert` is enabled.
		project_onto(self,LuaVec2) -> LuaVec2,

		///Returns the vector rejection of `self` from `rhs`.
		///
		///The vector rejection is the vector perpendicular to the projection of `self` onto
		///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
		///
		///`rhs` must be of non-zero length.
		///
		///# Panics
		///
		///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
		reject_from(self,LuaVec2) -> LuaVec2,

		///Returns the vector projection of `self` onto `rhs`.
		///
		///`rhs` must be normalized.
		///
		///# Panics
		///
		///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
		project_onto_normalized(self,LuaVec2) -> LuaVec2,

		///Returns the vector rejection of `self` from `rhs`.
		///
		///The vector rejection is the vector perpendicular to the projection of `self` onto
		///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
		///
		///`rhs` must be normalized.
		///
		///# Panics
		///
		///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
		reject_from_normalized(self,LuaVec2) -> LuaVec2,

		///Returns a vector containing the nearest integer to a number for each element of `self`.
		///Round half-way cases away from 0.0.
		round(self) -> LuaVec2,

		///Returns a vector containing the largest integer less than or equal to a number for each
		///element of `self`.
		floor(self) -> LuaVec2,

		///Returns a vector containing the smallest integer greater than or equal to a number for
		///each element of `self`.
		ceil(self) -> LuaVec2,

		///Returns a vector containing the fractional part of the vector, e.g. `self -
		///self.floor()`.
		///
		///Note that this is fast but not precise for large numbers.
		fract(self) -> LuaVec2,

		///Returns a vector containing `e^self` (the exponential function) for each element of
		///`self`.
		exp(self) -> LuaVec2,

		///Returns a vector containing each element of `self` raised to the power of `n`.
		powf(self,f32) -> LuaVec2,

		///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
		recip(self) -> LuaVec2,

		///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
		///
		///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
		///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
		///extrapolated.
		lerp(self,LuaVec2,f32) -> LuaVec2,

		///Returns true if the absolute difference of all elements between `self` and `rhs` is
		///less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two vectors contain similar elements. It works best when
		///comparing with a known value. The `max_abs_diff` that should be used used depends on
		///the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(self,LuaVec2,f32) -> bool,

		///Returns a vector with a length no less than `min` and no more than `max`
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp_length(self,f32,f32) -> LuaVec2,

		///Returns a vector with a length no more than `max`
		clamp_length_max(self,f32) -> LuaVec2,

		///Returns a vector with a length no less than `min`
		clamp_length_min(self,f32) -> LuaVec2,

		///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
		///error, yielding a more accurate result than an unfused multiply-add.
		///
		///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
		///architecture has a dedicated fma CPU instruction. However, this is not always true,
		///and will be heavily dependant on designing algorithms with specific target hardware in
		///mind.
		mul_add(self,LuaVec2,LuaVec2) -> LuaVec2,

		///Creates a 2D vector containing `[angle.cos(), angle.sin()]`. This can be used in
		///conjunction with the `rotate` method, e.g. `Vec2::from_angle(PI).rotate(Vec2::Y)` will
		///create the vector [-1, 0] and rotate `Vec2::Y` around it returning `-Vec2::Y`.
		from_angle(f32) -> LuaVec2,

		///Returns the angle (in radians) between `self` and `rhs`.
		///
		///The input vectors do not need to be unit length however they must be non-zero.
		angle_between(self,LuaVec2) -> f32,

		///Returns a vector that is equal to `self` rotated by 90 degrees.
		perp(self) -> LuaVec2,

		///The perpendicular dot product of `self` and `rhs`.
		///Also known as the wedge product, 2D cross product, and determinant.
		perp_dot(self,LuaVec2) -> f32,

		///Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
		///then this just rotation. This is what you usually want. Otherwise,
		///it will be like a rotation with a multiplication by `self`'s length.
		rotate(self,LuaVec2) -> LuaVec2,

	)
	+ BinOps
	(
		self Add LuaVec2 -> LuaVec2,
		self Add f32 -> LuaVec2,
		f32 Add self -> LuaVec2,
		self Sub LuaVec2 -> LuaVec2,
		self Sub f32 -> LuaVec2,
		f32 Sub self -> LuaVec2,
		self Div LuaVec2 -> LuaVec2,
		self Div f32 -> LuaVec2,
		f32 Div self -> LuaVec2,
		self Mul LuaVec2 -> LuaVec2,
		self Mul f32 -> LuaVec2,
		f32 Mul self -> LuaVec2,
		self Rem LuaVec2 -> LuaVec2,
		self Rem f32 -> LuaVec2,
		f32 Rem self -> LuaVec2,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
		(MetaMethod::Index) => |_,s,idx: usize| {Ok(s.clone()[idx])};
		mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,f32)| {Ok(s.val_mut(|s| s[idx] = val))};
	}
}
impl_lua_newtype!{
	///A 3-dimensional vector.
	glam::f32::vec3::Vec3 : Value
	: Fields
	(
		x: f32,
		y: f32,
		z: f32,
	)
	+ AutoMethods
	(
		///Creates a new vector.
		new(f32,f32,f32) -> LuaVec3,

		///Creates a vector with all elements set to `v`.
		splat(f32) -> LuaVec3,

		///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
		///for each element of `self`.
		///
		///A true element in the mask uses the corresponding element from `if_true`, and false
		///uses the element from `if_false`.
		select(LuaBVec3,LuaVec3,LuaVec3) -> LuaVec3,

		///Creates a 4D vector from `self` and the given `w` value.
		extend(self,f32) -> LuaVec4,

		///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
		///
		///Truncation may also be performed by using `self.xy()` or `Vec2::from()`.
		truncate(self) -> LuaVec2,

		///Computes the dot product of `self` and `rhs`.
		dot(self,LuaVec3) -> f32,

		///Computes the cross product of `self` and `rhs`.
		cross(self,LuaVec3) -> LuaVec3,

		///Returns a vector containing the minimum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
		min(self,LuaVec3) -> LuaVec3,

		///Returns a vector containing the maximum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
		max(self,LuaVec3) -> LuaVec3,

		///Component-wise clamping of values, similar to [`f32::clamp`].
		///
		///Each element in `min` must be less-or-equal to the corresponding element in `max`.
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp(self,LuaVec3,LuaVec3) -> LuaVec3,

		///Returns the horizontal minimum of `self`.
		///
		///In other words this computes `min(x, y, ..)`.
		min_element(self) -> f32,

		///Returns the horizontal maximum of `self`.
		///
		///In other words this computes `max(x, y, ..)`.
		max_element(self) -> f32,

		///Returns a vector mask containing the result of a `==` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
		///elements.
		cmpeq(self,LuaVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `!=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
		///elements.
		cmpne(self,LuaVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `>=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
		///elements.
		cmpge(self,LuaVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `>` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
		///elements.
		cmpgt(self,LuaVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `<=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
		///elements.
		cmple(self,LuaVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `<` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
		///elements.
		cmplt(self,LuaVec3) -> LuaBVec3,

		///Returns a vector containing the absolute value of each element of `self`.
		abs(self) -> LuaVec3,

		///Returns a vector with elements representing the sign of `self`.
		///
		///- `1.0` if the number is positive, `+0.0` or `INFINITY`
		///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
		///- `NAN` if the number is `NAN`
		signum(self) -> LuaVec3,

		///Returns `true` if, and only if, all elements are finite.  If any element is either
		///`NaN`, positive or negative infinity, this will return `false`.
		is_finite(self) -> bool,

		///Returns `true` if any elements are `NaN`.
		is_nan(self) -> bool,

		///Performs `is_nan` on each element of self, returning a vector mask of the results.
		///
		///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
		is_nan_mask(self) -> LuaBVec3,

		///Computes the length of `self`.
		length(self) -> f32,

		///Computes the squared length of `self`.
		///
		///This is faster than `length()` as it avoids a square root operation.
		length_squared(self) -> f32,

		///Computes `1.0 / length()`.
		///
		///For valid results, `self` must _not_ be of length zero.
		length_recip(self) -> f32,

		///Computes the Euclidean distance between two points in space.
		distance(self,LuaVec3) -> f32,

		///Compute the squared euclidean distance between two points in space.
		distance_squared(self,LuaVec3) -> f32,

		///Returns `self` normalized to length 1.0.
		///
		///For valid results, `self` must _not_ be of length zero, nor very close to zero.
		///
		///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
		///
		///Panics
		///
		///Will panic if `self` is zero length when `glam_assert` is enabled.
		normalize(self) -> LuaVec3,

		///Returns `self` normalized to length 1.0 if possible, else returns zero.
		///
		///In particular, if the input is zero (or very close to zero), or non-finite,
		///the result of this operation will be zero.
		///
		///See also [`Self::try_normalize`].
		normalize_or_zero(self) -> LuaVec3,

		///Returns whether `self` is length `1.0` or not.
		///
		///Uses a precision threshold of `1e-6`.
		is_normalized(self) -> bool,

		///Returns the vector projection of `self` onto `rhs`.
		///
		///`rhs` must be of non-zero length.
		///
		///# Panics
		///
		///Will panic if `rhs` is zero length when `glam_assert` is enabled.
		project_onto(self,LuaVec3) -> LuaVec3,

		///Returns the vector rejection of `self` from `rhs`.
		///
		///The vector rejection is the vector perpendicular to the projection of `self` onto
		///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
		///
		///`rhs` must be of non-zero length.
		///
		///# Panics
		///
		///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
		reject_from(self,LuaVec3) -> LuaVec3,

		///Returns the vector projection of `self` onto `rhs`.
		///
		///`rhs` must be normalized.
		///
		///# Panics
		///
		///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
		project_onto_normalized(self,LuaVec3) -> LuaVec3,

		///Returns the vector rejection of `self` from `rhs`.
		///
		///The vector rejection is the vector perpendicular to the projection of `self` onto
		///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
		///
		///`rhs` must be normalized.
		///
		///# Panics
		///
		///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
		reject_from_normalized(self,LuaVec3) -> LuaVec3,

		///Returns a vector containing the nearest integer to a number for each element of `self`.
		///Round half-way cases away from 0.0.
		round(self) -> LuaVec3,

		///Returns a vector containing the largest integer less than or equal to a number for each
		///element of `self`.
		floor(self) -> LuaVec3,

		///Returns a vector containing the smallest integer greater than or equal to a number for
		///each element of `self`.
		ceil(self) -> LuaVec3,

		///Returns a vector containing the fractional part of the vector, e.g. `self -
		///self.floor()`.
		///
		///Note that this is fast but not precise for large numbers.
		fract(self) -> LuaVec3,

		///Returns a vector containing `e^self` (the exponential function) for each element of
		///`self`.
		exp(self) -> LuaVec3,

		///Returns a vector containing each element of `self` raised to the power of `n`.
		powf(self,f32) -> LuaVec3,

		///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
		recip(self) -> LuaVec3,

		///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
		///
		///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
		///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
		///extrapolated.
		lerp(self,LuaVec3,f32) -> LuaVec3,

		///Returns true if the absolute difference of all elements between `self` and `rhs` is
		///less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two vectors contain similar elements. It works best when
		///comparing with a known value. The `max_abs_diff` that should be used used depends on
		///the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(self,LuaVec3,f32) -> bool,

		///Returns a vector with a length no less than `min` and no more than `max`
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp_length(self,f32,f32) -> LuaVec3,

		///Returns a vector with a length no more than `max`
		clamp_length_max(self,f32) -> LuaVec3,

		///Returns a vector with a length no less than `min`
		clamp_length_min(self,f32) -> LuaVec3,

		///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
		///error, yielding a more accurate result than an unfused multiply-add.
		///
		///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
		///architecture has a dedicated fma CPU instruction. However, this is not always true,
		///and will be heavily dependant on designing algorithms with specific target hardware in
		///mind.
		mul_add(self,LuaVec3,LuaVec3) -> LuaVec3,

		///Returns the angle (in radians) between two vectors.
		///
		///The input vectors do not need to be unit length however they must be non-zero.
		angle_between(self,LuaVec3) -> f32,

		///Returns some vector that is orthogonal to the given one.
		///
		///The input vector must be finite and non-zero.
		///
		///The output vector is not necessarily unit-length.
		///For that use [`Self::any_orthonormal_vector`] instead.
		any_orthogonal_vector(&self) -> LuaVec3,

		///Returns any unit-length vector that is orthogonal to the given one.
		///The input vector must be finite and non-zero.
		///
		///# Panics
		///
		///Will panic if `self` is not normalized when `glam_assert` is enabled.
		any_orthonormal_vector(&self) -> LuaVec3,

	)
	+ BinOps
	(
		self Add LuaVec3 -> LuaVec3,
		self Add f32 -> LuaVec3,
		f32 Add self -> LuaVec3,
		self Sub LuaVec3 -> LuaVec3,
		self Sub f32 -> LuaVec3,
		f32 Sub self -> LuaVec3,
		self Div LuaVec3 -> LuaVec3,
		self Div f32 -> LuaVec3,
		f32 Div self -> LuaVec3,
		self Mul LuaVec3 -> LuaVec3,
		self Mul f32 -> LuaVec3,
		f32 Mul self -> LuaVec3,
		self Rem LuaVec3 -> LuaVec3,
		self Rem f32 -> LuaVec3,
		f32 Rem self -> LuaVec3,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
		(MetaMethod::Index) => |_,s,idx: usize| {Ok(s.clone()[idx])};
		mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,f32)| {Ok(s.val_mut(|s| s[idx] = val))};
	}
}
impl_lua_newtype!{
	///A 3-dimensional vector with SIMD support.
	///
	///This type is 16 byte aligned. A SIMD vector type is used for storage on supported platforms for
	///better performance than the `Vec3` type.
	///
	///It is possible to convert between `Vec3` and `Vec3A` types using `From` trait implementations.
	glam::f32::sse2::vec3A::Vec3A : Value
	: Fields
	(
	)
	+ AutoMethods
	(
		///Creates a new vector.
		new(f32,f32,f32) -> LuaVec3A,

		///Creates a vector with all elements set to `v`.
		splat(f32) -> LuaVec3A,

		///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
		///for each element of `self`.
		///
		///A true element in the mask uses the corresponding element from `if_true`, and false
		///uses the element from `if_false`.
		select(LuaBVec3A,LuaVec3A,LuaVec3A) -> LuaVec3A,

		///Creates a 4D vector from `self` and the given `w` value.
		extend(self,f32) -> LuaVec4,

		///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
		///
		///Truncation may also be performed by using `self.xy()` or `Vec2::from()`.
		truncate(self) -> LuaVec2,

		///Computes the dot product of `self` and `rhs`.
		dot(self,LuaVec3A) -> f32,

		///Computes the cross product of `self` and `rhs`.
		cross(self,LuaVec3A) -> LuaVec3A,

		///Returns a vector containing the minimum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
		min(self,LuaVec3A) -> LuaVec3A,

		///Returns a vector containing the maximum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
		max(self,LuaVec3A) -> LuaVec3A,

		///Component-wise clamping of values, similar to [`f32::clamp`].
		///
		///Each element in `min` must be less-or-equal to the corresponding element in `max`.
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp(self,LuaVec3A,LuaVec3A) -> LuaVec3A,

		///Returns the horizontal minimum of `self`.
		///
		///In other words this computes `min(x, y, ..)`.
		min_element(self) -> f32,

		///Returns the horizontal maximum of `self`.
		///
		///In other words this computes `max(x, y, ..)`.
		max_element(self) -> f32,

		///Returns a vector mask containing the result of a `==` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
		///elements.
		cmpeq(self,LuaVec3A) -> LuaBVec3A,

		///Returns a vector mask containing the result of a `!=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
		///elements.
		cmpne(self,LuaVec3A) -> LuaBVec3A,

		///Returns a vector mask containing the result of a `>=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
		///elements.
		cmpge(self,LuaVec3A) -> LuaBVec3A,

		///Returns a vector mask containing the result of a `>` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
		///elements.
		cmpgt(self,LuaVec3A) -> LuaBVec3A,

		///Returns a vector mask containing the result of a `<=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
		///elements.
		cmple(self,LuaVec3A) -> LuaBVec3A,

		///Returns a vector mask containing the result of a `<` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
		///elements.
		cmplt(self,LuaVec3A) -> LuaBVec3A,

		///Returns a vector containing the absolute value of each element of `self`.
		abs(self) -> LuaVec3A,

		///Returns a vector with elements representing the sign of `self`.
		///
		///- `1.0` if the number is positive, `+0.0` or `INFINITY`
		///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
		///- `NAN` if the number is `NAN`
		signum(self) -> LuaVec3A,

		///Returns `true` if, and only if, all elements are finite.  If any element is either
		///`NaN`, positive or negative infinity, this will return `false`.
		is_finite(self) -> bool,

		///Returns `true` if any elements are `NaN`.
		is_nan(self) -> bool,

		///Performs `is_nan` on each element of self, returning a vector mask of the results.
		///
		///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
		is_nan_mask(self) -> LuaBVec3A,

		///Computes the length of `self`.
		length(self) -> f32,

		///Computes the squared length of `self`.
		///
		///This is faster than `length()` as it avoids a square root operation.
		length_squared(self) -> f32,

		///Computes `1.0 / length()`.
		///
		///For valid results, `self` must _not_ be of length zero.
		length_recip(self) -> f32,

		///Computes the Euclidean distance between two points in space.
		distance(self,LuaVec3A) -> f32,

		///Compute the squared euclidean distance between two points in space.
		distance_squared(self,LuaVec3A) -> f32,

		///Returns `self` normalized to length 1.0.
		///
		///For valid results, `self` must _not_ be of length zero, nor very close to zero.
		///
		///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
		///
		///Panics
		///
		///Will panic if `self` is zero length when `glam_assert` is enabled.
		normalize(self) -> LuaVec3A,

		///Returns `self` normalized to length 1.0 if possible, else returns zero.
		///
		///In particular, if the input is zero (or very close to zero), or non-finite,
		///the result of this operation will be zero.
		///
		///See also [`Self::try_normalize`].
		normalize_or_zero(self) -> LuaVec3A,

		///Returns whether `self` is length `1.0` or not.
		///
		///Uses a precision threshold of `1e-6`.
		is_normalized(self) -> bool,

		///Returns the vector projection of `self` onto `rhs`.
		///
		///`rhs` must be of non-zero length.
		///
		///# Panics
		///
		///Will panic if `rhs` is zero length when `glam_assert` is enabled.
		project_onto(self,LuaVec3A) -> LuaVec3A,

		///Returns the vector rejection of `self` from `rhs`.
		///
		///The vector rejection is the vector perpendicular to the projection of `self` onto
		///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
		///
		///`rhs` must be of non-zero length.
		///
		///# Panics
		///
		///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
		reject_from(self,LuaVec3A) -> LuaVec3A,

		///Returns the vector projection of `self` onto `rhs`.
		///
		///`rhs` must be normalized.
		///
		///# Panics
		///
		///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
		project_onto_normalized(self,LuaVec3A) -> LuaVec3A,

		///Returns the vector rejection of `self` from `rhs`.
		///
		///The vector rejection is the vector perpendicular to the projection of `self` onto
		///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
		///
		///`rhs` must be normalized.
		///
		///# Panics
		///
		///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
		reject_from_normalized(self,LuaVec3A) -> LuaVec3A,

		///Returns a vector containing the nearest integer to a number for each element of `self`.
		///Round half-way cases away from 0.0.
		round(self) -> LuaVec3A,

		///Returns a vector containing the largest integer less than or equal to a number for each
		///element of `self`.
		floor(self) -> LuaVec3A,

		///Returns a vector containing the smallest integer greater than or equal to a number for
		///each element of `self`.
		ceil(self) -> LuaVec3A,

		///Returns a vector containing the fractional part of the vector, e.g. `self -
		///self.floor()`.
		///
		///Note that this is fast but not precise for large numbers.
		fract(self) -> LuaVec3A,

		///Returns a vector containing `e^self` (the exponential function) for each element of
		///`self`.
		exp(self) -> LuaVec3A,

		///Returns a vector containing each element of `self` raised to the power of `n`.
		powf(self,f32) -> LuaVec3A,

		///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
		recip(self) -> LuaVec3A,

		///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
		///
		///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
		///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
		///extrapolated.
		lerp(self,LuaVec3A,f32) -> LuaVec3A,

		///Returns true if the absolute difference of all elements between `self` and `rhs` is
		///less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two vectors contain similar elements. It works best when
		///comparing with a known value. The `max_abs_diff` that should be used used depends on
		///the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(self,LuaVec3A,f32) -> bool,

		///Returns a vector with a length no less than `min` and no more than `max`
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp_length(self,f32,f32) -> LuaVec3A,

		///Returns a vector with a length no more than `max`
		clamp_length_max(self,f32) -> LuaVec3A,

		///Returns a vector with a length no less than `min`
		clamp_length_min(self,f32) -> LuaVec3A,

		///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
		///error, yielding a more accurate result than an unfused multiply-add.
		///
		///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
		///architecture has a dedicated fma CPU instruction. However, this is not always true,
		///and will be heavily dependant on designing algorithms with specific target hardware in
		///mind.
		mul_add(self,LuaVec3A,LuaVec3A) -> LuaVec3A,

		///Returns the angle (in radians) between two vectors.
		///
		///The input vectors do not need to be unit length however they must be non-zero.
		angle_between(self,LuaVec3A) -> f32,

		///Returns some vector that is orthogonal to the given one.
		///
		///The input vector must be finite and non-zero.
		///
		///The output vector is not necessarily unit-length.
		///For that use [`Self::any_orthonormal_vector`] instead.
		any_orthogonal_vector(&self) -> LuaVec3A,

		///Returns any unit-length vector that is orthogonal to the given one.
		///The input vector must be finite and non-zero.
		///
		///# Panics
		///
		///Will panic if `self` is not normalized when `glam_assert` is enabled.
		any_orthonormal_vector(&self) -> LuaVec3A,

	)
	+ BinOps
	(
		self Add LuaVec3A -> LuaVec3A,
		self Add f32 -> LuaVec3A,
		f32 Add self -> LuaVec3A,
		self Sub LuaVec3A -> LuaVec3A,
		self Sub f32 -> LuaVec3A,
		f32 Sub self -> LuaVec3A,
		self Div LuaVec3A -> LuaVec3A,
		self Div f32 -> LuaVec3A,
		f32 Div self -> LuaVec3A,
		self Mul LuaVec3A -> LuaVec3A,
		self Mul f32 -> LuaVec3A,
		f32 Mul self -> LuaVec3A,
		self Rem LuaVec3A -> LuaVec3A,
		self Rem f32 -> LuaVec3A,
		f32 Rem self -> LuaVec3A,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
		(MetaMethod::Index) => |_,s,idx: usize| {Ok(s.clone()[idx])};
		mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,f32)| {Ok(s.val_mut(|s| s[idx] = val))};
	}
}
impl_lua_newtype!{
	///A 4-dimensional vector with SIMD support.
	///
	///This type uses 16 byte aligned SIMD vector type for storage.
	glam::f32::sse2::vec4::Vec4 : Value
	: Fields
	(
	)
	+ AutoMethods
	(
		///Creates a new vector.
		new(f32,f32,f32,f32) -> LuaVec4,

		///Creates a vector with all elements set to `v`.
		splat(f32) -> LuaVec4,

		///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
		///for each element of `self`.
		///
		///A true element in the mask uses the corresponding element from `if_true`, and false
		///uses the element from `if_false`.
		select(LuaBVec4A,LuaVec4,LuaVec4) -> LuaVec4,

		///Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
		///
		///Truncation to `Vec3` may also be performed by using `self.xyz()` or `Vec3::from()`.
		///
		///To truncate to `Vec3A` use `Vec3A::from()`.
		truncate(self) -> LuaVec3,

		///Computes the dot product of `self` and `rhs`.
		dot(self,LuaVec4) -> f32,

		///Returns a vector containing the minimum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
		min(self,LuaVec4) -> LuaVec4,

		///Returns a vector containing the maximum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
		max(self,LuaVec4) -> LuaVec4,

		///Component-wise clamping of values, similar to [`f32::clamp`].
		///
		///Each element in `min` must be less-or-equal to the corresponding element in `max`.
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp(self,LuaVec4,LuaVec4) -> LuaVec4,

		///Returns the horizontal minimum of `self`.
		///
		///In other words this computes `min(x, y, ..)`.
		min_element(self) -> f32,

		///Returns the horizontal maximum of `self`.
		///
		///In other words this computes `max(x, y, ..)`.
		max_element(self) -> f32,

		///Returns a vector mask containing the result of a `==` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
		///elements.
		cmpeq(self,LuaVec4) -> LuaBVec4A,

		///Returns a vector mask containing the result of a `!=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
		///elements.
		cmpne(self,LuaVec4) -> LuaBVec4A,

		///Returns a vector mask containing the result of a `>=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
		///elements.
		cmpge(self,LuaVec4) -> LuaBVec4A,

		///Returns a vector mask containing the result of a `>` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
		///elements.
		cmpgt(self,LuaVec4) -> LuaBVec4A,

		///Returns a vector mask containing the result of a `<=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
		///elements.
		cmple(self,LuaVec4) -> LuaBVec4A,

		///Returns a vector mask containing the result of a `<` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
		///elements.
		cmplt(self,LuaVec4) -> LuaBVec4A,

		///Returns a vector containing the absolute value of each element of `self`.
		abs(self) -> LuaVec4,

		///Returns a vector with elements representing the sign of `self`.
		///
		///- `1.0` if the number is positive, `+0.0` or `INFINITY`
		///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
		///- `NAN` if the number is `NAN`
		signum(self) -> LuaVec4,

		///Returns `true` if, and only if, all elements are finite.  If any element is either
		///`NaN`, positive or negative infinity, this will return `false`.
		is_finite(self) -> bool,

		///Returns `true` if any elements are `NaN`.
		is_nan(self) -> bool,

		///Performs `is_nan` on each element of self, returning a vector mask of the results.
		///
		///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
		is_nan_mask(self) -> LuaBVec4A,

		///Computes the length of `self`.
		length(self) -> f32,

		///Computes the squared length of `self`.
		///
		///This is faster than `length()` as it avoids a square root operation.
		length_squared(self) -> f32,

		///Computes `1.0 / length()`.
		///
		///For valid results, `self` must _not_ be of length zero.
		length_recip(self) -> f32,

		///Computes the Euclidean distance between two points in space.
		distance(self,LuaVec4) -> f32,

		///Compute the squared euclidean distance between two points in space.
		distance_squared(self,LuaVec4) -> f32,

		///Returns `self` normalized to length 1.0.
		///
		///For valid results, `self` must _not_ be of length zero, nor very close to zero.
		///
		///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
		///
		///Panics
		///
		///Will panic if `self` is zero length when `glam_assert` is enabled.
		normalize(self) -> LuaVec4,

		///Returns `self` normalized to length 1.0 if possible, else returns zero.
		///
		///In particular, if the input is zero (or very close to zero), or non-finite,
		///the result of this operation will be zero.
		///
		///See also [`Self::try_normalize`].
		normalize_or_zero(self) -> LuaVec4,

		///Returns whether `self` is length `1.0` or not.
		///
		///Uses a precision threshold of `1e-6`.
		is_normalized(self) -> bool,

		///Returns the vector projection of `self` onto `rhs`.
		///
		///`rhs` must be of non-zero length.
		///
		///# Panics
		///
		///Will panic if `rhs` is zero length when `glam_assert` is enabled.
		project_onto(self,LuaVec4) -> LuaVec4,

		///Returns the vector rejection of `self` from `rhs`.
		///
		///The vector rejection is the vector perpendicular to the projection of `self` onto
		///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
		///
		///`rhs` must be of non-zero length.
		///
		///# Panics
		///
		///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
		reject_from(self,LuaVec4) -> LuaVec4,

		///Returns the vector projection of `self` onto `rhs`.
		///
		///`rhs` must be normalized.
		///
		///# Panics
		///
		///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
		project_onto_normalized(self,LuaVec4) -> LuaVec4,

		///Returns the vector rejection of `self` from `rhs`.
		///
		///The vector rejection is the vector perpendicular to the projection of `self` onto
		///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
		///
		///`rhs` must be normalized.
		///
		///# Panics
		///
		///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
		reject_from_normalized(self,LuaVec4) -> LuaVec4,

		///Returns a vector containing the nearest integer to a number for each element of `self`.
		///Round half-way cases away from 0.0.
		round(self) -> LuaVec4,

		///Returns a vector containing the largest integer less than or equal to a number for each
		///element of `self`.
		floor(self) -> LuaVec4,

		///Returns a vector containing the smallest integer greater than or equal to a number for
		///each element of `self`.
		ceil(self) -> LuaVec4,

		///Returns a vector containing the fractional part of the vector, e.g. `self -
		///self.floor()`.
		///
		///Note that this is fast but not precise for large numbers.
		fract(self) -> LuaVec4,

		///Returns a vector containing `e^self` (the exponential function) for each element of
		///`self`.
		exp(self) -> LuaVec4,

		///Returns a vector containing each element of `self` raised to the power of `n`.
		powf(self,f32) -> LuaVec4,

		///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
		recip(self) -> LuaVec4,

		///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
		///
		///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
		///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
		///extrapolated.
		lerp(self,LuaVec4,f32) -> LuaVec4,

		///Returns true if the absolute difference of all elements between `self` and `rhs` is
		///less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two vectors contain similar elements. It works best when
		///comparing with a known value. The `max_abs_diff` that should be used used depends on
		///the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(self,LuaVec4,f32) -> bool,

		///Returns a vector with a length no less than `min` and no more than `max`
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp_length(self,f32,f32) -> LuaVec4,

		///Returns a vector with a length no more than `max`
		clamp_length_max(self,f32) -> LuaVec4,

		///Returns a vector with a length no less than `min`
		clamp_length_min(self,f32) -> LuaVec4,

		///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
		///error, yielding a more accurate result than an unfused multiply-add.
		///
		///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
		///architecture has a dedicated fma CPU instruction. However, this is not always true,
		///and will be heavily dependant on designing algorithms with specific target hardware in
		///mind.
		mul_add(self,LuaVec4,LuaVec4) -> LuaVec4,

	)
	+ BinOps
	(
		self Add LuaVec4 -> LuaVec4,
		self Add f32 -> LuaVec4,
		f32 Add self -> LuaVec4,
		self Sub LuaVec4 -> LuaVec4,
		self Sub f32 -> LuaVec4,
		f32 Sub self -> LuaVec4,
		self Div LuaVec4 -> LuaVec4,
		self Div f32 -> LuaVec4,
		f32 Div self -> LuaVec4,
		self Mul LuaVec4 -> LuaVec4,
		self Mul f32 -> LuaVec4,
		f32 Mul self -> LuaVec4,
		self Rem LuaVec4 -> LuaVec4,
		self Rem f32 -> LuaVec4,
		f32 Rem self -> LuaVec4,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
		(MetaMethod::Index) => |_,s,idx: usize| {Ok(s.clone()[idx])};
		mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,f32)| {Ok(s.val_mut(|s| s[idx] = val))};
	}
}
impl_lua_newtype!{
	///A 2-dimensional boolean vector.
	glam::f32::sse2::vec2::BVec2 : Value
	: Fields
	(
		x: bool,
		y: bool,
	)
	+ AutoMethods
	(
		///Creates a new vector mask.
		new(bool,bool) -> LuaBVec2,

		///Returns a bitmask with the lowest two bits set from the elements of `self`.
		///
		///A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
		///into the first lowest bit, element `y` into the second, etc.
		bitmask(self) -> u32,

		///Returns true if any of the elements are true, false otherwise.
		any(self) -> bool,

		///Returns true if all the elements are true, false otherwise.
		all(self) -> bool,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///A 3-dimensional boolean vector.
	glam::f32::sse2::vec3::BVec3 : Value
	: Fields
	(
		x: bool,
		y: bool,
		z: bool,
	)
	+ AutoMethods
	(
		///Creates a new vector mask.
		new(bool,bool,bool) -> LuaBVec3,

		///Returns a bitmask with the lowest two bits set from the elements of `self`.
		///
		///A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
		///into the first lowest bit, element `y` into the second, etc.
		bitmask(self) -> u32,

		///Returns true if any of the elements are true, false otherwise.
		any(self) -> bool,

		///Returns true if all the elements are true, false otherwise.
		all(self) -> bool,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///A 4-dimensional boolean vector.
	glam::f32::sse2::vec4::BVec4 : Value
	: Fields
	(
		x: bool,
		y: bool,
		z: bool,
		w: bool,
	)
	+ AutoMethods
	(
		///Creates a new vector mask.
		new(bool,bool,bool,bool) -> LuaBVec4,

		///Returns a bitmask with the lowest two bits set from the elements of `self`.
		///
		///A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
		///into the first lowest bit, element `y` into the second, etc.
		bitmask(self) -> u32,

		///Returns true if any of the elements are true, false otherwise.
		any(self) -> bool,

		///Returns true if all the elements are true, false otherwise.
		all(self) -> bool,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///A 3-dimensional SIMD vector mask.
	///
	///This type is 16 byte aligned and is backed by a SIMD vector. If SIMD is not available
	///`BVec3A` will be a type alias for `BVec3`.
	glam::f32::sse2::vec3::BVec3A : Value
	: Fields
	(
	)
	+ AutoMethods
	(
		///Creates a new vector mask.
		new(bool,bool,bool) -> LuaBVec3A,

		///Returns a bitmask with the lowest two bits set from the elements of `self`.
		///
		///A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
		///into the first lowest bit, element `y` into the second, etc.
		bitmask(self) -> u32,

		///Returns true if any of the elements are true, false otherwise.
		any(self) -> bool,

		///Returns true if all the elements are true, false otherwise.
		all(self) -> bool,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///A 4-dimensional SIMD vector mask.
	///
	///This type is 16 byte aligned and is backed by a SIMD vector. If SIMD is not available
	///`BVec4A` will be a type alias for `BVec4`.
	glam::f32::sse2::vec4::BVec4A : Value
	: Fields
	(
	)
	+ AutoMethods
	(
		///Creates a new vector mask.
		new(bool,bool,bool,bool) -> LuaBVec4A,

		///Returns a bitmask with the lowest two bits set from the elements of `self`.
		///
		///A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
		///into the first lowest bit, element `y` into the second, etc.
		bitmask(self) -> u32,

		///Returns true if any of the elements are true, false otherwise.
		any(self) -> bool,

		///Returns true if all the elements are true, false otherwise.
		all(self) -> bool,

	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///A 2-dimensional vector.
	glam::f64::dvec2::DVec2 : Value
	: Fields
	(
		x: f64,
		y: f64,
	)
	+ AutoMethods
	(
		///Creates a new vector.
		new(f64,f64) -> LuaDVec2,

		///Creates a vector with all elements set to `v`.
		splat(f64) -> LuaDVec2,

		///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
		///for each element of `self`.
		///
		///A true element in the mask uses the corresponding element from `if_true`, and false
		///uses the element from `if_false`.
		select(LuaBVec2,LuaDVec2,LuaDVec2) -> LuaDVec2,

		///Creates a 3D vector from `self` and the given `z` value.
		extend(self,f64) -> LuaDVec3,

		///Computes the dot product of `self` and `rhs`.
		dot(self,LuaDVec2) -> f64,

		///Returns a vector containing the minimum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
		min(self,LuaDVec2) -> LuaDVec2,

		///Returns a vector containing the maximum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
		max(self,LuaDVec2) -> LuaDVec2,

		///Component-wise clamping of values, similar to [`f32::clamp`].
		///
		///Each element in `min` must be less-or-equal to the corresponding element in `max`.
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp(self,LuaDVec2,LuaDVec2) -> LuaDVec2,

		///Returns the horizontal minimum of `self`.
		///
		///In other words this computes `min(x, y, ..)`.
		min_element(self) -> f64,

		///Returns the horizontal maximum of `self`.
		///
		///In other words this computes `max(x, y, ..)`.
		max_element(self) -> f64,

		///Returns a vector mask containing the result of a `==` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
		///elements.
		cmpeq(self,LuaDVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `!=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
		///elements.
		cmpne(self,LuaDVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `>=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
		///elements.
		cmpge(self,LuaDVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `>` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
		///elements.
		cmpgt(self,LuaDVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `<=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
		///elements.
		cmple(self,LuaDVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `<` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
		///elements.
		cmplt(self,LuaDVec2) -> LuaBVec2,

		///Returns a vector containing the absolute value of each element of `self`.
		abs(self) -> LuaDVec2,

		///Returns a vector with elements representing the sign of `self`.
		///
		///- `1.0` if the number is positive, `+0.0` or `INFINITY`
		///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
		///- `NAN` if the number is `NAN`
		signum(self) -> LuaDVec2,

		///Returns `true` if, and only if, all elements are finite.  If any element is either
		///`NaN`, positive or negative infinity, this will return `false`.
		is_finite(self) -> bool,

		///Returns `true` if any elements are `NaN`.
		is_nan(self) -> bool,

		///Performs `is_nan` on each element of self, returning a vector mask of the results.
		///
		///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
		is_nan_mask(self) -> LuaBVec2,

		///Computes the length of `self`.
		length(self) -> f64,

		///Computes the squared length of `self`.
		///
		///This is faster than `length()` as it avoids a square root operation.
		length_squared(self) -> f64,

		///Computes `1.0 / length()`.
		///
		///For valid results, `self` must _not_ be of length zero.
		length_recip(self) -> f64,

		///Computes the Euclidean distance between two points in space.
		distance(self,LuaDVec2) -> f64,

		///Compute the squared euclidean distance between two points in space.
		distance_squared(self,LuaDVec2) -> f64,

		///Returns `self` normalized to length 1.0.
		///
		///For valid results, `self` must _not_ be of length zero, nor very close to zero.
		///
		///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
		///
		///Panics
		///
		///Will panic if `self` is zero length when `glam_assert` is enabled.
		normalize(self) -> LuaDVec2,

		///Returns `self` normalized to length 1.0 if possible, else returns zero.
		///
		///In particular, if the input is zero (or very close to zero), or non-finite,
		///the result of this operation will be zero.
		///
		///See also [`Self::try_normalize`].
		normalize_or_zero(self) -> LuaDVec2,

		///Returns whether `self` is length `1.0` or not.
		///
		///Uses a precision threshold of `1e-6`.
		is_normalized(self) -> bool,

		///Returns the vector projection of `self` onto `rhs`.
		///
		///`rhs` must be of non-zero length.
		///
		///# Panics
		///
		///Will panic if `rhs` is zero length when `glam_assert` is enabled.
		project_onto(self,LuaDVec2) -> LuaDVec2,

		///Returns the vector rejection of `self` from `rhs`.
		///
		///The vector rejection is the vector perpendicular to the projection of `self` onto
		///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
		///
		///`rhs` must be of non-zero length.
		///
		///# Panics
		///
		///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
		reject_from(self,LuaDVec2) -> LuaDVec2,

		///Returns the vector projection of `self` onto `rhs`.
		///
		///`rhs` must be normalized.
		///
		///# Panics
		///
		///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
		project_onto_normalized(self,LuaDVec2) -> LuaDVec2,

		///Returns the vector rejection of `self` from `rhs`.
		///
		///The vector rejection is the vector perpendicular to the projection of `self` onto
		///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
		///
		///`rhs` must be normalized.
		///
		///# Panics
		///
		///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
		reject_from_normalized(self,LuaDVec2) -> LuaDVec2,

		///Returns a vector containing the nearest integer to a number for each element of `self`.
		///Round half-way cases away from 0.0.
		round(self) -> LuaDVec2,

		///Returns a vector containing the largest integer less than or equal to a number for each
		///element of `self`.
		floor(self) -> LuaDVec2,

		///Returns a vector containing the smallest integer greater than or equal to a number for
		///each element of `self`.
		ceil(self) -> LuaDVec2,

		///Returns a vector containing the fractional part of the vector, e.g. `self -
		///self.floor()`.
		///
		///Note that this is fast but not precise for large numbers.
		fract(self) -> LuaDVec2,

		///Returns a vector containing `e^self` (the exponential function) for each element of
		///`self`.
		exp(self) -> LuaDVec2,

		///Returns a vector containing each element of `self` raised to the power of `n`.
		powf(self,f64) -> LuaDVec2,

		///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
		recip(self) -> LuaDVec2,

		///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
		///
		///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
		///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
		///extrapolated.
		lerp(self,LuaDVec2,f64) -> LuaDVec2,

		///Returns true if the absolute difference of all elements between `self` and `rhs` is
		///less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two vectors contain similar elements. It works best when
		///comparing with a known value. The `max_abs_diff` that should be used used depends on
		///the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(self,LuaDVec2,f64) -> bool,

		///Returns a vector with a length no less than `min` and no more than `max`
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp_length(self,f64,f64) -> LuaDVec2,

		///Returns a vector with a length no more than `max`
		clamp_length_max(self,f64) -> LuaDVec2,

		///Returns a vector with a length no less than `min`
		clamp_length_min(self,f64) -> LuaDVec2,

		///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
		///error, yielding a more accurate result than an unfused multiply-add.
		///
		///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
		///architecture has a dedicated fma CPU instruction. However, this is not always true,
		///and will be heavily dependant on designing algorithms with specific target hardware in
		///mind.
		mul_add(self,LuaDVec2,LuaDVec2) -> LuaDVec2,

		///Creates a 2D vector containing `[angle.cos(), angle.sin()]`. This can be used in
		///conjunction with the `rotate` method, e.g. `Vec2::from_angle(PI).rotate(Vec2::Y)` will
		///create the vector [-1, 0] and rotate `Vec2::Y` around it returning `-Vec2::Y`.
		from_angle(f64) -> LuaDVec2,

		///Returns the angle (in radians) between `self` and `rhs`.
		///
		///The input vectors do not need to be unit length however they must be non-zero.
		angle_between(self,LuaDVec2) -> f64,

		///Returns a vector that is equal to `self` rotated by 90 degrees.
		perp(self) -> LuaDVec2,

		///The perpendicular dot product of `self` and `rhs`.
		///Also known as the wedge product, 2D cross product, and determinant.
		perp_dot(self,LuaDVec2) -> f64,

		///Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
		///then this just rotation. This is what you usually want. Otherwise,
		///it will be like a rotation with a multiplication by `self`'s length.
		rotate(self,LuaDVec2) -> LuaDVec2,

	)
	+ BinOps
	(
		self Add LuaDVec2 -> LuaDVec2,
		self Add f64 -> LuaDVec2,
		f64 Add self -> LuaDVec2,
		self Sub LuaDVec2 -> LuaDVec2,
		self Sub f64 -> LuaDVec2,
		f64 Sub self -> LuaDVec2,
		self Div LuaDVec2 -> LuaDVec2,
		self Div f64 -> LuaDVec2,
		f64 Div self -> LuaDVec2,
		self Mul LuaDVec2 -> LuaDVec2,
		self Mul f64 -> LuaDVec2,
		f64 Mul self -> LuaDVec2,
		self Rem LuaDVec2 -> LuaDVec2,
		self Rem f64 -> LuaDVec2,
		f64 Rem self -> LuaDVec2,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
		(MetaMethod::Index) => |_,s,idx: usize| {Ok(s.clone()[idx])};
		mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,f64)| {Ok(s.val_mut(|s| s[idx] = val))};
	}
}
impl_lua_newtype!{
	///A 3-dimensional vector.
	glam::f64::dvec3::DVec3 : Value
	: Fields
	(
		x: f64,
		y: f64,
		z: f64,
	)
	+ AutoMethods
	(
		///Creates a new vector.
		new(f64,f64,f64) -> LuaDVec3,

		///Creates a vector with all elements set to `v`.
		splat(f64) -> LuaDVec3,

		///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
		///for each element of `self`.
		///
		///A true element in the mask uses the corresponding element from `if_true`, and false
		///uses the element from `if_false`.
		select(LuaBVec3,LuaDVec3,LuaDVec3) -> LuaDVec3,

		///Creates a 4D vector from `self` and the given `w` value.
		extend(self,f64) -> LuaDVec4,

		///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
		///
		///Truncation may also be performed by using `self.xy()` or `DVec2::from()`.
		truncate(self) -> LuaDVec2,

		///Computes the dot product of `self` and `rhs`.
		dot(self,LuaDVec3) -> f64,

		///Computes the cross product of `self` and `rhs`.
		cross(self,LuaDVec3) -> LuaDVec3,

		///Returns a vector containing the minimum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
		min(self,LuaDVec3) -> LuaDVec3,

		///Returns a vector containing the maximum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
		max(self,LuaDVec3) -> LuaDVec3,

		///Component-wise clamping of values, similar to [`f32::clamp`].
		///
		///Each element in `min` must be less-or-equal to the corresponding element in `max`.
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp(self,LuaDVec3,LuaDVec3) -> LuaDVec3,

		///Returns the horizontal minimum of `self`.
		///
		///In other words this computes `min(x, y, ..)`.
		min_element(self) -> f64,

		///Returns the horizontal maximum of `self`.
		///
		///In other words this computes `max(x, y, ..)`.
		max_element(self) -> f64,

		///Returns a vector mask containing the result of a `==` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
		///elements.
		cmpeq(self,LuaDVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `!=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
		///elements.
		cmpne(self,LuaDVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `>=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
		///elements.
		cmpge(self,LuaDVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `>` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
		///elements.
		cmpgt(self,LuaDVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `<=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
		///elements.
		cmple(self,LuaDVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `<` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
		///elements.
		cmplt(self,LuaDVec3) -> LuaBVec3,

		///Returns a vector containing the absolute value of each element of `self`.
		abs(self) -> LuaDVec3,

		///Returns a vector with elements representing the sign of `self`.
		///
		///- `1.0` if the number is positive, `+0.0` or `INFINITY`
		///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
		///- `NAN` if the number is `NAN`
		signum(self) -> LuaDVec3,

		///Returns `true` if, and only if, all elements are finite.  If any element is either
		///`NaN`, positive or negative infinity, this will return `false`.
		is_finite(self) -> bool,

		///Returns `true` if any elements are `NaN`.
		is_nan(self) -> bool,

		///Performs `is_nan` on each element of self, returning a vector mask of the results.
		///
		///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
		is_nan_mask(self) -> LuaBVec3,

		///Computes the length of `self`.
		length(self) -> f64,

		///Computes the squared length of `self`.
		///
		///This is faster than `length()` as it avoids a square root operation.
		length_squared(self) -> f64,

		///Computes `1.0 / length()`.
		///
		///For valid results, `self` must _not_ be of length zero.
		length_recip(self) -> f64,

		///Computes the Euclidean distance between two points in space.
		distance(self,LuaDVec3) -> f64,

		///Compute the squared euclidean distance between two points in space.
		distance_squared(self,LuaDVec3) -> f64,

		///Returns `self` normalized to length 1.0.
		///
		///For valid results, `self` must _not_ be of length zero, nor very close to zero.
		///
		///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
		///
		///Panics
		///
		///Will panic if `self` is zero length when `glam_assert` is enabled.
		normalize(self) -> LuaDVec3,

		///Returns `self` normalized to length 1.0 if possible, else returns zero.
		///
		///In particular, if the input is zero (or very close to zero), or non-finite,
		///the result of this operation will be zero.
		///
		///See also [`Self::try_normalize`].
		normalize_or_zero(self) -> LuaDVec3,

		///Returns whether `self` is length `1.0` or not.
		///
		///Uses a precision threshold of `1e-6`.
		is_normalized(self) -> bool,

		///Returns the vector projection of `self` onto `rhs`.
		///
		///`rhs` must be of non-zero length.
		///
		///# Panics
		///
		///Will panic if `rhs` is zero length when `glam_assert` is enabled.
		project_onto(self,LuaDVec3) -> LuaDVec3,

		///Returns the vector rejection of `self` from `rhs`.
		///
		///The vector rejection is the vector perpendicular to the projection of `self` onto
		///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
		///
		///`rhs` must be of non-zero length.
		///
		///# Panics
		///
		///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
		reject_from(self,LuaDVec3) -> LuaDVec3,

		///Returns the vector projection of `self` onto `rhs`.
		///
		///`rhs` must be normalized.
		///
		///# Panics
		///
		///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
		project_onto_normalized(self,LuaDVec3) -> LuaDVec3,

		///Returns the vector rejection of `self` from `rhs`.
		///
		///The vector rejection is the vector perpendicular to the projection of `self` onto
		///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
		///
		///`rhs` must be normalized.
		///
		///# Panics
		///
		///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
		reject_from_normalized(self,LuaDVec3) -> LuaDVec3,

		///Returns a vector containing the nearest integer to a number for each element of `self`.
		///Round half-way cases away from 0.0.
		round(self) -> LuaDVec3,

		///Returns a vector containing the largest integer less than or equal to a number for each
		///element of `self`.
		floor(self) -> LuaDVec3,

		///Returns a vector containing the smallest integer greater than or equal to a number for
		///each element of `self`.
		ceil(self) -> LuaDVec3,

		///Returns a vector containing the fractional part of the vector, e.g. `self -
		///self.floor()`.
		///
		///Note that this is fast but not precise for large numbers.
		fract(self) -> LuaDVec3,

		///Returns a vector containing `e^self` (the exponential function) for each element of
		///`self`.
		exp(self) -> LuaDVec3,

		///Returns a vector containing each element of `self` raised to the power of `n`.
		powf(self,f64) -> LuaDVec3,

		///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
		recip(self) -> LuaDVec3,

		///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
		///
		///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
		///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
		///extrapolated.
		lerp(self,LuaDVec3,f64) -> LuaDVec3,

		///Returns true if the absolute difference of all elements between `self` and `rhs` is
		///less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two vectors contain similar elements. It works best when
		///comparing with a known value. The `max_abs_diff` that should be used used depends on
		///the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(self,LuaDVec3,f64) -> bool,

		///Returns a vector with a length no less than `min` and no more than `max`
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp_length(self,f64,f64) -> LuaDVec3,

		///Returns a vector with a length no more than `max`
		clamp_length_max(self,f64) -> LuaDVec3,

		///Returns a vector with a length no less than `min`
		clamp_length_min(self,f64) -> LuaDVec3,

		///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
		///error, yielding a more accurate result than an unfused multiply-add.
		///
		///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
		///architecture has a dedicated fma CPU instruction. However, this is not always true,
		///and will be heavily dependant on designing algorithms with specific target hardware in
		///mind.
		mul_add(self,LuaDVec3,LuaDVec3) -> LuaDVec3,

		///Returns the angle (in radians) between two vectors.
		///
		///The input vectors do not need to be unit length however they must be non-zero.
		angle_between(self,LuaDVec3) -> f64,

		///Returns some vector that is orthogonal to the given one.
		///
		///The input vector must be finite and non-zero.
		///
		///The output vector is not necessarily unit-length.
		///For that use [`Self::any_orthonormal_vector`] instead.
		any_orthogonal_vector(&self) -> LuaDVec3,

		///Returns any unit-length vector that is orthogonal to the given one.
		///The input vector must be finite and non-zero.
		///
		///# Panics
		///
		///Will panic if `self` is not normalized when `glam_assert` is enabled.
		any_orthonormal_vector(&self) -> LuaDVec3,

	)
	+ BinOps
	(
		self Add LuaDVec3 -> LuaDVec3,
		self Add f64 -> LuaDVec3,
		f64 Add self -> LuaDVec3,
		self Sub LuaDVec3 -> LuaDVec3,
		self Sub f64 -> LuaDVec3,
		f64 Sub self -> LuaDVec3,
		self Div LuaDVec3 -> LuaDVec3,
		self Div f64 -> LuaDVec3,
		f64 Div self -> LuaDVec3,
		self Mul LuaDVec3 -> LuaDVec3,
		self Mul f64 -> LuaDVec3,
		f64 Mul self -> LuaDVec3,
		self Rem LuaDVec3 -> LuaDVec3,
		self Rem f64 -> LuaDVec3,
		f64 Rem self -> LuaDVec3,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
		(MetaMethod::Index) => |_,s,idx: usize| {Ok(s.clone()[idx])};
		mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,f64)| {Ok(s.val_mut(|s| s[idx] = val))};
	}
}
impl_lua_newtype!{
	///A 4-dimensional vector.
	glam::f64::dvec4::DVec4 : Value
	: Fields
	(
		x: f64,
		y: f64,
		z: f64,
		w: f64,
	)
	+ AutoMethods
	(
		///Creates a new vector.
		new(f64,f64,f64,f64) -> LuaDVec4,

		///Creates a vector with all elements set to `v`.
		splat(f64) -> LuaDVec4,

		///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
		///for each element of `self`.
		///
		///A true element in the mask uses the corresponding element from `if_true`, and false
		///uses the element from `if_false`.
		select(LuaBVec4,LuaDVec4,LuaDVec4) -> LuaDVec4,

		///Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
		///
		///Truncation to `DVec3` may also be performed by using `self.xyz()` or `DVec3::from()`.
		truncate(self) -> LuaDVec3,

		///Computes the dot product of `self` and `rhs`.
		dot(self,LuaDVec4) -> f64,

		///Returns a vector containing the minimum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
		min(self,LuaDVec4) -> LuaDVec4,

		///Returns a vector containing the maximum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
		max(self,LuaDVec4) -> LuaDVec4,

		///Component-wise clamping of values, similar to [`f32::clamp`].
		///
		///Each element in `min` must be less-or-equal to the corresponding element in `max`.
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp(self,LuaDVec4,LuaDVec4) -> LuaDVec4,

		///Returns the horizontal minimum of `self`.
		///
		///In other words this computes `min(x, y, ..)`.
		min_element(self) -> f64,

		///Returns the horizontal maximum of `self`.
		///
		///In other words this computes `max(x, y, ..)`.
		max_element(self) -> f64,

		///Returns a vector mask containing the result of a `==` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
		///elements.
		cmpeq(self,LuaDVec4) -> LuaBVec4,

		///Returns a vector mask containing the result of a `!=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
		///elements.
		cmpne(self,LuaDVec4) -> LuaBVec4,

		///Returns a vector mask containing the result of a `>=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
		///elements.
		cmpge(self,LuaDVec4) -> LuaBVec4,

		///Returns a vector mask containing the result of a `>` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
		///elements.
		cmpgt(self,LuaDVec4) -> LuaBVec4,

		///Returns a vector mask containing the result of a `<=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
		///elements.
		cmple(self,LuaDVec4) -> LuaBVec4,

		///Returns a vector mask containing the result of a `<` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
		///elements.
		cmplt(self,LuaDVec4) -> LuaBVec4,

		///Returns a vector containing the absolute value of each element of `self`.
		abs(self) -> LuaDVec4,

		///Returns a vector with elements representing the sign of `self`.
		///
		///- `1.0` if the number is positive, `+0.0` or `INFINITY`
		///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
		///- `NAN` if the number is `NAN`
		signum(self) -> LuaDVec4,

		///Returns `true` if, and only if, all elements are finite.  If any element is either
		///`NaN`, positive or negative infinity, this will return `false`.
		is_finite(self) -> bool,

		///Returns `true` if any elements are `NaN`.
		is_nan(self) -> bool,

		///Performs `is_nan` on each element of self, returning a vector mask of the results.
		///
		///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
		is_nan_mask(self) -> LuaBVec4,

		///Computes the length of `self`.
		length(self) -> f64,

		///Computes the squared length of `self`.
		///
		///This is faster than `length()` as it avoids a square root operation.
		length_squared(self) -> f64,

		///Computes `1.0 / length()`.
		///
		///For valid results, `self` must _not_ be of length zero.
		length_recip(self) -> f64,

		///Computes the Euclidean distance between two points in space.
		distance(self,LuaDVec4) -> f64,

		///Compute the squared euclidean distance between two points in space.
		distance_squared(self,LuaDVec4) -> f64,

		///Returns `self` normalized to length 1.0.
		///
		///For valid results, `self` must _not_ be of length zero, nor very close to zero.
		///
		///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
		///
		///Panics
		///
		///Will panic if `self` is zero length when `glam_assert` is enabled.
		normalize(self) -> LuaDVec4,

		///Returns `self` normalized to length 1.0 if possible, else returns zero.
		///
		///In particular, if the input is zero (or very close to zero), or non-finite,
		///the result of this operation will be zero.
		///
		///See also [`Self::try_normalize`].
		normalize_or_zero(self) -> LuaDVec4,

		///Returns whether `self` is length `1.0` or not.
		///
		///Uses a precision threshold of `1e-6`.
		is_normalized(self) -> bool,

		///Returns the vector projection of `self` onto `rhs`.
		///
		///`rhs` must be of non-zero length.
		///
		///# Panics
		///
		///Will panic if `rhs` is zero length when `glam_assert` is enabled.
		project_onto(self,LuaDVec4) -> LuaDVec4,

		///Returns the vector rejection of `self` from `rhs`.
		///
		///The vector rejection is the vector perpendicular to the projection of `self` onto
		///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
		///
		///`rhs` must be of non-zero length.
		///
		///# Panics
		///
		///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
		reject_from(self,LuaDVec4) -> LuaDVec4,

		///Returns the vector projection of `self` onto `rhs`.
		///
		///`rhs` must be normalized.
		///
		///# Panics
		///
		///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
		project_onto_normalized(self,LuaDVec4) -> LuaDVec4,

		///Returns the vector rejection of `self` from `rhs`.
		///
		///The vector rejection is the vector perpendicular to the projection of `self` onto
		///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
		///
		///`rhs` must be normalized.
		///
		///# Panics
		///
		///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
		reject_from_normalized(self,LuaDVec4) -> LuaDVec4,

		///Returns a vector containing the nearest integer to a number for each element of `self`.
		///Round half-way cases away from 0.0.
		round(self) -> LuaDVec4,

		///Returns a vector containing the largest integer less than or equal to a number for each
		///element of `self`.
		floor(self) -> LuaDVec4,

		///Returns a vector containing the smallest integer greater than or equal to a number for
		///each element of `self`.
		ceil(self) -> LuaDVec4,

		///Returns a vector containing the fractional part of the vector, e.g. `self -
		///self.floor()`.
		///
		///Note that this is fast but not precise for large numbers.
		fract(self) -> LuaDVec4,

		///Returns a vector containing `e^self` (the exponential function) for each element of
		///`self`.
		exp(self) -> LuaDVec4,

		///Returns a vector containing each element of `self` raised to the power of `n`.
		powf(self,f64) -> LuaDVec4,

		///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
		recip(self) -> LuaDVec4,

		///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
		///
		///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
		///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
		///extrapolated.
		lerp(self,LuaDVec4,f64) -> LuaDVec4,

		///Returns true if the absolute difference of all elements between `self` and `rhs` is
		///less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two vectors contain similar elements. It works best when
		///comparing with a known value. The `max_abs_diff` that should be used used depends on
		///the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(self,LuaDVec4,f64) -> bool,

		///Returns a vector with a length no less than `min` and no more than `max`
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp_length(self,f64,f64) -> LuaDVec4,

		///Returns a vector with a length no more than `max`
		clamp_length_max(self,f64) -> LuaDVec4,

		///Returns a vector with a length no less than `min`
		clamp_length_min(self,f64) -> LuaDVec4,

		///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
		///error, yielding a more accurate result than an unfused multiply-add.
		///
		///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
		///architecture has a dedicated fma CPU instruction. However, this is not always true,
		///and will be heavily dependant on designing algorithms with specific target hardware in
		///mind.
		mul_add(self,LuaDVec4,LuaDVec4) -> LuaDVec4,

	)
	+ BinOps
	(
		self Add LuaDVec4 -> LuaDVec4,
		self Add f64 -> LuaDVec4,
		f64 Add self -> LuaDVec4,
		self Sub LuaDVec4 -> LuaDVec4,
		self Sub f64 -> LuaDVec4,
		f64 Sub self -> LuaDVec4,
		self Div LuaDVec4 -> LuaDVec4,
		self Div f64 -> LuaDVec4,
		f64 Div self -> LuaDVec4,
		self Mul LuaDVec4 -> LuaDVec4,
		self Mul f64 -> LuaDVec4,
		f64 Mul self -> LuaDVec4,
		self Rem LuaDVec4 -> LuaDVec4,
		self Rem f64 -> LuaDVec4,
		f64 Rem self -> LuaDVec4,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
		(MetaMethod::Index) => |_,s,idx: usize| {Ok(s.clone()[idx])};
		mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,f64)| {Ok(s.val_mut(|s| s[idx] = val))};
	}
}
impl_lua_newtype!{
	///A 2-dimensional vector.
	glam::i32::ivec2::IVec2 : Value
	: Fields
	(
		x: i32,
		y: i32,
	)
	+ AutoMethods
	(
		///Creates a new vector.
		new(i32,i32) -> LuaIVec2,

		///Creates a vector with all elements set to `v`.
		splat(i32) -> LuaIVec2,

		///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
		///for each element of `self`.
		///
		///A true element in the mask uses the corresponding element from `if_true`, and false
		///uses the element from `if_false`.
		select(LuaBVec2,LuaIVec2,LuaIVec2) -> LuaIVec2,

		///Creates a 3D vector from `self` and the given `z` value.
		extend(self,i32) -> LuaIVec3,

		///Computes the dot product of `self` and `rhs`.
		dot(self,LuaIVec2) -> i32,

		///Returns a vector containing the minimum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
		min(self,LuaIVec2) -> LuaIVec2,

		///Returns a vector containing the maximum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
		max(self,LuaIVec2) -> LuaIVec2,

		///Component-wise clamping of values, similar to [`f32::clamp`].
		///
		///Each element in `min` must be less-or-equal to the corresponding element in `max`.
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp(self,LuaIVec2,LuaIVec2) -> LuaIVec2,

		///Returns the horizontal minimum of `self`.
		///
		///In other words this computes `min(x, y, ..)`.
		min_element(self) -> i32,

		///Returns the horizontal maximum of `self`.
		///
		///In other words this computes `max(x, y, ..)`.
		max_element(self) -> i32,

		///Returns a vector mask containing the result of a `==` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
		///elements.
		cmpeq(self,LuaIVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `!=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
		///elements.
		cmpne(self,LuaIVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `>=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
		///elements.
		cmpge(self,LuaIVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `>` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
		///elements.
		cmpgt(self,LuaIVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `<=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
		///elements.
		cmple(self,LuaIVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `<` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
		///elements.
		cmplt(self,LuaIVec2) -> LuaBVec2,

		///Returns a vector containing the absolute value of each element of `self`.
		abs(self) -> LuaIVec2,

		///Returns a vector with elements representing the sign of `self`.
		///
		///- `1.0` if the number is positive, `+0.0` or `INFINITY`
		///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
		///- `NAN` if the number is `NAN`
		signum(self) -> LuaIVec2,

		///Returns a vector that is equal to `self` rotated by 90 degrees.
		perp(self) -> LuaIVec2,

		///The perpendicular dot product of `self` and `rhs`.
		///Also known as the wedge product, 2D cross product, and determinant.
		perp_dot(self,LuaIVec2) -> i32,

		///Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
		///then this just rotation. This is what you usually want. Otherwise,
		///it will be like a rotation with a multiplication by `self`'s length.
		rotate(self,LuaIVec2) -> LuaIVec2,

	)
	+ BinOps
	(
		self Add LuaIVec2 -> LuaIVec2,
		self Add i32 -> LuaIVec2,
		i32 Add self -> LuaIVec2,
		self Sub LuaIVec2 -> LuaIVec2,
		self Sub i32 -> LuaIVec2,
		i32 Sub self -> LuaIVec2,
		self Div LuaIVec2 -> LuaIVec2,
		self Div i32 -> LuaIVec2,
		i32 Div self -> LuaIVec2,
		self Mul LuaIVec2 -> LuaIVec2,
		self Mul i32 -> LuaIVec2,
		i32 Mul self -> LuaIVec2,
		self Rem LuaIVec2 -> LuaIVec2,
		self Rem i32 -> LuaIVec2,
		i32 Rem self -> LuaIVec2,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
		(MetaMethod::Index) => |_,s,idx: usize| {Ok(s.clone()[idx])};
		mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,i32)| {Ok(s.val_mut(|s| s[idx] = val))};
	}
}
impl_lua_newtype!{
	///A 3-dimensional vector.
	glam::i32::ivec3::IVec3 : Value
	: Fields
	(
		x: i32,
		y: i32,
		z: i32,
	)
	+ AutoMethods
	(
		///Creates a new vector.
		new(i32,i32,i32) -> LuaIVec3,

		///Creates a vector with all elements set to `v`.
		splat(i32) -> LuaIVec3,

		///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
		///for each element of `self`.
		///
		///A true element in the mask uses the corresponding element from `if_true`, and false
		///uses the element from `if_false`.
		select(LuaBVec3,LuaIVec3,LuaIVec3) -> LuaIVec3,

		///Creates a 4D vector from `self` and the given `w` value.
		extend(self,i32) -> LuaIVec4,

		///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
		///
		///Truncation may also be performed by using `self.xy()` or `IVec2::from()`.
		truncate(self) -> LuaIVec2,

		///Computes the dot product of `self` and `rhs`.
		dot(self,LuaIVec3) -> i32,

		///Computes the cross product of `self` and `rhs`.
		cross(self,LuaIVec3) -> LuaIVec3,

		///Returns a vector containing the minimum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
		min(self,LuaIVec3) -> LuaIVec3,

		///Returns a vector containing the maximum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
		max(self,LuaIVec3) -> LuaIVec3,

		///Component-wise clamping of values, similar to [`f32::clamp`].
		///
		///Each element in `min` must be less-or-equal to the corresponding element in `max`.
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp(self,LuaIVec3,LuaIVec3) -> LuaIVec3,

		///Returns the horizontal minimum of `self`.
		///
		///In other words this computes `min(x, y, ..)`.
		min_element(self) -> i32,

		///Returns the horizontal maximum of `self`.
		///
		///In other words this computes `max(x, y, ..)`.
		max_element(self) -> i32,

		///Returns a vector mask containing the result of a `==` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
		///elements.
		cmpeq(self,LuaIVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `!=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
		///elements.
		cmpne(self,LuaIVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `>=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
		///elements.
		cmpge(self,LuaIVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `>` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
		///elements.
		cmpgt(self,LuaIVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `<=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
		///elements.
		cmple(self,LuaIVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `<` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
		///elements.
		cmplt(self,LuaIVec3) -> LuaBVec3,

		///Returns a vector containing the absolute value of each element of `self`.
		abs(self) -> LuaIVec3,

		///Returns a vector with elements representing the sign of `self`.
		///
		///- `1.0` if the number is positive, `+0.0` or `INFINITY`
		///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
		///- `NAN` if the number is `NAN`
		signum(self) -> LuaIVec3,

	)
	+ BinOps
	(
		self Add LuaIVec3 -> LuaIVec3,
		self Add i32 -> LuaIVec3,
		i32 Add self -> LuaIVec3,
		self Sub LuaIVec3 -> LuaIVec3,
		self Sub i32 -> LuaIVec3,
		i32 Sub self -> LuaIVec3,
		self Div LuaIVec3 -> LuaIVec3,
		self Div i32 -> LuaIVec3,
		i32 Div self -> LuaIVec3,
		self Mul LuaIVec3 -> LuaIVec3,
		self Mul i32 -> LuaIVec3,
		i32 Mul self -> LuaIVec3,
		self Rem LuaIVec3 -> LuaIVec3,
		self Rem i32 -> LuaIVec3,
		i32 Rem self -> LuaIVec3,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
		(MetaMethod::Index) => |_,s,idx: usize| {Ok(s.clone()[idx])};
		mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,i32)| {Ok(s.val_mut(|s| s[idx] = val))};
	}
}
impl_lua_newtype!{
	///A 4-dimensional vector.
	glam::i32::ivec4::IVec4 : Value
	: Fields
	(
		x: i32,
		y: i32,
		z: i32,
		w: i32,
	)
	+ AutoMethods
	(
		///Creates a new vector.
		new(i32,i32,i32,i32) -> LuaIVec4,

		///Creates a vector with all elements set to `v`.
		splat(i32) -> LuaIVec4,

		///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
		///for each element of `self`.
		///
		///A true element in the mask uses the corresponding element from `if_true`, and false
		///uses the element from `if_false`.
		select(LuaBVec4,LuaIVec4,LuaIVec4) -> LuaIVec4,

		///Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
		///
		///Truncation to `IVec3` may also be performed by using `self.xyz()` or `IVec3::from()`.
		truncate(self) -> LuaIVec3,

		///Computes the dot product of `self` and `rhs`.
		dot(self,LuaIVec4) -> i32,

		///Returns a vector containing the minimum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
		min(self,LuaIVec4) -> LuaIVec4,

		///Returns a vector containing the maximum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
		max(self,LuaIVec4) -> LuaIVec4,

		///Component-wise clamping of values, similar to [`f32::clamp`].
		///
		///Each element in `min` must be less-or-equal to the corresponding element in `max`.
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp(self,LuaIVec4,LuaIVec4) -> LuaIVec4,

		///Returns the horizontal minimum of `self`.
		///
		///In other words this computes `min(x, y, ..)`.
		min_element(self) -> i32,

		///Returns the horizontal maximum of `self`.
		///
		///In other words this computes `max(x, y, ..)`.
		max_element(self) -> i32,

		///Returns a vector mask containing the result of a `==` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
		///elements.
		cmpeq(self,LuaIVec4) -> LuaBVec4,

		///Returns a vector mask containing the result of a `!=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
		///elements.
		cmpne(self,LuaIVec4) -> LuaBVec4,

		///Returns a vector mask containing the result of a `>=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
		///elements.
		cmpge(self,LuaIVec4) -> LuaBVec4,

		///Returns a vector mask containing the result of a `>` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
		///elements.
		cmpgt(self,LuaIVec4) -> LuaBVec4,

		///Returns a vector mask containing the result of a `<=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
		///elements.
		cmple(self,LuaIVec4) -> LuaBVec4,

		///Returns a vector mask containing the result of a `<` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
		///elements.
		cmplt(self,LuaIVec4) -> LuaBVec4,

		///Returns a vector containing the absolute value of each element of `self`.
		abs(self) -> LuaIVec4,

		///Returns a vector with elements representing the sign of `self`.
		///
		///- `1.0` if the number is positive, `+0.0` or `INFINITY`
		///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
		///- `NAN` if the number is `NAN`
		signum(self) -> LuaIVec4,

	)
	+ BinOps
	(
		self Add LuaIVec4 -> LuaIVec4,
		self Add i32 -> LuaIVec4,
		i32 Add self -> LuaIVec4,
		self Sub LuaIVec4 -> LuaIVec4,
		self Sub i32 -> LuaIVec4,
		i32 Sub self -> LuaIVec4,
		self Div LuaIVec4 -> LuaIVec4,
		self Div i32 -> LuaIVec4,
		i32 Div self -> LuaIVec4,
		self Mul LuaIVec4 -> LuaIVec4,
		self Mul i32 -> LuaIVec4,
		i32 Mul self -> LuaIVec4,
		self Rem LuaIVec4 -> LuaIVec4,
		self Rem i32 -> LuaIVec4,
		i32 Rem self -> LuaIVec4,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
		(MetaMethod::Index) => |_,s,idx: usize| {Ok(s.clone()[idx])};
		mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,i32)| {Ok(s.val_mut(|s| s[idx] = val))};
	}
}
impl_lua_newtype!{
	///A 2-dimensional vector.
	glam::u32::uvec2::UVec2 : Value
	: Fields
	(
		x: u32,
		y: u32,
	)
	+ AutoMethods
	(
		///Creates a new vector.
		new(u32,u32) -> LuaUVec2,

		///Creates a vector with all elements set to `v`.
		splat(u32) -> LuaUVec2,

		///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
		///for each element of `self`.
		///
		///A true element in the mask uses the corresponding element from `if_true`, and false
		///uses the element from `if_false`.
		select(LuaBVec2,LuaUVec2,LuaUVec2) -> LuaUVec2,

		///Creates a 3D vector from `self` and the given `z` value.
		extend(self,u32) -> LuaUVec3,

		///Computes the dot product of `self` and `rhs`.
		dot(self,LuaUVec2) -> u32,

		///Returns a vector containing the minimum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
		min(self,LuaUVec2) -> LuaUVec2,

		///Returns a vector containing the maximum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
		max(self,LuaUVec2) -> LuaUVec2,

		///Component-wise clamping of values, similar to [`f32::clamp`].
		///
		///Each element in `min` must be less-or-equal to the corresponding element in `max`.
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp(self,LuaUVec2,LuaUVec2) -> LuaUVec2,

		///Returns the horizontal minimum of `self`.
		///
		///In other words this computes `min(x, y, ..)`.
		min_element(self) -> u32,

		///Returns the horizontal maximum of `self`.
		///
		///In other words this computes `max(x, y, ..)`.
		max_element(self) -> u32,

		///Returns a vector mask containing the result of a `==` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
		///elements.
		cmpeq(self,LuaUVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `!=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
		///elements.
		cmpne(self,LuaUVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `>=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
		///elements.
		cmpge(self,LuaUVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `>` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
		///elements.
		cmpgt(self,LuaUVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `<=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
		///elements.
		cmple(self,LuaUVec2) -> LuaBVec2,

		///Returns a vector mask containing the result of a `<` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
		///elements.
		cmplt(self,LuaUVec2) -> LuaBVec2,

	)
	+ BinOps
	(
		self Add LuaUVec2 -> LuaUVec2,
		self Add u32 -> LuaUVec2,
		u32 Add self -> LuaUVec2,
		self Sub LuaUVec2 -> LuaUVec2,
		self Sub u32 -> LuaUVec2,
		u32 Sub self -> LuaUVec2,
		self Div LuaUVec2 -> LuaUVec2,
		self Div u32 -> LuaUVec2,
		u32 Div self -> LuaUVec2,
		self Mul LuaUVec2 -> LuaUVec2,
		self Mul u32 -> LuaUVec2,
		u32 Mul self -> LuaUVec2,
		self Rem LuaUVec2 -> LuaUVec2,
		self Rem u32 -> LuaUVec2,
		u32 Rem self -> LuaUVec2,
	)
	+ UnaryOps
	(
	)
	impl
	{
		(MetaMethod::Index) => |_,s,idx: usize| {Ok(s.clone()[idx])};
		mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,u32)| {Ok(s.val_mut(|s| s[idx] = val))};
	}
}
impl_lua_newtype!{
	///A 3-dimensional vector.
	glam::u32::uvec3::UVec3 : Value
	: Fields
	(
		x: u32,
		y: u32,
		z: u32,
	)
	+ AutoMethods
	(
		///Creates a new vector.
		new(u32,u32,u32) -> LuaUVec3,

		///Creates a vector with all elements set to `v`.
		splat(u32) -> LuaUVec3,

		///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
		///for each element of `self`.
		///
		///A true element in the mask uses the corresponding element from `if_true`, and false
		///uses the element from `if_false`.
		select(LuaBVec3,LuaUVec3,LuaUVec3) -> LuaUVec3,

		///Creates a 4D vector from `self` and the given `w` value.
		extend(self,u32) -> LuaUVec4,

		///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
		///
		///Truncation may also be performed by using `self.xy()` or `UVec2::from()`.
		truncate(self) -> LuaUVec2,

		///Computes the dot product of `self` and `rhs`.
		dot(self,LuaUVec3) -> u32,

		///Computes the cross product of `self` and `rhs`.
		cross(self,LuaUVec3) -> LuaUVec3,

		///Returns a vector containing the minimum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
		min(self,LuaUVec3) -> LuaUVec3,

		///Returns a vector containing the maximum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
		max(self,LuaUVec3) -> LuaUVec3,

		///Component-wise clamping of values, similar to [`f32::clamp`].
		///
		///Each element in `min` must be less-or-equal to the corresponding element in `max`.
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp(self,LuaUVec3,LuaUVec3) -> LuaUVec3,

		///Returns the horizontal minimum of `self`.
		///
		///In other words this computes `min(x, y, ..)`.
		min_element(self) -> u32,

		///Returns the horizontal maximum of `self`.
		///
		///In other words this computes `max(x, y, ..)`.
		max_element(self) -> u32,

		///Returns a vector mask containing the result of a `==` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
		///elements.
		cmpeq(self,LuaUVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `!=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
		///elements.
		cmpne(self,LuaUVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `>=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
		///elements.
		cmpge(self,LuaUVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `>` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
		///elements.
		cmpgt(self,LuaUVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `<=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
		///elements.
		cmple(self,LuaUVec3) -> LuaBVec3,

		///Returns a vector mask containing the result of a `<` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
		///elements.
		cmplt(self,LuaUVec3) -> LuaBVec3,

	)
	+ BinOps
	(
		self Add LuaUVec3 -> LuaUVec3,
		self Add u32 -> LuaUVec3,
		u32 Add self -> LuaUVec3,
		self Sub LuaUVec3 -> LuaUVec3,
		self Sub u32 -> LuaUVec3,
		u32 Sub self -> LuaUVec3,
		self Div LuaUVec3 -> LuaUVec3,
		self Div u32 -> LuaUVec3,
		u32 Div self -> LuaUVec3,
		self Mul LuaUVec3 -> LuaUVec3,
		self Mul u32 -> LuaUVec3,
		u32 Mul self -> LuaUVec3,
		self Rem LuaUVec3 -> LuaUVec3,
		self Rem u32 -> LuaUVec3,
		u32 Rem self -> LuaUVec3,
	)
	+ UnaryOps
	(
	)
	impl
	{
		(MetaMethod::Index) => |_,s,idx: usize| {Ok(s.clone()[idx])};
		mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,u32)| {Ok(s.val_mut(|s| s[idx] = val))};
	}
}
impl_lua_newtype!{
	///A 4-dimensional vector.
	glam::u32::uvec4::UVec4 : Value
	: Fields
	(
		x: u32,
		y: u32,
		z: u32,
		w: u32,
	)
	+ AutoMethods
	(
		///Creates a new vector.
		new(u32,u32,u32,u32) -> LuaUVec4,

		///Creates a vector with all elements set to `v`.
		splat(u32) -> LuaUVec4,

		///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
		///for each element of `self`.
		///
		///A true element in the mask uses the corresponding element from `if_true`, and false
		///uses the element from `if_false`.
		select(LuaBVec4,LuaUVec4,LuaUVec4) -> LuaUVec4,

		///Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
		///
		///Truncation to `UVec3` may also be performed by using `self.xyz()` or `UVec3::from()`.
		truncate(self) -> LuaUVec3,

		///Computes the dot product of `self` and `rhs`.
		dot(self,LuaUVec4) -> u32,

		///Returns a vector containing the minimum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
		min(self,LuaUVec4) -> LuaUVec4,

		///Returns a vector containing the maximum values for each element of `self` and `rhs`.
		///
		///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
		max(self,LuaUVec4) -> LuaUVec4,

		///Component-wise clamping of values, similar to [`f32::clamp`].
		///
		///Each element in `min` must be less-or-equal to the corresponding element in `max`.
		///
		///# Panics
		///
		///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
		clamp(self,LuaUVec4,LuaUVec4) -> LuaUVec4,

		///Returns the horizontal minimum of `self`.
		///
		///In other words this computes `min(x, y, ..)`.
		min_element(self) -> u32,

		///Returns the horizontal maximum of `self`.
		///
		///In other words this computes `max(x, y, ..)`.
		max_element(self) -> u32,

		///Returns a vector mask containing the result of a `==` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
		///elements.
		cmpeq(self,LuaUVec4) -> LuaBVec4,

		///Returns a vector mask containing the result of a `!=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
		///elements.
		cmpne(self,LuaUVec4) -> LuaBVec4,

		///Returns a vector mask containing the result of a `>=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
		///elements.
		cmpge(self,LuaUVec4) -> LuaBVec4,

		///Returns a vector mask containing the result of a `>` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
		///elements.
		cmpgt(self,LuaUVec4) -> LuaBVec4,

		///Returns a vector mask containing the result of a `<=` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
		///elements.
		cmple(self,LuaUVec4) -> LuaBVec4,

		///Returns a vector mask containing the result of a `<` comparison for each element of
		///`self` and `rhs`.
		///
		///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
		///elements.
		cmplt(self,LuaUVec4) -> LuaBVec4,

	)
	+ BinOps
	(
		self Add LuaUVec4 -> LuaUVec4,
		self Add u32 -> LuaUVec4,
		u32 Add self -> LuaUVec4,
		self Sub LuaUVec4 -> LuaUVec4,
		self Sub u32 -> LuaUVec4,
		u32 Sub self -> LuaUVec4,
		self Div LuaUVec4 -> LuaUVec4,
		self Div u32 -> LuaUVec4,
		u32 Div self -> LuaUVec4,
		self Mul LuaUVec4 -> LuaUVec4,
		self Mul u32 -> LuaUVec4,
		u32 Mul self -> LuaUVec4,
		self Rem LuaUVec4 -> LuaUVec4,
		self Rem u32 -> LuaUVec4,
		u32 Rem self -> LuaUVec4,
	)
	+ UnaryOps
	(
	)
	impl
	{
		(MetaMethod::Index) => |_,s,idx: usize| {Ok(s.clone()[idx])};
		mut (MetaMethod::NewIndex) => |_,s,(idx,val): (usize,u32)| {Ok(s.val_mut(|s| s[idx] = val))};
	}
}
impl_lua_newtype!{
	///A 3x3 column major matrix.
	///
	///This 3x3 matrix type features convenience methods for creating and using linear and
	///affine transformations. If you are primarily dealing with 2D affine transformations the
	///[`Affine2`](crate::Affine2) type is much faster and more space efficient than
	///using a 3x3 matrix.
	///
	///Linear transformations including 3D rotation and scale can be created using methods
	///such as [`Self::from_diagonal()`], [`Self::from_quat()`], [`Self::from_axis_angle()`],
	///[`Self::from_rotation_x()`], [`Self::from_rotation_y()`], or
	///[`Self::from_rotation_z()`].
	///
	///The resulting matrices can be use to transform 3D vectors using regular vector
	///multiplication.
	///
	///Affine transformations including 2D translation, rotation and scale can be created
	///using methods such as [`Self::from_translation()`], [`Self::from_angle()`],
	///[`Self::from_scale()`] and [`Self::from_scale_angle_translation()`].
	///
	///The [`Self::transform_point2()`] and [`Self::transform_vector2()`] convenience methods
	///are provided for performing affine transforms on 2D vectors and points. These multiply
	///2D inputs as 3D vectors with an implicit `z` value of `1` for points and `0` for
	///vectors respectively. These methods assume that `Self` contains a valid affine
	///transform.
	glam::f32::mat3::Mat3 : Value
	: Fields
	(
		x_axis: LuaVec3,
		y_axis: LuaVec3,
		z_axis: LuaVec3,
	)
	+ AutoMethods
	(
		///Creates a 3x3 matrix from two column vectors.
		from_cols(LuaVec3,LuaVec3,LuaVec3) -> LuaMat3,

		///Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.
		from_diagonal(LuaVec3) -> LuaMat3,

		///Creates a 3x3 matrix from a 4x4 matrix, discarding the 3rd row and column.
		from_mat4(LuaMat4) -> LuaMat3,

		///Creates a 3D rotation matrix from the given quaternion.
		///
		///# Panics
		///
		///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
		from_quat(LuaQuat) -> LuaMat3,

		///Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in
		///radians).
		///
		///# Panics
		///
		///Will panic if `axis` is not normalized when `glam_assert` is enabled.
		from_axis_angle(LuaVec3,f32) -> LuaMat3,

		///Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in
		///radians).
		from_euler(LuaEulerRot,f32,f32,f32) -> LuaMat3,

		///Creates a 3D rotation matrix from `angle` (in radians) around the x axis.
		from_rotation_x(f32) -> LuaMat3,

		///Creates a 3D rotation matrix from `angle` (in radians) around the y axis.
		from_rotation_y(f32) -> LuaMat3,

		///Creates a 3D rotation matrix from `angle` (in radians) around the z axis.
		from_rotation_z(f32) -> LuaMat3,

		///Creates an affine transformation matrix from the given 2D `translation`.
		///
		///The resulting matrix can be used to transform 2D points and vectors. See
		///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
		from_translation(LuaVec2) -> LuaMat3,

		///Creates an affine transformation matrix from the given 2D rotation `angle` (in
		///radians).
		///
		///The resulting matrix can be used to transform 2D points and vectors. See
		///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
		from_angle(f32) -> LuaMat3,

		///Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in
		///radians) and `translation`.
		///
		///The resulting matrix can be used to transform 2D points and vectors. See
		///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
		from_scale_angle_translation(LuaVec2,f32,LuaVec2) -> LuaMat3,

		///Creates an affine transformation matrix from the given non-uniform 2D `scale`.
		///
		///The resulting matrix can be used to transform 2D points and vectors. See
		///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
		///
		///# Panics
		///
		///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
		from_scale(LuaVec2) -> LuaMat3,

		///Creates an affine transformation matrix from the given 2x2 matrix.
		///
		///The resulting matrix can be used to transform 2D points and vectors. See
		///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
		from_mat2(LuaMat2) -> LuaMat3,

		///Returns the matrix column for the given `index`.
		///
		///# Panics
		///
		///Panics if `index` is greater than 2.
		col(&self,usize) -> LuaVec3,

		///Returns the matrix row for the given `index`.
		///
		///# Panics
		///
		///Panics if `index` is greater than 2.
		row(&self,usize) -> LuaVec3,

		///Returns `true` if, and only if, all elements are finite.
		///If any element is either `NaN`, positive or negative infinity, this will return `false`.
		is_finite(&self) -> bool,

		///Returns `true` if any elements are `NaN`.
		is_nan(&self) -> bool,

		///Returns the transpose of `self`.
		transpose(&self) -> LuaMat3,

		///Returns the determinant of `self`.
		determinant(&self) -> f32,

		///Returns the inverse of `self`.
		///
		///If the matrix is not invertible the returned matrix will be invalid.
		///
		///# Panics
		///
		///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
		inverse(&self) -> LuaMat3,

		///Transforms the given 2D vector as a point.
		///
		///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.
		///
		///This method assumes that `self` contains a valid affine transform.
		transform_point2(&self,LuaVec2) -> LuaVec2,

		///Rotates the given 2D vector.
		///
		///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.
		///
		///This method assumes that `self` contains a valid affine transform.
		transform_vector2(&self,LuaVec2) -> LuaVec2,

		///Transforms a 3D vector.
		mul_vec3(&self,LuaVec3) -> LuaVec3,

		///Transforms a `Vec3A`.
		mul_vec3a(&self,LuaVec3A) -> LuaVec3A,

		///Multiplies two 3x3 matrices.
		mul_mat3(&self,&LuaMat3) -> LuaMat3,

		///Adds two 3x3 matrices.
		add_mat3(&self,&LuaMat3) -> LuaMat3,

		///Subtracts two 3x3 matrices.
		sub_mat3(&self,&LuaMat3) -> LuaMat3,

		///Multiplies a 3x3 matrix by a scalar.
		mul_scalar(&self,f32) -> LuaMat3,

		///Returns true if the absolute difference of all elements between `self` and `rhs`
		///is less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two matrices contain similar elements. It works best
		///when comparing with a known value. The `max_abs_diff` that should be used used
		///depends on the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(&self,LuaMat3,f32) -> bool,

		as_dmat3(&self) -> LuaDMat3,

	)
	+ BinOps
	(
		self Add LuaMat3 -> LuaMat3,
		self Sub LuaMat3 -> LuaMat3,
		self Mul LuaAffine2 -> LuaMat3,
		self Mul LuaMat3 -> LuaMat3,
		self Mul LuaVec3 -> LuaVec3,
		f32 Mul self -> LuaMat3,
		self Mul f32 -> LuaMat3,
		self Mul LuaVec3A -> LuaVec3A,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
		    
mut (MetaMethod::Index) => |_,s,idx : usize| {
    match s {
        LuaMat3::Owned(ref mut v, ref valid) => {
            Ok(LuaVec3::Ref(ScriptRef{
                root: ScriptRefBase::ScriptOwned{valid: Arc::downgrade((valid))},
                r: ReflectPtr::Mut(v.get_mut().col_mut(idx)),
                path: None
            }))
        },
        LuaMat3::Ref(ref mut r) => {
            r.get_mut(|s,r| {
                Ok(LuaVec3::Ref(ScriptRef{
                    root: r.root.clone(),
                    r: ReflectPtr::Mut(s.downcast_mut::<Mat3>().unwrap().col_mut(idx)),
                    path: None
                })) 
            })
        }
    }
}
;
	}
}
impl_lua_newtype!{
	///A 2x2 column major matrix.
	glam::f32::sse2::mat2::Mat2 : Value
	: Fields
	(
	)
	+ AutoMethods
	(
		///Creates a 2x2 matrix from two column vectors.
		from_cols(LuaVec2,LuaVec2) -> LuaMat2,

		///Creates a 2x2 matrix with its diagonal set to `diagonal` and all other entries set to 0.
		from_diagonal(LuaVec2) -> LuaMat2,

		///Creates a 2x2 matrix containing the combining non-uniform `scale` and rotation of
		///`angle` (in radians).
		from_scale_angle(LuaVec2,f32) -> LuaMat2,

		///Creates a 2x2 matrix containing a rotation of `angle` (in radians).
		from_angle(f32) -> LuaMat2,

		///Creates a 2x2 matrix from a 3x3 matrix, discarding the 2nd row and column.
		from_mat3(LuaMat3) -> LuaMat2,

		///Returns the matrix column for the given `index`.
		///
		///# Panics
		///
		///Panics if `index` is greater than 1.
		col(&self,usize) -> LuaVec2,

		///Returns the matrix row for the given `index`.
		///
		///# Panics
		///
		///Panics if `index` is greater than 1.
		row(&self,usize) -> LuaVec2,

		///Returns `true` if, and only if, all elements are finite.
		///If any element is either `NaN`, positive or negative infinity, this will return `false`.
		is_finite(&self) -> bool,

		///Returns `true` if any elements are `NaN`.
		is_nan(&self) -> bool,

		///Returns the transpose of `self`.
		transpose(&self) -> LuaMat2,

		///Returns the determinant of `self`.
		determinant(&self) -> f32,

		///Returns the inverse of `self`.
		///
		///If the matrix is not invertible the returned matrix will be invalid.
		///
		///# Panics
		///
		///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
		inverse(&self) -> LuaMat2,

		///Transforms a 2D vector.
		mul_vec2(&self,LuaVec2) -> LuaVec2,

		///Multiplies two 2x2 matrices.
		mul_mat2(&self,&LuaMat2) -> LuaMat2,

		///Adds two 2x2 matrices.
		add_mat2(&self,&LuaMat2) -> LuaMat2,

		///Subtracts two 2x2 matrices.
		sub_mat2(&self,&LuaMat2) -> LuaMat2,

		///Multiplies a 2x2 matrix by a scalar.
		mul_scalar(&self,f32) -> LuaMat2,

		///Returns true if the absolute difference of all elements between `self` and `rhs`
		///is less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two matrices contain similar elements. It works best
		///when comparing with a known value. The `max_abs_diff` that should be used used
		///depends on the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(&self,LuaMat2,f32) -> bool,

		as_dmat2(&self) -> LuaDMat2,

	)
	+ BinOps
	(
		self Add LuaMat2 -> LuaMat2,
		self Sub LuaMat2 -> LuaMat2,
		self Mul LuaMat2 -> LuaMat2,
		self Mul LuaVec2 -> LuaVec2,
		f32 Mul self -> LuaMat2,
		self Mul f32 -> LuaMat2,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
		    
mut (MetaMethod::Index) => |_,s,idx : usize| {
    match s {
        LuaMat2::Owned(ref mut v, ref valid) => {
            Ok(LuaVec2::Ref(ScriptRef{
                root: ScriptRefBase::ScriptOwned{valid: Arc::downgrade((valid))},
                r: ReflectPtr::Mut(v.get_mut().col_mut(idx)),
                path: None
            }))
        },
        LuaMat2::Ref(ref mut r) => {
            r.get_mut(|s,r| {
                Ok(LuaVec2::Ref(ScriptRef{
                    root: r.root.clone(),
                    r: ReflectPtr::Mut(s.downcast_mut::<Mat2>().unwrap().col_mut(idx)),
                    path: None
                })) 
            })
        }
    }
}
;
	}
}
impl_lua_newtype!{
	///A 3x3 column major matrix.
	///
	///This 3x3 matrix type features convenience methods for creating and using linear and
	///affine transformations. If you are primarily dealing with 2D affine transformations the
	///[`Affine2`](crate::Affine2) type is much faster and more space efficient than
	///using a 3x3 matrix.
	///
	///Linear transformations including 3D rotation and scale can be created using methods
	///such as [`Self::from_diagonal()`], [`Self::from_quat()`], [`Self::from_axis_angle()`],
	///[`Self::from_rotation_x()`], [`Self::from_rotation_y()`], or
	///[`Self::from_rotation_z()`].
	///
	///The resulting matrices can be use to transform 3D vectors using regular vector
	///multiplication.
	///
	///Affine transformations including 2D translation, rotation and scale can be created
	///using methods such as [`Self::from_translation()`], [`Self::from_angle()`],
	///[`Self::from_scale()`] and [`Self::from_scale_angle_translation()`].
	///
	///The [`Self::transform_point2()`] and [`Self::transform_vector2()`] convenience methods
	///are provided for performing affine transforms on 2D vectors and points. These multiply
	///2D inputs as 3D vectors with an implicit `z` value of `1` for points and `0` for
	///vectors respectively. These methods assume that `Self` contains a valid affine
	///transform.
	glam::f32::sse2::mat3::Mat3A : Value
	: Fields
	(
		x_axis: LuaVec3A,
		y_axis: LuaVec3A,
		z_axis: LuaVec3A,
	)
	+ AutoMethods
	(
		///Creates a 3x3 matrix from two column vectors.
		from_cols(LuaVec3A,LuaVec3A,LuaVec3A) -> LuaMat3A,

		///Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.
		from_diagonal(LuaVec3) -> LuaMat3A,

		///Creates a 3x3 matrix from a 4x4 matrix, discarding the 3rd row and column.
		from_mat4(LuaMat4) -> LuaMat3A,

		///Creates a 3D rotation matrix from the given quaternion.
		///
		///# Panics
		///
		///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
		from_quat(LuaQuat) -> LuaMat3A,

		///Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in
		///radians).
		///
		///# Panics
		///
		///Will panic if `axis` is not normalized when `glam_assert` is enabled.
		from_axis_angle(LuaVec3,f32) -> LuaMat3A,

		///Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in
		///radians).
		from_euler(LuaEulerRot,f32,f32,f32) -> LuaMat3A,

		///Creates a 3D rotation matrix from `angle` (in radians) around the x axis.
		from_rotation_x(f32) -> LuaMat3A,

		///Creates a 3D rotation matrix from `angle` (in radians) around the y axis.
		from_rotation_y(f32) -> LuaMat3A,

		///Creates a 3D rotation matrix from `angle` (in radians) around the z axis.
		from_rotation_z(f32) -> LuaMat3A,

		///Creates an affine transformation matrix from the given 2D `translation`.
		///
		///The resulting matrix can be used to transform 2D points and vectors. See
		///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
		from_translation(LuaVec2) -> LuaMat3A,

		///Creates an affine transformation matrix from the given 2D rotation `angle` (in
		///radians).
		///
		///The resulting matrix can be used to transform 2D points and vectors. See
		///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
		from_angle(f32) -> LuaMat3A,

		///Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in
		///radians) and `translation`.
		///
		///The resulting matrix can be used to transform 2D points and vectors. See
		///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
		from_scale_angle_translation(LuaVec2,f32,LuaVec2) -> LuaMat3A,

		///Creates an affine transformation matrix from the given non-uniform 2D `scale`.
		///
		///The resulting matrix can be used to transform 2D points and vectors. See
		///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
		///
		///# Panics
		///
		///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
		from_scale(LuaVec2) -> LuaMat3A,

		///Creates an affine transformation matrix from the given 2x2 matrix.
		///
		///The resulting matrix can be used to transform 2D points and vectors. See
		///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
		from_mat2(LuaMat2) -> LuaMat3A,

		///Returns the matrix column for the given `index`.
		///
		///# Panics
		///
		///Panics if `index` is greater than 2.
		col(&self,usize) -> LuaVec3A,

		///Returns the matrix row for the given `index`.
		///
		///# Panics
		///
		///Panics if `index` is greater than 2.
		row(&self,usize) -> LuaVec3A,

		///Returns `true` if, and only if, all elements are finite.
		///If any element is either `NaN`, positive or negative infinity, this will return `false`.
		is_finite(&self) -> bool,

		///Returns `true` if any elements are `NaN`.
		is_nan(&self) -> bool,

		///Returns the transpose of `self`.
		transpose(&self) -> LuaMat3A,

		///Returns the determinant of `self`.
		determinant(&self) -> f32,

		///Returns the inverse of `self`.
		///
		///If the matrix is not invertible the returned matrix will be invalid.
		///
		///# Panics
		///
		///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
		inverse(&self) -> LuaMat3A,

		///Transforms the given 2D vector as a point.
		///
		///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.
		///
		///This method assumes that `self` contains a valid affine transform.
		transform_point2(&self,LuaVec2) -> LuaVec2,

		///Rotates the given 2D vector.
		///
		///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.
		///
		///This method assumes that `self` contains a valid affine transform.
		transform_vector2(&self,LuaVec2) -> LuaVec2,

		///Transforms a 3D vector.
		mul_vec3(&self,LuaVec3) -> LuaVec3,

		///Transforms a `Vec3A`.
		mul_vec3a(&self,LuaVec3A) -> LuaVec3A,

		///Multiplies two 3x3 matrices.
		mul_mat3(&self,&LuaMat3A) -> LuaMat3A,

		///Adds two 3x3 matrices.
		add_mat3(&self,&LuaMat3A) -> LuaMat3A,

		///Subtracts two 3x3 matrices.
		sub_mat3(&self,&LuaMat3A) -> LuaMat3A,

		///Multiplies a 3x3 matrix by a scalar.
		mul_scalar(&self,f32) -> LuaMat3A,

		///Returns true if the absolute difference of all elements between `self` and `rhs`
		///is less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two matrices contain similar elements. It works best
		///when comparing with a known value. The `max_abs_diff` that should be used used
		///depends on the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(&self,LuaMat3A,f32) -> bool,

		as_dmat3(&self) -> LuaDMat3,

	)
	+ BinOps
	(
		self Add LuaMat3A -> LuaMat3A,
		self Sub LuaMat3A -> LuaMat3A,
		self Mul LuaAffine2 -> LuaMat3A,
		self Mul LuaMat3A -> LuaMat3A,
		self Mul LuaVec3A -> LuaVec3A,
		f32 Mul self -> LuaMat3A,
		self Mul f32 -> LuaMat3A,
		self Mul LuaVec3 -> LuaVec3,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
		    
mut (MetaMethod::Index) => |_,s,idx : usize| {
    match s {
        LuaMat3A::Owned(ref mut v, ref valid) => {
            Ok(LuaVec3A::Ref(ScriptRef{
                root: ScriptRefBase::ScriptOwned{valid: Arc::downgrade((valid))},
                r: ReflectPtr::Mut(v.get_mut().col_mut(idx)),
                path: None
            }))
        },
        LuaMat3A::Ref(ref mut r) => {
            r.get_mut(|s,r| {
                Ok(LuaVec3A::Ref(ScriptRef{
                    root: r.root.clone(),
                    r: ReflectPtr::Mut(s.downcast_mut::<Mat3A>().unwrap().col_mut(idx)),
                    path: None
                })) 
            })
        }
    }
}
;
	}
}
impl_lua_newtype!{
	///A 4x4 column major matrix.
	///
	///This 4x4 matrix type features convenience methods for creating and using affine transforms and
	///perspective projections. If you are primarily dealing with 3D affine transformations
	///considering using [`Affine3A`](crate::Affine3A) which is faster than a 4x4 matrix
	///for some affine operations.
	///
	///Affine transformations including 3D translation, rotation and scale can be created
	///using methods such as [`Self::from_translation()`], [`Self::from_quat()`],
	///[`Self::from_scale()`] and [`Self::from_scale_rotation_translation()`].
	///
	///Othographic projections can be created using the methods [`Self::orthographic_lh()`] for
	///left-handed coordinate systems and [`Self::orthographic_rh()`] for right-handed
	///systems. The resulting matrix is also an affine transformation.
	///
	///The [`Self::transform_point3()`] and [`Self::transform_vector3()`] convenience methods
	///are provided for performing affine transformations on 3D vectors and points. These
	///multiply 3D inputs as 4D vectors with an implicit `w` value of `1` for points and `0`
	///for vectors respectively. These methods assume that `Self` contains a valid affine
	///transform.
	///
	///Perspective projections can be created using methods such as
	///[`Self::perspective_lh()`], [`Self::perspective_infinite_lh()`] and
	///[`Self::perspective_infinite_reverse_lh()`] for left-handed co-ordinate systems and
	///[`Self::perspective_rh()`], [`Self::perspective_infinite_rh()`] and
	///[`Self::perspective_infinite_reverse_rh()`] for right-handed co-ordinate systems.
	///
	///The resulting perspective project can be use to transform 3D vectors as points with
	///perspective correction using the [`Self::project_point3()`] convenience method.
	glam::f32::sse2::mat4::Mat4 : Value
	: Fields
	(
		x_axis: LuaVec4,
		y_axis: LuaVec4,
		z_axis: LuaVec4,
		w_axis: LuaVec4,
	)
	+ AutoMethods
	(
		///Creates a 4x4 matrix from two column vectors.
		from_cols(LuaVec4,LuaVec4,LuaVec4,LuaVec4) -> LuaMat4,

		///Creates a 4x4 matrix with its diagonal set to `diagonal` and all other entries set to 0.
		from_diagonal(LuaVec4) -> LuaMat4,

		///Creates an affine transformation matrix from the given 3D `scale`, `rotation` and
		///`translation`.
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		///
		///# Panics
		///
		///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
		from_scale_rotation_translation(LuaVec3,LuaQuat,LuaVec3) -> LuaMat4,

		///Creates an affine transformation matrix from the given 3D `translation`.
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		///
		///# Panics
		///
		///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
		from_rotation_translation(LuaQuat,LuaVec3) -> LuaMat4,

		///Creates an affine transformation matrix from the given `rotation` quaternion.
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		///
		///# Panics
		///
		///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
		from_quat(LuaQuat) -> LuaMat4,

		///Creates an affine transformation matrix from the given 3x3 linear transformation
		///matrix.
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		from_mat3(LuaMat3) -> LuaMat4,

		///Creates an affine transformation matrix from the given 3D `translation`.
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		from_translation(LuaVec3) -> LuaMat4,

		///Creates an affine transformation matrix containing a 3D rotation around a normalized
		///rotation `axis` of `angle` (in radians).
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		///
		///# Panics
		///
		///Will panic if `axis` is not normalized when `glam_assert` is enabled.
		from_axis_angle(LuaVec3,f32) -> LuaMat4,

		///Creates a affine transformation matrix containing a rotation from the given euler
		///rotation sequence and angles (in radians).
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		from_euler(LuaEulerRot,f32,f32,f32) -> LuaMat4,

		///Creates an affine transformation matrix containing a 3D rotation around the x axis of
		///`angle` (in radians).
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		from_rotation_x(f32) -> LuaMat4,

		///Creates an affine transformation matrix containing a 3D rotation around the y axis of
		///`angle` (in radians).
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		from_rotation_y(f32) -> LuaMat4,

		///Creates an affine transformation matrix containing a 3D rotation around the z axis of
		///`angle` (in radians).
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		from_rotation_z(f32) -> LuaMat4,

		///Creates an affine transformation matrix containing the given 3D non-uniform `scale`.
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		///
		///# Panics
		///
		///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
		from_scale(LuaVec3) -> LuaMat4,

		///Returns the matrix column for the given `index`.
		///
		///# Panics
		///
		///Panics if `index` is greater than 3.
		col(&self,usize) -> LuaVec4,

		///Returns the matrix row for the given `index`.
		///
		///# Panics
		///
		///Panics if `index` is greater than 3.
		row(&self,usize) -> LuaVec4,

		///Returns `true` if, and only if, all elements are finite.
		///If any element is either `NaN`, positive or negative infinity, this will return `false`.
		is_finite(&self) -> bool,

		///Returns `true` if any elements are `NaN`.
		is_nan(&self) -> bool,

		///Returns the transpose of `self`.
		transpose(&self) -> LuaMat4,

		///Returns the determinant of `self`.
		determinant(&self) -> f32,

		///Returns the inverse of `self`.
		///
		///If the matrix is not invertible the returned matrix will be invalid.
		///
		///# Panics
		///
		///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
		inverse(&self) -> LuaMat4,

		///Creates a left-handed view matrix using a camera position, an up direction, and a focal
		///point.
		///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
		///
		///# Panics
		///
		///Will panic if `up` is not normalized when `glam_assert` is enabled.
		look_at_lh(LuaVec3,LuaVec3,LuaVec3) -> LuaMat4,

		///Creates a right-handed view matrix using a camera position, an up direction, and a focal
		///point.
		///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
		///
		///# Panics
		///
		///Will panic if `up` is not normalized when `glam_assert` is enabled.
		look_at_rh(LuaVec3,LuaVec3,LuaVec3) -> LuaMat4,

		///Creates a right-handed perspective projection matrix with [-1,1] depth range.
		///This is the same as the OpenGL `gluPerspective` function.
		///See <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml>
		perspective_rh_gl(f32,f32,f32,f32) -> LuaMat4,

		///Creates a left-handed perspective projection matrix with `[0,1]` depth range.
		///
		///# Panics
		///
		///Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
		///enabled.
		perspective_lh(f32,f32,f32,f32) -> LuaMat4,

		///Creates a right-handed perspective projection matrix with `[0,1]` depth range.
		///
		///# Panics
		///
		///Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
		///enabled.
		perspective_rh(f32,f32,f32,f32) -> LuaMat4,

		///Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
		///
		///# Panics
		///
		///Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
		perspective_infinite_lh(f32,f32,f32) -> LuaMat4,

		///Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
		///
		///# Panics
		///
		///Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
		perspective_infinite_reverse_lh(f32,f32,f32) -> LuaMat4,

		///Creates an infinite right-handed perspective projection matrix with
		///`[0,1]` depth range.
		perspective_infinite_rh(f32,f32,f32) -> LuaMat4,

		///Creates an infinite reverse right-handed perspective projection matrix
		///with `[0,1]` depth range.
		perspective_infinite_reverse_rh(f32,f32,f32) -> LuaMat4,

		///Creates a right-handed orthographic projection matrix with `[-1,1]` depth
		///range.  This is the same as the OpenGL `glOrtho` function in OpenGL.
		///See
		///<https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml>
		orthographic_rh_gl(f32,f32,f32,f32,f32,f32) -> LuaMat4,

		///Creates a left-handed orthographic projection matrix with `[0,1]` depth range.
		orthographic_lh(f32,f32,f32,f32,f32,f32) -> LuaMat4,

		///Creates a right-handed orthographic projection matrix with `[0,1]` depth range.
		orthographic_rh(f32,f32,f32,f32,f32,f32) -> LuaMat4,

		///Transforms the given 3D vector as a point, applying perspective correction.
		///
		///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is `1.0`.
		///The perspective divide is performed meaning the resulting 3D vector is divided by `w`.
		///
		///This method assumes that `self` contains a projective transform.
		project_point3(&self,LuaVec3) -> LuaVec3,

		///Transforms the given 3D vector as a point.
		///
		///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
		///`1.0`.
		///
		///This method assumes that `self` contains a valid affine transform. It does not perform
		///a persective divide, if `self` contains a perspective transform, or if you are unsure,
		///the [`Self::project_point3()`] method should be used instead.
		///
		///# Panics
		///
		///Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
		transform_point3(&self,LuaVec3) -> LuaVec3,

		///Transforms the give 3D vector as a direction.
		///
		///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
		///`0.0`.
		///
		///This method assumes that `self` contains a valid affine transform.
		///
		///# Panics
		///
		///Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
		transform_vector3(&self,LuaVec3) -> LuaVec3,

		///Transforms the given `Vec3A` as 3D point.
		///
		///This is the equivalent of multiplying the `Vec3A` as a 4D vector where `w` is `1.0`.
		transform_point3a(&self,LuaVec3A) -> LuaVec3A,

		///Transforms the give `Vec3A` as 3D vector.
		///
		///This is the equivalent of multiplying the `Vec3A` as a 4D vector where `w` is `0.0`.
		transform_vector3a(&self,LuaVec3A) -> LuaVec3A,

		///Transforms a 4D vector.
		mul_vec4(&self,LuaVec4) -> LuaVec4,

		///Multiplies two 4x4 matrices.
		mul_mat4(&self,&LuaMat4) -> LuaMat4,

		///Adds two 4x4 matrices.
		add_mat4(&self,&LuaMat4) -> LuaMat4,

		///Subtracts two 4x4 matrices.
		sub_mat4(&self,&LuaMat4) -> LuaMat4,

		///Multiplies a 4x4 matrix by a scalar.
		mul_scalar(&self,f32) -> LuaMat4,

		///Returns true if the absolute difference of all elements between `self` and `rhs`
		///is less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two matrices contain similar elements. It works best
		///when comparing with a known value. The `max_abs_diff` that should be used used
		///depends on the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(&self,LuaMat4,f32) -> bool,

		as_dmat4(&self) -> LuaDMat4,

	)
	+ BinOps
	(
		self Add LuaMat4 -> LuaMat4,
		self Sub LuaMat4 -> LuaMat4,
		self Mul LuaAffine3A -> LuaMat4,
		self Mul LuaMat4 -> LuaMat4,
		self Mul LuaVec4 -> LuaVec4,
		f32 Mul self -> LuaMat4,
		self Mul f32 -> LuaMat4,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
		    
mut (MetaMethod::Index) => |_,s,idx : usize| {
    match s {
        LuaMat4::Owned(ref mut v, ref valid) => {
            Ok(LuaVec4::Ref(ScriptRef{
                root: ScriptRefBase::ScriptOwned{valid: Arc::downgrade((valid))},
                r: ReflectPtr::Mut(v.get_mut().col_mut(idx)),
                path: None
            }))
        },
        LuaMat4::Ref(ref mut r) => {
            r.get_mut(|s,r| {
                Ok(LuaVec4::Ref(ScriptRef{
                    root: r.root.clone(),
                    r: ReflectPtr::Mut(s.downcast_mut::<Mat4>().unwrap().col_mut(idx)),
                    path: None
                })) 
            })
        }
    }
}
;
	}
}
impl_lua_newtype!{
	///A 2x2 column major matrix.
	glam::f64::dmat2::DMat2 : Value
	: Fields
	(
		x_axis: LuaDVec2,
		y_axis: LuaDVec2,
	)
	+ AutoMethods
	(
		///Creates a 2x2 matrix from two column vectors.
		from_cols(LuaDVec2,LuaDVec2) -> LuaDMat2,

		///Creates a 2x2 matrix with its diagonal set to `diagonal` and all other entries set to 0.
		from_diagonal(LuaDVec2) -> LuaDMat2,

		///Creates a 2x2 matrix containing the combining non-uniform `scale` and rotation of
		///`angle` (in radians).
		from_scale_angle(LuaDVec2,f64) -> LuaDMat2,

		///Creates a 2x2 matrix containing a rotation of `angle` (in radians).
		from_angle(f64) -> LuaDMat2,

		///Creates a 2x2 matrix from a 3x3 matrix, discarding the 2nd row and column.
		from_mat3(LuaDMat3) -> LuaDMat2,

		///Returns the matrix column for the given `index`.
		///
		///# Panics
		///
		///Panics if `index` is greater than 1.
		col(&self,usize) -> LuaDVec2,

		///Returns the matrix row for the given `index`.
		///
		///# Panics
		///
		///Panics if `index` is greater than 1.
		row(&self,usize) -> LuaDVec2,

		///Returns `true` if, and only if, all elements are finite.
		///If any element is either `NaN`, positive or negative infinity, this will return `false`.
		is_finite(&self) -> bool,

		///Returns `true` if any elements are `NaN`.
		is_nan(&self) -> bool,

		///Returns the transpose of `self`.
		transpose(&self) -> LuaDMat2,

		///Returns the determinant of `self`.
		determinant(&self) -> f64,

		///Returns the inverse of `self`.
		///
		///If the matrix is not invertible the returned matrix will be invalid.
		///
		///# Panics
		///
		///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
		inverse(&self) -> LuaDMat2,

		///Transforms a 2D vector.
		mul_vec2(&self,LuaDVec2) -> LuaDVec2,

		///Multiplies two 2x2 matrices.
		mul_mat2(&self,&LuaDMat2) -> LuaDMat2,

		///Adds two 2x2 matrices.
		add_mat2(&self,&LuaDMat2) -> LuaDMat2,

		///Subtracts two 2x2 matrices.
		sub_mat2(&self,&LuaDMat2) -> LuaDMat2,

		///Multiplies a 2x2 matrix by a scalar.
		mul_scalar(&self,f64) -> LuaDMat2,

		///Returns true if the absolute difference of all elements between `self` and `rhs`
		///is less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two matrices contain similar elements. It works best
		///when comparing with a known value. The `max_abs_diff` that should be used used
		///depends on the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(&self,LuaDMat2,f64) -> bool,

		as_mat2(&self) -> LuaMat2,

	)
	+ BinOps
	(
		self Add LuaDMat2 -> LuaDMat2,
		self Sub LuaDMat2 -> LuaDMat2,
		self Mul LuaDMat2 -> LuaDMat2,
		self Mul LuaDVec2 -> LuaDVec2,
		f64 Mul self -> LuaDMat2,
		self Mul f64 -> LuaDMat2,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
		    
mut (MetaMethod::Index) => |_,s,idx : usize| {
    match s {
        LuaDMat2::Owned(ref mut v, ref valid) => {
            Ok(LuaDVec2::Ref(ScriptRef{
                root: ScriptRefBase::ScriptOwned{valid: Arc::downgrade((valid))},
                r: ReflectPtr::Mut(v.get_mut().col_mut(idx)),
                path: None
            }))
        },
        LuaDMat2::Ref(ref mut r) => {
            r.get_mut(|s,r| {
                Ok(LuaDVec2::Ref(ScriptRef{
                    root: r.root.clone(),
                    r: ReflectPtr::Mut(s.downcast_mut::<DMat2>().unwrap().col_mut(idx)),
                    path: None
                })) 
            })
        }
    }
}
;
	}
}
impl_lua_newtype!{
	///A 3x3 column major matrix.
	///
	///This 3x3 matrix type features convenience methods for creating and using linear and
	///affine transformations. If you are primarily dealing with 2D affine transformations the
	///[`DAffine2`](crate::DAffine2) type is much faster and more space efficient than
	///using a 3x3 matrix.
	///
	///Linear transformations including 3D rotation and scale can be created using methods
	///such as [`Self::from_diagonal()`], [`Self::from_quat()`], [`Self::from_axis_angle()`],
	///[`Self::from_rotation_x()`], [`Self::from_rotation_y()`], or
	///[`Self::from_rotation_z()`].
	///
	///The resulting matrices can be use to transform 3D vectors using regular vector
	///multiplication.
	///
	///Affine transformations including 2D translation, rotation and scale can be created
	///using methods such as [`Self::from_translation()`], [`Self::from_angle()`],
	///[`Self::from_scale()`] and [`Self::from_scale_angle_translation()`].
	///
	///The [`Self::transform_point2()`] and [`Self::transform_vector2()`] convenience methods
	///are provided for performing affine transforms on 2D vectors and points. These multiply
	///2D inputs as 3D vectors with an implicit `z` value of `1` for points and `0` for
	///vectors respectively. These methods assume that `Self` contains a valid affine
	///transform.
	glam::f64::dmat3::DMat3 : Value
	: Fields
	(
		x_axis: LuaDVec3,
		y_axis: LuaDVec3,
		z_axis: LuaDVec3,
	)
	+ AutoMethods
	(
		///Creates a 3x3 matrix from two column vectors.
		from_cols(LuaDVec3,LuaDVec3,LuaDVec3) -> LuaDMat3,

		///Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.
		from_diagonal(LuaDVec3) -> LuaDMat3,

		///Creates a 3x3 matrix from a 4x4 matrix, discarding the 3rd row and column.
		from_mat4(LuaDMat4) -> LuaDMat3,

		///Creates a 3D rotation matrix from the given quaternion.
		///
		///# Panics
		///
		///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
		from_quat(LuaDQuat) -> LuaDMat3,

		///Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in
		///radians).
		///
		///# Panics
		///
		///Will panic if `axis` is not normalized when `glam_assert` is enabled.
		from_axis_angle(LuaDVec3,f64) -> LuaDMat3,

		///Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in
		///radians).
		from_euler(LuaEulerRot,f64,f64,f64) -> LuaDMat3,

		///Creates a 3D rotation matrix from `angle` (in radians) around the x axis.
		from_rotation_x(f64) -> LuaDMat3,

		///Creates a 3D rotation matrix from `angle` (in radians) around the y axis.
		from_rotation_y(f64) -> LuaDMat3,

		///Creates a 3D rotation matrix from `angle` (in radians) around the z axis.
		from_rotation_z(f64) -> LuaDMat3,

		///Creates an affine transformation matrix from the given 2D `translation`.
		///
		///The resulting matrix can be used to transform 2D points and vectors. See
		///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
		from_translation(LuaDVec2) -> LuaDMat3,

		///Creates an affine transformation matrix from the given 2D rotation `angle` (in
		///radians).
		///
		///The resulting matrix can be used to transform 2D points and vectors. See
		///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
		from_angle(f64) -> LuaDMat3,

		///Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in
		///radians) and `translation`.
		///
		///The resulting matrix can be used to transform 2D points and vectors. See
		///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
		from_scale_angle_translation(LuaDVec2,f64,LuaDVec2) -> LuaDMat3,

		///Creates an affine transformation matrix from the given non-uniform 2D `scale`.
		///
		///The resulting matrix can be used to transform 2D points and vectors. See
		///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
		///
		///# Panics
		///
		///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
		from_scale(LuaDVec2) -> LuaDMat3,

		///Creates an affine transformation matrix from the given 2x2 matrix.
		///
		///The resulting matrix can be used to transform 2D points and vectors. See
		///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
		from_mat2(LuaDMat2) -> LuaDMat3,

		///Returns the matrix column for the given `index`.
		///
		///# Panics
		///
		///Panics if `index` is greater than 2.
		col(&self,usize) -> LuaDVec3,

		///Returns the matrix row for the given `index`.
		///
		///# Panics
		///
		///Panics if `index` is greater than 2.
		row(&self,usize) -> LuaDVec3,

		///Returns `true` if, and only if, all elements are finite.
		///If any element is either `NaN`, positive or negative infinity, this will return `false`.
		is_finite(&self) -> bool,

		///Returns `true` if any elements are `NaN`.
		is_nan(&self) -> bool,

		///Returns the transpose of `self`.
		transpose(&self) -> LuaDMat3,

		///Returns the determinant of `self`.
		determinant(&self) -> f64,

		///Returns the inverse of `self`.
		///
		///If the matrix is not invertible the returned matrix will be invalid.
		///
		///# Panics
		///
		///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
		inverse(&self) -> LuaDMat3,

		///Transforms the given 2D vector as a point.
		///
		///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.
		///
		///This method assumes that `self` contains a valid affine transform.
		transform_point2(&self,LuaDVec2) -> LuaDVec2,

		///Rotates the given 2D vector.
		///
		///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.
		///
		///This method assumes that `self` contains a valid affine transform.
		transform_vector2(&self,LuaDVec2) -> LuaDVec2,

		///Transforms a 3D vector.
		mul_vec3(&self,LuaDVec3) -> LuaDVec3,

		///Multiplies two 3x3 matrices.
		mul_mat3(&self,&LuaDMat3) -> LuaDMat3,

		///Adds two 3x3 matrices.
		add_mat3(&self,&LuaDMat3) -> LuaDMat3,

		///Subtracts two 3x3 matrices.
		sub_mat3(&self,&LuaDMat3) -> LuaDMat3,

		///Multiplies a 3x3 matrix by a scalar.
		mul_scalar(&self,f64) -> LuaDMat3,

		///Returns true if the absolute difference of all elements between `self` and `rhs`
		///is less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two matrices contain similar elements. It works best
		///when comparing with a known value. The `max_abs_diff` that should be used used
		///depends on the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(&self,LuaDMat3,f64) -> bool,

		as_mat3(&self) -> LuaMat3,

	)
	+ BinOps
	(
		self Add LuaDMat3 -> LuaDMat3,
		self Sub LuaDMat3 -> LuaDMat3,
		self Mul LuaDAffine2 -> LuaDMat3,
		self Mul LuaDMat3 -> LuaDMat3,
		self Mul LuaDVec3 -> LuaDVec3,
		f64 Mul self -> LuaDMat3,
		self Mul f64 -> LuaDMat3,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
		    
mut (MetaMethod::Index) => |_,s,idx : usize| {
    match s {
        LuaDMat3::Owned(ref mut v, ref valid) => {
            Ok(LuaDVec3::Ref(ScriptRef{
                root: ScriptRefBase::ScriptOwned{valid: Arc::downgrade((valid))},
                r: ReflectPtr::Mut(v.get_mut().col_mut(idx)),
                path: None
            }))
        },
        LuaDMat3::Ref(ref mut r) => {
            r.get_mut(|s,r| {
                Ok(LuaDVec3::Ref(ScriptRef{
                    root: r.root.clone(),
                    r: ReflectPtr::Mut(s.downcast_mut::<DMat3>().unwrap().col_mut(idx)),
                    path: None
                })) 
            })
        }
    }
}
;
	}
}
impl_lua_newtype!{
	///A 4x4 column major matrix.
	///
	///This 4x4 matrix type features convenience methods for creating and using affine transforms and
	///perspective projections. If you are primarily dealing with 3D affine transformations
	///considering using [`DAffine3`](crate::DAffine3) which is faster than a 4x4 matrix
	///for some affine operations.
	///
	///Affine transformations including 3D translation, rotation and scale can be created
	///using methods such as [`Self::from_translation()`], [`Self::from_quat()`],
	///[`Self::from_scale()`] and [`Self::from_scale_rotation_translation()`].
	///
	///Othographic projections can be created using the methods [`Self::orthographic_lh()`] for
	///left-handed coordinate systems and [`Self::orthographic_rh()`] for right-handed
	///systems. The resulting matrix is also an affine transformation.
	///
	///The [`Self::transform_point3()`] and [`Self::transform_vector3()`] convenience methods
	///are provided for performing affine transformations on 3D vectors and points. These
	///multiply 3D inputs as 4D vectors with an implicit `w` value of `1` for points and `0`
	///for vectors respectively. These methods assume that `Self` contains a valid affine
	///transform.
	///
	///Perspective projections can be created using methods such as
	///[`Self::perspective_lh()`], [`Self::perspective_infinite_lh()`] and
	///[`Self::perspective_infinite_reverse_lh()`] for left-handed co-ordinate systems and
	///[`Self::perspective_rh()`], [`Self::perspective_infinite_rh()`] and
	///[`Self::perspective_infinite_reverse_rh()`] for right-handed co-ordinate systems.
	///
	///The resulting perspective project can be use to transform 3D vectors as points with
	///perspective correction using the [`Self::project_point3()`] convenience method.
	glam::f64::dmat4::DMat4 : Value
	: Fields
	(
		x_axis: LuaDVec4,
		y_axis: LuaDVec4,
		z_axis: LuaDVec4,
		w_axis: LuaDVec4,
	)
	+ AutoMethods
	(
		///Creates a 4x4 matrix from two column vectors.
		from_cols(LuaDVec4,LuaDVec4,LuaDVec4,LuaDVec4) -> LuaDMat4,

		///Creates a 4x4 matrix with its diagonal set to `diagonal` and all other entries set to 0.
		from_diagonal(LuaDVec4) -> LuaDMat4,

		///Creates an affine transformation matrix from the given 3D `scale`, `rotation` and
		///`translation`.
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		///
		///# Panics
		///
		///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
		from_scale_rotation_translation(LuaDVec3,LuaDQuat,LuaDVec3) -> LuaDMat4,

		///Creates an affine transformation matrix from the given 3D `translation`.
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		///
		///# Panics
		///
		///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
		from_rotation_translation(LuaDQuat,LuaDVec3) -> LuaDMat4,

		///Creates an affine transformation matrix from the given `rotation` quaternion.
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		///
		///# Panics
		///
		///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
		from_quat(LuaDQuat) -> LuaDMat4,

		///Creates an affine transformation matrix from the given 3x3 linear transformation
		///matrix.
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		from_mat3(LuaDMat3) -> LuaDMat4,

		///Creates an affine transformation matrix from the given 3D `translation`.
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		from_translation(LuaDVec3) -> LuaDMat4,

		///Creates an affine transformation matrix containing a 3D rotation around a normalized
		///rotation `axis` of `angle` (in radians).
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		///
		///# Panics
		///
		///Will panic if `axis` is not normalized when `glam_assert` is enabled.
		from_axis_angle(LuaDVec3,f64) -> LuaDMat4,

		///Creates a affine transformation matrix containing a rotation from the given euler
		///rotation sequence and angles (in radians).
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		from_euler(LuaEulerRot,f64,f64,f64) -> LuaDMat4,

		///Creates an affine transformation matrix containing a 3D rotation around the x axis of
		///`angle` (in radians).
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		from_rotation_x(f64) -> LuaDMat4,

		///Creates an affine transformation matrix containing a 3D rotation around the y axis of
		///`angle` (in radians).
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		from_rotation_y(f64) -> LuaDMat4,

		///Creates an affine transformation matrix containing a 3D rotation around the z axis of
		///`angle` (in radians).
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		from_rotation_z(f64) -> LuaDMat4,

		///Creates an affine transformation matrix containing the given 3D non-uniform `scale`.
		///
		///The resulting matrix can be used to transform 3D points and vectors. See
		///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
		///
		///# Panics
		///
		///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
		from_scale(LuaDVec3) -> LuaDMat4,

		///Returns the matrix column for the given `index`.
		///
		///# Panics
		///
		///Panics if `index` is greater than 3.
		col(&self,usize) -> LuaDVec4,

		///Returns the matrix row for the given `index`.
		///
		///# Panics
		///
		///Panics if `index` is greater than 3.
		row(&self,usize) -> LuaDVec4,

		///Returns `true` if, and only if, all elements are finite.
		///If any element is either `NaN`, positive or negative infinity, this will return `false`.
		is_finite(&self) -> bool,

		///Returns `true` if any elements are `NaN`.
		is_nan(&self) -> bool,

		///Returns the transpose of `self`.
		transpose(&self) -> LuaDMat4,

		///Returns the determinant of `self`.
		determinant(&self) -> f64,

		///Returns the inverse of `self`.
		///
		///If the matrix is not invertible the returned matrix will be invalid.
		///
		///# Panics
		///
		///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
		inverse(&self) -> LuaDMat4,

		///Creates a left-handed view matrix using a camera position, an up direction, and a focal
		///point.
		///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
		///
		///# Panics
		///
		///Will panic if `up` is not normalized when `glam_assert` is enabled.
		look_at_lh(LuaDVec3,LuaDVec3,LuaDVec3) -> LuaDMat4,

		///Creates a right-handed view matrix using a camera position, an up direction, and a focal
		///point.
		///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
		///
		///# Panics
		///
		///Will panic if `up` is not normalized when `glam_assert` is enabled.
		look_at_rh(LuaDVec3,LuaDVec3,LuaDVec3) -> LuaDMat4,

		///Creates a right-handed perspective projection matrix with [-1,1] depth range.
		///This is the same as the OpenGL `gluPerspective` function.
		///See <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml>
		perspective_rh_gl(f64,f64,f64,f64) -> LuaDMat4,

		///Creates a left-handed perspective projection matrix with `[0,1]` depth range.
		///
		///# Panics
		///
		///Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
		///enabled.
		perspective_lh(f64,f64,f64,f64) -> LuaDMat4,

		///Creates a right-handed perspective projection matrix with `[0,1]` depth range.
		///
		///# Panics
		///
		///Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
		///enabled.
		perspective_rh(f64,f64,f64,f64) -> LuaDMat4,

		///Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
		///
		///# Panics
		///
		///Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
		perspective_infinite_lh(f64,f64,f64) -> LuaDMat4,

		///Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
		///
		///# Panics
		///
		///Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
		perspective_infinite_reverse_lh(f64,f64,f64) -> LuaDMat4,

		///Creates an infinite right-handed perspective projection matrix with
		///`[0,1]` depth range.
		perspective_infinite_rh(f64,f64,f64) -> LuaDMat4,

		///Creates an infinite reverse right-handed perspective projection matrix
		///with `[0,1]` depth range.
		perspective_infinite_reverse_rh(f64,f64,f64) -> LuaDMat4,

		///Creates a right-handed orthographic projection matrix with `[-1,1]` depth
		///range.  This is the same as the OpenGL `glOrtho` function in OpenGL.
		///See
		///<https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml>
		orthographic_rh_gl(f64,f64,f64,f64,f64,f64) -> LuaDMat4,

		///Creates a left-handed orthographic projection matrix with `[0,1]` depth range.
		orthographic_lh(f64,f64,f64,f64,f64,f64) -> LuaDMat4,

		///Creates a right-handed orthographic projection matrix with `[0,1]` depth range.
		orthographic_rh(f64,f64,f64,f64,f64,f64) -> LuaDMat4,

		///Transforms the given 3D vector as a point, applying perspective correction.
		///
		///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is `1.0`.
		///The perspective divide is performed meaning the resulting 3D vector is divided by `w`.
		///
		///This method assumes that `self` contains a projective transform.
		project_point3(&self,LuaDVec3) -> LuaDVec3,

		///Transforms the given 3D vector as a point.
		///
		///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
		///`1.0`.
		///
		///This method assumes that `self` contains a valid affine transform. It does not perform
		///a persective divide, if `self` contains a perspective transform, or if you are unsure,
		///the [`Self::project_point3()`] method should be used instead.
		///
		///# Panics
		///
		///Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
		transform_point3(&self,LuaDVec3) -> LuaDVec3,

		///Transforms the give 3D vector as a direction.
		///
		///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
		///`0.0`.
		///
		///This method assumes that `self` contains a valid affine transform.
		///
		///# Panics
		///
		///Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
		transform_vector3(&self,LuaDVec3) -> LuaDVec3,

		///Transforms a 4D vector.
		mul_vec4(&self,LuaDVec4) -> LuaDVec4,

		///Multiplies two 4x4 matrices.
		mul_mat4(&self,&LuaDMat4) -> LuaDMat4,

		///Adds two 4x4 matrices.
		add_mat4(&self,&LuaDMat4) -> LuaDMat4,

		///Subtracts two 4x4 matrices.
		sub_mat4(&self,&LuaDMat4) -> LuaDMat4,

		///Multiplies a 4x4 matrix by a scalar.
		mul_scalar(&self,f64) -> LuaDMat4,

		///Returns true if the absolute difference of all elements between `self` and `rhs`
		///is less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two matrices contain similar elements. It works best
		///when comparing with a known value. The `max_abs_diff` that should be used used
		///depends on the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(&self,LuaDMat4,f64) -> bool,

		as_mat4(&self) -> LuaMat4,

	)
	+ BinOps
	(
		self Add LuaDMat4 -> LuaDMat4,
		self Sub LuaDMat4 -> LuaDMat4,
		self Mul LuaDAffine3 -> LuaDMat4,
		self Mul LuaDMat4 -> LuaDMat4,
		self Mul LuaDVec4 -> LuaDVec4,
		f64 Mul self -> LuaDMat4,
		self Mul f64 -> LuaDMat4,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
		    
mut (MetaMethod::Index) => |_,s,idx : usize| {
    match s {
        LuaDMat4::Owned(ref mut v, ref valid) => {
            Ok(LuaDVec4::Ref(ScriptRef{
                root: ScriptRefBase::ScriptOwned{valid: Arc::downgrade((valid))},
                r: ReflectPtr::Mut(v.get_mut().col_mut(idx)),
                path: None
            }))
        },
        LuaDMat4::Ref(ref mut r) => {
            r.get_mut(|s,r| {
                Ok(LuaDVec4::Ref(ScriptRef{
                    root: r.root.clone(),
                    r: ReflectPtr::Mut(s.downcast_mut::<DMat4>().unwrap().col_mut(idx)),
                    path: None
                })) 
            })
        }
    }
}
;
	}
}
impl_lua_newtype!{
	///A 2D affine transform, which can represent translation, rotation, scaling and shear.
	glam::f32::sse2::mat2::Affine2 : Value
	: Fields
	(
		matrix2: LuaMat2,
		translation: LuaVec2,
	)
	+ AutoMethods
	(
		///Creates an affine transform from three column vectors.
		from_cols(LuaVec2,LuaVec2,LuaVec2) -> LuaAffine2,

		///Creates an affine transform that changes scale.
		///Note that if any scale is zero the transform will be non-invertible.
		from_scale(LuaVec2) -> LuaAffine2,

		///Creates an affine transform from the given rotation `angle`.
		from_angle(f32) -> LuaAffine2,

		///Creates an affine transformation from the given 2D `translation`.
		from_translation(LuaVec2) -> LuaAffine2,

		///Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation)
		from_mat2(LuaMat2) -> LuaAffine2,

		///Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation) and a
		///translation vector.
		///
		///Equivalent to
		///`Affine2::from_translation(translation) * Affine2::from_mat2(mat2)`
		from_mat2_translation(LuaMat2,LuaVec2) -> LuaAffine2,

		///Creates an affine transform from the given 2D `scale`, rotation `angle` (in radians) and
		///`translation`.
		///
		///Equivalent to `Affine2::from_translation(translation) *
		///Affine2::from_angle(angle) * Affine2::from_scale(scale)`
		from_scale_angle_translation(LuaVec2,f32,LuaVec2) -> LuaAffine2,

		///Creates an affine transform from the given 2D rotation `angle` (in radians) and
		///`translation`.
		///
		///Equivalent to `Affine2::from_translation(translation) * Affine2::from_angle(angle)`
		from_angle_translation(f32,LuaVec2) -> LuaAffine2,

		///The given `Mat3` must be an affine transform,
		from_mat3(LuaMat3) -> LuaAffine2,

		///Transforms the given 2D point, applying shear, scale, rotation and translation.
		transform_point2(&self,LuaVec2) -> LuaVec2,

		///Transforms the given 2D vector, applying shear, scale and rotation (but NOT
		///translation).
		///
		///To also apply translation, use [`Self::transform_point2`] instead.
		transform_vector2(&self,LuaVec2) -> LuaVec2,

		///Returns `true` if, and only if, all elements are finite.
		///
		///If any element is either `NaN`, positive or negative infinity, this will return
		///`false`.
		is_finite(&self) -> bool,

		///Returns `true` if any elements are `NaN`.
		is_nan(&self) -> bool,

		///Returns true if the absolute difference of all elements between `self` and `rhs`
		///is less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two 3x4 matrices contain similar elements. It works
		///best when comparing with a known value. The `max_abs_diff` that should be used used
		///depends on the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(&self,LuaAffine2,f32) -> bool,

		///Return the inverse of this transform.
		///
		///Note that if the transform is not invertible the result will be invalid.
		inverse(&self) -> LuaAffine2,

	)
	+ BinOps
	(
		self Add LuaAffine2 -> LuaAffine2,
		self Sub LuaAffine2 -> LuaAffine2,
		self Mul LuaAffine2 -> LuaAffine2,
		f32 Mul self -> LuaAffine2,
		self Mul f32 -> LuaAffine2,
		self Mul LuaMat3 -> LuaMat3,
		self Mul LuaMat3A -> LuaMat3A,
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///A 3D affine transform, which can represent translation, rotation, scaling and shear.
	glam::f32::sse2::mat3::Affine3A : Value
	: Fields
	(
		matrix3: LuaMat3A,
		translation: LuaVec3A,
	)
	+ AutoMethods
	(
		///Creates an affine transform from three column vectors.
		from_cols(LuaVec3A,LuaVec3A,LuaVec3A,LuaVec3A) -> LuaAffine3A,

		///Creates an affine transform that changes scale.
		///Note that if any scale is zero the transform will be non-invertible.
		from_scale(LuaVec3) -> LuaAffine3A,

		///Creates an affine transform from the given `rotation` quaternion.
		from_quat(LuaQuat) -> LuaAffine3A,

		///Creates an affine transform containing a 3D rotation around a normalized
		///rotation `axis` of `angle` (in radians).
		from_axis_angle(LuaVec3,f32) -> LuaAffine3A,

		///Creates an affine transform containing a 3D rotation around the x axis of
		///`angle` (in radians).
		from_rotation_x(f32) -> LuaAffine3A,

		///Creates an affine transform containing a 3D rotation around the y axis of
		///`angle` (in radians).
		from_rotation_y(f32) -> LuaAffine3A,

		///Creates an affine transform containing a 3D rotation around the z axis of
		///`angle` (in radians).
		from_rotation_z(f32) -> LuaAffine3A,

		///Creates an affine transformation from the given 3D `translation`.
		from_translation(LuaVec3) -> LuaAffine3A,

		///Creates an affine transform from a 3x3 matrix (expressing scale, shear and
		///rotation)
		from_mat3(LuaMat3) -> LuaAffine3A,

		///Creates an affine transform from a 3x3 matrix (expressing scale, shear and rotation)
		///and a translation vector.
		///
		///Equivalent to `Affine3A::from_translation(translation) * Affine3A::from_mat3(mat3)`
		from_mat3_translation(LuaMat3,LuaVec3) -> LuaAffine3A,

		///Creates an affine transform from the given 3D `scale`, `rotation` and
		///`translation`.
		///
		///Equivalent to `Affine3A::from_translation(translation) *
		///Affine3A::from_quat(rotation) * Affine3A::from_scale(scale)`
		from_scale_rotation_translation(LuaVec3,LuaQuat,LuaVec3) -> LuaAffine3A,

		///Creates an affine transform from the given 3D `rotation` and `translation`.
		///
		///Equivalent to `Affine3A::from_translation(translation) * Affine3A::from_quat(rotation)`
		from_rotation_translation(LuaQuat,LuaVec3) -> LuaAffine3A,

		///The given `Mat4` must be an affine transform,
		///i.e. contain no perspective transform.
		from_mat4(LuaMat4) -> LuaAffine3A,

		///Creates a left-handed view transform using a camera position, an up direction, and
		///a focal point.
		///
		///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
		///
		///# Panics
		///
		///Will panic if `up` is not normalized when `glam_assert` is enabled.
		look_at_lh(LuaVec3,LuaVec3,LuaVec3) -> LuaAffine3A,

		///Creates a right-handed view transform using a camera position, an up direction, and
		///a focal point.
		///
		///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
		///
		///# Panics
		///
		///Will panic if `up` is not normalized when `glam_assert` is enabled.
		look_at_rh(LuaVec3,LuaVec3,LuaVec3) -> LuaAffine3A,

		///Transforms the given 3D points, applying shear, scale, rotation and translation.
		transform_point3(&self,LuaVec3) -> LuaVec3,

		///Transforms the given 3D vector, applying shear, scale and rotation (but NOT
		///translation).
		///
		///To also apply translation, use [`Self::transform_point3`] instead.
		transform_vector3(&self,LuaVec3) -> LuaVec3,

		///Transforms the given `Vec3A`, applying shear, scale, rotation and translation.
		transform_point3a(&self,LuaVec3A) -> LuaVec3A,

		///Transforms the given `Vec3A`, applying shear, scale and rotation (but NOT
		///translation).
		///
		///To also apply translation, use [`Self::transform_point3`] instead.
		transform_vector3a(&self,LuaVec3A) -> LuaVec3A,

		///Returns `true` if, and only if, all elements are finite.
		///
		///If any element is either `NaN`, positive or negative infinity, this will return
		///`false`.
		is_finite(&self) -> bool,

		///Returns `true` if any elements are `NaN`.
		is_nan(&self) -> bool,

		///Returns true if the absolute difference of all elements between `self` and `rhs`
		///is less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two 3x4 matrices contain similar elements. It works
		///best when comparing with a known value. The `max_abs_diff` that should be used used
		///depends on the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(&self,LuaAffine3A,f32) -> bool,

		///Return the inverse of this transform.
		///
		///Note that if the transform is not invertible the result will be invalid.
		inverse(&self) -> LuaAffine3A,

	)
	+ BinOps
	(
		self Add LuaAffine3A -> LuaAffine3A,
		self Sub LuaAffine3A -> LuaAffine3A,
		self Mul LuaAffine3A -> LuaAffine3A,
		f32 Mul self -> LuaAffine3A,
		self Mul f32 -> LuaAffine3A,
		self Mul LuaMat4 -> LuaMat4,
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///A 2D affine transform, which can represent translation, rotation, scaling and shear.
	glam::f64::sse2::mat2::DAffine2 : Value
	: Fields
	(
		matrix2: LuaDMat2,
		translation: LuaDVec2,
	)
	+ AutoMethods
	(
		///Creates an affine transform from three column vectors.
		from_cols(LuaDVec2,LuaDVec2,LuaDVec2) -> LuaDAffine2,

		///Creates an affine transform that changes scale.
		///Note that if any scale is zero the transform will be non-invertible.
		from_scale(LuaDVec2) -> LuaDAffine2,

		///Creates an affine transform from the given rotation `angle`.
		from_angle(f64) -> LuaDAffine2,

		///Creates an affine transformation from the given 2D `translation`.
		from_translation(LuaDVec2) -> LuaDAffine2,

		///Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation)
		from_mat2(LuaDMat2) -> LuaDAffine2,

		///Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation) and a
		///translation vector.
		///
		///Equivalent to
		///`DAffine2::from_translation(translation) * DAffine2::from_mat2(mat2)`
		from_mat2_translation(LuaDMat2,LuaDVec2) -> LuaDAffine2,

		///Creates an affine transform from the given 2D `scale`, rotation `angle` (in radians) and
		///`translation`.
		///
		///Equivalent to `DAffine2::from_translation(translation) *
		///DAffine2::from_angle(angle) * DAffine2::from_scale(scale)`
		from_scale_angle_translation(LuaDVec2,f64,LuaDVec2) -> LuaDAffine2,

		///Creates an affine transform from the given 2D rotation `angle` (in radians) and
		///`translation`.
		///
		///Equivalent to `DAffine2::from_translation(translation) * DAffine2::from_angle(angle)`
		from_angle_translation(f64,LuaDVec2) -> LuaDAffine2,

		///The given `DMat3` must be an affine transform,
		from_mat3(LuaDMat3) -> LuaDAffine2,

		///Transforms the given 2D point, applying shear, scale, rotation and translation.
		transform_point2(&self,LuaDVec2) -> LuaDVec2,

		///Transforms the given 2D vector, applying shear, scale and rotation (but NOT
		///translation).
		///
		///To also apply translation, use [`Self::transform_point2`] instead.
		transform_vector2(&self,LuaDVec2) -> LuaDVec2,

		///Returns `true` if, and only if, all elements are finite.
		///
		///If any element is either `NaN`, positive or negative infinity, this will return
		///`false`.
		is_finite(&self) -> bool,

		///Returns `true` if any elements are `NaN`.
		is_nan(&self) -> bool,

		///Returns true if the absolute difference of all elements between `self` and `rhs`
		///is less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two 3x4 matrices contain similar elements. It works
		///best when comparing with a known value. The `max_abs_diff` that should be used used
		///depends on the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(&self,LuaDAffine2,f64) -> bool,

		///Return the inverse of this transform.
		///
		///Note that if the transform is not invertible the result will be invalid.
		inverse(&self) -> LuaDAffine2,

	)
	+ BinOps
	(
		self Add LuaDAffine2 -> LuaDAffine2,
		self Sub LuaDAffine2 -> LuaDAffine2,
		self Mul LuaDAffine2 -> LuaDAffine2,
		f64 Mul self -> LuaDAffine2,
		self Mul f64 -> LuaDAffine2,
		self Mul LuaDMat3 -> LuaDMat3,
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///A 3D affine transform, which can represent translation, rotation, scaling and shear.
	glam::f64::sse2::mat3::DAffine3 : Value
	: Fields
	(
		matrix3: LuaDMat3,
		translation: LuaDVec3,
	)
	+ AutoMethods
	(
		///Creates an affine transform from three column vectors.
		from_cols(LuaDVec3,LuaDVec3,LuaDVec3,LuaDVec3) -> LuaDAffine3,

		///Creates an affine transform that changes scale.
		///Note that if any scale is zero the transform will be non-invertible.
		from_scale(LuaDVec3) -> LuaDAffine3,

		///Creates an affine transform from the given `rotation` quaternion.
		from_quat(LuaDQuat) -> LuaDAffine3,

		///Creates an affine transform containing a 3D rotation around a normalized
		///rotation `axis` of `angle` (in radians).
		from_axis_angle(LuaDVec3,f64) -> LuaDAffine3,

		///Creates an affine transform containing a 3D rotation around the x axis of
		///`angle` (in radians).
		from_rotation_x(f64) -> LuaDAffine3,

		///Creates an affine transform containing a 3D rotation around the y axis of
		///`angle` (in radians).
		from_rotation_y(f64) -> LuaDAffine3,

		///Creates an affine transform containing a 3D rotation around the z axis of
		///`angle` (in radians).
		from_rotation_z(f64) -> LuaDAffine3,

		///Creates an affine transformation from the given 3D `translation`.
		from_translation(LuaDVec3) -> LuaDAffine3,

		///Creates an affine transform from a 3x3 matrix (expressing scale, shear and
		///rotation)
		from_mat3(LuaDMat3) -> LuaDAffine3,

		///Creates an affine transform from a 3x3 matrix (expressing scale, shear and rotation)
		///and a translation vector.
		///
		///Equivalent to `DAffine3::from_translation(translation) * DAffine3::from_mat3(mat3)`
		from_mat3_translation(LuaDMat3,LuaDVec3) -> LuaDAffine3,

		///Creates an affine transform from the given 3D `scale`, `rotation` and
		///`translation`.
		///
		///Equivalent to `DAffine3::from_translation(translation) *
		///DAffine3::from_quat(rotation) * DAffine3::from_scale(scale)`
		from_scale_rotation_translation(LuaDVec3,LuaDQuat,LuaDVec3) -> LuaDAffine3,

		///Creates an affine transform from the given 3D `rotation` and `translation`.
		///
		///Equivalent to `DAffine3::from_translation(translation) * DAffine3::from_quat(rotation)`
		from_rotation_translation(LuaDQuat,LuaDVec3) -> LuaDAffine3,

		///The given `DMat4` must be an affine transform,
		///i.e. contain no perspective transform.
		from_mat4(LuaDMat4) -> LuaDAffine3,

		///Creates a left-handed view transform using a camera position, an up direction, and
		///a focal point.
		///
		///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
		///
		///# Panics
		///
		///Will panic if `up` is not normalized when `glam_assert` is enabled.
		look_at_lh(LuaDVec3,LuaDVec3,LuaDVec3) -> LuaDAffine3,

		///Creates a right-handed view transform using a camera position, an up direction, and
		///a focal point.
		///
		///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
		///
		///# Panics
		///
		///Will panic if `up` is not normalized when `glam_assert` is enabled.
		look_at_rh(LuaDVec3,LuaDVec3,LuaDVec3) -> LuaDAffine3,

		///Transforms the given 3D points, applying shear, scale, rotation and translation.
		transform_point3(&self,LuaDVec3) -> LuaDVec3,

		///Transforms the given 3D vector, applying shear, scale and rotation (but NOT
		///translation).
		///
		///To also apply translation, use [`Self::transform_point3`] instead.
		transform_vector3(&self,LuaDVec3) -> LuaDVec3,

		///Returns `true` if, and only if, all elements are finite.
		///
		///If any element is either `NaN`, positive or negative infinity, this will return
		///`false`.
		is_finite(&self) -> bool,

		///Returns `true` if any elements are `NaN`.
		is_nan(&self) -> bool,

		///Returns true if the absolute difference of all elements between `self` and `rhs`
		///is less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two 3x4 matrices contain similar elements. It works
		///best when comparing with a known value. The `max_abs_diff` that should be used used
		///depends on the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(&self,LuaDAffine3,f64) -> bool,

		///Return the inverse of this transform.
		///
		///Note that if the transform is not invertible the result will be invalid.
		inverse(&self) -> LuaDAffine3,

	)
	+ BinOps
	(
		self Add LuaDAffine3 -> LuaDAffine3,
		self Sub LuaDAffine3 -> LuaDAffine3,
		self Mul LuaDAffine3 -> LuaDAffine3,
		f64 Mul self -> LuaDAffine3,
		self Mul f64 -> LuaDAffine3,
		self Mul LuaDMat4 -> LuaDMat4,
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///A quaternion representing an orientation.
	///
	///This quaternion is intended to be of unit length but may denormalize due to
	///floating point "error creep" which can occur when successive quaternion
	///operations are applied.
	///
	///This type is 16 byte aligned.
	glam::f32::sse2::quat::Quat : Value
	: Fields
	(
	)
	+ AutoMethods
	(
		///Creates a new rotation quaternion.
		///
		///This should generally not be called manually unless you know what you are doing.
		///Use one of the other constructors instead such as `identity` or `from_axis_angle`.
		///
		///`from_xyzw` is mostly used by unit tests and `serde` deserialization.
		///
		///# Preconditions
		///
		///This function does not check if the input is normalized, it is up to the user to
		///provide normalized input or to normalized the resulting quaternion.
		from_xyzw(f32,f32,f32,f32) -> LuaQuat,

		///Creates a new rotation quaternion from a 4D vector.
		///
		///# Preconditions
		///
		///This function does not check if the input is normalized, it is up to the user to
		///provide normalized input or to normalized the resulting quaternion.
		from_vec4(LuaVec4) -> LuaQuat,

		///Create a quaternion for a normalized rotation `axis` and `angle` (in radians).
		///The axis must be normalized (unit-length).
		///
		///# Panics
		///
		///Will panic if `axis` is not normalized when `glam_assert` is enabled.
		from_axis_angle(LuaVec3,f32) -> LuaQuat,

		///Create a quaternion that rotates `v.length()` radians around `v.normalize()`.
		///
		///`from_scaled_axis(Vec3::ZERO)` results in the identity quaternion.
		from_scaled_axis(LuaVec3) -> LuaQuat,

		///Creates a quaternion from the `angle` (in radians) around the x axis.
		from_rotation_x(f32) -> LuaQuat,

		///Creates a quaternion from the `angle` (in radians) around the y axis.
		from_rotation_y(f32) -> LuaQuat,

		///Creates a quaternion from the `angle` (in radians) around the z axis.
		from_rotation_z(f32) -> LuaQuat,

		///Creates a quaternion from the given Euler rotation sequence and the angles (in radians).
		from_euler(LuaEulerRot,f32,f32,f32) -> LuaQuat,

		///Creates a quaternion from a 3x3 rotation matrix.
		from_mat3(&LuaMat3) -> LuaQuat,

		///Creates a quaternion from a 3x3 rotation matrix inside a homogeneous 4x4 matrix.
		from_mat4(&LuaMat4) -> LuaQuat,

		///Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the
		///plane spanned by the two vectors.  Will rotate at most 180 degrees.
		///
		///The input vectors must be normalized (unit-length).
		///
		///`from_rotation_arc(from, to) * from ≈ to`.
		///
		///For near-singular cases (from≈to and from≈-to) the current implementation
		///is only accurate to about 0.001 (for `f32`).
		///
		///# Panics
		///
		///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
		from_rotation_arc(LuaVec3,LuaVec3) -> LuaQuat,

		///Gets the minimal rotation for transforming `from` to either `to` or `-to`.  This means
		///that the resulting quaternion will rotate `from` so that it is colinear with `to`.
		///
		///The rotation is in the plane spanned by the two vectors.  Will rotate at most 90
		///degrees.
		///
		///The input vectors must be normalized (unit-length).
		///
		///`to.dot(from_rotation_arc_colinear(from, to) * from).abs() ≈ 1`.
		///
		///# Panics
		///
		///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
		from_rotation_arc_colinear(LuaVec3,LuaVec3) -> LuaQuat,

		///Gets the minimal rotation for transforming `from` to `to`.  The resulting rotation is
		///around the z axis. Will rotate at most 180 degrees.
		///
		///The input vectors must be normalized (unit-length).
		///
		///`from_rotation_arc_2d(from, to) * from ≈ to`.
		///
		///For near-singular cases (from≈to and from≈-to) the current implementation
		///is only accurate to about 0.001 (for `f32`).
		///
		///# Panics
		///
		///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
		from_rotation_arc_2d(LuaVec2,LuaVec2) -> LuaQuat,

		///Returns the rotation axis scaled by the rotation in radians.
		to_scaled_axis(self) -> LuaVec3,

		///Returns the vector part of the quaternion.
		xyz(self) -> LuaVec3,

		///Returns the quaternion conjugate of `self`. For a unit quaternion the
		///conjugate is also the inverse.
		conjugate(self) -> LuaQuat,

		///Returns the inverse of a normalized quaternion.
		///
		///Typically quaternion inverse returns the conjugate of a normalized quaternion.
		///Because `self` is assumed to already be unit length this method *does not* normalize
		///before returning the conjugate.
		///
		///# Panics
		///
		///Will panic if `self` is not normalized when `glam_assert` is enabled.
		inverse(self) -> LuaQuat,

		///Computes the dot product of `self` and `rhs`. The dot product is
		///equal to the cosine of the angle between two quaternion rotations.
		dot(self,LuaQuat) -> f32,

		///Computes the length of `self`.
		length(self) -> f32,

		///Computes the squared length of `self`.
		///
		///This is generally faster than `length()` as it avoids a square
		///root operation.
		length_squared(self) -> f32,

		///Computes `1.0 / length()`.
		///
		///For valid results, `self` must _not_ be of length zero.
		length_recip(self) -> f32,

		///Returns `self` normalized to length 1.0.
		///
		///For valid results, `self` must _not_ be of length zero.
		///
		///Panics
		///
		///Will panic if `self` is zero length when `glam_assert` is enabled.
		normalize(self) -> LuaQuat,

		///Returns `true` if, and only if, all elements are finite.
		///If any element is either `NaN`, positive or negative infinity, this will return `false`.
		is_finite(self) -> bool,

		is_nan(self) -> bool,

		///Returns whether `self` of length `1.0` or not.
		///
		///Uses a precision threshold of `1e-6`.
		is_normalized(self) -> bool,

		is_near_identity(self) -> bool,

		///Returns the angle (in radians) for the minimal rotation
		///for transforming this quaternion into another.
		///
		///Both quaternions must be normalized.
		///
		///# Panics
		///
		///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
		angle_between(self,LuaQuat) -> f32,

		///Returns true if the absolute difference of all elements between `self` and `rhs`
		///is less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two quaternions contain similar elements. It works
		///best when comparing with a known value. The `max_abs_diff` that should be used used
		///depends on the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(self,LuaQuat,f32) -> bool,

		///Performs a linear interpolation between `self` and `rhs` based on
		///the value `s`.
		///
		///When `s` is `0.0`, the result will be equal to `self`.  When `s`
		///is `1.0`, the result will be equal to `rhs`.
		///
		///# Panics
		///
		///Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
		lerp(self,LuaQuat,f32) -> LuaQuat,

		///Performs a spherical linear interpolation between `self` and `end`
		///based on the value `s`.
		///
		///When `s` is `0.0`, the result will be equal to `self`.  When `s`
		///is `1.0`, the result will be equal to `end`.
		///
		///# Panics
		///
		///Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
		slerp(self,LuaQuat,f32) -> LuaQuat,

		///Multiplies a quaternion and a 3D vector, returning the rotated vector.
		///
		///# Panics
		///
		///Will panic if `self` is not normalized when `glam_assert` is enabled.
		mul_vec3(self,LuaVec3) -> LuaVec3,

		///Multiplies two quaternions. If they each represent a rotation, the result will
		///represent the combined rotation.
		///
		///Note that due to floating point rounding the result may not be perfectly normalized.
		///
		///# Panics
		///
		///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
		mul_quat(self,LuaQuat) -> LuaQuat,

		///Multiplies a quaternion and a 3D vector, returning the rotated vector.
		mul_vec3a(self,LuaVec3A) -> LuaVec3A,

		as_f64(self) -> LuaDQuat,

	)
	+ BinOps
	(
		self Add LuaQuat -> LuaQuat,
		self Sub LuaQuat -> LuaQuat,
		self Div f32 -> LuaQuat,
		self Mul f32 -> LuaQuat,
		self Mul LuaQuat -> LuaQuat,
		self Mul LuaVec3 -> LuaVec3,
		self Mul LuaVec3A -> LuaVec3A,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///A quaternion representing an orientation.
	///
	///This quaternion is intended to be of unit length but may denormalize due to
	///floating point "error creep" which can occur when successive quaternion
	///operations are applied.
	glam::f64::dquat::DQuat : Value
	: Fields
	(
		x: f64,
		y: f64,
		z: f64,
		w: f64,
	)
	+ AutoMethods
	(
		///Creates a new rotation quaternion.
		///
		///This should generally not be called manually unless you know what you are doing.
		///Use one of the other constructors instead such as `identity` or `from_axis_angle`.
		///
		///`from_xyzw` is mostly used by unit tests and `serde` deserialization.
		///
		///# Preconditions
		///
		///This function does not check if the input is normalized, it is up to the user to
		///provide normalized input or to normalized the resulting quaternion.
		from_xyzw(f64,f64,f64,f64) -> LuaDQuat,

		///Creates a new rotation quaternion from a 4D vector.
		///
		///# Preconditions
		///
		///This function does not check if the input is normalized, it is up to the user to
		///provide normalized input or to normalized the resulting quaternion.
		from_vec4(LuaDVec4) -> LuaDQuat,

		///Create a quaternion for a normalized rotation `axis` and `angle` (in radians).
		///The axis must be normalized (unit-length).
		///
		///# Panics
		///
		///Will panic if `axis` is not normalized when `glam_assert` is enabled.
		from_axis_angle(LuaDVec3,f64) -> LuaDQuat,

		///Create a quaternion that rotates `v.length()` radians around `v.normalize()`.
		///
		///`from_scaled_axis(Vec3::ZERO)` results in the identity quaternion.
		from_scaled_axis(LuaDVec3) -> LuaDQuat,

		///Creates a quaternion from the `angle` (in radians) around the x axis.
		from_rotation_x(f64) -> LuaDQuat,

		///Creates a quaternion from the `angle` (in radians) around the y axis.
		from_rotation_y(f64) -> LuaDQuat,

		///Creates a quaternion from the `angle` (in radians) around the z axis.
		from_rotation_z(f64) -> LuaDQuat,

		///Creates a quaternion from the given Euler rotation sequence and the angles (in radians).
		from_euler(LuaEulerRot,f64,f64,f64) -> LuaDQuat,

		///Creates a quaternion from a 3x3 rotation matrix.
		from_mat3(&LuaDMat3) -> LuaDQuat,

		///Creates a quaternion from a 3x3 rotation matrix inside a homogeneous 4x4 matrix.
		from_mat4(&LuaDMat4) -> LuaDQuat,

		///Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the
		///plane spanned by the two vectors.  Will rotate at most 180 degrees.
		///
		///The input vectors must be normalized (unit-length).
		///
		///`from_rotation_arc(from, to) * from ≈ to`.
		///
		///For near-singular cases (from≈to and from≈-to) the current implementation
		///is only accurate to about 0.001 (for `f32`).
		///
		///# Panics
		///
		///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
		from_rotation_arc(LuaDVec3,LuaDVec3) -> LuaDQuat,

		///Gets the minimal rotation for transforming `from` to either `to` or `-to`.  This means
		///that the resulting quaternion will rotate `from` so that it is colinear with `to`.
		///
		///The rotation is in the plane spanned by the two vectors.  Will rotate at most 90
		///degrees.
		///
		///The input vectors must be normalized (unit-length).
		///
		///`to.dot(from_rotation_arc_colinear(from, to) * from).abs() ≈ 1`.
		///
		///# Panics
		///
		///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
		from_rotation_arc_colinear(LuaDVec3,LuaDVec3) -> LuaDQuat,

		///Gets the minimal rotation for transforming `from` to `to`.  The resulting rotation is
		///around the z axis. Will rotate at most 180 degrees.
		///
		///The input vectors must be normalized (unit-length).
		///
		///`from_rotation_arc_2d(from, to) * from ≈ to`.
		///
		///For near-singular cases (from≈to and from≈-to) the current implementation
		///is only accurate to about 0.001 (for `f32`).
		///
		///# Panics
		///
		///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
		from_rotation_arc_2d(LuaDVec2,LuaDVec2) -> LuaDQuat,

		///Returns the rotation axis scaled by the rotation in radians.
		to_scaled_axis(self) -> LuaDVec3,

		///Returns the vector part of the quaternion.
		xyz(self) -> LuaDVec3,

		///Returns the quaternion conjugate of `self`. For a unit quaternion the
		///conjugate is also the inverse.
		conjugate(self) -> LuaDQuat,

		///Returns the inverse of a normalized quaternion.
		///
		///Typically quaternion inverse returns the conjugate of a normalized quaternion.
		///Because `self` is assumed to already be unit length this method *does not* normalize
		///before returning the conjugate.
		///
		///# Panics
		///
		///Will panic if `self` is not normalized when `glam_assert` is enabled.
		inverse(self) -> LuaDQuat,

		///Computes the dot product of `self` and `rhs`. The dot product is
		///equal to the cosine of the angle between two quaternion rotations.
		dot(self,LuaDQuat) -> f64,

		///Computes the length of `self`.
		length(self) -> f64,

		///Computes the squared length of `self`.
		///
		///This is generally faster than `length()` as it avoids a square
		///root operation.
		length_squared(self) -> f64,

		///Computes `1.0 / length()`.
		///
		///For valid results, `self` must _not_ be of length zero.
		length_recip(self) -> f64,

		///Returns `self` normalized to length 1.0.
		///
		///For valid results, `self` must _not_ be of length zero.
		///
		///Panics
		///
		///Will panic if `self` is zero length when `glam_assert` is enabled.
		normalize(self) -> LuaDQuat,

		///Returns `true` if, and only if, all elements are finite.
		///If any element is either `NaN`, positive or negative infinity, this will return `false`.
		is_finite(self) -> bool,

		is_nan(self) -> bool,

		///Returns whether `self` of length `1.0` or not.
		///
		///Uses a precision threshold of `1e-6`.
		is_normalized(self) -> bool,

		is_near_identity(self) -> bool,

		///Returns the angle (in radians) for the minimal rotation
		///for transforming this quaternion into another.
		///
		///Both quaternions must be normalized.
		///
		///# Panics
		///
		///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
		angle_between(self,LuaDQuat) -> f64,

		///Returns true if the absolute difference of all elements between `self` and `rhs`
		///is less than or equal to `max_abs_diff`.
		///
		///This can be used to compare if two quaternions contain similar elements. It works
		///best when comparing with a known value. The `max_abs_diff` that should be used used
		///depends on the values being compared against.
		///
		///For more see
		///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
		abs_diff_eq(self,LuaDQuat,f64) -> bool,

		///Performs a linear interpolation between `self` and `rhs` based on
		///the value `s`.
		///
		///When `s` is `0.0`, the result will be equal to `self`.  When `s`
		///is `1.0`, the result will be equal to `rhs`.
		///
		///# Panics
		///
		///Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
		lerp(self,LuaDQuat,f64) -> LuaDQuat,

		///Performs a spherical linear interpolation between `self` and `end`
		///based on the value `s`.
		///
		///When `s` is `0.0`, the result will be equal to `self`.  When `s`
		///is `1.0`, the result will be equal to `end`.
		///
		///# Panics
		///
		///Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
		slerp(self,LuaDQuat,f64) -> LuaDQuat,

		///Multiplies a quaternion and a 3D vector, returning the rotated vector.
		///
		///# Panics
		///
		///Will panic if `self` is not normalized when `glam_assert` is enabled.
		mul_vec3(self,LuaDVec3) -> LuaDVec3,

		///Multiplies two quaternions. If they each represent a rotation, the result will
		///represent the combined rotation.
		///
		///Note that due to floating point rounding the result may not be perfectly normalized.
		///
		///# Panics
		///
		///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
		mul_quat(self,LuaDQuat) -> LuaDQuat,

		as_f32(self) -> LuaQuat,

	)
	+ BinOps
	(
		self Add LuaDQuat -> LuaDQuat,
		self Sub LuaDQuat -> LuaDQuat,
		self Div f64 -> LuaDQuat,
		self Mul f64 -> LuaDQuat,
		self Mul LuaDQuat -> LuaDQuat,
		self Mul LuaDVec3 -> LuaDVec3,
	)
	+ UnaryOps
	(
		Neg self
	)
	impl
	{
	}
}
impl_lua_newtype!{
	///Euler rotation sequences.
	///
	///The angles are applied starting from the right.
	///E.g. XYZ will first apply the z-axis rotation.
	///
	///YXZ can be used for yaw (y-axis), pitch (x-axis), roll (z-axis).
	///
	///The two-axis rotations (e.g. ZYZ) are not fully tested and have to be treated with caution.
	glam::euler::EulerRot : Value
	: Fields
	(
	)
	+ AutoMethods
	(
	)
	+ BinOps
	(
	)
	+ UnaryOps
	(
	)
	impl
	{
	}
}
pub(crate) struct BevyAPIGlobals {}
impl tealr::mlu::ExportInstances for BevyAPIGlobals{
	fn add_instances<'lua, T: tealr::mlu::InstanceCollector<'lua>>(instances: &mut T) -> LuaResult<()>
	{
		instances.add_instance("AnimationPlayer".into(), tealr::mlu::UserDataProxy::<LuaAnimationPlayer>::new)?;
		instances.add_instance("Name".into(), tealr::mlu::UserDataProxy::<LuaName>::new)?;
		instances.add_instance("Children".into(), tealr::mlu::UserDataProxy::<LuaChildren>::new)?;
		instances.add_instance("Stopwatch".into(), tealr::mlu::UserDataProxy::<LuaStopwatch>::new)?;
		instances.add_instance("Timer".into(), tealr::mlu::UserDataProxy::<LuaTimer>::new)?;
		instances.add_instance("Entity".into(), tealr::mlu::UserDataProxy::<LuaEntity>::new)?;
		instances.add_instance("Transform".into(), tealr::mlu::UserDataProxy::<LuaTransform>::new)?;
		instances.add_instance("GlobalTransform".into(), tealr::mlu::UserDataProxy::<LuaGlobalTransform>::new)?;
		instances.add_instance("CubemapVisibleEntities".into(), tealr::mlu::UserDataProxy::<LuaCubemapVisibleEntities>::new)?;
		instances.add_instance("Anchor".into(), tealr::mlu::UserDataProxy::<LuaAnchor>::new)?;
		instances.add_instance("Rect".into(), tealr::mlu::UserDataProxy::<LuaRect>::new)?;
		instances.add_instance("RenderLayers".into(), tealr::mlu::UserDataProxy::<LuaRenderLayers>::new)?;
		instances.add_instance("VisibleEntities".into(), tealr::mlu::UserDataProxy::<LuaVisibleEntities>::new)?;
		instances.add_instance("Color".into(), tealr::mlu::UserDataProxy::<LuaColor>::new)?;
		instances.add_instance("Aabb".into(), tealr::mlu::UserDataProxy::<LuaAabb>::new)?;
		instances.add_instance("CubemapFrusta".into(), tealr::mlu::UserDataProxy::<LuaCubemapFrusta>::new)?;
		instances.add_instance("Frustum".into(), tealr::mlu::UserDataProxy::<LuaFrustum>::new)?;
		instances.add_instance("Camera".into(), tealr::mlu::UserDataProxy::<LuaCamera>::new)?;
		instances.add_instance("RenderTarget".into(), tealr::mlu::UserDataProxy::<LuaRenderTarget>::new)?;
		instances.add_instance("Projection".into(), tealr::mlu::UserDataProxy::<LuaProjection>::new)?;
		instances.add_instance("OrthographicProjection".into(), tealr::mlu::UserDataProxy::<LuaOrthographicProjection>::new)?;
		instances.add_instance("PerspectiveProjection".into(), tealr::mlu::UserDataProxy::<LuaPerspectiveProjection>::new)?;
		instances.add_instance("AssetPathId".into(), tealr::mlu::UserDataProxy::<LuaAssetPathId>::new)?;
		instances.add_instance("Vec2".into(), tealr::mlu::UserDataProxy::<LuaVec2>::new)?;
		instances.add_instance("Vec3".into(), tealr::mlu::UserDataProxy::<LuaVec3>::new)?;
		instances.add_instance("Vec3A".into(), tealr::mlu::UserDataProxy::<LuaVec3A>::new)?;
		instances.add_instance("Vec4".into(), tealr::mlu::UserDataProxy::<LuaVec4>::new)?;
		instances.add_instance("BVec2".into(), tealr::mlu::UserDataProxy::<LuaBVec2>::new)?;
		instances.add_instance("BVec3".into(), tealr::mlu::UserDataProxy::<LuaBVec3>::new)?;
		instances.add_instance("BVec4".into(), tealr::mlu::UserDataProxy::<LuaBVec4>::new)?;
		instances.add_instance("BVec3A".into(), tealr::mlu::UserDataProxy::<LuaBVec3A>::new)?;
		instances.add_instance("BVec4A".into(), tealr::mlu::UserDataProxy::<LuaBVec4A>::new)?;
		instances.add_instance("DVec2".into(), tealr::mlu::UserDataProxy::<LuaDVec2>::new)?;
		instances.add_instance("DVec3".into(), tealr::mlu::UserDataProxy::<LuaDVec3>::new)?;
		instances.add_instance("DVec4".into(), tealr::mlu::UserDataProxy::<LuaDVec4>::new)?;
		instances.add_instance("IVec2".into(), tealr::mlu::UserDataProxy::<LuaIVec2>::new)?;
		instances.add_instance("IVec3".into(), tealr::mlu::UserDataProxy::<LuaIVec3>::new)?;
		instances.add_instance("IVec4".into(), tealr::mlu::UserDataProxy::<LuaIVec4>::new)?;
		instances.add_instance("UVec2".into(), tealr::mlu::UserDataProxy::<LuaUVec2>::new)?;
		instances.add_instance("UVec3".into(), tealr::mlu::UserDataProxy::<LuaUVec3>::new)?;
		instances.add_instance("UVec4".into(), tealr::mlu::UserDataProxy::<LuaUVec4>::new)?;
		instances.add_instance("Mat3".into(), tealr::mlu::UserDataProxy::<LuaMat3>::new)?;
		instances.add_instance("Mat2".into(), tealr::mlu::UserDataProxy::<LuaMat2>::new)?;
		instances.add_instance("Mat3A".into(), tealr::mlu::UserDataProxy::<LuaMat3A>::new)?;
		instances.add_instance("Mat4".into(), tealr::mlu::UserDataProxy::<LuaMat4>::new)?;
		instances.add_instance("DMat2".into(), tealr::mlu::UserDataProxy::<LuaDMat2>::new)?;
		instances.add_instance("DMat3".into(), tealr::mlu::UserDataProxy::<LuaDMat3>::new)?;
		instances.add_instance("DMat4".into(), tealr::mlu::UserDataProxy::<LuaDMat4>::new)?;
		instances.add_instance("Affine2".into(), tealr::mlu::UserDataProxy::<LuaAffine2>::new)?;
		instances.add_instance("Affine3A".into(), tealr::mlu::UserDataProxy::<LuaAffine3A>::new)?;
		instances.add_instance("DAffine2".into(), tealr::mlu::UserDataProxy::<LuaDAffine2>::new)?;
		instances.add_instance("DAffine3".into(), tealr::mlu::UserDataProxy::<LuaDAffine3>::new)?;
		instances.add_instance("Quat".into(), tealr::mlu::UserDataProxy::<LuaQuat>::new)?;
		instances.add_instance("DQuat".into(), tealr::mlu::UserDataProxy::<LuaDQuat>::new)?;
		Ok(())
	}
}
pub struct LuaBevyAPIProvider;
impl APIProvider for LuaBevyAPIProvider{
	type Target = Mutex<Lua>;
	type DocTarget = LuaDocFragment;
	fn attach_api(&mut self, ctx: &mut Self::Target) -> Result<(), crate::ScriptError>	{
		let ctx = ctx.lock().expect("Unable to acquire lock on Lua context");
		Ok(tealr::mlu::set_global_env::<BevyAPIGlobals>(&ctx)?)
	}
	fn get_doc_fragment(&self) -> Option<Self::DocTarget>	{
		Some(LuaDocFragment::new(|tw|		{
			tw
			.process_type::<LuaAlignContent>()
			.process_type::<LuaAlignItems>()
			.process_type::<LuaAlignSelf>()
			.process_type::<LuaDirection>()
			.process_type::<LuaFlexDirection>()
			.process_type::<LuaFlexWrap>()
			.process_type::<LuaFocusPolicy>()
			.process_type::<LuaInteraction>()
			.process_type::<LuaJustifyContent>()
			.process_type::<LuaOverflow>()
			.process_type::<LuaPositionType>()
			.process_type::<LuaVal>()
			.process_type::<LuaCalculatedClip>()
			.process_type::<LuaCalculatedSize>()
			.process_type::<LuaNode>()
			.process_type::<LuaStyle>()
			.process_type::<LuaUiColor>()
			.process_type::<LuaUiImage>()
			.process_type::<LuaButton>()
			.process_type::<LuaImageMode>()
			.process_type::<LuaDisplay>()
			.process_type::<LuaAnimationPlayer>()
			.process_type::<tealr::mlu::UserDataProxy<LuaAnimationPlayer>>()
			.process_type::<LuaName>()
			.process_type::<tealr::mlu::UserDataProxy<LuaName>>()
			.process_type::<LuaGltfExtras>()
			.process_type::<LuaChildren>()
			.process_type::<tealr::mlu::UserDataProxy<LuaChildren>>()
			.process_type::<LuaParent>()
			.process_type::<LuaPreviousParent>()
			.process_type::<LuaText2dBounds>()
			.process_type::<LuaText2dSize>()
			.process_type::<LuaText>()
			.process_type::<LuaTextAlignment>()
			.process_type::<LuaTextSection>()
			.process_type::<LuaTextStyle>()
			.process_type::<LuaHorizontalAlign>()
			.process_type::<LuaVerticalAlign>()
			.process_type::<LuaStopwatch>()
			.process_type::<tealr::mlu::UserDataProxy<LuaStopwatch>>()
			.process_type::<LuaTimer>()
			.process_type::<tealr::mlu::UserDataProxy<LuaTimer>>()
			.process_type::<LuaEntity>()
			.process_type::<tealr::mlu::UserDataProxy<LuaEntity>>()
			.process_type::<LuaTransform>()
			.process_type::<tealr::mlu::UserDataProxy<LuaTransform>>()
			.process_type::<LuaGlobalTransform>()
			.process_type::<tealr::mlu::UserDataProxy<LuaGlobalTransform>>()
			.process_type::<LuaAmbientLight>()
			.process_type::<LuaCubemapVisibleEntities>()
			.process_type::<tealr::mlu::UserDataProxy<LuaCubemapVisibleEntities>>()
			.process_type::<LuaDirectionalLight>()
			.process_type::<LuaDirectionalLightShadowMap>()
			.process_type::<LuaNotShadowCaster>()
			.process_type::<LuaNotShadowReceiver>()
			.process_type::<LuaPointLight>()
			.process_type::<LuaPointLightShadowMap>()
			.process_type::<LuaAlphaMode>()
			.process_type::<LuaWireframe>()
			.process_type::<LuaWireframeConfig>()
			.process_type::<LuaCamera3dDepthLoadOp>()
			.process_type::<LuaClearColor>()
			.process_type::<LuaClearColorConfig>()
			.process_type::<LuaCamera2d>()
			.process_type::<LuaCamera3d>()
			.process_type::<LuaAnchor>()
			.process_type::<tealr::mlu::UserDataProxy<LuaAnchor>>()
			.process_type::<LuaMesh2dHandle>()
			.process_type::<LuaTextureAtlasSprite>()
			.process_type::<LuaSprite>()
			.process_type::<LuaRect>()
			.process_type::<tealr::mlu::UserDataProxy<LuaRect>>()
			.process_type::<LuaRenderLayers>()
			.process_type::<tealr::mlu::UserDataProxy<LuaRenderLayers>>()
			.process_type::<LuaVisibility>()
			.process_type::<LuaVisibleEntities>()
			.process_type::<tealr::mlu::UserDataProxy<LuaVisibleEntities>>()
			.process_type::<LuaComputedVisibility>()
			.process_type::<LuaSkinnedMesh>()
			.process_type::<LuaScalingMode>()
			.process_type::<LuaWindowOrigin>()
			.process_type::<LuaColor>()
			.process_type::<tealr::mlu::UserDataProxy<LuaColor>>()
			.process_type::<LuaAabb>()
			.process_type::<tealr::mlu::UserDataProxy<LuaAabb>>()
			.process_type::<LuaCubemapFrusta>()
			.process_type::<tealr::mlu::UserDataProxy<LuaCubemapFrusta>>()
			.process_type::<LuaFrustum>()
			.process_type::<tealr::mlu::UserDataProxy<LuaFrustum>>()
			.process_type::<LuaMsaa>()
			.process_type::<LuaCamera>()
			.process_type::<tealr::mlu::UserDataProxy<LuaCamera>>()
			.process_type::<LuaRenderTarget>()
			.process_type::<tealr::mlu::UserDataProxy<LuaRenderTarget>>()
			.process_type::<LuaViewport>()
			.process_type::<LuaProjection>()
			.process_type::<tealr::mlu::UserDataProxy<LuaProjection>>()
			.process_type::<LuaOrthographicProjection>()
			.process_type::<tealr::mlu::UserDataProxy<LuaOrthographicProjection>>()
			.process_type::<LuaPerspectiveProjection>()
			.process_type::<tealr::mlu::UserDataProxy<LuaPerspectiveProjection>>()
			.process_type::<LuaDepthCalculation>()
			.process_type::<LuaCameraRenderGraph>()
			.process_type::<LuaAssetPathId>()
			.process_type::<tealr::mlu::UserDataProxy<LuaAssetPathId>>()
			.process_type::<LuaLabelId>()
			.process_type::<LuaSourcePathId>()
			.process_type::<LuaHandleId>()
			.process_type::<LuaVec2>()
			.process_type::<tealr::mlu::UserDataProxy<LuaVec2>>()
			.process_type::<LuaVec3>()
			.process_type::<tealr::mlu::UserDataProxy<LuaVec3>>()
			.process_type::<LuaVec3A>()
			.process_type::<tealr::mlu::UserDataProxy<LuaVec3A>>()
			.process_type::<LuaVec4>()
			.process_type::<tealr::mlu::UserDataProxy<LuaVec4>>()
			.process_type::<LuaBVec2>()
			.process_type::<tealr::mlu::UserDataProxy<LuaBVec2>>()
			.process_type::<LuaBVec3>()
			.process_type::<tealr::mlu::UserDataProxy<LuaBVec3>>()
			.process_type::<LuaBVec4>()
			.process_type::<tealr::mlu::UserDataProxy<LuaBVec4>>()
			.process_type::<LuaBVec3A>()
			.process_type::<tealr::mlu::UserDataProxy<LuaBVec3A>>()
			.process_type::<LuaBVec4A>()
			.process_type::<tealr::mlu::UserDataProxy<LuaBVec4A>>()
			.process_type::<LuaDVec2>()
			.process_type::<tealr::mlu::UserDataProxy<LuaDVec2>>()
			.process_type::<LuaDVec3>()
			.process_type::<tealr::mlu::UserDataProxy<LuaDVec3>>()
			.process_type::<LuaDVec4>()
			.process_type::<tealr::mlu::UserDataProxy<LuaDVec4>>()
			.process_type::<LuaIVec2>()
			.process_type::<tealr::mlu::UserDataProxy<LuaIVec2>>()
			.process_type::<LuaIVec3>()
			.process_type::<tealr::mlu::UserDataProxy<LuaIVec3>>()
			.process_type::<LuaIVec4>()
			.process_type::<tealr::mlu::UserDataProxy<LuaIVec4>>()
			.process_type::<LuaUVec2>()
			.process_type::<tealr::mlu::UserDataProxy<LuaUVec2>>()
			.process_type::<LuaUVec3>()
			.process_type::<tealr::mlu::UserDataProxy<LuaUVec3>>()
			.process_type::<LuaUVec4>()
			.process_type::<tealr::mlu::UserDataProxy<LuaUVec4>>()
			.process_type::<LuaMat3>()
			.process_type::<tealr::mlu::UserDataProxy<LuaMat3>>()
			.process_type::<LuaMat2>()
			.process_type::<tealr::mlu::UserDataProxy<LuaMat2>>()
			.process_type::<LuaMat3A>()
			.process_type::<tealr::mlu::UserDataProxy<LuaMat3A>>()
			.process_type::<LuaMat4>()
			.process_type::<tealr::mlu::UserDataProxy<LuaMat4>>()
			.process_type::<LuaDMat2>()
			.process_type::<tealr::mlu::UserDataProxy<LuaDMat2>>()
			.process_type::<LuaDMat3>()
			.process_type::<tealr::mlu::UserDataProxy<LuaDMat3>>()
			.process_type::<LuaDMat4>()
			.process_type::<tealr::mlu::UserDataProxy<LuaDMat4>>()
			.process_type::<LuaAffine2>()
			.process_type::<tealr::mlu::UserDataProxy<LuaAffine2>>()
			.process_type::<LuaAffine3A>()
			.process_type::<tealr::mlu::UserDataProxy<LuaAffine3A>>()
			.process_type::<LuaDAffine2>()
			.process_type::<tealr::mlu::UserDataProxy<LuaDAffine2>>()
			.process_type::<LuaDAffine3>()
			.process_type::<tealr::mlu::UserDataProxy<LuaDAffine3>>()
			.process_type::<LuaQuat>()
			.process_type::<tealr::mlu::UserDataProxy<LuaQuat>>()
			.process_type::<LuaDQuat>()
			.process_type::<tealr::mlu::UserDataProxy<LuaDQuat>>()
			.process_type::<LuaEulerRot>()
		}
		))
	}
	fn register_with_app(&self, app: &mut App)	{
		app.register_foreign_lua_type::<AlignContent>();
		app.register_foreign_lua_type::<AlignItems>();
		app.register_foreign_lua_type::<AlignSelf>();
		app.register_foreign_lua_type::<Direction>();
		app.register_foreign_lua_type::<FlexDirection>();
		app.register_foreign_lua_type::<FlexWrap>();
		app.register_foreign_lua_type::<FocusPolicy>();
		app.register_foreign_lua_type::<Interaction>();
		app.register_foreign_lua_type::<JustifyContent>();
		app.register_foreign_lua_type::<Overflow>();
		app.register_foreign_lua_type::<PositionType>();
		app.register_foreign_lua_type::<Val>();
		app.register_foreign_lua_type::<CalculatedClip>();
		app.register_foreign_lua_type::<CalculatedSize>();
		app.register_foreign_lua_type::<Node>();
		app.register_foreign_lua_type::<Style>();
		app.register_foreign_lua_type::<UiColor>();
		app.register_foreign_lua_type::<UiImage>();
		app.register_foreign_lua_type::<Button>();
		app.register_foreign_lua_type::<ImageMode>();
		app.register_foreign_lua_type::<Display>();
		app.register_foreign_lua_type::<AnimationPlayer>();
		app.register_foreign_lua_type::<Name>();
		app.register_foreign_lua_type::<GltfExtras>();
		app.register_foreign_lua_type::<Children>();
		app.register_foreign_lua_type::<Parent>();
		app.register_foreign_lua_type::<PreviousParent>();
		app.register_foreign_lua_type::<Text2dBounds>();
		app.register_foreign_lua_type::<Text2dSize>();
		app.register_foreign_lua_type::<Text>();
		app.register_foreign_lua_type::<TextAlignment>();
		app.register_foreign_lua_type::<TextSection>();
		app.register_foreign_lua_type::<TextStyle>();
		app.register_foreign_lua_type::<HorizontalAlign>();
		app.register_foreign_lua_type::<VerticalAlign>();
		app.register_foreign_lua_type::<Stopwatch>();
		app.register_foreign_lua_type::<Timer>();
		app.register_foreign_lua_type::<Entity>();
		app.register_foreign_lua_type::<Transform>();
		app.register_foreign_lua_type::<GlobalTransform>();
		app.register_foreign_lua_type::<AmbientLight>();
		app.register_foreign_lua_type::<CubemapVisibleEntities>();
		app.register_foreign_lua_type::<DirectionalLight>();
		app.register_foreign_lua_type::<DirectionalLightShadowMap>();
		app.register_foreign_lua_type::<NotShadowCaster>();
		app.register_foreign_lua_type::<NotShadowReceiver>();
		app.register_foreign_lua_type::<PointLight>();
		app.register_foreign_lua_type::<PointLightShadowMap>();
		app.register_foreign_lua_type::<AlphaMode>();
		app.register_foreign_lua_type::<Wireframe>();
		app.register_foreign_lua_type::<WireframeConfig>();
		app.register_foreign_lua_type::<Camera3dDepthLoadOp>();
		app.register_foreign_lua_type::<ClearColor>();
		app.register_foreign_lua_type::<ClearColorConfig>();
		app.register_foreign_lua_type::<Camera2d>();
		app.register_foreign_lua_type::<Camera3d>();
		app.register_foreign_lua_type::<Anchor>();
		app.register_foreign_lua_type::<Mesh2dHandle>();
		app.register_foreign_lua_type::<TextureAtlasSprite>();
		app.register_foreign_lua_type::<Sprite>();
		app.register_foreign_lua_type::<Rect>();
		app.register_foreign_lua_type::<RenderLayers>();
		app.register_foreign_lua_type::<Visibility>();
		app.register_foreign_lua_type::<VisibleEntities>();
		app.register_foreign_lua_type::<ComputedVisibility>();
		app.register_foreign_lua_type::<SkinnedMesh>();
		app.register_foreign_lua_type::<ScalingMode>();
		app.register_foreign_lua_type::<WindowOrigin>();
		app.register_foreign_lua_type::<Color>();
		app.register_foreign_lua_type::<Aabb>();
		app.register_foreign_lua_type::<CubemapFrusta>();
		app.register_foreign_lua_type::<Frustum>();
		app.register_foreign_lua_type::<Msaa>();
		app.register_foreign_lua_type::<Camera>();
		app.register_foreign_lua_type::<RenderTarget>();
		app.register_foreign_lua_type::<Viewport>();
		app.register_foreign_lua_type::<Projection>();
		app.register_foreign_lua_type::<OrthographicProjection>();
		app.register_foreign_lua_type::<PerspectiveProjection>();
		app.register_foreign_lua_type::<DepthCalculation>();
		app.register_foreign_lua_type::<CameraRenderGraph>();
		app.register_foreign_lua_type::<AssetPathId>();
		app.register_foreign_lua_type::<LabelId>();
		app.register_foreign_lua_type::<SourcePathId>();
		app.register_foreign_lua_type::<HandleId>();
		app.register_foreign_lua_type::<Vec2>();
		app.register_foreign_lua_type::<Vec3>();
		app.register_foreign_lua_type::<Vec3A>();
		app.register_foreign_lua_type::<Vec4>();
		app.register_foreign_lua_type::<BVec2>();
		app.register_foreign_lua_type::<BVec3>();
		app.register_foreign_lua_type::<BVec4>();
		app.register_foreign_lua_type::<BVec3A>();
		app.register_foreign_lua_type::<BVec4A>();
		app.register_foreign_lua_type::<DVec2>();
		app.register_foreign_lua_type::<DVec3>();
		app.register_foreign_lua_type::<DVec4>();
		app.register_foreign_lua_type::<IVec2>();
		app.register_foreign_lua_type::<IVec3>();
		app.register_foreign_lua_type::<IVec4>();
		app.register_foreign_lua_type::<UVec2>();
		app.register_foreign_lua_type::<UVec3>();
		app.register_foreign_lua_type::<UVec4>();
		app.register_foreign_lua_type::<Mat3>();
		app.register_foreign_lua_type::<Mat2>();
		app.register_foreign_lua_type::<Mat3A>();
		app.register_foreign_lua_type::<Mat4>();
		app.register_foreign_lua_type::<DMat2>();
		app.register_foreign_lua_type::<DMat3>();
		app.register_foreign_lua_type::<DMat4>();
		app.register_foreign_lua_type::<Affine2>();
		app.register_foreign_lua_type::<Affine3A>();
		app.register_foreign_lua_type::<DAffine2>();
		app.register_foreign_lua_type::<DAffine3>();
		app.register_foreign_lua_type::<Quat>();
		app.register_foreign_lua_type::<DQuat>();
		app.register_foreign_lua_type::<EulerRot>();
		app.register_foreign_lua_type::<f32>();
		app.register_foreign_lua_type::<usize>();
		app.register_foreign_lua_type::<u16>();
		app.register_foreign_lua_type::<i64>();
		app.register_foreign_lua_type::<u64>();
		app.register_foreign_lua_type::<isize>();
		app.register_foreign_lua_type::<i8>();
		app.register_foreign_lua_type::<u32>();
		app.register_foreign_lua_type::<u128>();
		app.register_foreign_lua_type::<i16>();
		app.register_foreign_lua_type::<String>();
		app.register_foreign_lua_type::<f64>();
		app.register_foreign_lua_type::<u8>();
		app.register_foreign_lua_type::<i32>();
		app.register_foreign_lua_type::<i128>();
	}
}

