use std::collections::HashSet;

use clap::Parser;
use indexmap::{IndexMap, IndexSet};
use rustdoc_types::{Crate, Item, ItemEnum, Visibility};
use serde::Deserialize;
use serde_derive::Serialize;

#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
pub struct Args {
    /// Paths to json files generated by `rustdoc -p <crate> --output-format json`
    #[clap(short, long, value_parser)]
    pub json: Vec<String>,

    /// The path to toml config file which contains the types to be wrapped and overrides
    #[clap(short, long, value_parser)]
    pub config: String,

    #[clap(short, long, value_parser, default_value = "templates")]
    pub templates: String,

    #[clap(short, long, value_parser, default_value = "generated.rs")]
    pub output: String,

    #[clap(short, long, value_parser, num_args(0..))]
    pub type_allowlist: Option<Vec<String>>,

    /// if true the excluded methods will show up as commented out code with reasons for exclusion
    #[clap(long)]
    pub print_errors: bool,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Config {
    #[serde(skip_deserializing, default)]
    pub types: IndexMap<String, Newtype>,

    #[serde(rename = "types")]
    pub types_: Vec<Newtype>,

    pub imports: String,
    pub other: String,

    pub lua_api_defaults: String,

    /// Describes the set of non generic things which are representible
    /// as simple lua types and don't need UserData proxies
    pub primitives: IndexSet<String>,

    pub manual_lua_types: Vec<ManualLuaType>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct ManualLuaType {
    pub name: String,

    /// whether or not to exclude this type from the type walker list
    #[serde(default)]
    pub dont_process: bool,

    /// the name exposed to scripts as global
    #[serde(default)]
    pub proxy_name: String,

    /// whether or not to include global proxy
    #[serde(default)]
    pub include_global_proxy: bool,

    /// whether or not to use a dummy instance (DummyTypeName)
    #[serde(default)]
    pub use_dummy_proxy: bool,
}

#[derive(Serialize, Deserialize, Debug, Hash, PartialEq, Eq)]
pub struct Newtype {
    #[serde(rename = "type")]
    pub type_: String,

    /// Override type-level docstring
    pub doc: Option<String>,

    #[serde(default)]
    pub source: Source,

    #[serde(default)]
    pub lua_methods: Vec<String>,

    #[serde(default)]
    pub derive_flags: Vec<String>,

    #[serde(default)]
    pub import_path: String,

    #[serde(default)]
    pub traits: Vec<TraitMethods>,
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, Hash, Default)]
pub struct TraitMethods {
    pub name: String,
    pub import_path: String,
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, Hash)]
pub struct Source(pub String);

impl Default for Source {
    fn default() -> Self {
        Self("bevy".to_string())
    }
}

impl Newtype {
    /// Returns true if this Type:
    /// - describes the given item element
    /// - if the element is fully described in the source crate
    /// - if the element is a struct or enum
    /// - if the element has no generics
    pub fn matches_result(&self, item: &Item, source: &Crate) -> bool {
        match &item.inner {
            ItemEnum::Struct(s) => {
                if !s.generics.params.is_empty() {
                    return false;
                }
            }
            ItemEnum::Enum(_) => {}
            _ => return false,
        };

        if source.external_crates.contains_key(&item.crate_id) {
            return false;
        };

        matches!(item.visibility, Visibility::Public)
    }
}
